(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var a,o,s=e[0],l=e[1],c=e[2],d=0,p=[];d<s.length;d++)o=s[d],Object.prototype.hasOwnProperty.call(r,o)&&r[o]&&p.push(r[o][0]),r[o]=0;for(a in l)Object.prototype.hasOwnProperty.call(l,a)&&(n[a]=l[a]);for(u&&u(e);p.length;)p.shift()();return i.push.apply(i,c||[]),t()}function t(){for(var n,e=0;e<i.length;e++){for(var t=i[e],a=!0,s=1;s<t.length;s++){var l=t[s];0!==r[l]&&(a=!1)}a&&(i.splice(e--,1),n=o(o.s=t[0]))}return n}var a={},r={3:0},i=[];function o(e){if(a[e])return a[e].exports;var t=a[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=r[n];if(0!==t)if(t)e.push(t[2]);else{var a=new Promise((function(e,a){t=r[n]=[e,a]}));e.push(t[2]=a);var i,s=document.createElement("script");s.charset="utf-8",s.timeout=120,o.nc&&s.setAttribute("nonce",o.nc),s.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{1:"fd1255a5",2:"6d94c54d",4:"7295131e",5:"6dc33016",6:"aad427d0",7:"2d9b4140",8:"494b86d7",9:"1a802d57",10:"28618317",11:"a2c1770a",12:"99ef68d3",13:"174279e9",14:"7f8d5a89",15:"60691f27",16:"84316f53",17:"313a5236",18:"a3dc36cd",19:"b1380c4b",20:"afac5783",21:"ec15928f",22:"bfd60d5d",23:"db4d5213",24:"7b1a6548",25:"6bd3882b",26:"b298e3e1",27:"ed00434e",28:"166ca593",29:"721bf53a",30:"fa06fc51",31:"511c71b3",32:"69972fe9",33:"9adc8c9a",34:"036a6690",35:"4673109c",36:"0499e7fa",37:"cffafda4",38:"5943895c",39:"1d31562f",40:"0fc9c435",41:"935050de",42:"c6247737",43:"3e73fb91",44:"16783dd5",45:"198bbf8e",46:"fefa82bc",47:"df58f55f",48:"b8081d15",49:"b76eb7c8",50:"27c4af69",51:"269beb10",52:"7f212a35",53:"7d7f27e0",54:"8e9b10f4",55:"c890ec4c",56:"b62e6d3a",57:"f81a1737",58:"b83ec62f",59:"6d788480",60:"7ed433ac",61:"5b1a6315",62:"79abf8e1",63:"16167c41",64:"896b67b9",65:"ea6ec387",66:"2511dd8f",67:"086e2598",68:"c72f6ee5",69:"dc7bd478",70:"56ad8495",71:"c3c362f6",72:"75b1ca37",73:"8d9b93c3",74:"3fe9b852",75:"27412ba6",76:"74679cdb",77:"ce510f3d",78:"1af2d5a1",79:"819f2e49",80:"a0484722",81:"6bcc495b",82:"a78968c4",83:"77a0f1f5",84:"8aaec0ec",85:"5112dd13"}[n]+".js"}(n);var l=new Error;i=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=r[n];if(0!==t){if(t){var a=e&&("load"===e.type?"missing":e.type),i=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+a+": "+i+")",l.name="ChunkLoadError",l.type=a,l.request=i,t[1](l)}r[n]=void 0}};var c=setTimeout((function(){i({type:"timeout",target:s})}),12e4);s.onerror=s.onload=i,document.head.appendChild(s)}return Promise.all(e)},o.m=n,o.c=a,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)o.d(t,a,function(e){return n[e]}.bind(null,a));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/vblog/",o.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var u=l;i.push([134,0]),t()}([function(n,e,t){"use strict";t.d(e,"a",(function(){return Hn})),t.d(e,"b",(function(){return ta})),t.d(e,"c",(function(){return Ke})),t.d(e,"d",(function(){return pn})),t.d(e,"e",(function(){return Qe})),t.d(e,"f",(function(){return Ge})),t.d(e,"g",(function(){return Mn})),t.d(e,"h",(function(){return Bn})),t.d(e,"i",(function(){return Vn}));
/*!
 * Vue.js v2.7.14
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var a=Object.freeze({}),r=Array.isArray;function i(n){return null==n}function o(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function u(n){return null!==n&&"object"==typeof n}var d=Object.prototype.toString;function p(n){return"[object Object]"===d.call(n)}function h(n){return"[object RegExp]"===d.call(n)}function f(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function m(n){return o(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function g(n){return null==n?"":Array.isArray(n)||p(n)&&n.toString===d?JSON.stringify(n,null,2):String(n)}function v(n){var e=parseFloat(n);return isNaN(e)?n:e}function y(n,e){for(var t=Object.create(null),a=n.split(","),r=0;r<a.length;r++)t[a[r]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}y("slot,component",!0);var b=y("key,ref,slot,slot-scope,is");function k(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var a=n.indexOf(e);if(a>-1)return n.splice(a,1)}}var w=Object.prototype.hasOwnProperty;function x(n,e){return w.call(n,e)}function S(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var _=/-(\w)/g,j=S((function(n){return n.replace(_,(function(n,e){return e?e.toUpperCase():""}))})),T=S((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),C=/\B([A-Z])/g,A=S((function(n){return n.replace(C,"-$1").toLowerCase()}));var I=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var a=arguments.length;return a?a>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function E(n,e){e=e||0;for(var t=n.length-e,a=new Array(t);t--;)a[t]=n[t+e];return a}function O(n,e){for(var t in e)n[t]=e[t];return n}function L(n){for(var e={},t=0;t<n.length;t++)n[t]&&O(e,n[t]);return e}function $(n,e,t){}var P=function(n,e,t){return!1},z=function(n){return n};function D(n,e){if(n===e)return!0;var t=u(n),a=u(e);if(!t||!a)return!t&&!a&&String(n)===String(e);try{var r=Array.isArray(n),i=Array.isArray(e);if(r&&i)return n.length===e.length&&n.every((function(n,t){return D(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(r||i)return!1;var o=Object.keys(n),s=Object.keys(e);return o.length===s.length&&o.every((function(t){return D(n[t],e[t])}))}catch(n){return!1}}function M(n,e){for(var t=0;t<n.length;t++)if(D(n[t],e))return t;return-1}function F(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function R(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var q=["component","directive","filter"],N=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],B={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:P,isReservedAttr:P,isUnknownElement:P,getTagNamespace:$,parsePlatformTagName:z,mustUseProp:P,async:!0,_lifecycleHooks:N},U=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function J(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function V(n,e,t,a){Object.defineProperty(n,e,{value:t,enumerable:!!a,writable:!0,configurable:!0})}var W=new RegExp("[^".concat(U.source,".$_\\d]"));var H="__proto__"in{},Q="undefined"!=typeof window,G=Q&&window.navigator.userAgent.toLowerCase(),K=G&&/msie|trident/.test(G),Y=G&&G.indexOf("msie 9.0")>0,X=G&&G.indexOf("edge/")>0;G&&G.indexOf("android");var Z=G&&/iphone|ipad|ipod|ios/.test(G);G&&/chrome\/\d+/.test(G),G&&/phantomjs/.test(G);var nn,en=G&&G.match(/firefox\/(\d+)/),tn={}.watch,an=!1;if(Q)try{var rn={};Object.defineProperty(rn,"passive",{get:function(){an=!0}}),window.addEventListener("test-passive",null,rn)}catch(n){}var on=function(){return void 0===nn&&(nn=!Q&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},sn=Q&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,un="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);cn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var dn=null;function pn(){return dn&&{proxy:dn}}function hn(n){void 0===n&&(n=null),n||dn&&dn._scope.off(),dn=n,n&&n._scope.on()}var fn=function(){function n(n,e,t,a,r,i,o,s){this.tag=n,this.data=e,this.children=t,this.text=a,this.elm=r,this.ns=void 0,this.context=i,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),mn=function(n){void 0===n&&(n="");var e=new fn;return e.text=n,e.isComment=!0,e};function gn(n){return new fn(void 0,void 0,void 0,String(n))}function vn(n){var e=new fn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var yn=0,bn=[],kn=function(){function n(){this._pending=!1,this.id=yn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,bn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,a=e.length;t<a;t++){0,e[t].update()}},n}();kn.target=null;var wn=[];function xn(n){wn.push(n),kn.target=n}function Sn(){wn.pop(),kn.target=wn[wn.length-1]}var _n=Array.prototype,jn=Object.create(_n);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=_n[n];V(jn,n,(function(){for(var t=[],a=0;a<arguments.length;a++)t[a]=arguments[a];var r,i=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":r=t;break;case"splice":r=t.slice(2)}return r&&o.observeArray(r),o.dep.notify(),i}))}));var Tn=Object.getOwnPropertyNames(jn),Cn={},An=!0;function In(n){An=n}var En={notify:$,depend:$,addSub:$,removeSub:$},On=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?En:new kn,this.vmCount=0,V(n,"__ob__",this),r(n)){if(!t)if(H)n.__proto__=jn;else for(var a=0,i=Tn.length;a<i;a++){V(n,s=Tn[a],jn[s])}e||this.observeArray(n)}else{var o=Object.keys(n);for(a=0;a<o.length;a++){var s;$n(n,s=o[a],Cn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Ln(n[e],!1,this.mock)},n}();function Ln(n,e,t){return n&&x(n,"__ob__")&&n.__ob__ instanceof On?n.__ob__:!An||!t&&on()||!r(n)&&!p(n)||!Object.isExtensible(n)||n.__v_skip||Nn(n)||n instanceof fn?void 0:new On(n,e,t)}function $n(n,e,t,a,i,o){var s=new kn,l=Object.getOwnPropertyDescriptor(n,e);if(!l||!1!==l.configurable){var c=l&&l.get,u=l&&l.set;c&&!u||t!==Cn&&2!==arguments.length||(t=n[e]);var d=!i&&Ln(t,!1,o);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=c?c.call(n):t;return kn.target&&(s.depend(),d&&(d.dep.depend(),r(e)&&Dn(e))),Nn(e)&&!i?e.value:e},set:function(e){var a=c?c.call(n):t;if(R(a,e)){if(u)u.call(n,e);else{if(c)return;if(!i&&Nn(a)&&!Nn(e))return void(a.value=e);t=e}d=!i&&Ln(e,!1,o),s.notify()}}}),s}}function Pn(n,e,t){if(!qn(n)){var a=n.__ob__;return r(n)&&f(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),a&&!a.shallow&&a.mock&&Ln(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||a&&a.vmCount?t:a?($n(a.value,e,t,void 0,a.shallow,a.mock),a.dep.notify(),t):(n[e]=t,t)}}function zn(n,e){if(r(n)&&f(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||qn(n)||x(n,e)&&(delete n[e],t&&t.dep.notify())}}function Dn(n){for(var e=void 0,t=0,a=n.length;t<a;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),r(e)&&Dn(e)}function Mn(n){return Rn(n,!1),n}function Fn(n){return Rn(n,!0),V(n,"__v_isShallow",!0),n}function Rn(n,e){if(!qn(n)){Ln(n,e,on());0}}function qn(n){return!(!n||!n.__v_isReadonly)}function Nn(n){return!(!n||!0!==n.__v_isRef)}function Bn(n){return Un(n,!1)}function Un(n,e){if(Nn(n))return n;var t={};return V(t,"__v_isRef",!0),V(t,"__v_isShallow",e),V(t,"dep",$n(t,"value",n,null,e,on())),t}function Jn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Nn(n))return n.value;var a=n&&n.__ob__;return a&&a.dep.depend(),n},set:function(n){var a=e[t];Nn(a)&&!Nn(n)?a.value=n:e[t]=n}})}function Vn(n){var e=r(n)?new Array(n.length):{};for(var t in n)e[t]=Wn(n,t);return e}function Wn(n,e,t){var a=n[e];if(Nn(a))return a;var r={get value(){var a=n[e];return void 0===a?t:a},set value(t){n[e]=t}};return V(r,"__v_isRef",!0),r}function Hn(n,e){var t,a,r=c(n);r?(t=n,a=$):(t=n.get,a=n.set);var i=on()?null:new et(dn,t,$,{lazy:!0});var o={effect:i,get value(){return i?(i.dirty&&i.evaluate(),kn.target&&i.depend(),i.value):t()},set value(n){a(n)}};return V(o,"__v_isRef",!0),V(o,"__v_isReadonly",r),o}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Qn;var Gn=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Qn,!n&&Qn&&(this.index=(Qn.scopes||(Qn.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Qn;try{return Qn=this,n()}finally{Qn=e}}else 0},n.prototype.on=function(){Qn=this},n.prototype.off=function(){Qn=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var a=this.parent.scopes.pop();a&&a!==this&&(this.parent.scopes[this.index]=a,a.index=this.index)}this.parent=void 0,this.active=!1}},n}();function Kn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Yn=S((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),a="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=a?n.slice(1):n,once:t,capture:a,passive:e}}));function Xn(n,e){function t(){var n=t.fns;if(!r(n))return Pe(n,null,arguments,e,"v-on handler");for(var a=n.slice(),i=0;i<a.length;i++)Pe(a[i],null,arguments,e,"v-on handler")}return t.fns=n,t}function Zn(n,e,t,a,r,o){var l,c,u,d;for(l in n)c=n[l],u=e[l],d=Yn(l),i(c)||(i(u)?(i(c.fns)&&(c=n[l]=Xn(c,o)),s(d.once)&&(c=n[l]=r(d.name,c,d.capture)),t(d.name,c,d.capture,d.passive,d.params)):c!==u&&(u.fns=c,n[l]=u));for(l in e)i(n[l])&&a((d=Yn(l)).name,e[l],d.capture)}function ne(n,e,t){var a;n instanceof fn&&(n=n.data.hook||(n.data.hook={}));var r=n[e];function l(){t.apply(this,arguments),k(a.fns,l)}i(r)?a=Xn([l]):o(r.fns)&&s(r.merged)?(a=r).fns.push(l):a=Xn([r,l]),a.merged=!0,n[e]=a}function ee(n,e,t,a,r){if(o(e)){if(x(e,t))return n[t]=e[t],r||delete e[t],!0;if(x(e,a))return n[t]=e[a],r||delete e[a],!0}return!1}function te(n){return l(n)?[gn(n)]:r(n)?function n(e,t){var a,c,u,d,p=[];for(a=0;a<e.length;a++)i(c=e[a])||"boolean"==typeof c||(u=p.length-1,d=p[u],r(c)?c.length>0&&(ae((c=n(c,"".concat(t||"","_").concat(a)))[0])&&ae(d)&&(p[u]=gn(d.text+c[0].text),c.shift()),p.push.apply(p,c)):l(c)?ae(d)?p[u]=gn(d.text+c):""!==c&&p.push(gn(c)):ae(c)&&ae(d)?p[u]=gn(d.text+c.text):(s(e._isVList)&&o(c.tag)&&i(c.key)&&o(t)&&(c.key="__vlist".concat(t,"_").concat(a,"__")),p.push(c)));return p}(n):void 0}function ae(n){return o(n)&&o(n.text)&&!1===n.isComment}function re(n,e){var t,a,i,s,l=null;if(r(n)||"string"==typeof n)for(l=new Array(n.length),t=0,a=n.length;t<a;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(u(n))if(un&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),d=c.next();!d.done;)l.push(e(d.value,l.length)),d=c.next()}else for(i=Object.keys(n),l=new Array(i.length),t=0,a=i.length;t<a;t++)s=i[t],l[t]=e(n[s],s,t);return o(l)||(l=[]),l._isVList=!0,l}function ie(n,e,t,a){var r,i=this.$scopedSlots[n];i?(t=t||{},a&&(t=O(O({},a),t)),r=i(t)||(c(e)?e():e)):r=this.$slots[n]||(c(e)?e():e);var o=t&&t.slot;return o?this.$createElement("template",{slot:o},r):r}function oe(n){return qt(this.$options,"filters",n,!0)||z}function se(n,e){return r(n)?-1===n.indexOf(e):n!==e}function le(n,e,t,a,r){var i=B.keyCodes[e]||t;return r&&a&&!B.keyCodes[e]?se(r,a):i?se(i,n):a?A(a)!==e:void 0===n}function ce(n,e,t,a,i){if(t)if(u(t)){r(t)&&(t=L(t));var o=void 0,s=function(r){if("class"===r||"style"===r||b(r))o=n;else{var s=n.attrs&&n.attrs.type;o=a||B.mustUseProp(e,s,r)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=j(r),c=A(r);l in o||c in o||(o[r]=t[r],i&&((n.on||(n.on={}))["update:".concat(r)]=function(n){t[r]=n}))};for(var l in t)s(l)}else;return n}function ue(n,e){var t=this._staticTrees||(this._staticTrees=[]),a=t[n];return a&&!e||pe(a=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),a}function de(n,e,t){return pe(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function pe(n,e,t){if(r(n))for(var a=0;a<n.length;a++)n[a]&&"string"!=typeof n[a]&&he(n[a],"".concat(e,"_").concat(a),t);else he(n,e,t)}function he(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function fe(n,e){if(e)if(p(e)){var t=n.on=n.on?O({},n.on):{};for(var a in e){var r=t[a],i=e[a];t[a]=r?[].concat(r,i):i}}else;return n}function me(n,e,t,a){e=e||{$stable:!t};for(var i=0;i<n.length;i++){var o=n[i];r(o)?me(o,e,t):o&&(o.proxy&&(o.fn.proxy=!0),e[o.key]=o.fn)}return a&&(e.$key=a),e}function ge(n,e){for(var t=0;t<e.length;t+=2){var a=e[t];"string"==typeof a&&a&&(n[e[t]]=e[t+1])}return n}function ve(n,e){return"string"==typeof n?e+n:n}function ye(n){n._o=de,n._n=v,n._s=g,n._l=re,n._t=ie,n._q=D,n._i=M,n._m=ue,n._f=oe,n._k=le,n._b=ce,n._v=gn,n._e=mn,n._u=me,n._g=fe,n._d=ge,n._p=ve}function be(n,e){if(!n||!n.length)return{};for(var t={},a=0,r=n.length;a<r;a++){var i=n[a],o=i.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,i.context!==e&&i.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(i);else{var s=o.slot,l=t[s]||(t[s]=[]);"template"===i.tag?l.push.apply(l,i.children||[]):l.push(i)}}for(var c in t)t[c].every(ke)&&delete t[c];return t}function ke(n){return n.isComment&&!n.asyncFactory||" "===n.text}function we(n){return n.isComment&&n.asyncFactory}function xe(n,e,t,r){var i,o=Object.keys(t).length>0,s=e?!!e.$stable:!o,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&r&&r!==a&&l===r.$key&&!o&&!r.$hasNormal)return r;for(var c in i={},e)e[c]&&"$"!==c[0]&&(i[c]=Se(n,t,c,e[c]))}else i={};for(var u in t)u in i||(i[u]=_e(t,u));return e&&Object.isExtensible(e)&&(e._normalized=i),V(i,"$stable",s),V(i,"$key",l),V(i,"$hasNormal",o),i}function Se(n,e,t,a){var i=function(){var e=dn;hn(n);var t=arguments.length?a.apply(null,arguments):a({}),i=(t=t&&"object"==typeof t&&!r(t)?[t]:te(t))&&t[0];return hn(e),t&&(!i||1===t.length&&i.isComment&&!we(i))?void 0:t};return a.proxy&&Object.defineProperty(e,t,{get:i,enumerable:!0,configurable:!0}),i}function _e(n,e){return function(){return n[e]}}function je(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};V(e,"_v_attr_proxy",!0),Te(e,n.$attrs,a,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||Te(n._listenersProxy={},n.$listeners,a,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||Ae(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:I(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Jn(n,e,t)}))}}}function Te(n,e,t,a,r){var i=!1;for(var o in e)o in n?e[o]!==t[o]&&(i=!0):(i=!0,Ce(n,o,a,r));for(var o in n)o in e||(i=!0,delete n[o]);return i}function Ce(n,e,t,a){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[a][e]}})}function Ae(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var Ie=null;function Ee(n,e){return(n.__esModule||un&&"Module"===n[Symbol.toStringTag])&&(n=n.default),u(n)?e.extend(n):n}function Oe(n){if(r(n))for(var e=0;e<n.length;e++){var t=n[e];if(o(t)&&(o(t.componentOptions)||we(t)))return t}}function Le(n,e,t,a,d,p){return(r(t)||l(t))&&(d=a,a=t,t=void 0),s(p)&&(d=2),function(n,e,t,a,l){if(o(t)&&o(t.__ob__))return mn();o(t)&&o(t.is)&&(e=t.is);if(!e)return mn();0;r(a)&&c(a[0])&&((t=t||{}).scopedSlots={default:a[0]},a.length=0);2===l?a=te(a):1===l&&(a=function(n){for(var e=0;e<n.length;e++)if(r(n[e]))return Array.prototype.concat.apply([],n);return n}(a));var d,p;if("string"==typeof e){var h=void 0;p=n.$vnode&&n.$vnode.ns||B.getTagNamespace(e),d=B.isReservedTag(e)?new fn(B.parsePlatformTagName(e),t,a,void 0,void 0,n):t&&t.pre||!o(h=qt(n.$options,"components",e))?new fn(e,t,a,void 0,void 0,n):Et(h,t,n,a,e)}else d=Et(e,t,n,a);return r(d)?d:o(d)?(o(p)&&function n(e,t,a){e.ns=t,"foreignObject"===e.tag&&(t=void 0,a=!0);if(o(e.children))for(var r=0,l=e.children.length;r<l;r++){var c=e.children[r];o(c.tag)&&(i(c.ns)||s(a)&&"svg"!==c.tag)&&n(c,t,a)}}(d,p),o(t)&&function(n){u(n.style)&&Xe(n.style);u(n.class)&&Xe(n.class)}(t),d):mn()}(n,e,t,a,d)}function $e(n,e,t){xn();try{if(e)for(var a=e;a=a.$parent;){var r=a.$options.errorCaptured;if(r)for(var i=0;i<r.length;i++)try{if(!1===r[i].call(a,n,e,t))return}catch(n){ze(n,a,"errorCaptured hook")}}ze(n,e,t)}finally{Sn()}}function Pe(n,e,t,a,r){var i;try{(i=t?n.apply(e,t):n.call(e))&&!i._isVue&&m(i)&&!i._handled&&(i.catch((function(n){return $e(n,a,r+" (Promise/async)")})),i._handled=!0)}catch(n){$e(n,a,r)}return i}function ze(n,e,t){if(B.errorHandler)try{return B.errorHandler.call(null,n,e,t)}catch(e){e!==n&&De(e,null,"config.errorHandler")}De(n,e,t)}function De(n,e,t){if(!Q||"undefined"==typeof console)throw n;console.error(n)}var Me,Fe=!1,Re=[],qe=!1;function Ne(){qe=!1;var n=Re.slice(0);Re.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var Be=Promise.resolve();Me=function(){Be.then(Ne),Z&&setTimeout($)},Fe=!0}else if(K||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Me="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(Ne)}:function(){setTimeout(Ne,0)};else{var Ue=1,Je=new MutationObserver(Ne),Ve=document.createTextNode(String(Ue));Je.observe(Ve,{characterData:!0}),Me=function(){Ue=(Ue+1)%2,Ve.data=String(Ue)},Fe=!0}function We(n,e){var t;if(Re.push((function(){if(n)try{n.call(e)}catch(n){$e(n,e,"nextTick")}else t&&t(e)})),qe||(qe=!0,Me()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function He(n){return function(e,t){if(void 0===t&&(t=dn),t)return function(n,e,t){var a=n.$options;a[e]=Dt(a[e],t)}(t,n,e)}}He("beforeMount");var Qe=He("mounted"),Ge=(He("beforeUpdate"),He("updated"));He("beforeDestroy"),He("destroyed"),He("activated"),He("deactivated"),He("serverPrefetch"),He("renderTracked"),He("renderTriggered"),He("errorCaptured");function Ke(n){return n}var Ye=new cn;function Xe(n){return function n(e,t){var a,i,o=r(e);if(!o&&!u(e)||e.__v_skip||Object.isFrozen(e)||e instanceof fn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(o)for(a=e.length;a--;)n(e[a],t);else if(Nn(e))n(e.value,t);else for(i=Object.keys(e),a=i.length;a--;)n(e[i[a]],t)}(n,Ye),Ye.clear(),n}var Ze,nt=0,et=function(){function n(n,e,t,a,r){var i,o;i=this,void 0===(o=Qn&&!Qn._vm?Qn:n?n._scope:void 0)&&(o=Qn),o&&o.active&&o.effects.push(i),(this.vm=n)&&r&&(n._watcher=this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++nt,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!W.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=$)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;xn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;$e(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Xe(n),Sn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():xt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||u(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Pe(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&k(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function tt(n,e){Ze.$on(n,e)}function at(n,e){Ze.$off(n,e)}function rt(n,e){var t=Ze;return function a(){var r=e.apply(null,arguments);null!==r&&t.$off(n,a)}}function it(n,e,t){Ze=n,Zn(e,t||{},tt,at,rt,n),Ze=void 0}var ot=null;function st(n){var e=ot;return ot=n,function(){ot=e}}function lt(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function ct(n,e){if(e){if(n._directInactive=!1,lt(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)ct(n.$children[t]);ut(n,"activated")}}function ut(n,e,t,a){void 0===a&&(a=!0),xn();var r=dn;a&&hn(n);var i=n.$options[e],o="".concat(e," hook");if(i)for(var s=0,l=i.length;s<l;s++)Pe(i[s],n,t||null,n,o);n._hasHookEvent&&n.$emit("hook:"+e),a&&hn(r),Sn()}var dt=[],pt=[],ht={},ft=!1,mt=!1,gt=0;var vt=0,yt=Date.now;if(Q&&!K){var bt=window.performance;bt&&"function"==typeof bt.now&&yt()>document.createEvent("Event").timeStamp&&(yt=function(){return bt.now()})}var kt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function wt(){var n,e;for(vt=yt(),mt=!0,dt.sort(kt),gt=0;gt<dt.length;gt++)(n=dt[gt]).before&&n.before(),e=n.id,ht[e]=null,n.run();var t=pt.slice(),a=dt.slice();gt=dt.length=pt.length=0,ht={},ft=mt=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,ct(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],a=t.vm;a&&a._watcher===t&&a._isMounted&&!a._isDestroyed&&ut(a,"updated")}}(a),function(){for(var n=0;n<bn.length;n++){var e=bn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}bn.length=0}(),sn&&B.devtools&&sn.emit("flush")}function xt(n){var e=n.id;if(null==ht[e]&&(n!==kn.target||!n.noRecurse)){if(ht[e]=!0,mt){for(var t=dt.length-1;t>gt&&dt[t].id>n.id;)t--;dt.splice(t+1,0,n)}else dt.push(n);ft||(ft=!0,We(wt))}}function St(n,e){if(n){for(var t=Object.create(null),a=un?Reflect.ownKeys(n):Object.keys(n),r=0;r<a.length;r++){var i=a[r];if("__ob__"!==i){var o=n[i].from;if(o in e._provided)t[i]=e._provided[o];else if("default"in n[i]){var s=n[i].default;t[i]=c(s)?s.call(e):s}else 0}}return t}}function _t(n,e,t,i,o){var l,c=this,u=o.options;x(i,"_uid")?(l=Object.create(i))._original=i:(l=i,i=i._original);var d=s(u._compiled),p=!d;this.data=n,this.props=e,this.children=t,this.parent=i,this.listeners=n.on||a,this.injections=St(u.inject,i),this.slots=function(){return c.$slots||xe(i,n.scopedSlots,c.$slots=be(t,i)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return xe(i,n.scopedSlots,this.slots())}}),d&&(this.$options=u,this.$slots=this.slots(),this.$scopedSlots=xe(i,n.scopedSlots,this.$slots)),u._scopeId?this._c=function(n,e,t,a){var o=Le(l,n,e,t,a,p);return o&&!r(o)&&(o.fnScopeId=u._scopeId,o.fnContext=i),o}:this._c=function(n,e,t,a){return Le(l,n,e,t,a,p)}}function jt(n,e,t,a,r){var i=vn(n);return i.fnContext=t,i.fnOptions=a,e.slot&&((i.data||(i.data={})).slot=e.slot),i}function Tt(n,e){for(var t in e)n[j(t)]=e[t]}function Ct(n){return n.name||n.__name||n._componentTag}ye(_t.prototype);var At={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;At.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},a=n.data.inlineTemplate;o(a)&&(t.render=a.render,t.staticRenderFns=a.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,ot)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,i){var o=r.data.scopedSlots,s=n.$scopedSlots,l=!!(o&&!o.$stable||s!==a&&!s.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),c=!!(i||n.$options._renderChildren||l),u=n.$vnode;n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r),n.$options._renderChildren=i;var d=r.data.attrs||a;n._attrsProxy&&Te(n._attrsProxy,d,u.data&&u.data.attrs||a,n,"$attrs")&&(c=!0),n.$attrs=d,t=t||a;var p=n.$options._parentListeners;if(n._listenersProxy&&Te(n._listenersProxy,t,p||a,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,it(n,t,p),e&&n.$options.props){In(!1);for(var h=n._props,f=n.$options._propKeys||[],m=0;m<f.length;m++){var g=f[m],v=n.$options.props;h[g]=Nt(g,v,e,n)}In(!0),n.$options.propsData=e}c&&(n.$slots=be(i,r.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,a=n.componentInstance;a._isMounted||(a._isMounted=!0,ut(a,"mounted")),n.data.keepAlive&&(t._isMounted?((e=a)._inactive=!1,pt.push(e)):ct(a,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,lt(e))||e._inactive)){e._inactive=!0;for(var a=0;a<e.$children.length;a++)n(e.$children[a]);ut(e,"deactivated")}}(e,!0):e.$destroy())}},It=Object.keys(At);function Et(n,e,t,l,c){if(!i(n)){var d=t.$options._base;if(u(n)&&(n=d.extend(n)),"function"==typeof n){var p;if(i(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&o(n.errorComp))return n.errorComp;if(o(n.resolved))return n.resolved;var t=Ie;if(t&&o(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&o(n.loadingComp))return n.loadingComp;if(t&&!o(n.owners)){var a=n.owners=[t],r=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return k(a,t)}));var d=function(n){for(var e=0,t=a.length;e<t;e++)a[e].$forceUpdate();n&&(a.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},p=F((function(t){n.resolved=Ee(t,e),r?a.length=0:d(!0)})),h=F((function(e){o(n.errorComp)&&(n.error=!0,d(!0))})),f=n(p,h);return u(f)&&(m(f)?i(n.resolved)&&f.then(p,h):m(f.component)&&(f.component.then(p,h),o(f.error)&&(n.errorComp=Ee(f.error,e)),o(f.loading)&&(n.loadingComp=Ee(f.loading,e),0===f.delay?n.loading=!0:l=setTimeout((function(){l=null,i(n.resolved)&&i(n.error)&&(n.loading=!0,d(!1))}),f.delay||200)),o(f.timeout)&&(c=setTimeout((function(){c=null,i(n.resolved)&&h(null)}),f.timeout)))),r=!1,n.loading?n.loadingComp:n.resolved}}(p=n,d)))return function(n,e,t,a,r){var i=mn();return i.asyncFactory=n,i.asyncMeta={data:e,context:t,children:a,tag:r},i}(p,e,t,l,c);e=e||{},ea(n),o(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",a=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var i=e.on||(e.on={}),s=i[a],l=e.model.callback;o(s)?(r(s)?-1===s.indexOf(l):s!==l)&&(i[a]=[l].concat(s)):i[a]=l}(n.options,e);var h=function(n,e,t){var a=e.options.props;if(!i(a)){var r={},s=n.attrs,l=n.props;if(o(s)||o(l))for(var c in a){var u=A(c);ee(r,l,c,u,!0)||ee(r,s,c,u,!1)}return r}}(e,n);if(s(n.options.functional))return function(n,e,t,i,s){var l=n.options,c={},u=l.props;if(o(u))for(var d in u)c[d]=Nt(d,u,e||a);else o(t.attrs)&&Tt(c,t.attrs),o(t.props)&&Tt(c,t.props);var p=new _t(t,c,s,i,n),h=l.render.call(null,p._c,p);if(h instanceof fn)return jt(h,t,p.parent,l,p);if(r(h)){for(var f=te(h)||[],m=new Array(f.length),g=0;g<f.length;g++)m[g]=jt(f[g],t,p.parent,l,p);return m}}(n,h,e,t,l);var f=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var g=e.slot;e={},g&&(e.slot=g)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<It.length;t++){var a=It[t],r=e[a],i=At[a];r===i||r&&r._merged||(e[a]=r?Ot(i,r):i)}}(e);var v=Ct(n.options)||c;return new fn("vue-component-".concat(n.cid).concat(v?"-".concat(v):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:h,listeners:f,tag:c,children:l},p)}}}function Ot(n,e){var t=function(t,a){n(t,a),e(t,a)};return t._merged=!0,t}var Lt=$,$t=B.optionMergeStrategies;function Pt(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var a,r,i,o=un?Reflect.ownKeys(e):Object.keys(e),s=0;s<o.length;s++)"__ob__"!==(a=o[s])&&(r=n[a],i=e[a],t&&x(n,a)?r!==i&&p(r)&&p(i)&&Pt(r,i):Pn(n,a,i));return n}function zt(n,e,t){return t?function(){var a=c(e)?e.call(t,t):e,r=c(n)?n.call(t,t):n;return a?Pt(a,r):r}:e?n?function(){return Pt(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function Dt(n,e){var t=e?n?n.concat(e):r(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Mt(n,e,t,a){var r=Object.create(n||null);return e?O(r,e):r}$t.data=function(n,e,t){return t?zt(n,e,t):e&&"function"!=typeof e?n:zt(n,e)},N.forEach((function(n){$t[n]=Dt})),q.forEach((function(n){$t[n+"s"]=Mt})),$t.watch=function(n,e,t,a){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var i={};for(var o in O(i,n),e){var s=i[o],l=e[o];s&&!r(s)&&(s=[s]),i[o]=s?s.concat(l):r(l)?l:[l]}return i},$t.props=$t.methods=$t.inject=$t.computed=function(n,e,t,a){if(!n)return e;var r=Object.create(null);return O(r,n),e&&O(r,e),r},$t.provide=function(n,e){return n?function(){var t=Object.create(null);return Pt(t,c(n)?n.call(this):n),e&&Pt(t,c(e)?e.call(this):e,!1),t}:e};var Ft=function(n,e){return void 0===e?n:e};function Rt(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var a,i,o={};if(r(t))for(a=t.length;a--;)"string"==typeof(i=t[a])&&(o[j(i)]={type:null});else if(p(t))for(var s in t)i=t[s],o[j(s)]=p(i)?i:{type:i};else 0;n.props=o}}(e),function(n,e){var t=n.inject;if(t){var a=n.inject={};if(r(t))for(var i=0;i<t.length;i++)a[t[i]]={from:t[i]};else if(p(t))for(var o in t){var s=t[o];a[o]=p(s)?O({from:o},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var a=e[t];c(a)&&(e[t]={bind:a,update:a})}}(e),!e._base&&(e.extends&&(n=Rt(n,e.extends,t)),e.mixins))for(var a=0,i=e.mixins.length;a<i;a++)n=Rt(n,e.mixins[a],t);var o,s={};for(o in n)l(o);for(o in e)x(n,o)||l(o);function l(a){var r=$t[a]||Ft;s[a]=r(n[a],e[a],t,a)}return s}function qt(n,e,t,a){if("string"==typeof t){var r=n[e];if(x(r,t))return r[t];var i=j(t);if(x(r,i))return r[i];var o=T(i);return x(r,o)?r[o]:r[t]||r[i]||r[o]}}function Nt(n,e,t,a){var r=e[n],i=!x(t,n),o=t[n],s=Vt(Boolean,r.type);if(s>-1)if(i&&!x(r,"default"))o=!1;else if(""===o||o===A(n)){var l=Vt(String,r.type);(l<0||s<l)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!x(e,"default"))return;var a=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(a)&&"Function"!==Ut(e.type)?a.call(n):a}(a,r,n);var u=An;In(!0),Ln(o),In(u)}return o}var Bt=/^\s*function (\w+)/;function Ut(n){var e=n&&n.toString().match(Bt);return e?e[1]:""}function Jt(n,e){return Ut(n)===Ut(e)}function Vt(n,e){if(!r(e))return Jt(e,n)?0:-1;for(var t=0,a=e.length;t<a;t++)if(Jt(e[t],n))return t;return-1}var Wt={enumerable:!0,configurable:!0,get:$,set:$};function Ht(n,e,t){Wt.get=function(){return this[e][t]},Wt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Wt)}function Qt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},a=n._props=Fn({}),r=n.$options._propKeys=[];n.$parent&&In(!1);var i=function(i){r.push(i);var o=Nt(i,e,t,n);$n(a,i,o),i in n||Ht(n,"_props",i)};for(var o in e)i(o);In(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var a=n._setupContext=je(n);hn(n),xn();var r=Pe(t,null,[n._props||Fn({}),a],n,"setup");if(Sn(),hn(),c(r))e.render=r;else if(u(r))if(n._setupState=r,r.__sfc){var i=n._setupProxy={};for(var o in r)"__sfc"!==o&&Jn(i,r,o)}else for(var o in r)J(o)||Jn(n,r,o);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?$:I(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;p(e=n._data=c(e)?function(n,e){xn();try{return n.call(e,e)}catch(n){return $e(n,e,"data()"),{}}finally{Sn()}}(e,n):e||{})||(e={});var t=Object.keys(e),a=n.$options.props,r=(n.$options.methods,t.length);for(;r--;){var i=t[r];0,a&&x(a,i)||J(i)||Ht(n,"_data",i)}var o=Ln(e);o&&o.vmCount++}(n);else{var t=Ln(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),a=on();for(var r in e){var i=e[r],o=c(i)?i:i.get;0,a||(t[r]=new et(n,o||$,$,Gt)),r in n||Kt(n,r,i)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var a=e[t];if(r(a))for(var i=0;i<a.length;i++)Zt(n,t,a[i]);else Zt(n,t,a)}}(n,e.watch)}var Gt={lazy:!0};function Kt(n,e,t){var a=!on();c(t)?(Wt.get=a?Yt(e):Xt(t),Wt.set=$):(Wt.get=t.get?a&&!1!==t.cache?Yt(e):Xt(t.get):$,Wt.set=t.set||$),Object.defineProperty(n,e,Wt)}function Yt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),kn.target&&e.depend(),e.value}}function Xt(n){return function(){return n.call(this,this)}}function Zt(n,e,t,a){return p(t)&&(a=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,a)}var na=0;function ea(n){var e=n.options;if(n.super){var t=ea(n.super);if(t!==n.superOptions){n.superOptions=t;var a=function(n){var e,t=n.options,a=n.sealedOptions;for(var r in t)t[r]!==a[r]&&(e||(e={}),e[r]=t[r]);return e}(n);a&&O(n.extendOptions,a),(e=n.options=Rt(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function ta(n){this._init(n)}function aa(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,a=t.cid,r=n._Ctor||(n._Ctor={});if(r[a])return r[a];var i=Ct(n)||Ct(t.options);var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=Rt(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)Ht(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)Kt(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,q.forEach((function(n){o[n]=t[n]})),i&&(o.options.components[i]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=O({},o.options),r[a]=o,o}}function ra(n){return n&&(Ct(n.Ctor.options)||n.tag)}function ia(n,e){return r(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!h(n)&&n.test(e)}function oa(n,e){var t=n.cache,a=n.keys,r=n._vnode;for(var i in t){var o=t[i];if(o){var s=o.name;s&&!e(s)&&sa(t,i,a,r)}}}function sa(n,e,t,a){var r=n[e];!r||a&&r.tag===a.tag||r.componentInstance.$destroy(),n[e]=null,k(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=na++,e._isVue=!0,e.__v_skip=!0,e._scope=new Gn(!0),e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),a=e._parentVnode;t.parent=e.parent,t._parentVnode=a;var r=a.componentOptions;t.propsData=r.propsData,t._parentListeners=r.listeners,t._renderChildren=r.children,t._componentTag=r.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Rt(ea(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&it(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=be(e._renderChildren,r),n.$scopedSlots=t?xe(n.$parent,t.data.scopedSlots,n.$slots):a,n._c=function(e,t,a,r){return Le(n,e,t,a,r,!1)},n.$createElement=function(e,t,a,r){return Le(n,e,t,a,r,!0)};var i=t&&t.data;$n(n,"$attrs",i&&i.attrs||a,null,!0),$n(n,"$listeners",e._parentListeners||a,null,!0)}(e),ut(e,"beforeCreate",void 0,!1),function(n){var e=St(n.$options.inject,n);e&&(In(!1),Object.keys(e).forEach((function(t){$n(n,t,e[t])})),In(!0))}(e),Qt(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!u(t))return;for(var a=Kn(n),r=un?Reflect.ownKeys(t):Object.keys(t),i=0;i<r.length;i++){var o=r[i];Object.defineProperty(a,o,Object.getOwnPropertyDescriptor(t,o))}}}(e),ut(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(ta),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Pn,n.prototype.$delete=zn,n.prototype.$watch=function(n,e,t){if(p(e))return Zt(this,n,e,t);(t=t||{}).user=!0;var a=new et(this,n,e,t);if(t.immediate){var r='callback for immediate watcher "'.concat(a.expression,'"');xn(),Pe(e,this,[a.value],this,r),Sn()}return function(){a.teardown()}}}(ta),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var a=this;if(r(n))for(var i=0,o=n.length;i<o;i++)a.$on(n[i],t);else(a._events[n]||(a._events[n]=[])).push(t),e.test(n)&&(a._hasHookEvent=!0);return a},n.prototype.$once=function(n,e){var t=this;function a(){t.$off(n,a),e.apply(t,arguments)}return a.fn=e,t.$on(n,a),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(r(n)){for(var a=0,i=n.length;a<i;a++)t.$off(n[a],e);return t}var o,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((o=s[l])===e||o.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?E(t):t;for(var a=E(arguments,1),r='event handler for "'.concat(n,'"'),i=0,o=t.length;i<o;i++)Pe(t[i],e,a,e,r)}return e}}(ta),function(n){n.prototype._update=function(n,e){var t=this,a=t.$el,r=t._vnode,i=st(t);t._vnode=n,t.$el=r?t.__patch__(r,n):t.__patch__(t.$el,n,e,!1),i(),a&&(a.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var o=t;o&&o.$vnode&&o.$parent&&o.$vnode===o.$parent._vnode;)o.$parent.$el=o.$el,o=o.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){ut(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||k(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),ut(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(ta),function(n){ye(n.prototype),n.prototype.$nextTick=function(n){return We(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,a=t.render,i=t._parentVnode;i&&e._isMounted&&(e.$scopedSlots=xe(e.$parent,i.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&Ae(e._slotsProxy,e.$scopedSlots)),e.$vnode=i;try{hn(e),Ie=e,n=a.call(e._renderProxy,e.$createElement)}catch(t){$e(t,e,"render"),n=e._vnode}finally{Ie=null,hn()}return r(n)&&1===n.length&&(n=n[0]),n instanceof fn||(n=mn()),n.parent=i,n}}(ta);var la=[String,RegExp,Array],ca={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:la,exclude:la,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,a=this.keyToCache;if(t){var r=t.tag,i=t.componentInstance,o=t.componentOptions;n[a]={name:ra(o),tag:r,componentInstance:i},e.push(a),this.max&&e.length>parseInt(this.max)&&sa(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)sa(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){oa(n,(function(n){return ia(e,n)}))})),this.$watch("exclude",(function(e){oa(n,(function(n){return!ia(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Oe(n),t=e&&e.componentOptions;if(t){var a=ra(t),r=this.include,i=this.exclude;if(r&&(!a||!ia(r,a))||i&&a&&ia(i,a))return e;var o=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;o[l]?(e.componentInstance=o[l].componentInstance,k(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return B}};Object.defineProperty(n,"config",e),n.util={warn:Lt,extend:O,mergeOptions:Rt,defineReactive:$n},n.set=Pn,n.delete=zn,n.nextTick=We,n.observable=function(n){return Ln(n),n},n.options=Object.create(null),q.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,O(n.options.components,ca),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=E(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Rt(this.options,n),this}}(n),aa(n),function(n){q.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&p(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(ta),Object.defineProperty(ta.prototype,"$isServer",{get:on}),Object.defineProperty(ta.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(ta,"FunctionalRenderContext",{value:_t}),ta.version="2.7.14";var ua=y("style,class"),da=y("input,textarea,option,select,progress"),pa=y("contenteditable,draggable,spellcheck"),ha=y("events,caret,typing,plaintext-only"),fa=y("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ma="http://www.w3.org/1999/xlink",ga=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},va=function(n){return ga(n)?n.slice(6,n.length):""},ya=function(n){return null==n||!1===n};function ba(n){for(var e=n.data,t=n,a=n;o(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(e=ka(a.data,e));for(;o(t=t.parent);)t&&t.data&&(e=ka(e,t.data));return function(n,e){if(o(n)||o(e))return wa(n,xa(e));return""}(e.staticClass,e.class)}function ka(n,e){return{staticClass:wa(n.staticClass,e.staticClass),class:o(n.class)?[n.class,e.class]:e.class}}function wa(n,e){return n?e?n+" "+e:n:e||""}function xa(n){return Array.isArray(n)?function(n){for(var e,t="",a=0,r=n.length;a<r;a++)o(e=xa(n[a]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):u(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var Sa={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},_a=y("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),ja=y("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Ta=function(n){return _a(n)||ja(n)};var Ca=Object.create(null);var Aa=y("text,number,password,search,email,tel,url");var Ia=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(Sa[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),Ea={create:function(n,e){Oa(e)},update:function(n,e){n.data.ref!==e.data.ref&&(Oa(n,!0),Oa(e))},destroy:function(n){Oa(n,!0)}};function Oa(n,e){var t=n.data.ref;if(o(t)){var a=n.context,i=n.componentInstance||n.elm,s=e?null:i,l=e?void 0:i;if(c(t))Pe(t,a,[s],a,"template ref function");else{var u=n.data.refInFor,d="string"==typeof t||"number"==typeof t,p=Nn(t),h=a.$refs;if(d||p)if(u){var f=d?h[t]:t.value;e?r(f)&&k(f,i):r(f)?f.includes(i)||f.push(i):d?(h[t]=[i],La(a,t,h[t])):t.value=[i]}else if(d){if(e&&h[t]!==i)return;h[t]=l,La(a,t,s)}else if(p){if(e&&t.value!==i)return;t.value=s}else 0}}}function La(n,e,t){var a=n._setupState;a&&x(a,e)&&(Nn(a[e])?a[e].value=t:a[e]=t)}var $a=new fn("",{},[]),Pa=["create","activate","update","remove","destroy"];function za(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&o(n.data)===o(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,a=o(t=n.data)&&o(t=t.attrs)&&t.type,r=o(t=e.data)&&o(t=t.attrs)&&t.type;return a===r||Aa(a)&&Aa(r)}(n,e)||s(n.isAsyncPlaceholder)&&i(e.asyncFactory.error))}function Da(n,e,t){var a,r,i={};for(a=e;a<=t;++a)o(r=n[a].key)&&(i[r]=a);return i}var Ma={create:Fa,update:Fa,destroy:function(n){Fa(n,$a)}};function Fa(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,a,r,i=n===$a,o=e===$a,s=qa(n.data.directives,n.context),l=qa(e.data.directives,e.context),c=[],u=[];for(t in l)a=s[t],r=l[t],a?(r.oldValue=a.value,r.oldArg=a.arg,Ba(r,"update",e,n),r.def&&r.def.componentUpdated&&u.push(r)):(Ba(r,"bind",e,n),r.def&&r.def.inserted&&c.push(r));if(c.length){var d=function(){for(var t=0;t<c.length;t++)Ba(c[t],"inserted",e,n)};i?ne(e,"insert",d):d()}u.length&&ne(e,"postpatch",(function(){for(var t=0;t<u.length;t++)Ba(u[t],"componentUpdated",e,n)}));if(!i)for(t in s)l[t]||Ba(s[t],"unbind",n,n,o)}(n,e)}var Ra=Object.create(null);function qa(n,e){var t,a,r=Object.create(null);if(!n)return r;for(t=0;t<n.length;t++){if((a=n[t]).modifiers||(a.modifiers=Ra),r[Na(a)]=a,e._setupState&&e._setupState.__sfc){var i=a.def||qt(e,"_setupState","v-"+a.name);a.def="function"==typeof i?{bind:i,update:i}:i}a.def=a.def||qt(e.$options,"directives",a.name)}return r}function Na(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Ba(n,e,t,a,r){var i=n.def&&n.def[e];if(i)try{i(t.elm,n,t,a,r)}catch(a){$e(a,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Ua=[Ea,Ma];function Ja(n,e){var t=e.componentOptions;if(!(o(t)&&!1===t.Ctor.options.inheritAttrs||i(n.data.attrs)&&i(e.data.attrs))){var a,r,l=e.elm,c=n.data.attrs||{},u=e.data.attrs||{};for(a in(o(u.__ob__)||s(u._v_attr_proxy))&&(u=e.data.attrs=O({},u)),u)r=u[a],c[a]!==r&&Va(l,a,r,e.data.pre);for(a in(K||X)&&u.value!==c.value&&Va(l,"value",u.value),c)i(u[a])&&(ga(a)?l.removeAttributeNS(ma,va(a)):pa(a)||l.removeAttribute(a))}}function Va(n,e,t,a){a||n.tagName.indexOf("-")>-1?Wa(n,e,t):fa(e)?ya(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):pa(e)?n.setAttribute(e,function(n,e){return ya(e)||"false"===e?"false":"contenteditable"===n&&ha(e)?e:"true"}(e,t)):ga(e)?ya(t)?n.removeAttributeNS(ma,va(e)):n.setAttributeNS(ma,e,t):Wa(n,e,t)}function Wa(n,e,t){if(ya(t))n.removeAttribute(e);else{if(K&&!Y&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var a=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",a)};n.addEventListener("input",a),n.__ieph=!0}n.setAttribute(e,t)}}var Ha={create:Ja,update:Ja};function Qa(n,e){var t=e.elm,a=e.data,r=n.data;if(!(i(a.staticClass)&&i(a.class)&&(i(r)||i(r.staticClass)&&i(r.class)))){var s=ba(e),l=t._transitionClasses;o(l)&&(s=wa(s,xa(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var Ga,Ka={create:Qa,update:Qa};function Ya(n,e,t){var a=Ga;return function r(){var i=e.apply(null,arguments);null!==i&&nr(n,r,t,a)}}var Xa=Fe&&!(en&&Number(en[1])<=53);function Za(n,e,t,a){if(Xa){var r=vt,i=e;e=i._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=r||n.timeStamp<=0||n.target.ownerDocument!==document)return i.apply(this,arguments)}}Ga.addEventListener(n,e,an?{capture:t,passive:a}:t)}function nr(n,e,t,a){(a||Ga).removeEventListener(n,e._wrapper||e,t)}function er(n,e){if(!i(n.data.on)||!i(e.data.on)){var t=e.data.on||{},a=n.data.on||{};Ga=e.elm||n.elm,function(n){if(o(n.__r)){var e=K?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}o(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Zn(t,a,Za,nr,Ya,e.context),Ga=void 0}}var tr,ar={create:er,update:er,destroy:function(n){return er(n,$a)}};function rr(n,e){if(!i(n.data.domProps)||!i(e.data.domProps)){var t,a,r=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(o(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.domProps=O({},c)),l)t in c||(r[t]="");for(t in c){if(a=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),a===l[t])continue;1===r.childNodes.length&&r.removeChild(r.childNodes[0])}if("value"===t&&"PROGRESS"!==r.tagName){r._value=a;var u=i(a)?"":String(a);ir(r,u)&&(r.value=u)}else if("innerHTML"===t&&ja(r.tagName)&&i(r.innerHTML)){(tr=tr||document.createElement("div")).innerHTML="<svg>".concat(a,"</svg>");for(var d=tr.firstChild;r.firstChild;)r.removeChild(r.firstChild);for(;d.firstChild;)r.appendChild(d.firstChild)}else if(a!==l[t])try{r[t]=a}catch(n){}}}}function ir(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,a=n._vModifiers;if(o(a)){if(a.number)return v(t)!==v(e);if(a.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var or={create:rr,update:rr},sr=S((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var a=n.split(t);a.length>1&&(e[a[0].trim()]=a[1].trim())}})),e}));function lr(n){var e=cr(n.style);return n.staticStyle?O(n.staticStyle,e):e}function cr(n){return Array.isArray(n)?L(n):"string"==typeof n?sr(n):n}var ur,dr=/^--/,pr=/\s*!important$/,hr=function(n,e,t){if(dr.test(e))n.style.setProperty(e,t);else if(pr.test(t))n.style.setProperty(A(e),t.replace(pr,""),"important");else{var a=mr(e);if(Array.isArray(t))for(var r=0,i=t.length;r<i;r++)n.style[a]=t[r];else n.style[a]=t}},fr=["Webkit","Moz","ms"],mr=S((function(n){if(ur=ur||document.createElement("div").style,"filter"!==(n=j(n))&&n in ur)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<fr.length;t++){var a=fr[t]+e;if(a in ur)return a}}));function gr(n,e){var t=e.data,a=n.data;if(!(i(t.staticStyle)&&i(t.style)&&i(a.staticStyle)&&i(a.style))){var r,s,l=e.elm,c=a.staticStyle,u=a.normalizedStyle||a.style||{},d=c||u,p=cr(e.data.style)||{};e.data.normalizedStyle=o(p.__ob__)?O({},p):p;var h=function(n,e){var t,a={};if(e)for(var r=n;r.componentInstance;)(r=r.componentInstance._vnode)&&r.data&&(t=lr(r.data))&&O(a,t);(t=lr(n.data))&&O(a,t);for(var i=n;i=i.parent;)i.data&&(t=lr(i.data))&&O(a,t);return a}(e,!0);for(s in d)i(h[s])&&hr(l,s,"");for(s in h)(r=h[s])!==d[s]&&hr(l,s,null==r?"":r)}}var vr={create:gr,update:gr},yr=/\s+/;function br(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(yr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function kr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(yr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),a=" "+e+" ";t.indexOf(a)>=0;)t=t.replace(a," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function wr(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&O(e,xr(n.name||"v")),O(e,n),e}return"string"==typeof n?xr(n):void 0}}var xr=S((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),Sr=Q&&!Y,_r="transition",jr="transitionend",Tr="animation",Cr="animationend";Sr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(_r="WebkitTransition",jr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Tr="WebkitAnimation",Cr="webkitAnimationEnd"));var Ar=Q?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Ir(n){Ar((function(){Ar(n)}))}function Er(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),br(n,e))}function Or(n,e){n._transitionClasses&&k(n._transitionClasses,e),kr(n,e)}function Lr(n,e,t){var a=Pr(n,e),r=a.type,i=a.timeout,o=a.propCount;if(!r)return t();var s="transition"===r?jr:Cr,l=0,c=function(){n.removeEventListener(s,u),t()},u=function(e){e.target===n&&++l>=o&&c()};setTimeout((function(){l<o&&c()}),i+1),n.addEventListener(s,u)}var $r=/\b(transform|all)(,|$)/;function Pr(n,e){var t,a=window.getComputedStyle(n),r=(a[_r+"Delay"]||"").split(", "),i=(a[_r+"Duration"]||"").split(", "),o=zr(r,i),s=(a[Tr+"Delay"]||"").split(", "),l=(a[Tr+"Duration"]||"").split(", "),c=zr(s,l),u=0,d=0;return"transition"===e?o>0&&(t="transition",u=o,d=i.length):"animation"===e?c>0&&(t="animation",u=c,d=l.length):d=(t=(u=Math.max(o,c))>0?o>c?"transition":"animation":null)?"transition"===t?i.length:l.length:0,{type:t,timeout:u,propCount:d,hasTransform:"transition"===t&&$r.test(a[_r+"Property"])}}function zr(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Dr(e)+Dr(n[t])})))}function Dr(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Mr(n,e){var t=n.elm;o(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var a=wr(n.data.transition);if(!i(a)&&!o(t._enterCb)&&1===t.nodeType){for(var r=a.css,s=a.type,l=a.enterClass,d=a.enterToClass,p=a.enterActiveClass,h=a.appearClass,f=a.appearToClass,m=a.appearActiveClass,g=a.beforeEnter,y=a.enter,b=a.afterEnter,k=a.enterCancelled,w=a.beforeAppear,x=a.appear,S=a.afterAppear,_=a.appearCancelled,j=a.duration,T=ot,C=ot.$vnode;C&&C.parent;)T=C.context,C=C.parent;var A=!T._isMounted||!n.isRootInsert;if(!A||x||""===x){var I=A&&h?h:l,E=A&&m?m:p,O=A&&f?f:d,L=A&&w||g,$=A&&c(x)?x:y,P=A&&S||b,z=A&&_||k,D=v(u(j)?j.enter:j);0;var M=!1!==r&&!Y,R=qr($),q=t._enterCb=F((function(){M&&(Or(t,O),Or(t,E)),q.cancelled?(M&&Or(t,I),z&&z(t)):P&&P(t),t._enterCb=null}));n.data.show||ne(n,"insert",(function(){var e=t.parentNode,a=e&&e._pending&&e._pending[n.key];a&&a.tag===n.tag&&a.elm._leaveCb&&a.elm._leaveCb(),$&&$(t,q)})),L&&L(t),M&&(Er(t,I),Er(t,E),Ir((function(){Or(t,I),q.cancelled||(Er(t,O),R||(Rr(D)?setTimeout(q,D):Lr(t,s,q)))}))),n.data.show&&(e&&e(),$&&$(t,q)),M||R||q()}}}function Fr(n,e){var t=n.elm;o(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var a=wr(n.data.transition);if(i(a)||1!==t.nodeType)return e();if(!o(t._leaveCb)){var r=a.css,s=a.type,l=a.leaveClass,c=a.leaveToClass,d=a.leaveActiveClass,p=a.beforeLeave,h=a.leave,f=a.afterLeave,m=a.leaveCancelled,g=a.delayLeave,y=a.duration,b=!1!==r&&!Y,k=qr(h),w=v(u(y)?y.leave:y);0;var x=t._leaveCb=F((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),b&&(Or(t,c),Or(t,d)),x.cancelled?(b&&Or(t,l),m&&m(t)):(e(),f&&f(t)),t._leaveCb=null}));g?g(S):S()}function S(){x.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),b&&(Er(t,l),Er(t,d),Ir((function(){Or(t,l),x.cancelled||(Er(t,c),k||(Rr(w)?setTimeout(x,w):Lr(t,s,x)))}))),h&&h(t,x),b||k||x())}}function Rr(n){return"number"==typeof n&&!isNaN(n)}function qr(n){if(i(n))return!1;var e=n.fns;return o(e)?qr(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Nr(n,e){!0!==e.data.show&&Mr(e)}var Br=function(n){var e,t,a={},c=n.modules,u=n.nodeOps;for(e=0;e<Pa.length;++e)for(a[Pa[e]]=[],t=0;t<c.length;++t)o(c[t][Pa[e]])&&a[Pa[e]].push(c[t][Pa[e]]);function d(n){var e=u.parentNode(n);o(e)&&u.removeChild(e,n)}function p(n,e,t,r,i,l,c){if(o(n.elm)&&o(l)&&(n=l[c]=vn(n)),n.isRootInsert=!i,!function(n,e,t,r){var i=n.data;if(o(i)){var l=o(n.componentInstance)&&i.keepAlive;if(o(i=i.hook)&&o(i=i.init)&&i(n,!1),o(n.componentInstance))return h(n,e),f(t,n.elm,r),s(l)&&function(n,e,t,r){var i,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,o(i=s.data)&&o(i=i.transition)){for(i=0;i<a.activate.length;++i)a.activate[i]($a,s);e.push(s);break}f(t,n.elm,r)}(n,e,t,r),!0}}(n,e,t,r)){var d=n.data,p=n.children,g=n.tag;o(g)?(n.elm=n.ns?u.createElementNS(n.ns,g):u.createElement(g,n),b(n),m(n,p,e),o(d)&&v(n,e),f(t,n.elm,r)):s(n.isComment)?(n.elm=u.createComment(n.text),f(t,n.elm,r)):(n.elm=u.createTextNode(n.text),f(t,n.elm,r))}}function h(n,e){o(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(v(n,e),b(n)):(Oa(n),e.push(n))}function f(n,e,t){o(n)&&(o(t)?u.parentNode(t)===n&&u.insertBefore(n,e,t):u.appendChild(n,e))}function m(n,e,t){if(r(e)){0;for(var a=0;a<e.length;++a)p(e[a],t,n.elm,null,!0,e,a)}else l(n.text)&&u.appendChild(n.elm,u.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return o(n.tag)}function v(n,t){for(var r=0;r<a.create.length;++r)a.create[r]($a,n);o(e=n.data.hook)&&(o(e.create)&&e.create($a,n),o(e.insert)&&t.push(n))}function b(n){var e;if(o(e=n.fnScopeId))u.setStyleScope(n.elm,e);else for(var t=n;t;)o(e=t.context)&&o(e=e.$options._scopeId)&&u.setStyleScope(n.elm,e),t=t.parent;o(e=ot)&&e!==n.context&&e!==n.fnContext&&o(e=e.$options._scopeId)&&u.setStyleScope(n.elm,e)}function k(n,e,t,a,r,i){for(;a<=r;++a)p(t[a],i,n,e,!1,t,a)}function w(n){var e,t,r=n.data;if(o(r))for(o(e=r.hook)&&o(e=e.destroy)&&e(n),e=0;e<a.destroy.length;++e)a.destroy[e](n);if(o(e=n.children))for(t=0;t<n.children.length;++t)w(n.children[t])}function x(n,e,t){for(;e<=t;++e){var a=n[e];o(a)&&(o(a.tag)?(S(a),w(a)):d(a.elm))}}function S(n,e){if(o(e)||o(n.data)){var t,r=a.remove.length+1;for(o(e)?e.listeners+=r:e=function(n,e){function t(){0==--t.listeners&&d(n)}return t.listeners=e,t}(n.elm,r),o(t=n.componentInstance)&&o(t=t._vnode)&&o(t.data)&&S(t,e),t=0;t<a.remove.length;++t)a.remove[t](n,e);o(t=n.data.hook)&&o(t=t.remove)?t(n,e):e()}else d(n.elm)}function _(n,e,t,a){for(var r=t;r<a;r++){var i=e[r];if(o(i)&&za(n,i))return r}}function j(n,e,t,r,l,c){if(n!==e){o(e.elm)&&o(r)&&(e=r[l]=vn(e));var d=e.elm=n.elm;if(s(n.isAsyncPlaceholder))o(e.asyncFactory.resolved)?A(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var h,f=e.data;o(f)&&o(h=f.hook)&&o(h=h.prepatch)&&h(n,e);var m=n.children,v=e.children;if(o(f)&&g(e)){for(h=0;h<a.update.length;++h)a.update[h](n,e);o(h=f.hook)&&o(h=h.update)&&h(n,e)}i(e.text)?o(m)&&o(v)?m!==v&&function(n,e,t,a,r){var s,l,c,d=0,h=0,f=e.length-1,m=e[0],g=e[f],v=t.length-1,y=t[0],b=t[v],w=!r;for(0;d<=f&&h<=v;)i(m)?m=e[++d]:i(g)?g=e[--f]:za(m,y)?(j(m,y,a,t,h),m=e[++d],y=t[++h]):za(g,b)?(j(g,b,a,t,v),g=e[--f],b=t[--v]):za(m,b)?(j(m,b,a,t,v),w&&u.insertBefore(n,m.elm,u.nextSibling(g.elm)),m=e[++d],b=t[--v]):za(g,y)?(j(g,y,a,t,h),w&&u.insertBefore(n,g.elm,m.elm),g=e[--f],y=t[++h]):(i(s)&&(s=Da(e,d,f)),i(l=o(y.key)?s[y.key]:_(y,e,d,f))?p(y,a,n,m.elm,!1,t,h):za(c=e[l],y)?(j(c,y,a,t,h),e[l]=void 0,w&&u.insertBefore(n,c.elm,m.elm)):p(y,a,n,m.elm,!1,t,h),y=t[++h]);d>f?k(n,i(t[v+1])?null:t[v+1].elm,t,h,v,a):h>v&&x(e,d,f)}(d,m,v,t,c):o(v)?(o(n.text)&&u.setTextContent(d,""),k(d,null,v,0,v.length-1,t)):o(m)?x(m,0,m.length-1):o(n.text)&&u.setTextContent(d,""):n.text!==e.text&&u.setTextContent(d,e.text),o(f)&&o(h=f.hook)&&o(h=h.postpatch)&&h(n,e)}}}function T(n,e,t){if(s(t)&&o(n.parent))n.parent.data.pendingInsert=e;else for(var a=0;a<e.length;++a)e[a].data.hook.insert(e[a])}var C=y("attrs,class,staticClass,staticStyle,key");function A(n,e,t,a){var r,i=e.tag,l=e.data,c=e.children;if(a=a||l&&l.pre,e.elm=n,s(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(l)&&(o(r=l.hook)&&o(r=r.init)&&r(e,!0),o(r=e.componentInstance)))return h(e,t),!0;if(o(i)){if(o(c))if(n.hasChildNodes())if(o(r=l)&&o(r=r.domProps)&&o(r=r.innerHTML)){if(r!==n.innerHTML)return!1}else{for(var u=!0,d=n.firstChild,p=0;p<c.length;p++){if(!d||!A(d,c[p],t,a)){u=!1;break}d=d.nextSibling}if(!u||d)return!1}else m(e,c,t);if(o(l)){var f=!1;for(var g in l)if(!C(g)){f=!0,v(e,t);break}!f&&l.class&&Xe(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,r){if(!i(e)){var l,c=!1,d=[];if(i(n))c=!0,p(e,d);else{var h=o(n.nodeType);if(!h&&za(n,e))j(n,e,d,null,null,r);else{if(h){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&A(n,e,d))return T(e,d,!0),n;l=n,n=new fn(u.tagName(l).toLowerCase(),{},[],void 0,l)}var f=n.elm,m=u.parentNode(f);if(p(e,d,f._leaveCb?null:m,u.nextSibling(f)),o(e.parent))for(var v=e.parent,y=g(e);v;){for(var b=0;b<a.destroy.length;++b)a.destroy[b](v);if(v.elm=e.elm,y){for(var k=0;k<a.create.length;++k)a.create[k]($a,v);var S=v.data.hook.insert;if(S.merged)for(var _=1;_<S.fns.length;_++)S.fns[_]()}else Oa(v);v=v.parent}o(m)?x([n],0,0):o(n.tag)&&w(n)}}return T(e,d,c),e.elm}o(n)&&w(n)}}({nodeOps:Ia,modules:[Ha,Ka,ar,or,vr,Q?{create:Nr,activate:Nr,remove:function(n,e){!0!==n.data.show?Fr(n,e):e()}}:{}].concat(Ua)});Y&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Kr(n,"input")}));var Ur={inserted:function(n,e,t,a){"select"===t.tag?(a.elm&&!a.elm._vOptions?ne(t,"postpatch",(function(){Ur.componentUpdated(n,e,t)})):Jr(n,e,t.context),n._vOptions=[].map.call(n.options,Hr)):("textarea"===t.tag||Aa(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Qr),n.addEventListener("compositionend",Gr),n.addEventListener("change",Gr),Y&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Jr(n,e,t.context);var a=n._vOptions,r=n._vOptions=[].map.call(n.options,Hr);if(r.some((function(n,e){return!D(n,a[e])})))(n.multiple?e.value.some((function(n){return Wr(n,r)})):e.value!==e.oldValue&&Wr(e.value,r))&&Kr(n,"change")}}};function Jr(n,e,t){Vr(n,e,t),(K||X)&&setTimeout((function(){Vr(n,e,t)}),0)}function Vr(n,e,t){var a=e.value,r=n.multiple;if(!r||Array.isArray(a)){for(var i,o,s=0,l=n.options.length;s<l;s++)if(o=n.options[s],r)i=M(a,Hr(o))>-1,o.selected!==i&&(o.selected=i);else if(D(Hr(o),a))return void(n.selectedIndex!==s&&(n.selectedIndex=s));r||(n.selectedIndex=-1)}}function Wr(n,e){return e.every((function(e){return!D(e,n)}))}function Hr(n){return"_value"in n?n._value:n.value}function Qr(n){n.target.composing=!0}function Gr(n){n.target.composing&&(n.target.composing=!1,Kr(n.target,"input"))}function Kr(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Yr(n){return!n.componentInstance||n.data&&n.data.transition?n:Yr(n.componentInstance._vnode)}var Xr={model:Ur,show:{bind:function(n,e,t){var a=e.value,r=(t=Yr(t)).data&&t.data.transition,i=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;a&&r?(t.data.show=!0,Mr(t,(function(){n.style.display=i}))):n.style.display=a?i:"none"},update:function(n,e,t){var a=e.value;!a!=!e.oldValue&&((t=Yr(t)).data&&t.data.transition?(t.data.show=!0,a?Mr(t,(function(){n.style.display=n.__vOriginalDisplay})):Fr(t,(function(){n.style.display="none"}))):n.style.display=a?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,a,r){r||(n.style.display=n.__vOriginalDisplay)}}},Zr={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function ni(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?ni(Oe(e.children)):n}function ei(n){var e={},t=n.$options;for(var a in t.propsData)e[a]=n[a];var r=t._parentListeners;for(var a in r)e[j(a)]=r[a];return e}function ti(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var ai=function(n){return n.tag||we(n)},ri=function(n){return"show"===n.name},ii={name:"transition",props:Zr,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(ai)).length){0;var a=this.mode;0;var r=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return r;var i=ni(r);if(!i)return r;if(this._leaving)return ti(n,r);var o="__transition-".concat(this._uid,"-");i.key=null==i.key?i.isComment?o+"comment":o+i.tag:l(i.key)?0===String(i.key).indexOf(o)?i.key:o+i.key:i.key;var s=(i.data||(i.data={})).transition=ei(this),c=this._vnode,u=ni(c);if(i.data.directives&&i.data.directives.some(ri)&&(i.data.show=!0),u&&u.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(i,u)&&!we(u)&&(!u.componentInstance||!u.componentInstance._vnode.isComment)){var d=u.data.transition=O({},s);if("out-in"===a)return this._leaving=!0,ne(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),ti(n,r);if("in-out"===a){if(we(i))return c;var p,h=function(){p()};ne(s,"afterEnter",h),ne(s,"enterCancelled",h),ne(d,"delayLeave",(function(n){p=n}))}}return r}}},oi=O({tag:String,moveClass:String},Zr);function si(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function li(n){n.data.newPos=n.elm.getBoundingClientRect()}function ci(n){var e=n.data.pos,t=n.data.newPos,a=e.left-t.left,r=e.top-t.top;if(a||r){n.data.moved=!0;var i=n.elm.style;i.transform=i.WebkitTransform="translate(".concat(a,"px,").concat(r,"px)"),i.transitionDuration="0s"}}delete oi.mode;var ui={Transition:ii,TransitionGroup:{props:oi,beforeMount:function(){var n=this,e=this._update;this._update=function(t,a){var r=st(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,r(),e.call(n,t,a)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),a=this.prevChildren=this.children,r=this.$slots.default||[],i=this.children=[],o=ei(this),s=0;s<r.length;s++){if((u=r[s]).tag)if(null!=u.key&&0!==String(u.key).indexOf("__vlist"))i.push(u),t[u.key]=u,(u.data||(u.data={})).transition=o;else;}if(a){var l=[],c=[];for(s=0;s<a.length;s++){var u;(u=a[s]).data.transition=o,u.data.pos=u.elm.getBoundingClientRect(),t[u.key]?l.push(u):c.push(u)}this.kept=n(e,null,l),this.removed=c}return n(e,null,i)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(si),n.forEach(li),n.forEach(ci),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,a=t.style;Er(t,e),a.transform=a.WebkitTransform=a.transitionDuration="",t.addEventListener(jr,t._moveCb=function n(a){a&&a.target!==t||a&&!/transform$/.test(a.propertyName)||(t.removeEventListener(jr,n),t._moveCb=null,Or(t,e))})}})))},methods:{hasMove:function(n,e){if(!Sr)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){kr(t,n)})),br(t,e),t.style.display="none",this.$el.appendChild(t);var a=Pr(t);return this.$el.removeChild(t),this._hasMove=a.hasTransform}}}};ta.config.mustUseProp=function(n,e,t){return"value"===t&&da(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},ta.config.isReservedTag=Ta,ta.config.isReservedAttr=ua,ta.config.getTagNamespace=function(n){return ja(n)?"svg":"math"===n?"math":void 0},ta.config.isUnknownElement=function(n){if(!Q)return!0;if(Ta(n))return!1;if(n=n.toLowerCase(),null!=Ca[n])return Ca[n];var e=document.createElement(n);return n.indexOf("-")>-1?Ca[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:Ca[n]=/HTMLUnknownElement/.test(e.toString())},O(ta.options.directives,Xr),O(ta.options.components,ui),ta.prototype.__patch__=Q?Br:$,ta.prototype.$mount=function(n,e){return function(n,e,t){var a;n.$el=e,n.$options.render||(n.$options.render=mn),ut(n,"beforeMount"),a=function(){n._update(n._render(),t)},new et(n,a,$,{before:function(){n._isMounted&&!n._isDestroyed&&ut(n,"beforeUpdate")}},!0),t=!1;var r=n._preWatchers;if(r)for(var i=0;i<r.length;i++)r[i].run();return null==n.$vnode&&(n._isMounted=!0,ut(n,"mounted")),n}(this,n=n&&Q?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},Q&&setTimeout((function(){B.devtools&&sn&&sn.emit("init",ta)}),0)},function(n,e,t){"use strict";function a(n,e,t,a,r,i,o,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),a&&(c.functional=!0),i&&(c._scopeId="data-v-"+i),o?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),r&&r.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},c._ssrRegister=l):r&&(l=s?function(){r.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:r),l)if(c.functional){c._injectStyles=l;var u=c.render;c.render=function(n,e){return l.call(e),u(n,e)}}else{var d=c.beforeCreate;c.beforeCreate=d?[].concat(d,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return a}))},function(n,e,t){var a=t(70),r=a.all;n.exports=a.IS_HTMLDDA?function(n){return"function"==typeof n||n===r}:function(n){return"function"==typeof n}},function(n,e,t){"use strict";var a=t(114),r=Object.prototype.toString;function i(n){return"[object Array]"===r.call(n)}function o(n){return void 0===n}function s(n){return null!==n&&"object"==typeof n}function l(n){if("[object Object]"!==r.call(n))return!1;var e=Object.getPrototypeOf(n);return null===e||e===Object.prototype}function c(n){return"[object Function]"===r.call(n)}function u(n,e){if(null!=n)if("object"!=typeof n&&(n=[n]),i(n))for(var t=0,a=n.length;t<a;t++)e.call(null,n[t],t,n);else for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&e.call(null,n[r],r,n)}n.exports={isArray:i,isArrayBuffer:function(n){return"[object ArrayBuffer]"===r.call(n)},isBuffer:function(n){return null!==n&&!o(n)&&null!==n.constructor&&!o(n.constructor)&&"function"==typeof n.constructor.isBuffer&&n.constructor.isBuffer(n)},isFormData:function(n){return"undefined"!=typeof FormData&&n instanceof FormData},isArrayBufferView:function(n){return"undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(n):n&&n.buffer&&n.buffer instanceof ArrayBuffer},isString:function(n){return"string"==typeof n},isNumber:function(n){return"number"==typeof n},isObject:s,isPlainObject:l,isUndefined:o,isDate:function(n){return"[object Date]"===r.call(n)},isFile:function(n){return"[object File]"===r.call(n)},isBlob:function(n){return"[object Blob]"===r.call(n)},isFunction:c,isStream:function(n){return s(n)&&c(n.pipe)},isURLSearchParams:function(n){return"undefined"!=typeof URLSearchParams&&n instanceof URLSearchParams},isStandardBrowserEnv:function(){return("undefined"==typeof navigator||"ReactNative"!==navigator.product&&"NativeScript"!==navigator.product&&"NS"!==navigator.product)&&("undefined"!=typeof window&&"undefined"!=typeof document)},forEach:u,merge:function n(){var e={};function t(t,a){l(e[a])&&l(t)?e[a]=n(e[a],t):l(t)?e[a]=n({},t):i(t)?e[a]=t.slice():e[a]=t}for(var a=0,r=arguments.length;a<r;a++)u(arguments[a],t);return e},extend:function(n,e,t){return u(e,(function(e,r){n[r]=t&&"function"==typeof e?a(e,t):e})),n},trim:function(n){return n.trim?n.trim():n.replace(/^\s+|\s+$/g,"")},stripBOM:function(n){return 65279===n.charCodeAt(0)&&(n=n.slice(1)),n}}},function(n,e,t){var a=t(41),r=Function.prototype,i=r.call,o=a&&r.bind.bind(i,i);n.exports=a?o:function(n){return function(){return i.apply(n,arguments)}}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){"use strict";t.d(e,"a",(function(){return d}));var a=t(0);
/**
  * vue-class-component v7.2.6
  * (c) 2015-present Evan You
  * @license MIT
  */function r(n){return(r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}function i(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function o(n){return function(n){if(Array.isArray(n)){for(var e=0,t=new Array(n.length);e<n.length;e++)t[e]=n[e];return t}}(n)||function(n){if(Symbol.iterator in Object(n)||"[object Arguments]"===Object.prototype.toString.call(n))return Array.from(n)}(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}function s(){return"undefined"!=typeof Reflect&&Reflect.defineMetadata&&Reflect.getOwnMetadataKeys}function l(n,e){c(n,e),Object.getOwnPropertyNames(e.prototype).forEach((function(t){c(n.prototype,e.prototype,t)})),Object.getOwnPropertyNames(e).forEach((function(t){c(n,e,t)}))}function c(n,e,t){(t?Reflect.getOwnMetadataKeys(e,t):Reflect.getOwnMetadataKeys(e)).forEach((function(a){var r=t?Reflect.getOwnMetadata(a,e,t):Reflect.getOwnMetadata(a,e);t?Reflect.defineMetadata(a,r,n,t):Reflect.defineMetadata(a,r,n)}))}var u={__proto__:[]}instanceof Array;function d(n){return function(e,t,a){var r="function"==typeof e?e:e.constructor;r.__decorators__||(r.__decorators__=[]),"number"!=typeof a&&(a=void 0),r.__decorators__.push((function(e){return n(e,t,a)}))}}function p(n,e){var t=e.prototype._init;e.prototype._init=function(){var e=this,t=Object.getOwnPropertyNames(n);if(n.$options.props)for(var a in n.$options.props)n.hasOwnProperty(a)||t.push(a);t.forEach((function(t){Object.defineProperty(e,t,{get:function(){return n[t]},set:function(e){n[t]=e},configurable:!0})}))};var a=new e;e.prototype._init=t;var r={};return Object.keys(a).forEach((function(n){void 0!==a[n]&&(r[n]=a[n])})),r}var h=["data","beforeCreate","created","beforeMount","mounted","beforeDestroy","destroyed","beforeUpdate","updated","activated","deactivated","render","errorCaptured","serverPrefetch"];function f(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};e.name=e.name||n._componentTag||n.name;var t=n.prototype;Object.getOwnPropertyNames(t).forEach((function(n){if("constructor"!==n)if(h.indexOf(n)>-1)e[n]=t[n];else{var a=Object.getOwnPropertyDescriptor(t,n);void 0!==a.value?"function"==typeof a.value?(e.methods||(e.methods={}))[n]=a.value:(e.mixins||(e.mixins=[])).push({data:function(){return i({},n,a.value)}}):(a.get||a.set)&&((e.computed||(e.computed={}))[n]={get:a.get,set:a.set})}})),(e.mixins||(e.mixins=[])).push({data:function(){return p(this,n)}});var r=n.__decorators__;r&&(r.forEach((function(n){return n(e)})),delete n.__decorators__);var o=Object.getPrototypeOf(n.prototype),c=o instanceof a.b?o.constructor:a.b,u=c.extend(e);return g(u,n,c),s()&&l(u,n),u}var m={prototype:!0,arguments:!0,callee:!0,caller:!0};function g(n,e,t){Object.getOwnPropertyNames(e).forEach((function(a){if(!m[a]){var i=Object.getOwnPropertyDescriptor(n,a);if(!i||i.configurable){var o,s,l=Object.getOwnPropertyDescriptor(e,a);if(!u){if("cid"===a)return;var c=Object.getOwnPropertyDescriptor(t,a);if(o=l.value,s=r(o),null!=o&&("object"===s||"function"===s)&&c&&c.value===l.value)return}0,Object.defineProperty(n,a,l)}}}))}function v(n){return"function"==typeof n?f(n):function(e){return f(e,n)}}v.registerHooks=function(n){h.push.apply(h,o(n))},e.b=v},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e,t){var a=t(5);n.exports=!a((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){n.exports=t(310)},function(n,e,t){var a=t(88),r="object"==typeof self&&self&&self.Object===Object&&self,i=a||r||Function("return this")();n.exports=i},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var a=t(4),r=t(29),i=a({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return i(r(n),e)}},function(n,e,t){"use strict";var a=t(21),r=t(29),i=t(30),o=t(158),s=t(160);a({target:"Array",proto:!0,arity:1,forced:t(5)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=r(this),t=i(e),a=arguments.length;s(t+a);for(var l=0;l<a;l++)e[t]=arguments[l],t++;return o(e,t),t}})},function(n,e,t){var a=t(2),r=t(70),i=r.all;n.exports=r.IS_HTMLDDA?function(n){return"object"==typeof n?null!==n:a(n)||n===i}:function(n){return"object"==typeof n?null!==n:a(n)}},function(n,e,t){var a=t(192),r=t(195);n.exports=function(n,e){var t=r(n,e);return a(t)?t:void 0}},function(n,e,t){var a=t(298),r=t(112),i=/[T ]/,o=/:/,s=/^(\d{2})$/,l=[/^([+-]\d{2})$/,/^([+-]\d{3})$/,/^([+-]\d{4})$/],c=/^(\d{4})/,u=[/^([+-]\d{4})/,/^([+-]\d{5})/,/^([+-]\d{6})/],d=/^-(\d{2})$/,p=/^-?(\d{3})$/,h=/^-?(\d{2})-?(\d{2})$/,f=/^-?W(\d{2})$/,m=/^-?W(\d{2})-?(\d{1})$/,g=/^(\d{2}([.,]\d*)?)$/,v=/^(\d{2}):?(\d{2}([.,]\d*)?)$/,y=/^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,b=/([Z+-].*)$/,k=/^(Z)$/,w=/^([+-])(\d{2})$/,x=/^([+-])(\d{2}):?(\d{2})$/;function S(n,e,t){e=e||0,t=t||0;var a=new Date(0);a.setUTCFullYear(n,0,4);var r=7*e+t+1-(a.getUTCDay()||7);return a.setUTCDate(a.getUTCDate()+r),a}n.exports=function(n,e){if(r(n))return new Date(n.getTime());if("string"!=typeof n)return new Date(n);var t=(e||{}).additionalDigits;t=null==t?2:Number(t);var _=function(n){var e,t={},a=n.split(i);o.test(a[0])?(t.date=null,e=a[0]):(t.date=a[0],e=a[1]);if(e){var r=b.exec(e);r?(t.time=e.replace(r[1],""),t.timezone=r[1]):t.time=e}return t}(n),j=function(n,e){var t,a=l[e],r=u[e];if(t=c.exec(n)||r.exec(n)){var i=t[1];return{year:parseInt(i,10),restDateString:n.slice(i.length)}}if(t=s.exec(n)||a.exec(n)){var o=t[1];return{year:100*parseInt(o,10),restDateString:n.slice(o.length)}}return{year:null}}(_.date,t),T=j.year,C=function(n,e){if(null===e)return null;var t,a,r,i;if(0===n.length)return(a=new Date(0)).setUTCFullYear(e),a;if(t=d.exec(n))return a=new Date(0),r=parseInt(t[1],10)-1,a.setUTCFullYear(e,r),a;if(t=p.exec(n)){a=new Date(0);var o=parseInt(t[1],10);return a.setUTCFullYear(e,0,o),a}if(t=h.exec(n)){a=new Date(0),r=parseInt(t[1],10)-1;var s=parseInt(t[2],10);return a.setUTCFullYear(e,r,s),a}if(t=f.exec(n))return i=parseInt(t[1],10)-1,S(e,i);if(t=m.exec(n)){i=parseInt(t[1],10)-1;var l=parseInt(t[2],10)-1;return S(e,i,l)}return null}(j.restDateString,T);if(C){var A,I=C.getTime(),E=0;if(_.time&&(E=function(n){var e,t,a;if(e=g.exec(n))return(t=parseFloat(e[1].replace(",",".")))%24*36e5;if(e=v.exec(n))return t=parseInt(e[1],10),a=parseFloat(e[2].replace(",",".")),t%24*36e5+6e4*a;if(e=y.exec(n)){t=parseInt(e[1],10),a=parseInt(e[2],10);var r=parseFloat(e[3].replace(",","."));return t%24*36e5+6e4*a+1e3*r}return null}(_.time)),_.timezone)A=6e4*function(n){var e,t;if(e=k.exec(n))return 0;if(e=w.exec(n))return t=60*parseInt(e[2],10),"+"===e[1]?-t:t;if(e=x.exec(n))return t=60*parseInt(e[2],10)+parseInt(e[3],10),"+"===e[1]?-t:t;return 0}(_.timezone);else{var O=I+E,L=new Date(O);A=a(L);var $=new Date(O);$.setDate(L.getDate()+1);var P=a($)-a(L);P>0&&(A+=P)}return new Date(I+E+A)}return new Date(n)}},function(n,e,t){"use strict";t.d(e,"c",(function(){return i})),t.d(e,"i",(function(){return o})),t.d(e,"f",(function(){return l})),t.d(e,"g",(function(){return c})),t.d(e,"h",(function(){return u})),t.d(e,"d",(function(){return d})),t.d(e,"e",(function(){return p})),t.d(e,"k",(function(){return h})),t.d(e,"l",(function(){return f})),t.d(e,"j",(function(){return m})),t.d(e,"b",(function(){return v})),t.d(e,"a",(function(){return y}));t(13);const a=/#.*$/,r=/\.(md|html)$/,i=/\/$/,o=/^(https?:|mailto:|tel:)/;function s(n){return decodeURI(n).replace(a,"").replace(r,"")}function l(n){return o.test(n)}function c(n){return/^mailto:/.test(n)}function u(n){return/^tel:/.test(n)}function d(n){if(l(n))return n;const e=n.match(a),t=e?e[0]:"",r=s(n);return i.test(r)?n:r+".html"+t}function p(n,e){const t=n.hash,r=function(n){const e=n.match(a);if(e)return e[0]}(e);if(r&&t!==r)return!1;return s(n.path)===s(e)}function h(n,e,t){t&&(e=function(n,e,t){const a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;const r=e.split("/");t&&r[r.length-1]||r.pop();const i=n.replace(/^\//,"").split("/");for(let n=0;n<i.length;n++){const e=i[n];".."===e?r.pop():"."!==e&&r.push(e)}""!==r[0]&&r.unshift("");return r.join("/")}(e,t));const a=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===a)return Object.assign({},n[e],{type:"page",path:d(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function f(n,e,t,a){const{pages:r,themeConfig:i}=t,o=(a&&i.locales&&i.locales[a]||i).sidebar||i.sidebar,{base:s,config:l}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const a in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(a)))return{base:a,config:e[a]};var t;return{}}(e,o);return l?l.map(n=>function n(e,t,a,r=1){if("string"==typeof e)return h(t,e,a);if(Array.isArray(e))return Object.assign(h(t,e[0],a),{title:e[1]});{r>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const i=e.children||[];return 0===i.length&&e.path?Object.assign(h(t,e.path,a),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,children:i.map(e=>n(e,t,a,r+1)),collapsable:!1!==e.collapsable}}}(n,r,s)):[]}function m(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function g(n){return n?new Date(n).getTime():0}function v(n,e){const t=g(n.frontmatter.date),a=g(e.frontmatter.date);return 0===t||0===a?0:a-t}function y(n){const e=document.createElement("link");e.rel="stylesheet",e.href=n,document.head.append(e)}},function(n,e,t){var a=t(8),r=t(79),i=t(81),o=t(23),s=t(69),l=TypeError,c=Object.defineProperty,u=Object.getOwnPropertyDescriptor;e.f=a?i?function(n,e,t){if(o(n),e=s(e),o(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var a=u(n,e);a&&a.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:a.configurable,enumerable:"enumerable"in t?t.enumerable:a.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(o(n),e=s(e),o(t),r)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){"use strict";var a=t(286),r=t(296),i=t(61);n.exports={formats:i,parse:r,stringify:a}},function(n,e,t){var a=t(7),r=t(67).f,i=t(22),o=t(141),s=t(47),l=t(83),c=t(154);n.exports=function(n,e){var t,u,d,p,h,f=n.target,m=n.global,g=n.stat;if(t=m?a:g?a[f]||s(f,{}):(a[f]||{}).prototype)for(u in e){if(p=e[u],d=n.dontCallGetSet?(h=r(t,u))&&h.value:t[u],!c(m?u:f+(g?".":"#")+u,n.forced)&&void 0!==d){if(typeof p==typeof d)continue;l(p,d)}(n.sham||d&&d.sham)&&i(p,"sham",!0),o(t,u,p,n)}}},function(n,e,t){var a=t(8),r=t(18),i=t(44);n.exports=a?function(n,e,t){return r.f(n,e,i(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var a=t(14),r=String,i=TypeError;n.exports=function(n){if(a(n))return n;throw i(r(n)+" is not an object")}},function(n,e,t){var a=t(10).Symbol;n.exports=a},function(n,e,t){var a=t(24),r=t(177),i=t(178),o=a?a.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?r(n):i(n)}},function(n,e,t){"use strict";t.d(e,"a",(function(){return r})),t.d(e,"c",(function(){return i})),t.d(e,"b",(function(){return o}));var a=t(17);function r(n,e){return n=n.filter((t,a)=>{const{title:r,frontmatter:{home:i,date:o,publish:s}}=t;if(n.indexOf(t)!==a)return!1;{const n=!0===i||null==r||!1===s;return!0===e?!(n||void 0===o):!n}})}function i(n){n.sort((n,e)=>{const t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(a.b)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(a.b)(n,e)})}function o(n){n.sort((n,e)=>Object(a.b)(n,e))}},function(n,e,t){var a=t(4),r=a({}.toString),i=a("".slice);n.exports=function(n){return i(r(n),8,-1)}},function(n,e,t){var a=t(7),r=t(76),i=t(12),o=t(78),s=t(74),l=t(73),c=a.Symbol,u=r("wks"),d=l?c.for||c:c&&c.withoutSetter||o;n.exports=function(n){return i(u,n)||(u[n]=s&&i(c,n)?c[n]:d("Symbol."+n)),u[n]}},function(n,e,t){var a=t(45),r=Object;n.exports=function(n){return r(a(n))}},function(n,e,t){var a=t(152);n.exports=function(n){return a(n.length)}},function(n,e,t){var a=t(64),r=t(45);n.exports=function(n){return a(r(n))}},function(n,e,t){var a=t(7),r=t(2),i=function(n){return r(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?i(a[n]):a[n]&&a[n][e]}},function(n,e,t){var a=t(151);n.exports=function(n){var e=+n;return e!=e||0===e?0:a(e)}},function(n,e,t){var a=t(182),r=t(183),i=t(184),o=t(185),s=t(186);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var a=t(90);n.exports=function(n,e){for(var t=n.length;t--;)if(a(n[t][0],e))return t;return-1}},function(n,e,t){var a=t(15)(Object,"create");n.exports=a},function(n,e,t){var a=t(204);n.exports=function(n,e){var t=n.__data__;return a(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var a=t(57);n.exports=function(n){if("string"==typeof n||a(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var a,r;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(r="function"==typeof(a=function(){var n,e,t={version:"0.2.0"},a=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function r(n,e,t){return n<e?e:n>t?t:n}function i(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(a[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=r(n,a.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(a.barSelector),u=a.speed,d=a.easing;return l.offsetWidth,o((function(e){""===a.positionUsing&&(a.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var r;return(r="translate3d"===a.positionUsing?{transform:"translate3d("+i(n)+"%,0,0)"}:"translate"===a.positionUsing?{transform:"translate("+i(n)+"%,0)"}:{"margin-left":i(n)+"%"}).transition="all "+e+"ms "+t,r}(n,u,d)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+u+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),u)}),u)):setTimeout(e,u)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),a.trickleSpeed)};return a.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*r(Math.random()*e,.1,.95)),e=r(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*a.trickleRate)},n=0,e=0,t.promise=function(a){return a&&"resolved"!==a.state()?(0===e&&t.start(),n++,e++,a.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=a.template;var r,o=e.querySelector(a.barSelector),l=n?"-100":i(t.status||0),u=document.querySelector(a.parent);return s(o,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),a.showSpinner||(r=e.querySelector(a.spinnerSelector))&&p(r),u!=document.body&&c(u,"nprogress-custom-parent"),u.appendChild(e),e},t.remove=function(){u(document.documentElement,"nprogress-busy"),u(document.querySelector(a.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var a,r=n.length,i=e.charAt(0).toUpperCase()+e.slice(1);r--;)if((a=n[r]+i)in t)return a;return e}(t))}function a(n,e,a){e=t(e),n.style[e]=a}return function(n,e){var t,r,i=arguments;if(2==i.length)for(t in e)void 0!==(r=e[t])&&e.hasOwnProperty(t)&&a(n,t,r);else a(n,i[1],i[2])}}();function l(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=d(n),a=t+e;l(t,e)||(n.className=a.substring(1))}function u(n,e){var t,a=d(n);l(n,e)&&(t=a.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?a.call(e,t,e,n):a)||(n.exports=r)},function(n,e,t){"use strict";t.d(e,"b",(function(){return a})),t.d(e,"c",(function(){return r})),t.d(e,"a",(function(){return i}));t(13),t(17);function a(){const n=["#e15b64","#f47e60","#f8b26a","#abbd81","#849b87","#e15b64","#f47e60","#f8b26a","#f26d6d","#67cc86","#fb9b5f","#3498db"];return n[Math.floor(Math.random()*n.length)]}function r(n){const e=n.__proto__.push;n.__proto__.push=function(n){return e.call(this,n).catch(n=>n)}}function i(n){const e=n.getRoutes();n.beforeEach((n,t,a)=>{const r=e.find(e=>e.regex.test(n.path));return/\.html$/.test(n.path)||r&&"*"!==r.path&&!r.redirect?a():decodeURIComponent(n.path)!==n.path?a(Object.assign({},n,{path:decodeURIComponent(n.path),fullPath:decodeURIComponent(n.fullPath)})):void a()})}},function(n,e,t){var a=t(5);n.exports=!a((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var a=t(2),r=t(139),i=TypeError;n.exports=function(n){if(a(n))return n;throw i(r(n)+" is not a function")}},function(n,e,t){var a=t(41),r=Function.prototype.call;n.exports=a?r.bind(r):function(){return r.apply(r,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var a=t(68),r=TypeError;n.exports=function(n){if(a(n))throw r("Can't call method on "+n);return n}},function(n,e,t){var a=t(7),r=t(47),i=a["__core-js_shared__"]||r("__core-js_shared__",{});n.exports=i},function(n,e,t){var a=t(7),r=Object.defineProperty;n.exports=function(n,e){try{r(a,n,{value:e,configurable:!0,writable:!0})}catch(t){a[n]=e}return e}},function(n,e){n.exports={}},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var a=t(176),r=t(19),i=Object.prototype,o=i.hasOwnProperty,s=i.propertyIsEnumerable,l=a(function(){return arguments}())?a:function(n){return r(n)&&o.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var a=t(15)(t(10),"Map");n.exports=a},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var a=t(196),r=t(203),i=t(205),o=t(206),s=t(207);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var a=t(11),r=t(57),i=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,e){if(a(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!r(n))||(o.test(n)||!i.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var a=t(25),r=t(19);n.exports=function(n){return"symbol"==typeof n||r(n)&&"[object Symbol]"==a(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){"use strict";var a=SyntaxError,r=Function,i=TypeError,o=function(n){try{return r('"use strict"; return ('+n+").constructor;")()}catch(n){}},s=Object.getOwnPropertyDescriptor;if(s)try{s({},"")}catch(n){s=null}var l=function(){throw new i},c=s?function(){try{return l}catch(n){try{return s(arguments,"callee").get}catch(n){return l}}}():l,u=t(288)(),d=Object.getPrototypeOf||function(n){return n.__proto__},p={},h="undefined"==typeof Uint8Array?void 0:d(Uint8Array),f={"%AggregateError%":"undefined"==typeof AggregateError?void 0:AggregateError,"%Array%":Array,"%ArrayBuffer%":"undefined"==typeof ArrayBuffer?void 0:ArrayBuffer,"%ArrayIteratorPrototype%":u?d([][Symbol.iterator]()):void 0,"%AsyncFromSyncIteratorPrototype%":void 0,"%AsyncFunction%":p,"%AsyncGenerator%":p,"%AsyncGeneratorFunction%":p,"%AsyncIteratorPrototype%":p,"%Atomics%":"undefined"==typeof Atomics?void 0:Atomics,"%BigInt%":"undefined"==typeof BigInt?void 0:BigInt,"%BigInt64Array%":"undefined"==typeof BigInt64Array?void 0:BigInt64Array,"%BigUint64Array%":"undefined"==typeof BigUint64Array?void 0:BigUint64Array,"%Boolean%":Boolean,"%DataView%":"undefined"==typeof DataView?void 0:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":Error,"%eval%":eval,"%EvalError%":EvalError,"%Float32Array%":"undefined"==typeof Float32Array?void 0:Float32Array,"%Float64Array%":"undefined"==typeof Float64Array?void 0:Float64Array,"%FinalizationRegistry%":"undefined"==typeof FinalizationRegistry?void 0:FinalizationRegistry,"%Function%":r,"%GeneratorFunction%":p,"%Int8Array%":"undefined"==typeof Int8Array?void 0:Int8Array,"%Int16Array%":"undefined"==typeof Int16Array?void 0:Int16Array,"%Int32Array%":"undefined"==typeof Int32Array?void 0:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":u?d(d([][Symbol.iterator]())):void 0,"%JSON%":"object"==typeof JSON?JSON:void 0,"%Map%":"undefined"==typeof Map?void 0:Map,"%MapIteratorPrototype%":"undefined"!=typeof Map&&u?d((new Map)[Symbol.iterator]()):void 0,"%Math%":Math,"%Number%":Number,"%Object%":Object,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":"undefined"==typeof Promise?void 0:Promise,"%Proxy%":"undefined"==typeof Proxy?void 0:Proxy,"%RangeError%":RangeError,"%ReferenceError%":ReferenceError,"%Reflect%":"undefined"==typeof Reflect?void 0:Reflect,"%RegExp%":RegExp,"%Set%":"undefined"==typeof Set?void 0:Set,"%SetIteratorPrototype%":"undefined"!=typeof Set&&u?d((new Set)[Symbol.iterator]()):void 0,"%SharedArrayBuffer%":"undefined"==typeof SharedArrayBuffer?void 0:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":u?d(""[Symbol.iterator]()):void 0,"%Symbol%":u?Symbol:void 0,"%SyntaxError%":a,"%ThrowTypeError%":c,"%TypedArray%":h,"%TypeError%":i,"%Uint8Array%":"undefined"==typeof Uint8Array?void 0:Uint8Array,"%Uint8ClampedArray%":"undefined"==typeof Uint8ClampedArray?void 0:Uint8ClampedArray,"%Uint16Array%":"undefined"==typeof Uint16Array?void 0:Uint16Array,"%Uint32Array%":"undefined"==typeof Uint32Array?void 0:Uint32Array,"%URIError%":URIError,"%WeakMap%":"undefined"==typeof WeakMap?void 0:WeakMap,"%WeakRef%":"undefined"==typeof WeakRef?void 0:WeakRef,"%WeakSet%":"undefined"==typeof WeakSet?void 0:WeakSet};try{null.error}catch(n){var m=d(d(n));f["%Error.prototype%"]=m}var g={"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},v=t(60),y=t(291),b=v.call(Function.call,Array.prototype.concat),k=v.call(Function.apply,Array.prototype.splice),w=v.call(Function.call,String.prototype.replace),x=v.call(Function.call,String.prototype.slice),S=v.call(Function.call,RegExp.prototype.exec),_=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,j=/\\(\\)?/g,T=function(n){var e=x(n,0,1),t=x(n,-1);if("%"===e&&"%"!==t)throw new a("invalid intrinsic syntax, expected closing `%`");if("%"===t&&"%"!==e)throw new a("invalid intrinsic syntax, expected opening `%`");var r=[];return w(n,_,(function(n,e,t,a){r[r.length]=t?w(a,j,"$1"):e||n})),r},C=function(n,e){var t,r=n;if(y(g,r)&&(r="%"+(t=g[r])[0]+"%"),y(f,r)){var s=f[r];if(s===p&&(s=function n(e){var t;if("%AsyncFunction%"===e)t=o("async function () {}");else if("%GeneratorFunction%"===e)t=o("function* () {}");else if("%AsyncGeneratorFunction%"===e)t=o("async function* () {}");else if("%AsyncGenerator%"===e){var a=n("%AsyncGeneratorFunction%");a&&(t=a.prototype)}else if("%AsyncIteratorPrototype%"===e){var r=n("%AsyncGenerator%");r&&(t=d(r.prototype))}return f[e]=t,t}(r)),void 0===s&&!e)throw new i("intrinsic "+n+" exists, but is not available. Please file an issue!");return{alias:t,name:r,value:s}}throw new a("intrinsic "+n+" does not exist!")};n.exports=function(n,e){if("string"!=typeof n||0===n.length)throw new i("intrinsic name must be a non-empty string");if(arguments.length>1&&"boolean"!=typeof e)throw new i('"allowMissing" argument must be a boolean');if(null===S(/^%?[^%]*%?$/,n))throw new a("`%` may not be present anywhere but at the beginning and end of the intrinsic name");var t=T(n),r=t.length>0?t[0]:"",o=C("%"+r+"%",e),l=o.name,c=o.value,u=!1,d=o.alias;d&&(r=d[0],k(t,b([0,1],d)));for(var p=1,h=!0;p<t.length;p+=1){var m=t[p],g=x(m,0,1),v=x(m,-1);if(('"'===g||"'"===g||"`"===g||'"'===v||"'"===v||"`"===v)&&g!==v)throw new a("property names with quotes must have matching quotes");if("constructor"!==m&&h||(u=!0),y(f,l="%"+(r+="."+m)+"%"))c=f[l];else if(null!=c){if(!(m in c)){if(!e)throw new i("base intrinsic for "+n+" exists, but the property is not available.");return}if(s&&p+1>=t.length){var w=s(c,m);c=(h=!!w)&&"get"in w&&!("originalValue"in w.get)?w.get:c[m]}else h=y(c,m),c=c[m];h&&!u&&(f[l]=c)}}return c}},function(n,e,t){"use strict";var a=t(290);n.exports=Function.prototype.bind||a},function(n,e,t){"use strict";var a=String.prototype.replace,r=/%20/g,i="RFC1738",o="RFC3986";n.exports={default:o,formatters:{RFC1738:function(n){return a.call(n,r,"+")},RFC3986:function(n){return String(n)}},RFC1738:i,RFC3986:o}},function(n,e,t){var a=t(303);n.exports=function(n){return a(n,{weekStartsOn:1})}},function(n,e,t){"use strict";var a=t(3),r=t(315),i=t(116),o={"Content-Type":"application/x-www-form-urlencoded"};function s(n,e){!a.isUndefined(n)&&a.isUndefined(n["Content-Type"])&&(n["Content-Type"]=e)}var l,c={transitional:{silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1},adapter:(("undefined"!=typeof XMLHttpRequest||"undefined"!=typeof process&&"[object process]"===Object.prototype.toString.call(process))&&(l=t(117)),l),transformRequest:[function(n,e){return r(e,"Accept"),r(e,"Content-Type"),a.isFormData(n)||a.isArrayBuffer(n)||a.isBuffer(n)||a.isStream(n)||a.isFile(n)||a.isBlob(n)?n:a.isArrayBufferView(n)?n.buffer:a.isURLSearchParams(n)?(s(e,"application/x-www-form-urlencoded;charset=utf-8"),n.toString()):a.isObject(n)||e&&"application/json"===e["Content-Type"]?(s(e,"application/json"),function(n,e,t){if(a.isString(n))try{return(e||JSON.parse)(n),a.trim(n)}catch(n){if("SyntaxError"!==n.name)throw n}return(t||JSON.stringify)(n)}(n)):n}],transformResponse:[function(n){var e=this.transitional,t=e&&e.silentJSONParsing,r=e&&e.forcedJSONParsing,o=!t&&"json"===this.responseType;if(o||r&&a.isString(n)&&n.length)try{return JSON.parse(n)}catch(n){if(o){if("SyntaxError"===n.name)throw i(n,this,"E_JSON_PARSE");throw n}}return n}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,validateStatus:function(n){return n>=200&&n<300}};c.headers={common:{Accept:"application/json, text/plain, */*"}},a.forEach(["delete","get","head"],(function(n){c.headers[n]={}})),a.forEach(["post","put","patch"],(function(n){c.headers[n]=a.merge(o)})),n.exports=c},function(n,e,t){var a=t(4),r=t(5),i=t(27),o=Object,s=a("".split);n.exports=r((function(){return!o("z").propertyIsEnumerable(0)}))?function(n){return"String"==i(n)?s(n,""):o(n)}:o},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e,t){"use strict";var a=t(21),r=t(155).left,i=t(156),o=t(75);a({target:"Array",proto:!0,forced:!t(157)&&o>79&&o<83||!i("reduce")},{reduce:function(n){var e=arguments.length;return r(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){var a=t(8),r=t(43),i=t(135),o=t(44),s=t(31),l=t(69),c=t(12),u=t(79),d=Object.getOwnPropertyDescriptor;e.f=a?d:function(n,e){if(n=s(n),e=l(e),u)try{return d(n,e)}catch(n){}if(c(n,e))return o(!r(i.f,n,e),n[e])}},function(n,e){n.exports=function(n){return null==n}},function(n,e,t){var a=t(136),r=t(71);n.exports=function(n){var e=a(n,"string");return r(e)?e:e+""}},function(n,e){var t="object"==typeof document&&document.all,a=void 0===t&&void 0!==t;n.exports={all:t,IS_HTMLDDA:a}},function(n,e,t){var a=t(32),r=t(2),i=t(72),o=t(73),s=Object;n.exports=o?function(n){return"symbol"==typeof n}:function(n){var e=a("Symbol");return r(e)&&i(e.prototype,s(n))}},function(n,e,t){var a=t(4);n.exports=a({}.isPrototypeOf)},function(n,e,t){var a=t(74);n.exports=a&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var a=t(75),r=t(5);n.exports=!!Object.getOwnPropertySymbols&&!r((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&a&&a<41}))},function(n,e,t){var a,r,i=t(7),o=t(137),s=i.process,l=i.Deno,c=s&&s.versions||l&&l.version,u=c&&c.v8;u&&(r=(a=u.split("."))[0]>0&&a[0]<4?1:+(a[0]+a[1])),!r&&o&&(!(a=o.match(/Edge\/(\d+)/))||a[1]>=74)&&(a=o.match(/Chrome\/(\d+)/))&&(r=+a[1]),n.exports=r},function(n,e,t){var a=t(77),r=t(46);(n.exports=function(n,e){return r[n]||(r[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.30.0",mode:a?"pure":"global",copyright:"© 2014-2023 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.30.0/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var a=t(4),r=0,i=Math.random(),o=a(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++r+i,36)}},function(n,e,t){var a=t(8),r=t(5),i=t(80);n.exports=!a&&!r((function(){return 7!=Object.defineProperty(i("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var a=t(7),r=t(14),i=a.document,o=r(i)&&r(i.createElement);n.exports=function(n){return o?i.createElement(n):{}}},function(n,e,t){var a=t(8),r=t(5);n.exports=a&&r((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var a=t(76),r=t(78),i=a("keys");n.exports=function(n){return i[n]||(i[n]=r(n))}},function(n,e,t){var a=t(12),r=t(147),i=t(67),o=t(18);n.exports=function(n,e,t){for(var s=r(e),l=o.f,c=i.f,u=0;u<s.length;u++){var d=s[u];a(n,d)||t&&a(t,d)||l(n,d,c(e,d))}}},function(n,e,t){var a=t(4),r=t(12),i=t(31),o=t(149).indexOf,s=t(48),l=a([].push);n.exports=function(n,e){var t,a=i(n),c=0,u=[];for(t in a)!r(s,t)&&r(a,t)&&l(u,t);for(;e.length>c;)r(a,t=e[c++])&&(~o(u,t)||l(u,t));return u}},function(n,e,t){var a=t(163),r=t(23),i=t(164);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=a(Object.prototype,"__proto__","set"))(t,[]),e=t instanceof Array}catch(n){}return function(t,a){return r(t),i(a),e?n(t,a):t.__proto__=a,t}}():void 0)},function(n,e,t){var a=t(168),r=String;n.exports=function(n){if("Symbol"===a(n))throw TypeError("Cannot convert a Symbol value to a string");return r(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,a=e.length,r=n.length;++t<a;)n[r+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var a=t(34),r=t(187),i=t(188),o=t(189),s=t(190),l=t(191);function c(n){var e=this.__data__=new a(n);this.size=e.size}c.prototype.clear=r,c.prototype.delete=i,c.prototype.get=o,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var a=t(25),r=t(52);n.exports=function(n){if(!r(n))return!1;var e=a(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var a=t(208),r=t(19);n.exports=function n(e,t,i,o,s){return e===t||(null==e||null==t||!r(e)&&!r(t)?e!=e&&t!=t:a(e,t,i,o,n,s))}},function(n,e,t){var a=t(95),r=t(211),i=t(96);n.exports=function(n,e,t,o,s,l){var c=1&t,u=n.length,d=e.length;if(u!=d&&!(c&&d>u))return!1;var p=l.get(n),h=l.get(e);if(p&&h)return p==e&&h==n;var f=-1,m=!0,g=2&t?new a:void 0;for(l.set(n,e),l.set(e,n);++f<u;){var v=n[f],y=e[f];if(o)var b=c?o(y,v,f,e,n,l):o(v,y,f,n,e,l);if(void 0!==b){if(b)continue;m=!1;break}if(g){if(!r(e,(function(n,e){if(!i(g,e)&&(v===n||s(v,n,t,o,l)))return g.push(e)}))){m=!1;break}}else if(v!==y&&!s(v,y,t,o,l)){m=!1;break}}return l.delete(n),l.delete(e),m}},function(n,e,t){var a=t(53),r=t(209),i=t(210);function o(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new a;++e<t;)this.add(n[e])}o.prototype.add=o.prototype.push=r,o.prototype.has=i,n.exports=o},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var a=t(221),r=t(227),i=t(101);n.exports=function(n){return i(n)?a(n):r(n)}},function(n,e,t){(function(n){var a=t(10),r=t(223),i=e&&!e.nodeType&&e,o=i&&"object"==typeof n&&n&&!n.nodeType&&n,s=o&&o.exports===i?a.Buffer:void 0,l=(s?s.isBuffer:void 0)||r;n.exports=l}).call(this,t(65)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var a=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==a||"symbol"!=a&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var a=t(224),r=t(225),i=t(226),o=i&&i.isTypedArray,s=o?r(o):a;n.exports=s},function(n,e,t){var a=t(91),r=t(55);n.exports=function(n){return null!=n&&r(n.length)&&!a(n)}},function(n,e,t){var a=t(15)(t(10),"Set");n.exports=a},function(n,e,t){var a=t(52);n.exports=function(n){return n==n&&!a(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var a=t(106),r=t(38);n.exports=function(n,e){for(var t=0,i=(e=a(e,n)).length;null!=n&&t<i;)n=n[r(e[t++])];return t&&t==i?n:void 0}},function(n,e,t){var a=t(11),r=t(56),i=t(238),o=t(241);n.exports=function(n,e){return a(n)?n:r(n,e)?[n]:i(o(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";var a=t(61),r=Object.prototype.hasOwnProperty,i=Array.isArray,o=function(){for(var n=[],e=0;e<256;++e)n.push("%"+((e<16?"0":"")+e.toString(16)).toUpperCase());return n}(),s=function(n,e){for(var t=e&&e.plainObjects?Object.create(null):{},a=0;a<n.length;++a)void 0!==n[a]&&(t[a]=n[a]);return t};n.exports={arrayToObject:s,assign:function(n,e){return Object.keys(e).reduce((function(n,t){return n[t]=e[t],n}),n)},combine:function(n,e){return[].concat(n,e)},compact:function(n){for(var e=[{obj:{o:n},prop:"o"}],t=[],a=0;a<e.length;++a)for(var r=e[a],o=r.obj[r.prop],s=Object.keys(o),l=0;l<s.length;++l){var c=s[l],u=o[c];"object"==typeof u&&null!==u&&-1===t.indexOf(u)&&(e.push({obj:o,prop:c}),t.push(u))}return function(n){for(;n.length>1;){var e=n.pop(),t=e.obj[e.prop];if(i(t)){for(var a=[],r=0;r<t.length;++r)void 0!==t[r]&&a.push(t[r]);e.obj[e.prop]=a}}}(e),n},decode:function(n,e,t){var a=n.replace(/\+/g," ");if("iso-8859-1"===t)return a.replace(/%[0-9a-f]{2}/gi,unescape);try{return decodeURIComponent(a)}catch(n){return a}},encode:function(n,e,t,r,i){if(0===n.length)return n;var s=n;if("symbol"==typeof n?s=Symbol.prototype.toString.call(n):"string"!=typeof n&&(s=String(n)),"iso-8859-1"===t)return escape(s).replace(/%u[0-9a-f]{4}/gi,(function(n){return"%26%23"+parseInt(n.slice(2),16)+"%3B"}));for(var l="",c=0;c<s.length;++c){var u=s.charCodeAt(c);45===u||46===u||95===u||126===u||u>=48&&u<=57||u>=65&&u<=90||u>=97&&u<=122||i===a.RFC1738&&(40===u||41===u)?l+=s.charAt(c):u<128?l+=o[u]:u<2048?l+=o[192|u>>6]+o[128|63&u]:u<55296||u>=57344?l+=o[224|u>>12]+o[128|u>>6&63]+o[128|63&u]:(c+=1,u=65536+((1023&u)<<10|1023&s.charCodeAt(c)),l+=o[240|u>>18]+o[128|u>>12&63]+o[128|u>>6&63]+o[128|63&u])}return l},isBuffer:function(n){return!(!n||"object"!=typeof n)&&!!(n.constructor&&n.constructor.isBuffer&&n.constructor.isBuffer(n))},isRegExp:function(n){return"[object RegExp]"===Object.prototype.toString.call(n)},maybeMap:function(n,e){if(i(n)){for(var t=[],a=0;a<n.length;a+=1)t.push(e(n[a]));return t}return e(n)},merge:function n(e,t,a){if(!t)return e;if("object"!=typeof t){if(i(e))e.push(t);else{if(!e||"object"!=typeof e)return[e,t];(a&&(a.plainObjects||a.allowPrototypes)||!r.call(Object.prototype,t))&&(e[t]=!0)}return e}if(!e||"object"!=typeof e)return[e].concat(t);var o=e;return i(e)&&!i(t)&&(o=s(e,a)),i(e)&&i(t)?(t.forEach((function(t,i){if(r.call(e,i)){var o=e[i];o&&"object"==typeof o&&t&&"object"==typeof t?e[i]=n(o,t,a):e.push(t)}else e[i]=t})),e):Object.keys(t).reduce((function(e,i){var o=t[i];return r.call(e,i)?e[i]=n(e[i],o,a):e[i]=o,e}),o)}}},function(n,e){n.exports=function(n){return n instanceof Date}},function(n,e,t){var a=t(16),r=t(62);n.exports=function(n){var e=a(n),t=e.getFullYear(),i=new Date(0);i.setFullYear(t+1,0,4),i.setHours(0,0,0,0);var o=r(i),s=new Date(0);s.setFullYear(t,0,4),s.setHours(0,0,0,0);var l=r(s);return e.getTime()>=o.getTime()?t+1:e.getTime()>=l.getTime()?t:t-1}},function(n,e,t){"use strict";n.exports=function(n,e){return function(){for(var t=new Array(arguments.length),a=0;a<t.length;a++)t[a]=arguments[a];return n.apply(e,t)}}},function(n,e,t){"use strict";var a=t(3);function r(n){return encodeURIComponent(n).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}n.exports=function(n,e,t){if(!e)return n;var i;if(t)i=t(e);else if(a.isURLSearchParams(e))i=e.toString();else{var o=[];a.forEach(e,(function(n,e){null!=n&&(a.isArray(n)?e+="[]":n=[n],a.forEach(n,(function(n){a.isDate(n)?n=n.toISOString():a.isObject(n)&&(n=JSON.stringify(n)),o.push(r(e)+"="+r(n))})))})),i=o.join("&")}if(i){var s=n.indexOf("#");-1!==s&&(n=n.slice(0,s)),n+=(-1===n.indexOf("?")?"?":"&")+i}return n}},function(n,e,t){"use strict";n.exports=function(n,e,t,a,r){return n.config=e,t&&(n.code=t),n.request=a,n.response=r,n.isAxiosError=!0,n.toJSON=function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:this.config,code:this.code}},n}},function(n,e,t){"use strict";var a=t(3),r=t(316),i=t(317),o=t(115),s=t(318),l=t(321),c=t(322),u=t(118);n.exports=function(n){return new Promise((function(e,t){var d=n.data,p=n.headers,h=n.responseType;a.isFormData(d)&&delete p["Content-Type"];var f=new XMLHttpRequest;if(n.auth){var m=n.auth.username||"",g=n.auth.password?unescape(encodeURIComponent(n.auth.password)):"";p.Authorization="Basic "+btoa(m+":"+g)}var v=s(n.baseURL,n.url);function y(){if(f){var a="getAllResponseHeaders"in f?l(f.getAllResponseHeaders()):null,i={data:h&&"text"!==h&&"json"!==h?f.response:f.responseText,status:f.status,statusText:f.statusText,headers:a,config:n,request:f};r(e,t,i),f=null}}if(f.open(n.method.toUpperCase(),o(v,n.params,n.paramsSerializer),!0),f.timeout=n.timeout,"onloadend"in f?f.onloadend=y:f.onreadystatechange=function(){f&&4===f.readyState&&(0!==f.status||f.responseURL&&0===f.responseURL.indexOf("file:"))&&setTimeout(y)},f.onabort=function(){f&&(t(u("Request aborted",n,"ECONNABORTED",f)),f=null)},f.onerror=function(){t(u("Network Error",n,null,f)),f=null},f.ontimeout=function(){var e="timeout of "+n.timeout+"ms exceeded";n.timeoutErrorMessage&&(e=n.timeoutErrorMessage),t(u(e,n,n.transitional&&n.transitional.clarifyTimeoutError?"ETIMEDOUT":"ECONNABORTED",f)),f=null},a.isStandardBrowserEnv()){var b=(n.withCredentials||c(v))&&n.xsrfCookieName?i.read(n.xsrfCookieName):void 0;b&&(p[n.xsrfHeaderName]=b)}"setRequestHeader"in f&&a.forEach(p,(function(n,e){void 0===d&&"content-type"===e.toLowerCase()?delete p[e]:f.setRequestHeader(e,n)})),a.isUndefined(n.withCredentials)||(f.withCredentials=!!n.withCredentials),h&&"json"!==h&&(f.responseType=n.responseType),"function"==typeof n.onDownloadProgress&&f.addEventListener("progress",n.onDownloadProgress),"function"==typeof n.onUploadProgress&&f.upload&&f.upload.addEventListener("progress",n.onUploadProgress),n.cancelToken&&n.cancelToken.promise.then((function(n){f&&(f.abort(),t(n),f=null)})),d||(d=null),f.send(d)}))}},function(n,e,t){"use strict";var a=t(116);n.exports=function(n,e,t,r,i){var o=new Error(n);return a(o,e,t,r,i)}},function(n,e,t){"use strict";n.exports=function(n){return!(!n||!n.__CANCEL__)}},function(n,e,t){"use strict";var a=t(3);n.exports=function(n,e){e=e||{};var t={},r=["url","method","data"],i=["headers","auth","proxy","params"],o=["baseURL","transformRequest","transformResponse","paramsSerializer","timeout","timeoutMessage","withCredentials","adapter","responseType","xsrfCookieName","xsrfHeaderName","onUploadProgress","onDownloadProgress","decompress","maxContentLength","maxBodyLength","maxRedirects","transport","httpAgent","httpsAgent","cancelToken","socketPath","responseEncoding"],s=["validateStatus"];function l(n,e){return a.isPlainObject(n)&&a.isPlainObject(e)?a.merge(n,e):a.isPlainObject(e)?a.merge({},e):a.isArray(e)?e.slice():e}function c(r){a.isUndefined(e[r])?a.isUndefined(n[r])||(t[r]=l(void 0,n[r])):t[r]=l(n[r],e[r])}a.forEach(r,(function(n){a.isUndefined(e[n])||(t[n]=l(void 0,e[n]))})),a.forEach(i,c),a.forEach(o,(function(r){a.isUndefined(e[r])?a.isUndefined(n[r])||(t[r]=l(void 0,n[r])):t[r]=l(void 0,e[r])})),a.forEach(s,(function(a){a in e?t[a]=l(n[a],e[a]):a in n&&(t[a]=l(void 0,n[a]))}));var u=r.concat(i).concat(o).concat(s),d=Object.keys(n).concat(Object.keys(e)).filter((function(n){return-1===u.indexOf(n)}));return a.forEach(d,c),t}},function(n,e,t){"use strict";function a(n){this.message=n}a.prototype.toString=function(){return"Cancel"+(this.message?": "+this.message:"")},a.prototype.__CANCEL__=!0,n.exports=a},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var a=t(174),r=t(179),i=t(250),o=t(258),s=t(267),l=t(268),c=i((function(n){var e=l(n);return s(e)&&(e=void 0),o(a(n,1,s,!0),r(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var a=/["'&<>]/;n.exports=function(n){var e,t=""+n,r=a.exec(t);if(!r)return t;var i="",o=0,s=0;for(o=r.index;o<t.length;o++){switch(t.charCodeAt(o)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==o&&(i+=t.substring(s,o)),s=o+1,i+=e}return s!==o?i+t.substring(s,o):i}},function(n,e){var t=/^\s+|\s+$/g,a=/^[-+]0x[0-9a-f]+$/i,r=/^0b[01]+$/i,i=/^0o[0-7]+$/i,o=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),u=Object.prototype.toString,d=Math.max,p=Math.min,h=function(){return c.Date.now()};function f(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function m(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==u.call(n)}(n))return NaN;if(f(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=f(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=r.test(n);return s||i.test(n)?o(n.slice(2),s?2:8):a.test(n)?NaN:+n}n.exports=function(n,e,t){var a,r,i,o,s,l,c=0,u=!1,g=!1,v=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function y(e){var t=a,i=r;return a=r=void 0,c=e,o=n.apply(i,t)}function b(n){return c=n,s=setTimeout(w,e),u?y(n):o}function k(n){var t=n-l;return void 0===l||t>=e||t<0||g&&n-c>=i}function w(){var n=h();if(k(n))return x(n);s=setTimeout(w,function(n){var t=e-(n-l);return g?p(t,i-(n-c)):t}(n))}function x(n){return s=void 0,v&&a?y(n):(a=r=void 0,o)}function S(){var n=h(),t=k(n);if(a=arguments,r=this,l=n,t){if(void 0===s)return b(l);if(g)return s=setTimeout(w,e),y(l)}return void 0===s&&(s=setTimeout(w,e)),o}return e=m(e)||0,f(t)&&(u=!!t.leading,i=(g="maxWait"in t)?d(m(t.maxWait)||0,e):i,v="trailing"in t?!!t.trailing:v),S.cancel=function(){void 0!==s&&clearTimeout(s),c=0,a=l=r=s=void 0},S.flush=function(){return void 0===s?o:x(h())},S}},function(n,e,t){!function(){"use strict";n.exports={polyfill:function(){var n=window,e=document;if(!("scrollBehavior"in e.documentElement.style)||!0===n.__forceSmoothScrollPolyfill__){var t,a=n.HTMLElement||n.Element,r={scroll:n.scroll||n.scrollTo,scrollBy:n.scrollBy,elementScroll:a.prototype.scroll||s,scrollIntoView:a.prototype.scrollIntoView},i=n.performance&&n.performance.now?n.performance.now.bind(n.performance):Date.now,o=(t=n.navigator.userAgent,new RegExp(["MSIE ","Trident/","Edge/"].join("|")).test(t)?1:0);n.scroll=n.scrollTo=function(){void 0!==arguments[0]&&(!0!==l(arguments[0])?f.call(n,e.body,void 0!==arguments[0].left?~~arguments[0].left:n.scrollX||n.pageXOffset,void 0!==arguments[0].top?~~arguments[0].top:n.scrollY||n.pageYOffset):r.scroll.call(n,void 0!==arguments[0].left?arguments[0].left:"object"!=typeof arguments[0]?arguments[0]:n.scrollX||n.pageXOffset,void 0!==arguments[0].top?arguments[0].top:void 0!==arguments[1]?arguments[1]:n.scrollY||n.pageYOffset))},n.scrollBy=function(){void 0!==arguments[0]&&(l(arguments[0])?r.scrollBy.call(n,void 0!==arguments[0].left?arguments[0].left:"object"!=typeof arguments[0]?arguments[0]:0,void 0!==arguments[0].top?arguments[0].top:void 0!==arguments[1]?arguments[1]:0):f.call(n,e.body,~~arguments[0].left+(n.scrollX||n.pageXOffset),~~arguments[0].top+(n.scrollY||n.pageYOffset)))},a.prototype.scroll=a.prototype.scrollTo=function(){if(void 0!==arguments[0])if(!0!==l(arguments[0])){var n=arguments[0].left,e=arguments[0].top;f.call(this,this,void 0===n?this.scrollLeft:~~n,void 0===e?this.scrollTop:~~e)}else{if("number"==typeof arguments[0]&&void 0===arguments[1])throw new SyntaxError("Value could not be converted");r.elementScroll.call(this,void 0!==arguments[0].left?~~arguments[0].left:"object"!=typeof arguments[0]?~~arguments[0]:this.scrollLeft,void 0!==arguments[0].top?~~arguments[0].top:void 0!==arguments[1]?~~arguments[1]:this.scrollTop)}},a.prototype.scrollBy=function(){void 0!==arguments[0]&&(!0!==l(arguments[0])?this.scroll({left:~~arguments[0].left+this.scrollLeft,top:~~arguments[0].top+this.scrollTop,behavior:arguments[0].behavior}):r.elementScroll.call(this,void 0!==arguments[0].left?~~arguments[0].left+this.scrollLeft:~~arguments[0]+this.scrollLeft,void 0!==arguments[0].top?~~arguments[0].top+this.scrollTop:~~arguments[1]+this.scrollTop))},a.prototype.scrollIntoView=function(){if(!0!==l(arguments[0])){var t=p(this),a=t.getBoundingClientRect(),i=this.getBoundingClientRect();t!==e.body?(f.call(this,t,t.scrollLeft+i.left-a.left,t.scrollTop+i.top-a.top),"fixed"!==n.getComputedStyle(t).position&&n.scrollBy({left:a.left,top:a.top,behavior:"smooth"})):n.scrollBy({left:i.left,top:i.top,behavior:"smooth"})}else r.scrollIntoView.call(this,void 0===arguments[0]||arguments[0])}}function s(n,e){this.scrollLeft=n,this.scrollTop=e}function l(n){if(null===n||"object"!=typeof n||void 0===n.behavior||"auto"===n.behavior||"instant"===n.behavior)return!0;if("object"==typeof n&&"smooth"===n.behavior)return!1;throw new TypeError("behavior member of ScrollOptions "+n.behavior+" is not a valid value for enumeration ScrollBehavior.")}function c(n,e){return"Y"===e?n.clientHeight+o<n.scrollHeight:"X"===e?n.clientWidth+o<n.scrollWidth:void 0}function u(e,t){var a=n.getComputedStyle(e,null)["overflow"+t];return"auto"===a||"scroll"===a}function d(n){var e=c(n,"Y")&&u(n,"Y"),t=c(n,"X")&&u(n,"X");return e||t}function p(n){for(;n!==e.body&&!1===d(n);)n=n.parentNode||n.host;return n}function h(e){var t,a,r,o,s=(i()-e.startTime)/468;o=s=s>1?1:s,t=.5*(1-Math.cos(Math.PI*o)),a=e.startX+(e.x-e.startX)*t,r=e.startY+(e.y-e.startY)*t,e.method.call(e.scrollable,a,r),a===e.x&&r===e.y||n.requestAnimationFrame(h.bind(n,e))}function f(t,a,o){var l,c,u,d,p=i();t===e.body?(l=n,c=n.scrollX||n.pageXOffset,u=n.scrollY||n.pageYOffset,d=r.scroll):(l=t,c=t.scrollLeft,u=t.scrollTop,d=s),h({scrollable:l,method:d,startTime:p,startX:c,startY:u,x:a,y:o})}}}}()},function(n,e,t){function a(){var n;try{n=e.storage.debug}catch(n){}return!n&&"undefined"!=typeof process&&"env"in process&&(n=process.env.DEBUG),n}(e=n.exports=t(281)).log=function(){return"object"==typeof console&&console.log&&Function.prototype.apply.call(console.log,console,arguments)},e.formatArgs=function(n){var t=this.useColors;if(n[0]=(t?"%c":"")+this.namespace+(t?" %c":" ")+n[0]+(t?"%c ":" ")+"+"+e.humanize(this.diff),!t)return;var a="color: "+this.color;n.splice(1,0,a,"color: inherit");var r=0,i=0;n[0].replace(/%[a-zA-Z%]/g,(function(n){"%%"!==n&&(r++,"%c"===n&&(i=r))})),n.splice(i,0,a)},e.save=function(n){try{null==n?e.storage.removeItem("debug"):e.storage.debug=n}catch(n){}},e.load=a,e.useColors=function(){if("undefined"!=typeof window&&window.process&&"renderer"===window.process.type)return!0;return"undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)},e.storage="undefined"!=typeof chrome&&void 0!==chrome.storage?chrome.storage.local:function(){try{return window.localStorage}catch(n){}}(),e.colors=["lightseagreen","forestgreen","goldenrod","dodgerblue","darkorchid","crimson"],e.formatters.j=function(n){try{return JSON.stringify(n)}catch(n){return"[UnexpectedJSONParseError]: "+n.message}},e.enable(a())},function(n,e,t){var a=t(297),r=t(302),i=t(113),o=t(16),s=t(305),l=t(306);var c={M:function(n){return n.getMonth()+1},MM:function(n){return p(n.getMonth()+1,2)},Q:function(n){return Math.ceil((n.getMonth()+1)/3)},D:function(n){return n.getDate()},DD:function(n){return p(n.getDate(),2)},DDD:function(n){return a(n)},DDDD:function(n){return p(a(n),3)},d:function(n){return n.getDay()},E:function(n){return n.getDay()||7},W:function(n){return r(n)},WW:function(n){return p(r(n),2)},YY:function(n){return p(n.getFullYear(),4).substr(2)},YYYY:function(n){return p(n.getFullYear(),4)},GG:function(n){return String(i(n)).substr(2)},GGGG:function(n){return i(n)},H:function(n){return n.getHours()},HH:function(n){return p(n.getHours(),2)},h:function(n){var e=n.getHours();return 0===e?12:e>12?e%12:e},hh:function(n){return p(c.h(n),2)},m:function(n){return n.getMinutes()},mm:function(n){return p(n.getMinutes(),2)},s:function(n){return n.getSeconds()},ss:function(n){return p(n.getSeconds(),2)},S:function(n){return Math.floor(n.getMilliseconds()/100)},SS:function(n){return p(Math.floor(n.getMilliseconds()/10),2)},SSS:function(n){return p(n.getMilliseconds(),3)},Z:function(n){return d(n.getTimezoneOffset(),":")},ZZ:function(n){return d(n.getTimezoneOffset())},X:function(n){return Math.floor(n.getTime()/1e3)},x:function(n){return n.getTime()}};function u(n){return n.match(/\[[\s\S]/)?n.replace(/^\[|]$/g,""):n.replace(/\\/g,"")}function d(n,e){e=e||"";var t=n>0?"-":"+",a=Math.abs(n),r=a%60;return t+p(Math.floor(a/60),2)+e+p(r,2)}function p(n,e){for(var t=Math.abs(n).toString();t.length<e;)t="0"+t;return t}n.exports=function(n,e,t){var a=e?String(e):"YYYY-MM-DDTHH:mm:ss.SSSZ",r=(t||{}).locale,i=l.format.formatters,d=l.format.formattingTokensRegExp;r&&r.format&&r.format.formatters&&(i=r.format.formatters,r.format.formattingTokensRegExp&&(d=r.format.formattingTokensRegExp));var p=o(n);return s(p)?function(n,e,t){var a,r,i=n.match(t),o=i.length;for(a=0;a<o;a++)r=e[i[a]]||c[i[a]],i[a]=r||u(i[a]);return function(n){for(var e="",t=0;t<o;t++)i[t]instanceof Function?e+=i[t](n,c):e+=i[t];return e}}(a,i,d)(p):"Invalid Date"}},function(n,e,t){var a=t(21),r=t(7),i=t(161),o=t(162),s=r.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=o(n,e,l),a({global:!0,constructor:!0,arity:1,forced:l},t)},u=function(n,e){if(s&&s[n]){var t={};t[n]=o("WebAssembly."+n,e,l),a({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return i(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return i(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return i(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return i(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return i(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return i(n,this,arguments)}})),c("URIError",(function(n){return function(e){return i(n,this,arguments)}})),u("CompileError",(function(n){return function(e){return i(n,this,arguments)}})),u("LinkError",(function(n){return function(e){return i(n,this,arguments)}})),u("RuntimeError",(function(n){return function(e){return i(n,this,arguments)}}))},function(n,e,t){var a=t(28),r=t(274),i=t(18).f,o=a("unscopables"),s=Array.prototype;null==s[o]&&i(s,o,{configurable:!0,value:r(null)}),n.exports=function(n){s[o][n]=!0}},function(n,e,t){n.exports=t(333)},function(n,e,t){"use strict";var a={}.propertyIsEnumerable,r=Object.getOwnPropertyDescriptor,i=r&&!a.call({1:2},1);e.f=i?function(n){var e=r(this,n);return!!e&&e.enumerable}:a},function(n,e,t){var a=t(43),r=t(14),i=t(71),o=t(138),s=t(140),l=t(28),c=TypeError,u=l("toPrimitive");n.exports=function(n,e){if(!r(n)||i(n))return n;var t,l=o(n,u);if(l){if(void 0===e&&(e="default"),t=a(l,n,e),!r(t)||i(t))return t;throw c("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e){n.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},function(n,e,t){var a=t(42),r=t(68);n.exports=function(n,e){var t=n[e];return r(t)?void 0:a(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var a=t(43),r=t(2),i=t(14),o=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&r(t=n.toString)&&!i(s=a(t,n)))return s;if(r(t=n.valueOf)&&!i(s=a(t,n)))return s;if("string"!==e&&r(t=n.toString)&&!i(s=a(t,n)))return s;throw o("Can't convert object to primitive value")}},function(n,e,t){var a=t(2),r=t(18),i=t(142),o=t(47);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,c=void 0!==s.name?s.name:e;if(a(t)&&i(t,c,s),s.global)l?n[e]=t:o(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:r.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){var a=t(4),r=t(5),i=t(2),o=t(12),s=t(8),l=t(143).CONFIGURABLE,c=t(144),u=t(145),d=u.enforce,p=u.get,h=String,f=Object.defineProperty,m=a("".slice),g=a("".replace),v=a([].join),y=s&&!r((function(){return 8!==f((function(){}),"length",{value:8}).length})),b=String(String).split("String"),k=n.exports=function(n,e,t){"Symbol("===m(h(e),0,7)&&(e="["+g(h(e),/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!o(n,"name")||l&&n.name!==e)&&(s?f(n,"name",{value:e,configurable:!0}):n.name=e),y&&t&&o(t,"arity")&&n.length!==t.arity&&f(n,"length",{value:t.arity});try{t&&o(t,"constructor")&&t.constructor?s&&f(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var a=d(n);return o(a,"source")||(a.source=v(b,"string"==typeof e?e:"")),n};Function.prototype.toString=k((function(){return i(this)&&p(this).source||c(this)}),"toString")},function(n,e,t){var a=t(8),r=t(12),i=Function.prototype,o=a&&Object.getOwnPropertyDescriptor,s=r(i,"name"),l=s&&"something"===function(){}.name,c=s&&(!a||a&&o(i,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var a=t(4),r=t(2),i=t(46),o=a(Function.toString);r(i.inspectSource)||(i.inspectSource=function(n){return o(n)}),n.exports=i.inspectSource},function(n,e,t){var a,r,i,o=t(146),s=t(7),l=t(14),c=t(22),u=t(12),d=t(46),p=t(82),h=t(48),f=s.TypeError,m=s.WeakMap;if(o||d.state){var g=d.state||(d.state=new m);g.get=g.get,g.has=g.has,g.set=g.set,a=function(n,e){if(g.has(n))throw f("Object already initialized");return e.facade=n,g.set(n,e),e},r=function(n){return g.get(n)||{}},i=function(n){return g.has(n)}}else{var v=p("state");h[v]=!0,a=function(n,e){if(u(n,v))throw f("Object already initialized");return e.facade=n,c(n,v,e),e},r=function(n){return u(n,v)?n[v]:{}},i=function(n){return u(n,v)}}n.exports={set:a,get:r,has:i,enforce:function(n){return i(n)?r(n):a(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=r(e)).type!==n)throw f("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var a=t(7),r=t(2),i=a.WeakMap;n.exports=r(i)&&/native code/.test(String(i))},function(n,e,t){var a=t(32),r=t(4),i=t(148),o=t(153),s=t(23),l=r([].concat);n.exports=a("Reflect","ownKeys")||function(n){var e=i.f(s(n)),t=o.f;return t?l(e,t(n)):e}},function(n,e,t){var a=t(84),r=t(49).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return a(n,r)}},function(n,e,t){var a=t(31),r=t(150),i=t(30),o=function(n){return function(e,t,o){var s,l=a(e),c=i(l),u=r(o,c);if(n&&t!=t){for(;c>u;)if((s=l[u++])!=s)return!0}else for(;c>u;u++)if((n||u in l)&&l[u]===t)return n||u||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,e,t){var a=t(33),r=Math.max,i=Math.min;n.exports=function(n,e){var t=a(n);return t<0?r(t+e,0):i(t,e)}},function(n,e){var t=Math.ceil,a=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?a:t)(e)}},function(n,e,t){var a=t(33),r=Math.min;n.exports=function(n){return n>0?r(a(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var a=t(5),r=t(2),i=/#|\.prototype\./,o=function(n,e){var t=l[s(n)];return t==u||t!=c&&(r(e)?a(e):!!e)},s=o.normalize=function(n){return String(n).replace(i,".").toLowerCase()},l=o.data={},c=o.NATIVE="N",u=o.POLYFILL="P";n.exports=o},function(n,e,t){var a=t(42),r=t(29),i=t(64),o=t(30),s=TypeError,l=function(n){return function(e,t,l,c){a(t);var u=r(e),d=i(u),p=o(u),h=n?p-1:0,f=n?-1:1;if(l<2)for(;;){if(h in d){c=d[h],h+=f;break}if(h+=f,n?h<0:p<=h)throw s("Reduce of empty array with no initial value")}for(;n?h>=0:p>h;h+=f)h in d&&(c=t(c,d[h],h,u));return c}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var a=t(5);n.exports=function(n,e){var t=[][n];return!!t&&a((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var a=t(27);n.exports="undefined"!=typeof process&&"process"==a(process)},function(n,e,t){"use strict";var a=t(8),r=t(159),i=TypeError,o=Object.getOwnPropertyDescriptor,s=a&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,e){if(r(n)&&!o(n,"length").writable)throw i("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){var a=t(27);n.exports=Array.isArray||function(n){return"Array"==a(n)}},function(n,e){var t=TypeError;n.exports=function(n){if(n>9007199254740991)throw t("Maximum allowed index exceeded");return n}},function(n,e,t){var a=t(41),r=Function.prototype,i=r.apply,o=r.call;n.exports="object"==typeof Reflect&&Reflect.apply||(a?o.bind(i):function(){return o.apply(i,arguments)})},function(n,e,t){"use strict";var a=t(32),r=t(12),i=t(22),o=t(72),s=t(85),l=t(83),c=t(165),u=t(166),d=t(167),p=t(170),h=t(171),f=t(8),m=t(77);n.exports=function(n,e,t,g){var v=g?2:1,y=n.split("."),b=y[y.length-1],k=a.apply(null,y);if(k){var w=k.prototype;if(!m&&r(w,"cause")&&delete w.cause,!t)return k;var x=a("Error"),S=e((function(n,e){var t=d(g?e:n,void 0),a=g?new k(n):new k;return void 0!==t&&i(a,"message",t),h(a,S,a.stack,2),this&&o(w,this)&&u(a,this,S),arguments.length>v&&p(a,arguments[v]),a}));if(S.prototype=w,"Error"!==b?s?s(S,x):l(S,x,{name:!0}):f&&"stackTraceLimit"in k&&(c(S,k,"stackTraceLimit"),c(S,k,"prepareStackTrace")),l(S,k),!m)try{w.name!==b&&i(w,"name",b),w.constructor=S}catch(n){}return S}}},function(n,e,t){var a=t(4),r=t(42);n.exports=function(n,e,t){try{return a(r(Object.getOwnPropertyDescriptor(n,e)[t]))}catch(n){}}},function(n,e,t){var a=t(2),r=String,i=TypeError;n.exports=function(n){if("object"==typeof n||a(n))return n;throw i("Can't set "+r(n)+" as a prototype")}},function(n,e,t){var a=t(18).f;n.exports=function(n,e,t){t in n||a(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var a=t(2),r=t(14),i=t(85);n.exports=function(n,e,t){var o,s;return i&&a(o=e.constructor)&&o!==t&&r(s=o.prototype)&&s!==t.prototype&&i(n,s),n}},function(n,e,t){var a=t(86);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:a(n)}},function(n,e,t){var a=t(169),r=t(2),i=t(27),o=t(28)("toStringTag"),s=Object,l="Arguments"==i(function(){return arguments}());n.exports=a?i:function(n){var e,t,a;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),o))?t:l?i(e):"Object"==(a=i(e))&&r(e.callee)?"Arguments":a}},function(n,e,t){var a={};a[t(28)("toStringTag")]="z",n.exports="[object z]"===String(a)},function(n,e,t){var a=t(14),r=t(22);n.exports=function(n,e){a(e)&&"cause"in e&&r(n,"cause",e.cause)}},function(n,e,t){var a=t(22),r=t(172),i=t(173),o=Error.captureStackTrace;n.exports=function(n,e,t,s){i&&(o?o(n,e):a(n,"stack",r(t,s)))}},function(n,e,t){var a=t(4),r=Error,i=a("".replace),o=String(r("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(o);n.exports=function(n,e){if(l&&"string"==typeof n&&!r.prepareStackTrace)for(;e--;)n=i(n,s,"");return n}},function(n,e,t){var a=t(5),r=t(44);n.exports=!a((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",r(1,7)),7!==n.stack)}))},function(n,e,t){var a=t(87),r=t(175);n.exports=function n(e,t,i,o,s){var l=-1,c=e.length;for(i||(i=r),s||(s=[]);++l<c;){var u=e[l];t>0&&i(u)?t>1?n(u,t-1,i,o,s):a(s,u):o||(s[s.length]=u)}return s}},function(n,e,t){var a=t(24),r=t(50),i=t(11),o=a?a.isConcatSpreadable:void 0;n.exports=function(n){return i(n)||r(n)||!!(o&&n&&n[o])}},function(n,e,t){var a=t(25),r=t(19);n.exports=function(n){return r(n)&&"[object Arguments]"==a(n)}},function(n,e,t){var a=t(24),r=Object.prototype,i=r.hasOwnProperty,o=r.toString,s=a?a.toStringTag:void 0;n.exports=function(n){var e=i.call(n,s),t=n[s];try{n[s]=void 0;var a=!0}catch(n){}var r=o.call(n);return a&&(e?n[s]=t:delete n[s]),r}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var a=t(180),r=t(236),i=t(58),o=t(11),s=t(247);n.exports=function(n){return"function"==typeof n?n:null==n?i:"object"==typeof n?o(n)?r(n[0],n[1]):a(n):s(n)}},function(n,e,t){var a=t(181),r=t(235),i=t(104);n.exports=function(n){var e=r(n);return 1==e.length&&e[0][2]?i(e[0][0],e[0][1]):function(t){return t===n||a(t,n,e)}}},function(n,e,t){var a=t(89),r=t(93);n.exports=function(n,e,t,i){var o=t.length,s=o,l=!i;if(null==n)return!s;for(n=Object(n);o--;){var c=t[o];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++o<s;){var u=(c=t[o])[0],d=n[u],p=c[1];if(l&&c[2]){if(void 0===d&&!(u in n))return!1}else{var h=new a;if(i)var f=i(d,p,u,n,e,h);if(!(void 0===f?r(p,d,3,i,h):f))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var a=t(35),r=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=a(e,n);return!(t<0)&&(t==e.length-1?e.pop():r.call(e,t,1),--this.size,!0)}},function(n,e,t){var a=t(35);n.exports=function(n){var e=this.__data__,t=a(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var a=t(35);n.exports=function(n){return a(this.__data__,n)>-1}},function(n,e,t){var a=t(35);n.exports=function(n,e){var t=this.__data__,r=a(t,n);return r<0?(++this.size,t.push([n,e])):t[r][1]=e,this}},function(n,e,t){var a=t(34);n.exports=function(){this.__data__=new a,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var a=t(34),r=t(51),i=t(53);n.exports=function(n,e){var t=this.__data__;if(t instanceof a){var o=t.__data__;if(!r||o.length<199)return o.push([n,e]),this.size=++t.size,this;t=this.__data__=new i(o)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var a=t(91),r=t(193),i=t(52),o=t(92),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,u=l.toString,d=c.hasOwnProperty,p=RegExp("^"+u.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!i(n)||r(n))&&(a(n)?p:s).test(o(n))}},function(n,e,t){var a,r=t(194),i=(a=/[^.]+$/.exec(r&&r.keys&&r.keys.IE_PROTO||""))?"Symbol(src)_1."+a:"";n.exports=function(n){return!!i&&i in n}},function(n,e,t){var a=t(10)["__core-js_shared__"];n.exports=a},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var a=t(197),r=t(34),i=t(51);n.exports=function(){this.size=0,this.__data__={hash:new a,map:new(i||r),string:new a}}},function(n,e,t){var a=t(198),r=t(199),i=t(200),o=t(201),s=t(202);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var a=t(36);n.exports=function(){this.__data__=a?a(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var a=t(36),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(a){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return r.call(e,n)?e[n]:void 0}},function(n,e,t){var a=t(36),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return a?void 0!==e[n]:r.call(e,n)}},function(n,e,t){var a=t(36);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=a&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var a=t(37);n.exports=function(n){var e=a(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var a=t(37);n.exports=function(n){return a(this,n).get(n)}},function(n,e,t){var a=t(37);n.exports=function(n){return a(this,n).has(n)}},function(n,e,t){var a=t(37);n.exports=function(n,e){var t=a(this,n),r=t.size;return t.set(n,e),this.size+=t.size==r?0:1,this}},function(n,e,t){var a=t(89),r=t(94),i=t(212),o=t(215),s=t(231),l=t(11),c=t(98),u=t(100),d="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,h,f,m){var g=l(n),v=l(e),y=g?"[object Array]":s(n),b=v?"[object Array]":s(e),k=(y="[object Arguments]"==y?d:y)==d,w=(b="[object Arguments]"==b?d:b)==d,x=y==b;if(x&&c(n)){if(!c(e))return!1;g=!0,k=!1}if(x&&!k)return m||(m=new a),g||u(n)?r(n,e,t,h,f,m):i(n,e,y,t,h,f,m);if(!(1&t)){var S=k&&p.call(n,"__wrapped__"),_=w&&p.call(e,"__wrapped__");if(S||_){var j=S?n.value():n,T=_?e.value():e;return m||(m=new a),f(j,T,t,h,m)}}return!!x&&(m||(m=new a),o(n,e,t,h,f,m))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length;++t<a;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var a=t(24),r=t(213),i=t(90),o=t(94),s=t(214),l=t(54),c=a?a.prototype:void 0,u=c?c.valueOf:void 0;n.exports=function(n,e,t,a,c,d,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new r(n),new r(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return i(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var h=s;case"[object Set]":var f=1&a;if(h||(h=l),n.size!=e.size&&!f)return!1;var m=p.get(n);if(m)return m==e;a|=2,p.set(n,e);var g=o(h(n),h(e),a,c,d,p);return p.delete(n),g;case"[object Symbol]":if(u)return u.call(n)==u.call(e)}return!1}},function(n,e,t){var a=t(10).Uint8Array;n.exports=a},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,a){t[++e]=[a,n]})),t}},function(n,e,t){var a=t(216),r=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,i,o,s){var l=1&t,c=a(n),u=c.length;if(u!=a(e).length&&!l)return!1;for(var d=u;d--;){var p=c[d];if(!(l?p in e:r.call(e,p)))return!1}var h=s.get(n),f=s.get(e);if(h&&f)return h==e&&f==n;var m=!0;s.set(n,e),s.set(e,n);for(var g=l;++d<u;){var v=n[p=c[d]],y=e[p];if(i)var b=l?i(y,v,p,e,n,s):i(v,y,p,n,e,s);if(!(void 0===b?v===y||o(v,y,t,i,s):b)){m=!1;break}g||(g="constructor"==p)}if(m&&!g){var k=n.constructor,w=e.constructor;k==w||!("constructor"in n)||!("constructor"in e)||"function"==typeof k&&k instanceof k&&"function"==typeof w&&w instanceof w||(m=!1)}return s.delete(n),s.delete(e),m}},function(n,e,t){var a=t(217),r=t(218),i=t(97);n.exports=function(n){return a(n,i,r)}},function(n,e,t){var a=t(87),r=t(11);n.exports=function(n,e,t){var i=e(n);return r(n)?i:a(i,t(n))}},function(n,e,t){var a=t(219),r=t(220),i=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,s=o?function(n){return null==n?[]:(n=Object(n),a(o(n),(function(e){return i.call(n,e)})))}:r;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,r=0,i=[];++t<a;){var o=n[t];e(o,t,n)&&(i[r++]=o)}return i}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var a=t(222),r=t(50),i=t(11),o=t(98),s=t(99),l=t(100),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=i(n),u=!t&&r(n),d=!t&&!u&&o(n),p=!t&&!u&&!d&&l(n),h=t||u||d||p,f=h?a(n.length,String):[],m=f.length;for(var g in n)!e&&!c.call(n,g)||h&&("length"==g||d&&("offset"==g||"parent"==g)||p&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||s(g,m))||f.push(g);return f}},function(n,e){n.exports=function(n,e){for(var t=-1,a=Array(n);++t<n;)a[t]=e(t);return a}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var a=t(25),r=t(55),i=t(19),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return i(n)&&r(n.length)&&!!o[a(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var a=t(88),r=e&&!e.nodeType&&e,i=r&&"object"==typeof n&&n&&!n.nodeType&&n,o=i&&i.exports===r&&a.process,s=function(){try{var n=i&&i.require&&i.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=s}).call(this,t(65)(n))},function(n,e,t){var a=t(228),r=t(229),i=Object.prototype.hasOwnProperty;n.exports=function(n){if(!a(n))return r(n);var e=[];for(var t in Object(n))i.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var a=t(230)(Object.keys,Object);n.exports=a},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var a=t(232),r=t(51),i=t(233),o=t(102),s=t(234),l=t(25),c=t(92),u=c(a),d=c(r),p=c(i),h=c(o),f=c(s),m=l;(a&&"[object DataView]"!=m(new a(new ArrayBuffer(1)))||r&&"[object Map]"!=m(new r)||i&&"[object Promise]"!=m(i.resolve())||o&&"[object Set]"!=m(new o)||s&&"[object WeakMap]"!=m(new s))&&(m=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,a=t?c(t):"";if(a)switch(a){case u:return"[object DataView]";case d:return"[object Map]";case p:return"[object Promise]";case h:return"[object Set]";case f:return"[object WeakMap]"}return e}),n.exports=m},function(n,e,t){var a=t(15)(t(10),"DataView");n.exports=a},function(n,e,t){var a=t(15)(t(10),"Promise");n.exports=a},function(n,e,t){var a=t(15)(t(10),"WeakMap");n.exports=a},function(n,e,t){var a=t(103),r=t(97);n.exports=function(n){for(var e=r(n),t=e.length;t--;){var i=e[t],o=n[i];e[t]=[i,o,a(o)]}return e}},function(n,e,t){var a=t(93),r=t(237),i=t(244),o=t(56),s=t(103),l=t(104),c=t(38);n.exports=function(n,e){return o(n)&&s(e)?l(c(n),e):function(t){var o=r(t,n);return void 0===o&&o===e?i(t,n):a(e,o,3)}}},function(n,e,t){var a=t(105);n.exports=function(n,e,t){var r=null==n?void 0:a(n,e);return void 0===r?t:r}},function(n,e,t){var a=t(239),r=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,i=/\\(\\)?/g,o=a((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(r,(function(n,t,a,r){e.push(a?r.replace(i,"$1"):t||n)})),e}));n.exports=o},function(n,e,t){var a=t(240);n.exports=function(n){var e=a(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var a=t(53);function r(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var a=arguments,r=e?e.apply(this,a):a[0],i=t.cache;if(i.has(r))return i.get(r);var o=n.apply(this,a);return t.cache=i.set(r,o)||i,o};return t.cache=new(r.Cache||a),t}r.Cache=a,n.exports=r},function(n,e,t){var a=t(242);n.exports=function(n){return null==n?"":a(n)}},function(n,e,t){var a=t(24),r=t(243),i=t(11),o=t(57),s=a?a.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(i(e))return r(e,n)+"";if(o(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,r=Array(a);++t<a;)r[t]=e(n[t],t,n);return r}},function(n,e,t){var a=t(245),r=t(246);n.exports=function(n,e){return null!=n&&r(n,e,a)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var a=t(106),r=t(50),i=t(11),o=t(99),s=t(55),l=t(38);n.exports=function(n,e,t){for(var c=-1,u=(e=a(e,n)).length,d=!1;++c<u;){var p=l(e[c]);if(!(d=null!=n&&t(n,p)))break;n=n[p]}return d||++c!=u?d:!!(u=null==n?0:n.length)&&s(u)&&o(p,u)&&(i(n)||r(n))}},function(n,e,t){var a=t(248),r=t(249),i=t(56),o=t(38);n.exports=function(n){return i(n)?a(o(n)):r(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var a=t(105);n.exports=function(n){return function(e){return a(e,n)}}},function(n,e,t){var a=t(58),r=t(251),i=t(253);n.exports=function(n,e){return i(r(n,e,a),n+"")}},function(n,e,t){var a=t(252),r=Math.max;n.exports=function(n,e,t){return e=r(void 0===e?n.length-1:e,0),function(){for(var i=arguments,o=-1,s=r(i.length-e,0),l=Array(s);++o<s;)l[o]=i[e+o];o=-1;for(var c=Array(e+1);++o<e;)c[o]=i[o];return c[e]=t(l),a(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var a=t(254),r=t(257)(a);n.exports=r},function(n,e,t){var a=t(255),r=t(256),i=t(58),o=r?function(n,e){return r(n,"toString",{configurable:!0,enumerable:!1,value:a(e),writable:!0})}:i;n.exports=o},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var a=t(15),r=function(){try{var n=a(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=r},function(n,e){var t=Date.now;n.exports=function(n){var e=0,a=0;return function(){var r=t(),i=16-(r-a);if(a=r,i>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var a=t(95),r=t(259),i=t(264),o=t(96),s=t(265),l=t(54);n.exports=function(n,e,t){var c=-1,u=r,d=n.length,p=!0,h=[],f=h;if(t)p=!1,u=i;else if(d>=200){var m=e?null:s(n);if(m)return l(m);p=!1,u=o,f=new a}else f=e?[]:h;n:for(;++c<d;){var g=n[c],v=e?e(g):g;if(g=t||0!==g?g:0,p&&v==v){for(var y=f.length;y--;)if(f[y]===v)continue n;e&&f.push(v),h.push(g)}else u(f,v,t)||(f!==h&&f.push(v),h.push(g))}return h}},function(n,e,t){var a=t(260);n.exports=function(n,e){return!!(null==n?0:n.length)&&a(n,e,0)>-1}},function(n,e,t){var a=t(261),r=t(262),i=t(263);n.exports=function(n,e,t){return e==e?i(n,e,t):a(n,r,t)}},function(n,e){n.exports=function(n,e,t,a){for(var r=n.length,i=t+(a?1:-1);a?i--:++i<r;)if(e(n[i],i,n))return i;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var a=t-1,r=n.length;++a<r;)if(n[a]===e)return a;return-1}},function(n,e){n.exports=function(n,e,t){for(var a=-1,r=null==n?0:n.length;++a<r;)if(t(e,n[a]))return!0;return!1}},function(n,e,t){var a=t(102),r=t(266),i=t(54),o=a&&1/i(new a([,-0]))[1]==1/0?function(n){return new a(n)}:r;n.exports=o},function(n,e){n.exports=function(){}},function(n,e,t){var a=t(101),r=t(19);n.exports=function(n){return r(n)&&a(n)}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(107)},function(n,e,t){"use strict";var a=t(21),r=t(29),i=t(30),o=t(33),s=t(133);a({target:"Array",proto:!0},{at:function(n){var e=r(this),t=i(e),a=o(n),s=a>=0?a:t+a;return s<0||s>=t?void 0:e[s]}}),s("at")},function(n,e,t){var a,r=t(23),i=t(275),o=t(49),s=t(48),l=t(277),c=t(80),u=t(82),d=u("IE_PROTO"),p=function(){},h=function(n){return"<script>"+n+"<\/script>"},f=function(n){n.write(h("")),n.close();var e=n.parentWindow.Object;return n=null,e},m=function(){try{a=new ActiveXObject("htmlfile")}catch(n){}var n,e;m="undefined"!=typeof document?document.domain&&a?f(a):((e=c("iframe")).style.display="none",l.appendChild(e),e.src=String("javascript:"),(n=e.contentWindow.document).open(),n.write(h("document.F=Object")),n.close(),n.F):f(a);for(var t=o.length;t--;)delete m.prototype[o[t]];return m()};s[d]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(p.prototype=r(n),t=new p,p.prototype=null,t[d]=n):t=m(),void 0===e?t:i.f(t,e)}},function(n,e,t){var a=t(8),r=t(81),i=t(18),o=t(23),s=t(31),l=t(276);e.f=a&&!r?Object.defineProperties:function(n,e){o(n);for(var t,a=s(e),r=l(e),c=r.length,u=0;c>u;)i.f(n,t=r[u++],a[t]);return n}},function(n,e,t){var a=t(84),r=t(49);n.exports=Object.keys||function(n){return a(n,r)}},function(n,e,t){var a=t(32);n.exports=a("document","documentElement")},function(n,e,t){"use strict";var a=t(21),r=t(4),i=t(45),o=t(33),s=t(86),l=t(5),c=r("".charAt);a({target:"String",proto:!0,forced:l((function(){return"\ud842"!=="𠮷".at(-2)}))},{at:function(n){var e=s(i(this)),t=e.length,a=o(n),r=a>=0?a:t+a;return r<0||r>=t?void 0:c(e,r)}})},function(n,e,t){"use strict";t(108)},function(n,e,t){},function(n,e,t){var a;function r(n){function t(){if(t.enabled){var n=t,r=+new Date,i=r-(a||r);n.diff=i,n.prev=a,n.curr=r,a=r;for(var o=new Array(arguments.length),s=0;s<o.length;s++)o[s]=arguments[s];o[0]=e.coerce(o[0]),"string"!=typeof o[0]&&o.unshift("%O");var l=0;o[0]=o[0].replace(/%([a-zA-Z%])/g,(function(t,a){if("%%"===t)return t;l++;var r=e.formatters[a];if("function"==typeof r){var i=o[l];t=r.call(n,i),o.splice(l,1),l--}return t})),e.formatArgs.call(n,o);var c=t.log||e.log||console.log.bind(console);c.apply(n,o)}}return t.namespace=n,t.enabled=e.enabled(n),t.useColors=e.useColors(),t.color=function(n){var t,a=0;for(t in n)a=(a<<5)-a+n.charCodeAt(t),a|=0;return e.colors[Math.abs(a)%e.colors.length]}(n),"function"==typeof e.init&&e.init(t),t}(e=n.exports=r.debug=r.default=r).coerce=function(n){return n instanceof Error?n.stack||n.message:n},e.disable=function(){e.enable("")},e.enable=function(n){e.save(n),e.names=[],e.skips=[];for(var t=("string"==typeof n?n:"").split(/[\s,]+/),a=t.length,r=0;r<a;r++)t[r]&&("-"===(n=t[r].replace(/\*/g,".*?"))[0]?e.skips.push(new RegExp("^"+n.substr(1)+"$")):e.names.push(new RegExp("^"+n+"$")))},e.enabled=function(n){var t,a;for(t=0,a=e.skips.length;t<a;t++)if(e.skips[t].test(n))return!1;for(t=0,a=e.names.length;t<a;t++)if(e.names[t].test(n))return!0;return!1},e.humanize=t(282),e.names=[],e.skips=[],e.formatters={}},function(n,e){var t=1e3,a=6e4,r=60*a,i=24*r;function o(n,e,t){if(!(n<e))return n<1.5*e?Math.floor(n/e)+" "+t:Math.ceil(n/e)+" "+t+"s"}n.exports=function(n,e){e=e||{};var s,l=typeof n;if("string"===l&&n.length>0)return function(n){if((n=String(n)).length>100)return;var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(n);if(!e)return;var o=parseFloat(e[1]);switch((e[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return 315576e5*o;case"days":case"day":case"d":return o*i;case"hours":case"hour":case"hrs":case"hr":case"h":return o*r;case"minutes":case"minute":case"mins":case"min":case"m":return o*a;case"seconds":case"second":case"secs":case"sec":case"s":return o*t;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return o;default:return}}(n);if("number"===l&&!1===isNaN(n))return e.long?o(s=n,i,"day")||o(s,r,"hour")||o(s,a,"minute")||o(s,t,"second")||s+" ms":function(n){if(n>=i)return Math.round(n/i)+"d";if(n>=r)return Math.round(n/r)+"h";if(n>=a)return Math.round(n/a)+"m";if(n>=t)return Math.round(n/t)+"s";return n+"ms"}(n);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(n))}},function(n,e,t){"use strict";t(109)},function(n,e,t){
/*!
 * Valine v1.5.1
 * (c) 2017-2022 xCss
 * Released under the GPL-2.0 License.
 * Last Update: 2022-7-21 3:43:59 ├F10: PM┤
 */
n.exports=function(n){function e(a){if(t[a])return t[a].exports;var r=t[a]={i:a,l:!1,exports:{}};return n[a].call(r.exports,r,r.exports,e),r.l=!0,r.exports}var t={};return e.m=n,e.c=t,e.i=function(n){return n},e.d=function(n,t,a){e.o(n,t)||Object.defineProperty(n,t,{configurable:!1,enumerable:!0,get:a})},e.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(t,"a",t),t},e.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},e.p="",e(e.s=108)}([function(n,e,t){"use strict";var a=SyntaxError,r=Function,i=TypeError,o=function(n){try{return r('"use strict"; return ('+n+").constructor;")()}catch(n){}},s=Object.getOwnPropertyDescriptor;if(s)try{s({},"")}catch(n){s=null}var l=function(){throw new i},c=s?function(){try{return l}catch(n){try{return s(arguments,"callee").get}catch(n){return l}}}():l,u=t(22)(),d=Object.getPrototypeOf||function(n){return n.__proto__},p={},h="undefined"==typeof Uint8Array?void 0:d(Uint8Array),f={"%AggregateError%":"undefined"==typeof AggregateError?void 0:AggregateError,"%Array%":Array,"%ArrayBuffer%":"undefined"==typeof ArrayBuffer?void 0:ArrayBuffer,"%ArrayIteratorPrototype%":u?d([][Symbol.iterator]()):void 0,"%AsyncFromSyncIteratorPrototype%":void 0,"%AsyncFunction%":p,"%AsyncGenerator%":p,"%AsyncGeneratorFunction%":p,"%AsyncIteratorPrototype%":p,"%Atomics%":"undefined"==typeof Atomics?void 0:Atomics,"%BigInt%":"undefined"==typeof BigInt?void 0:BigInt,"%Boolean%":Boolean,"%DataView%":"undefined"==typeof DataView?void 0:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":Error,"%eval%":eval,"%EvalError%":EvalError,"%Float32Array%":"undefined"==typeof Float32Array?void 0:Float32Array,"%Float64Array%":"undefined"==typeof Float64Array?void 0:Float64Array,"%FinalizationRegistry%":"undefined"==typeof FinalizationRegistry?void 0:FinalizationRegistry,"%Function%":r,"%GeneratorFunction%":p,"%Int8Array%":"undefined"==typeof Int8Array?void 0:Int8Array,"%Int16Array%":"undefined"==typeof Int16Array?void 0:Int16Array,"%Int32Array%":"undefined"==typeof Int32Array?void 0:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":u?d(d([][Symbol.iterator]())):void 0,"%JSON%":"object"==typeof JSON?JSON:void 0,"%Map%":"undefined"==typeof Map?void 0:Map,"%MapIteratorPrototype%":"undefined"!=typeof Map&&u?d((new Map)[Symbol.iterator]()):void 0,"%Math%":Math,"%Number%":Number,"%Object%":Object,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":"undefined"==typeof Promise?void 0:Promise,"%Proxy%":"undefined"==typeof Proxy?void 0:Proxy,"%RangeError%":RangeError,"%ReferenceError%":ReferenceError,"%Reflect%":"undefined"==typeof Reflect?void 0:Reflect,"%RegExp%":RegExp,"%Set%":"undefined"==typeof Set?void 0:Set,"%SetIteratorPrototype%":"undefined"!=typeof Set&&u?d((new Set)[Symbol.iterator]()):void 0,"%SharedArrayBuffer%":"undefined"==typeof SharedArrayBuffer?void 0:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":u?d(""[Symbol.iterator]()):void 0,"%Symbol%":u?Symbol:void 0,"%SyntaxError%":a,"%ThrowTypeError%":c,"%TypedArray%":h,"%TypeError%":i,"%Uint8Array%":"undefined"==typeof Uint8Array?void 0:Uint8Array,"%Uint8ClampedArray%":"undefined"==typeof Uint8ClampedArray?void 0:Uint8ClampedArray,"%Uint16Array%":"undefined"==typeof Uint16Array?void 0:Uint16Array,"%Uint32Array%":"undefined"==typeof Uint32Array?void 0:Uint32Array,"%URIError%":URIError,"%WeakMap%":"undefined"==typeof WeakMap?void 0:WeakMap,"%WeakRef%":"undefined"==typeof WeakRef?void 0:WeakRef,"%WeakSet%":"undefined"==typeof WeakSet?void 0:WeakSet},m=function n(e){var t;if("%AsyncFunction%"===e)t=o("async function () {}");else if("%GeneratorFunction%"===e)t=o("function* () {}");else if("%AsyncGeneratorFunction%"===e)t=o("async function* () {}");else if("%AsyncGenerator%"===e){var a=n("%AsyncGeneratorFunction%");a&&(t=a.prototype)}else if("%AsyncIteratorPrototype%"===e){var r=n("%AsyncGenerator%");r&&(t=d(r.prototype))}return f[e]=t,t},g={"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},v=t(9),y=t(25),b=v.call(Function.call,Array.prototype.concat),k=v.call(Function.apply,Array.prototype.splice),w=v.call(Function.call,String.prototype.replace),x=v.call(Function.call,String.prototype.slice),S=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,_=/\\(\\)?/g,j=function(n){var e=x(n,0,1),t=x(n,-1);if("%"===e&&"%"!==t)throw new a("invalid intrinsic syntax, expected closing `%`");if("%"===t&&"%"!==e)throw new a("invalid intrinsic syntax, expected opening `%`");var r=[];return w(n,S,(function(n,e,t,a){r[r.length]=t?w(a,_,"$1"):e||n})),r},T=function(n,e){var t,r=n;if(y(g,r)&&(r="%"+(t=g[r])[0]+"%"),y(f,r)){var o=f[r];if(o===p&&(o=m(r)),void 0===o&&!e)throw new i("intrinsic "+n+" exists, but is not available. Please file an issue!");return{alias:t,name:r,value:o}}throw new a("intrinsic "+n+" does not exist!")};n.exports=function(n,e){if("string"!=typeof n||0===n.length)throw new i("intrinsic name must be a non-empty string");if(arguments.length>1&&"boolean"!=typeof e)throw new i('"allowMissing" argument must be a boolean');var t=j(n),r=t.length>0?t[0]:"",o=T("%"+r+"%",e),l=o.name,c=o.value,u=!1,d=o.alias;d&&(r=d[0],k(t,b([0,1],d)));for(var p=1,h=!0;p<t.length;p+=1){var m=t[p],g=x(m,0,1),v=x(m,-1);if(('"'===g||"'"===g||"`"===g||'"'===v||"'"===v||"`"===v)&&g!==v)throw new a("property names with quotes must have matching quotes");if("constructor"!==m&&h||(u=!0),y(f,l="%"+(r+="."+m)+"%"))c=f[l];else if(null!=c){if(!(m in c)){if(!e)throw new i("base intrinsic for "+n+" exists, but the property is not available.");return}if(s&&p+1>=t.length){var w=s(c,m);c=(h=!!w)&&"get"in w&&!("originalValue"in w.get)?w.get:c[m]}else h=y(c,m),c=c[m];h&&!u&&(f[l]=c)}}return c}},function(n,e,t){"use strict";var a=t(0),r=t(4),i=r(a("String.prototype.indexOf"));n.exports=function(n,e){var t=a(n,!!e);return"function"==typeof t&&i(n,".prototype.")>-1?r(t):t}},function(n,e,t){"use strict";var a=t(88),r="function"==typeof Symbol&&"symbol"==typeof Symbol("foo"),i=Object.prototype.toString,o=Array.prototype.concat,s=Object.defineProperty,l=s&&function(){var n={};try{for(var e in s(n,"x",{enumerable:!1,value:n}),n)return!1;return n.x===n}catch(n){return!1}}(),c=function(n,e,t,a){(!(e in n)||function(n){return"function"==typeof n&&"[object Function]"===i.call(n)}(a)&&a())&&(l?s(n,e,{configurable:!0,enumerable:!1,value:t,writable:!0}):n[e]=t)},u=function(n,e){var t=arguments.length>2?arguments[2]:{},i=a(e);r&&(i=o.call(i,Object.getOwnPropertySymbols(e)));for(var s=0;s<i.length;s+=1)c(n,i[s],e[i[s]],t[i[s]])};u.supportsDescriptors=!!l,n.exports=u},function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{default:n}}e.__esModule=!0;var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},i=a(t(85)),o=a(t(49)),s=a(t(46)),l=a(t(48)),c=a(t(45)),u=document,d=navigator,p=/[&<>"'`\\]/g,h=RegExp(p.source),f=/&(?:amp|lt|gt|quot|#39|#x60|#x5c);/g,m=RegExp(f.source),g={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","`":"&#x60;","\\":"&#x5c;"},v={};for(var y in g)v[g[y]]=y;var b=null;Array.prototype.forEach||(Array.prototype.forEach=function(n,e){var t,a;if(null==this)throw new TypeError(" this is null or not defined");var r=Object(this),i=r.length>>>0;if("function"!=typeof n)throw new TypeError(n+" is not a function");for(arguments.length>1&&(t=e),a=0;a<i;){var o;a in r&&(o=r[a],n.call(t,o,a,r)),a++}}),window.NodeList&&!NodeList.prototype.forEach&&(NodeList.prototype.forEach=Array.prototype.forEach),String.prototype.trim||(String.prototype.trim=function(){return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"")}),(0,i.default)(o.default.fn,{prepend:function(n){return n instanceof HTMLElement||(n=n[0]),this.forEach((function(e){e.insertAdjacentElement("afterBegin",n)})),this},append:function(n){return n instanceof HTMLElement||(n=n[0]),this.forEach((function(e){e.insertAdjacentElement("beforeEnd",n)})),this},remove:function(){return this.forEach((function(n){try{n.parentNode.removeChild(n)}catch(n){}})),this},find:function(n){return(0,o.default)(n,this)},show:function(){return this.forEach((function(n){n.style.display="block"})),this},hide:function(){return this.forEach((function(n){n.style.display="none"})),this},on:function(n,e,t){return o.default.fn.off(n,e,t),this.forEach((function(a){n.split(" ").forEach((function(n){a.addEventListener?a.addEventListener(n,e,t||!1):a.attachEvent?a.attachEvent("on"+n,e):a["on"+n]=e}))})),this},off:function(n,e,t){return this.forEach((function(a){n.split(" ").forEach((function(n){a.removeEventListener?a.removeEventListener(n,e,t||!1):a.detachEvent?a.detachEvent("on"+n,e):a["on"+n]=null}))})),this},html:function(n){return void 0!==n?(this.forEach((function(e){e.innerHTML=n})),this):this[0].innerHTML},text:function(n){return void 0!==n?(this.forEach((function(e){e.innerText=n})),this):this[0].innerText},empty:function(n){return n=n||0,this.forEach((function(e){setTimeout((function(n){e.innerText=""}),n)})),this},val:function(n){return void 0!==n?(this.forEach((function(e){e.value=n})),this):this[0].value||""},attr:function(){var n=arguments;if("object"==r(arguments[0])){var e=arguments[0],t=this;return Object.keys(e).forEach((function(n){t.forEach((function(t){t.setAttribute(n,e[n])}))})),this}return"string"==typeof arguments[0]&&arguments.length<2?this[0].getAttribute(arguments[0])||"":(this.forEach((function(e){e.setAttribute(n[0],n[1])})),this)},removeAttr:function(n){return this.forEach((function(e){var t,a=0,r=n&&n.match(/[^\x20\t\r\n\f\*\/\\]+/g);if(r&&1===e.nodeType)for(;t=r[a++];)e.removeAttribute(t)})),this},hasClass:function(n){return!!this[0]&&new RegExp("(\\s|^)"+n+"(\\s|$)").test(this[0].getAttribute("class"))},addClass:function(n){return this.forEach((function(e){var t=(0,o.default)(e),a=t.attr("class");t.hasClass(n)||t.attr("class",a+=" "+n)})),this},removeClass:function(n){return this.forEach((function(e){var t=(0,o.default)(e),a=t.attr("class");if(t.hasClass(n)){var r=new RegExp("(\\s|^)"+n+"(\\s|$)");t.attr("class",a.replace(r,""))}})),this}}),(0,i.default)(o.default,{extend:i.default,noop:function(){},navi:d,ua:d.userAgent,lang:d.language||d.languages[0],detect:s.default,store:l.default,escape:function(n){return n&&h.test(n)?n.replace(p,(function(n){return g[n]})):n},unescape:function(n){return n&&m.test(n)?n.replace(f,(function(n){return v[n]})):n},dynamicLoadSource:function(n,e){if((0,o.default)('script[src="'+n+'"]').length)e&&e();else{var t=u.createElement("script");t.onload=t.onreadystatechange=function(){this.onload=this.onreadystatechange=null,e&&e(),(0,o.default)(t).remove()},t.async=!0,t.setAttribute("referrerPolicy","no-referrer"),(0,o.default)("head")[0].appendChild(t),t.src=n}},sdkLoader:function(n,e,t){e in window&&window[e]?(b&&clearTimeout(b),t&&t()):o.default.dynamicLoadSource(n,(function(){b=setTimeout(o.default.sdkLoader(n,e,t),100)}))},deleteInWin:function(n,e){var t=function(e){if(n in window)try{delete window[n]}catch(e){window[n]=null}};0===e?t():setTimeout(t,e||500)},ajax:c.default}),e.default=o.default},function(n,e,t){"use strict";var a=t(9),r=t(0),i=r("%Function.prototype.apply%"),o=r("%Function.prototype.call%"),s=r("%Reflect.apply%",!0)||a.call(o,i),l=r("%Object.getOwnPropertyDescriptor%",!0),c=r("%Object.defineProperty%",!0),u=r("%Math.max%");if(c)try{c({},"a",{value:1})}catch(n){c=null}n.exports=function(n){var e=s(a,o,arguments);return l&&c&&l(e,"length").configurable&&c(e,"length",{value:1+u(0,n.length-(arguments.length-1))}),e};var d=function(){return s(a,i,arguments)};c?c(n.exports,"apply",{value:d}):n.exports.apply=d},function(n,e,t){"use strict";n.exports=t(62)},function(n,e,t){"use strict";e.__esModule=!0,e.DEFAULT_EMOJI_CDN="//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/",e.DB_NAME="Comment",e.CONFIG={lang:"zh-CN",langMode:null,appId:"",appKey:"",clazzName:"Comment",meta:["nick","mail","link"],path:location.pathname,placeholder:"Just Go Go",pageSize:10,recordIP:!0,serverURLs:"",visitor:!1,mathJax:!1,emojiCDN:"",emojiMaps:void 0,enableQQ:!1,requiredFields:[]},e.defaultMeta=["nick","mail","link"],e.QQCacheKey="_v_Cache_Q",e.MetaCacheKey="_v_Cache_Meta",e.RandomStr=function(n){return(Date.now()+Math.round(1e3*Math.random())).toString(32)},e.VERSION="1.5.1"},function(n,e,t){var a=t(16),r=t(50);for(var i in(e=n.exports=function(n,e){return new r(e).process(n)}).FilterCSS=r,a)e[i]=a[i];"undefined"!=typeof window&&(window.filterCSS=n.exports)},function(n,e,t){"use strict";var a=t(66);n.exports=function(n){return"symbol"==typeof n?"Symbol":"bigint"==typeof n?"BigInt":a(n)}},function(n,e,t){"use strict";var a=t(78);n.exports=Function.prototype.bind||a},function(n,e,t){"use strict";var a,r,i=Function.prototype.toString,o="object"==typeof Reflect&&null!==Reflect&&Reflect.apply;if("function"==typeof o&&"function"==typeof Object.defineProperty)try{a=Object.defineProperty({},"length",{get:function(){throw r}}),r={},o((function(){throw 42}),null,a)}catch(n){n!==r&&(o=null)}else o=null;var s=/^\s*class\b/,l=function(n){try{var e=i.call(n);return s.test(e)}catch(n){return!1}},c=Object.prototype.toString,u="function"==typeof Symbol&&!!Symbol.toStringTag,d="object"==typeof document&&void 0===document.all&&void 0!==document.all?document.all:{};n.exports=o?function(n){if(n===d)return!0;if(!n)return!1;if("function"!=typeof n&&"object"!=typeof n)return!1;if("function"==typeof n&&!n.prototype)return!0;try{o(n,null,a)}catch(n){if(n!==r)return!1}return!l(n)}:function(n){if(n===d)return!0;if(!n)return!1;if("function"!=typeof n&&"object"!=typeof n)return!1;if("function"==typeof n&&!n.prototype)return!0;if(u)return function(n){try{return!l(n)&&(i.call(n),!0)}catch(n){return!1}}(n);if(l(n))return!1;var e=c.call(n);return"[object Function]"===e||"[object GeneratorFunction]"===e}},function(n,e){n.exports={indexOf:function(n,e){var t,a;if(Array.prototype.indexOf)return n.indexOf(e);for(t=0,a=n.length;t<a;t++)if(n[t]===e)return t;return-1},forEach:function(n,e,t){var a,r;if(Array.prototype.forEach)return n.forEach(e,t);for(a=0,r=n.length;a<r;a++)e.call(t,n[a],a,n)},trim:function(n){return String.prototype.trim?n.trim():n.replace(/(^\s*)|(\s*$)/g,"")},spaceIndex:function(n){var e=/\s|\n|\t/.exec(n);return e?e.index:-1}}},function(n,e,t){"use strict";e.__esModule=!0;var a={cdn:t(6).DEFAULT_EMOJI_CDN,maps:t(97),parse:function(n,e){return String(n).replace(new RegExp(":("+Object.keys(a.maps).join("|")+"):","ig"),(function(n,t){return a.maps[t]?a.build(t,e):n}))},build:function(n,e){var t=/^(https?:)?\/\//i,r=a.maps[n],i=t.test(r)?r:a.cdn+r,o=' <img alt="'+n+'" referrerpolicy="no-referrer" class="vemoji" src="'+i+'" />';return t.test(i)?o:""}};e.default=a},function(n,e,t){"use strict";e.__esModule=!0;var a=function(n){return n&&n.__esModule?n:{default:n}}(t(95));e.default=function(n){return(0,a.default)(n,{onTagAttr:function(n,e,t,a){return r(n,e,t,a)},onIgnoreTagAttr:function(n,e,t,a){return r(n,e,t,a)}}).replace(/\<\/?div\>/gi,"")};var r=function(n,e,t,r){if(/video|audio/i.test(n))return"";if(/code|pre|span/i.test(n)){if("style"==e){var i=t.match(/color:([#a-z0-9]{3,7}|\s+[#a-z0-9]{3,8})/gi);return i&&i.length?'style="'+i[0]+'"':""}if("class"==e)return e+"='"+a.default.escapeAttrValue(t)+"'"}return"a"===n&&"class"==e&&"at"===t?e+"='"+a.default.escapeAttrValue(t)+"'":"img"===n&&/src|class/i.test(e)?e+"='"+a.default.escapeAttrValue(t)+"' referrerPolicy='no-referrer'":void 0}},function(n,e,t){"use strict";var a=t(0),r=t(1),i=a("%TypeError%"),o=t(52),s=t(18),l=t(53),c=t(55),u=t(56),d=t(60),p=t(20),h=t(81),f=r("String.prototype.split"),m=Object("a"),g="a"!==m[0]||!(0 in m);n.exports=function(n){var e,t=d(this),a=g&&h(this)?f(this,""):t,r=u(a);if(!c(n))throw new i("Array.prototype.forEach callback must be a function");arguments.length>1&&(e=arguments[1]);for(var m=0;m<r;){var v=p(m);if(l(a,v)){var y=s(a,v);o(n,e,[y,m,a])}m+=1}}},function(n,e,t){"use strict";var a=t(75),r=t(14);n.exports=function(){var n=Array.prototype.forEach;return a(n)?n:r}},function(n,e){function t(){var n={"align-content":!1,"align-items":!1,"align-self":!1,"alignment-adjust":!1,"alignment-baseline":!1,all:!1,"anchor-point":!1,animation:!1,"animation-delay":!1,"animation-direction":!1,"animation-duration":!1,"animation-fill-mode":!1,"animation-iteration-count":!1,"animation-name":!1,"animation-play-state":!1,"animation-timing-function":!1,azimuth:!1,"backface-visibility":!1,background:!0,"background-attachment":!0,"background-clip":!0,"background-color":!0,"background-image":!0,"background-origin":!0,"background-position":!0,"background-repeat":!0,"background-size":!0,"baseline-shift":!1,binding:!1,bleed:!1,"bookmark-label":!1,"bookmark-level":!1,"bookmark-state":!1,border:!0,"border-bottom":!0,"border-bottom-color":!0,"border-bottom-left-radius":!0,"border-bottom-right-radius":!0,"border-bottom-style":!0,"border-bottom-width":!0,"border-collapse":!0,"border-color":!0,"border-image":!0,"border-image-outset":!0,"border-image-repeat":!0,"border-image-slice":!0,"border-image-source":!0,"border-image-width":!0,"border-left":!0,"border-left-color":!0,"border-left-style":!0,"border-left-width":!0,"border-radius":!0,"border-right":!0,"border-right-color":!0,"border-right-style":!0,"border-right-width":!0,"border-spacing":!0,"border-style":!0,"border-top":!0,"border-top-color":!0,"border-top-left-radius":!0,"border-top-right-radius":!0,"border-top-style":!0,"border-top-width":!0,"border-width":!0,bottom:!1,"box-decoration-break":!0,"box-shadow":!0,"box-sizing":!0,"box-snap":!0,"box-suppress":!0,"break-after":!0,"break-before":!0,"break-inside":!0,"caption-side":!1,chains:!1,clear:!0,clip:!1,"clip-path":!1,"clip-rule":!1,color:!0,"color-interpolation-filters":!0,"column-count":!1,"column-fill":!1,"column-gap":!1,"column-rule":!1,"column-rule-color":!1,"column-rule-style":!1,"column-rule-width":!1,"column-span":!1,"column-width":!1,columns:!1,contain:!1,content:!1,"counter-increment":!1,"counter-reset":!1,"counter-set":!1,crop:!1,cue:!1,"cue-after":!1,"cue-before":!1,cursor:!1,direction:!1,display:!0,"display-inside":!0,"display-list":!0,"display-outside":!0,"dominant-baseline":!1,elevation:!1,"empty-cells":!1,filter:!1,flex:!1,"flex-basis":!1,"flex-direction":!1,"flex-flow":!1,"flex-grow":!1,"flex-shrink":!1,"flex-wrap":!1,float:!1,"float-offset":!1,"flood-color":!1,"flood-opacity":!1,"flow-from":!1,"flow-into":!1,font:!0,"font-family":!0,"font-feature-settings":!0,"font-kerning":!0,"font-language-override":!0,"font-size":!0,"font-size-adjust":!0,"font-stretch":!0,"font-style":!0,"font-synthesis":!0,"font-variant":!0,"font-variant-alternates":!0,"font-variant-caps":!0,"font-variant-east-asian":!0,"font-variant-ligatures":!0,"font-variant-numeric":!0,"font-variant-position":!0,"font-weight":!0,grid:!1,"grid-area":!1,"grid-auto-columns":!1,"grid-auto-flow":!1,"grid-auto-rows":!1,"grid-column":!1,"grid-column-end":!1,"grid-column-start":!1,"grid-row":!1,"grid-row-end":!1,"grid-row-start":!1,"grid-template":!1,"grid-template-areas":!1,"grid-template-columns":!1,"grid-template-rows":!1,"hanging-punctuation":!1,height:!0,hyphens:!1,icon:!1,"image-orientation":!1,"image-resolution":!1,"ime-mode":!1,"initial-letters":!1,"inline-box-align":!1,"justify-content":!1,"justify-items":!1,"justify-self":!1,left:!1,"letter-spacing":!0,"lighting-color":!0,"line-box-contain":!1,"line-break":!1,"line-grid":!1,"line-height":!1,"line-snap":!1,"line-stacking":!1,"line-stacking-ruby":!1,"line-stacking-shift":!1,"line-stacking-strategy":!1,"list-style":!0,"list-style-image":!0,"list-style-position":!0,"list-style-type":!0,margin:!0,"margin-bottom":!0,"margin-left":!0,"margin-right":!0,"margin-top":!0,"marker-offset":!1,"marker-side":!1,marks:!1,mask:!1,"mask-box":!1,"mask-box-outset":!1,"mask-box-repeat":!1,"mask-box-slice":!1,"mask-box-source":!1,"mask-box-width":!1,"mask-clip":!1,"mask-image":!1,"mask-origin":!1,"mask-position":!1,"mask-repeat":!1,"mask-size":!1,"mask-source-type":!1,"mask-type":!1,"max-height":!0,"max-lines":!1,"max-width":!0,"min-height":!0,"min-width":!0,"move-to":!1,"nav-down":!1,"nav-index":!1,"nav-left":!1,"nav-right":!1,"nav-up":!1,"object-fit":!1,"object-position":!1,opacity:!1,order:!1,orphans:!1,outline:!1,"outline-color":!1,"outline-offset":!1,"outline-style":!1,"outline-width":!1,overflow:!1,"overflow-wrap":!1,"overflow-x":!1,"overflow-y":!1,padding:!0,"padding-bottom":!0,"padding-left":!0,"padding-right":!0,"padding-top":!0,page:!1,"page-break-after":!1,"page-break-before":!1,"page-break-inside":!1,"page-policy":!1,pause:!1,"pause-after":!1,"pause-before":!1,perspective:!1,"perspective-origin":!1,pitch:!1,"pitch-range":!1,"play-during":!1,position:!1,"presentation-level":!1,quotes:!1,"region-fragment":!1,resize:!1,rest:!1,"rest-after":!1,"rest-before":!1,richness:!1,right:!1,rotation:!1,"rotation-point":!1,"ruby-align":!1,"ruby-merge":!1,"ruby-position":!1,"shape-image-threshold":!1,"shape-outside":!1,"shape-margin":!1,size:!1,speak:!1,"speak-as":!1,"speak-header":!1,"speak-numeral":!1,"speak-punctuation":!1,"speech-rate":!1,stress:!1,"string-set":!1,"tab-size":!1,"table-layout":!1,"text-align":!0,"text-align-last":!0,"text-combine-upright":!0,"text-decoration":!0,"text-decoration-color":!0,"text-decoration-line":!0,"text-decoration-skip":!0,"text-decoration-style":!0,"text-emphasis":!0,"text-emphasis-color":!0,"text-emphasis-position":!0,"text-emphasis-style":!0,"text-height":!0,"text-indent":!0,"text-justify":!0,"text-orientation":!0,"text-overflow":!0,"text-shadow":!0,"text-space-collapse":!0,"text-transform":!0,"text-underline-position":!0,"text-wrap":!0,top:!1,transform:!1,"transform-origin":!1,"transform-style":!1,transition:!1,"transition-delay":!1,"transition-duration":!1,"transition-property":!1,"transition-timing-function":!1,"unicode-bidi":!1,"vertical-align":!1,visibility:!1,"voice-balance":!1,"voice-duration":!1,"voice-family":!1,"voice-pitch":!1,"voice-range":!1,"voice-rate":!1,"voice-stress":!1,"voice-volume":!1,volume:!1,"white-space":!1,widows:!1,width:!0,"will-change":!1,"word-break":!0,"word-spacing":!0,"word-wrap":!0,"wrap-flow":!1,"wrap-through":!1,"writing-mode":!1,"z-index":!1};return n}var a=/javascript\s*\:/gim;e.whiteList=t(),e.getDefaultWhiteList=t,e.onAttr=function(n,e,t){},e.onIgnoreAttr=function(n,e,t){},e.safeAttrValue=function(n,e){return a.test(e)?"":e}},function(n,e){n.exports={indexOf:function(n,e){var t,a;if(Array.prototype.indexOf)return n.indexOf(e);for(t=0,a=n.length;t<a;t++)if(n[t]===e)return t;return-1},forEach:function(n,e,t){var a,r;if(Array.prototype.forEach)return n.forEach(e,t);for(a=0,r=n.length;a<r;a++)e.call(t,n[a],a,n)},trim:function(n){return String.prototype.trim?n.trim():n.replace(/(^\s*)|(\s*$)/g,"")},trimRight:function(n){return String.prototype.trimRight?n.trimRight():n.replace(/(\s*$)/g,"")}}},function(n,e,t){"use strict";var a=t(0)("%TypeError%"),r=t(86),i=t(19),o=t(8);n.exports=function(n,e){if("Object"!==o(n))throw new a("Assertion failed: Type(O) is not Object");if(!i(e))throw new a("Assertion failed: IsPropertyKey(P) is not true, got "+r(e));return n[e]}},function(n,e,t){"use strict";n.exports=function(n){return"string"==typeof n||"symbol"==typeof n}},function(n,e,t){"use strict";var a=t(0),r=a("%String%"),i=a("%TypeError%");n.exports=function(n){if("symbol"==typeof n)throw new i("Cannot convert a Symbol value to a string");return r(n)}},function(n,e,t){"use strict";n.exports=function(n){return null===n||"function"!=typeof n&&"object"!=typeof n}},function(n,e,t){"use strict";var a="undefined"!=typeof Symbol&&Symbol,r=t(23);n.exports=function(){return"function"==typeof a&&"function"==typeof Symbol&&"symbol"==typeof a("foo")&&"symbol"==typeof Symbol("bar")&&r()}},function(n,e,t){"use strict";n.exports=function(){if("function"!=typeof Symbol||"function"!=typeof Object.getOwnPropertySymbols)return!1;if("symbol"==typeof Symbol.iterator)return!0;var n={},e=Symbol("test"),t=Object(e);if("string"==typeof e)return!1;if("[object Symbol]"!==Object.prototype.toString.call(e))return!1;if("[object Symbol]"!==Object.prototype.toString.call(t))return!1;for(e in n[e]=42,n)return!1;if("function"==typeof Object.keys&&0!==Object.keys(n).length)return!1;if("function"==typeof Object.getOwnPropertyNames&&0!==Object.getOwnPropertyNames(n).length)return!1;var a=Object.getOwnPropertySymbols(n);if(1!==a.length||a[0]!==e)return!1;if(!Object.prototype.propertyIsEnumerable.call(n,e))return!1;if("function"==typeof Object.getOwnPropertyDescriptor){var r=Object.getOwnPropertyDescriptor(n,e);if(42!==r.value||!0!==r.enumerable)return!1}return!0}},function(n,e,t){"use strict";var a=t(23);n.exports=function(){return a()&&!!Symbol.toStringTag}},function(n,e,t){"use strict";var a=t(9);n.exports=a.call(Function.call,Object.prototype.hasOwnProperty)},function(n,e,t){"use strict";var a=Object.prototype.toString;n.exports=function(n){var e=a.call(n),t="[object Arguments]"===e;return t||(t="[object Array]"!==e&&null!==n&&"object"==typeof n&&"number"==typeof n.length&&n.length>=0&&"[object Function]"===a.call(n.callee)),t}},function(n,e,t){"use strict";var a=t(5),r=t(1),i=r("Object.prototype.propertyIsEnumerable"),o=r("Array.prototype.push");n.exports=function(n){var e=a(n),t=[];for(var r in e)i(e,r)&&o(t,[r,e[r]]);return t}},function(n,e,t){"use strict";var a=t(27);n.exports=function(){return"function"==typeof Object.entries?Object.entries:a}},function(n,e,t){"use strict";var a=t(5),r=t(20),i=t(1)("String.prototype.replace"),o=/^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+/,s=/[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+$/;n.exports=function(){var n=r(a(this));return i(i(n,o,""),s,"")}},function(n,e,t){"use strict";var a=t(29);n.exports=function(){return String.prototype.trim&&"​"==="​".trim()?String.prototype.trim:a}},function(n,e,t){function a(){return{a:["target","href","title"],abbr:["title"],address:[],area:["shape","coords","href","alt"],article:[],aside:[],audio:["autoplay","controls","crossorigin","loop","muted","preload","src"],b:[],bdi:["dir"],bdo:["dir"],big:[],blockquote:["cite"],br:[],caption:[],center:[],cite:[],code:[],col:["align","valign","span","width"],colgroup:["align","valign","span","width"],dd:[],del:["datetime"],details:["open"],div:[],dl:[],dt:[],em:[],figcaption:[],figure:[],font:["color","size","face"],footer:[],h1:[],h2:[],h3:[],h4:[],h5:[],h6:[],header:[],hr:[],i:[],img:["src","alt","title","width","height"],ins:["datetime"],li:[],mark:[],nav:[],ol:[],p:[],pre:[],s:[],section:[],small:[],span:[],sub:[],summary:[],sup:[],strong:[],strike:[],table:["width","border","align","valign"],tbody:["align","valign"],td:["width","rowspan","colspan","align","valign"],tfoot:["align","valign"],th:["width","rowspan","colspan","align","valign"],thead:["align","valign"],tr:["rowspan","align","valign"],tt:[],u:[],ul:[],video:["autoplay","controls","crossorigin","loop","muted","playsinline","poster","preload","src","height","width"]}}function r(n){return n.replace(g,"&lt;").replace(v,"&gt;")}function i(n){return n.replace(y,"&quot;")}function o(n){return n.replace(b,'"')}function s(n){return n.replace(k,(function(n,e){return"x"===e[0]||"X"===e[0]?String.fromCharCode(parseInt(e.substr(1),16)):String.fromCharCode(parseInt(e,10))}))}function l(n){return n.replace(w,":").replace(x," ")}function c(n){for(var e="",t=0,a=n.length;t<a;t++)e+=n.charCodeAt(t)<32?" ":n.charAt(t);return f.trim(e)}function u(n){return c(n=l(n=s(n=o(n))))}function d(n){return r(n=i(n))}var p=t(7).FilterCSS,h=t(7).getDefaultWhiteList,f=t(11),m=new p,g=/</g,v=/>/g,y=/"/g,b=/&quot;/g,k=/&#([a-zA-Z0-9]*);?/gim,w=/&colon;?/gim,x=/&newline;?/gim,S=/((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a)\:/gi,_=/e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi,j=/u\s*r\s*l\s*\(.*/gi;e.whiteList={a:["target","href","title"],abbr:["title"],address:[],area:["shape","coords","href","alt"],article:[],aside:[],audio:["autoplay","controls","crossorigin","loop","muted","preload","src"],b:[],bdi:["dir"],bdo:["dir"],big:[],blockquote:["cite"],br:[],caption:[],center:[],cite:[],code:[],col:["align","valign","span","width"],colgroup:["align","valign","span","width"],dd:[],del:["datetime"],details:["open"],div:[],dl:[],dt:[],em:[],figcaption:[],figure:[],font:["color","size","face"],footer:[],h1:[],h2:[],h3:[],h4:[],h5:[],h6:[],header:[],hr:[],i:[],img:["src","alt","title","width","height"],ins:["datetime"],li:[],mark:[],nav:[],ol:[],p:[],pre:[],s:[],section:[],small:[],span:[],sub:[],summary:[],sup:[],strong:[],strike:[],table:["width","border","align","valign"],tbody:["align","valign"],td:["width","rowspan","colspan","align","valign"],tfoot:["align","valign"],th:["width","rowspan","colspan","align","valign"],thead:["align","valign"],tr:["rowspan","align","valign"],tt:[],u:[],ul:[],video:["autoplay","controls","crossorigin","loop","muted","playsinline","poster","preload","src","height","width"]},e.getDefaultWhiteList=a,e.onTag=function(n,e,t){},e.onIgnoreTag=function(n,e,t){},e.onTagAttr=function(n,e,t){},e.onIgnoreTagAttr=function(n,e,t){},e.safeAttrValue=function(n,e,t,a){if(t=u(t),"href"===e||"src"===e){if("#"===(t=f.trim(t)))return"#";if("http://"!==t.substr(0,7)&&"https://"!==t.substr(0,8)&&"mailto:"!==t.substr(0,7)&&"tel:"!==t.substr(0,4)&&"data:image/"!==t.substr(0,11)&&"ftp://"!==t.substr(0,6)&&"./"!==t.substr(0,2)&&"../"!==t.substr(0,3)&&"#"!==t[0]&&"/"!==t[0])return""}else if("background"===e){if(S.lastIndex=0,S.test(t))return""}else if("style"===e){if(_.lastIndex=0,_.test(t))return"";if(j.lastIndex=0,j.test(t)&&(S.lastIndex=0,S.test(t)))return"";!1!==a&&(t=(a=a||m).process(t))}return d(t)},e.escapeHtml=r,e.escapeQuote=i,e.unescapeQuote=o,e.escapeHtmlEntities=s,e.escapeDangerHtml5Entities=l,e.clearNonPrintableCharacter=c,e.friendlyAttrValue=u,e.escapeAttrValue=d,e.onIgnoreTagStripAll=function(){return""},e.StripTagBody=function(n,e){function t(e){return!!a||-1!==f.indexOf(n,e)}"function"!=typeof e&&(e=function(){});var a=!Array.isArray(n),r=[],i=!1;return{onIgnoreTag:function(n,a,o){if(t(n)){if(o.isClosing){var s="[/removed]",l=o.position+s.length;return r.push([!1!==i?i:o.position,l]),i=!1,s}return i||(i=o.position),"[removed]"}return e(n,a,o)},remove:function(n){var e="",t=0;return f.forEach(r,(function(a){e+=n.slice(t,a[0]),t=a[1]})),e+=n.slice(t)}}},e.stripCommentTag=function(n){for(var e="",t=0;t<n.length;){var a=n.indexOf("\x3c!--",t);if(-1===a){e+=n.slice(t);break}e+=n.slice(t,a);var r=n.indexOf("--\x3e",a);if(-1===r)break;t=r+3}return e},e.stripBlankChar=function(n){var e=n.split("");return(e=e.filter((function(n){var e=n.charCodeAt(0);return!(127===e||e<=31&&10!==e&&13!==e)}))).join("")},e.cssFilter=m,e.getDefaultCSSWhiteList=h},function(n,e,t){function a(n){var e=l.spaceIndex(n);if(-1===e)var t=n.slice(1,-1);else t=n.slice(1,e+1);return"/"===(t=l.trim(t).toLowerCase()).slice(0,1)&&(t=t.slice(1)),"/"===t.slice(-1)&&(t=t.slice(0,-1)),t}function r(n){return"</"===n.slice(0,2)}function i(n,e){for(;e<n.length;e++){var t=n[e];if(" "!==t)return"="===t?e:-1}}function o(n,e){for(;e>0;e--){var t=n[e];if(" "!==t)return"="===t?e:-1}}function s(n){return function(n){return'"'===n[0]&&'"'===n[n.length-1]||"'"===n[0]&&"'"===n[n.length-1]}(n)?n.substr(1,n.length-2):n}var l=t(11),c=/[^a-zA-Z0-9_:\.\-]/gim;e.parseTag=function(n,e,t){"use strict";var i="",o=0,s=!1,l=!1,c=0,u=n.length,d="",p="";n:for(c=0;c<u;c++){var h=n.charAt(c);if(!1===s){if("<"===h){s=c;continue}}else if(!1===l){if("<"===h){i+=t(n.slice(o,c)),s=c,o=c;continue}if(">"===h){i+=t(n.slice(o,s)),d=a(p=n.slice(s,c+1)),i+=e(s,i.length,d,p,r(p)),o=c+1,s=!1;continue}if('"'===h||"'"===h)for(var f=1,m=n.charAt(c-f);""===m.trim()||"="===m;){if("="===m){l=h;continue n}m=n.charAt(c-++f)}}else if(h===l){l=!1;continue}}return o<n.length&&(i+=t(n.substr(o))),i},e.parseAttr=function(n,e){"use strict";function t(n,t){if(!((n=(n=l.trim(n)).replace(c,"").toLowerCase()).length<1)){var a=e(n,t||"");a&&r.push(a)}}for(var a=0,r=[],u=!1,d=n.length,p=0;p<d;p++){var h,f=n.charAt(p);if(!1!==u||"="!==f)if(!1===u||p!==a||'"'!==f&&"'"!==f||"="!==n.charAt(p-1)){if(/\s|\n|\t/.test(f)){if(n=n.replace(/\s|\n|\t/g," "),!1===u){if(-1===(h=i(n,p))){t(l.trim(n.slice(a,p))),u=!1,a=p+1;continue}p=h-1;continue}if(-1===(h=o(n,p-1))){t(u,s(l.trim(n.slice(a,p)))),u=!1,a=p+1;continue}}}else{if(-1===(h=n.indexOf(f,p+1)))break;t(u,l.trim(n.slice(a+1,h))),u=!1,a=(p=h)+1}else u=n.slice(a,p),a=p+1}return a<n.length&&(!1===u?t(n.slice(a)):t(u,s(l.trim(n.slice(a))))),l.trim(r.join(" "))}},function(n,e,t){var a,r,i;
/*!
	autosize 4.0.4
	license: MIT
	http://www.jacklmoore.com/autosize
*/r=[n,e],a=function(n,e){"use strict";function t(n){function e(e){var t=n.style.width;n.style.width="0px",n.offsetWidth,n.style.width=t,n.style.overflowY=e}function t(){if(0!==n.scrollHeight){var e=function(n){for(var e=[];n&&n.parentNode&&n.parentNode instanceof Element;)n.parentNode.scrollTop&&e.push({node:n.parentNode,scrollTop:n.parentNode.scrollTop}),n=n.parentNode;return e}(n),t=document.documentElement&&document.documentElement.scrollTop;n.style.height="",n.style.height=n.scrollHeight+r+"px",s=n.clientWidth,e.forEach((function(n){n.node.scrollTop=n.scrollTop})),t&&(document.documentElement.scrollTop=t)}}function a(){t();var a=Math.round(parseFloat(n.style.height)),r=window.getComputedStyle(n,null),i="content-box"===r.boxSizing?Math.round(parseFloat(r.height)):n.offsetHeight;if(i<a?"hidden"===r.overflowY&&(e("scroll"),t(),i="content-box"===r.boxSizing?Math.round(parseFloat(window.getComputedStyle(n,null).height)):n.offsetHeight):"hidden"!==r.overflowY&&(e("hidden"),t(),i="content-box"===r.boxSizing?Math.round(parseFloat(window.getComputedStyle(n,null).height)):n.offsetHeight),l!==i){l=i;var s=o("autosize:resized");try{n.dispatchEvent(s)}catch(n){}}}if(n&&n.nodeName&&"TEXTAREA"===n.nodeName&&!i.has(n)){var r=null,s=null,l=null,c=function(){n.clientWidth!==s&&a()},u=function(e){window.removeEventListener("resize",c,!1),n.removeEventListener("input",a,!1),n.removeEventListener("keyup",a,!1),n.removeEventListener("autosize:destroy",u,!1),n.removeEventListener("autosize:update",a,!1),Object.keys(e).forEach((function(t){n.style[t]=e[t]})),i.delete(n)}.bind(n,{height:n.style.height,resize:n.style.resize,overflowY:n.style.overflowY,overflowX:n.style.overflowX,wordWrap:n.style.wordWrap});n.addEventListener("autosize:destroy",u,!1),"onpropertychange"in n&&"oninput"in n&&n.addEventListener("keyup",a,!1),window.addEventListener("resize",c,!1),n.addEventListener("input",a,!1),n.addEventListener("autosize:update",a,!1),n.style.overflowX="hidden",n.style.wordWrap="break-word",i.set(n,{destroy:u,update:a}),function(){var e=window.getComputedStyle(n,null);"vertical"===e.resize?n.style.resize="none":"both"===e.resize&&(n.style.resize="horizontal"),r="content-box"===e.boxSizing?-(parseFloat(e.paddingTop)+parseFloat(e.paddingBottom)):parseFloat(e.borderTopWidth)+parseFloat(e.borderBottomWidth),isNaN(r)&&(r=0),a()}()}}function a(n){var e=i.get(n);e&&e.destroy()}function r(n){var e=i.get(n);e&&e.update()}var i="function"==typeof Map?new Map:function(){var n=[],e=[];return{has:function(e){return n.indexOf(e)>-1},get:function(t){return e[n.indexOf(t)]},set:function(t,a){-1===n.indexOf(t)&&(n.push(t),e.push(a))},delete:function(t){var a=n.indexOf(t);a>-1&&(n.splice(a,1),e.splice(a,1))}}}(),o=function(n){return new Event(n,{bubbles:!0})};try{new Event("test")}catch(n){o=function(n){var e=document.createEvent("Event");return e.initEvent(n,!0,!1),e}}var s=null;"undefined"==typeof window||"function"!=typeof window.getComputedStyle?((s=function(n){return n}).destroy=function(n){return n},s.update=function(n){return n}):((s=function(n,e){return n&&Array.prototype.forEach.call(n.length?n:[n],(function(n){return t(n)})),n}).destroy=function(n){return n&&Array.prototype.forEach.call(n.length?n:[n],a),n},s.update=function(n){return n&&Array.prototype.forEach.call(n.length?n:[n],r),n}),e.default=s,n.exports=e.default},void 0!==(i="function"==typeof a?a.apply(e,r):a)&&(n.exports=i)},function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{default:n}}function r(n){return!!n&&this.init(n),this}function i(n){return new r(n)}var o=a(t(42)),s=a(t(33)),l=a(t(37)),c=a(t(12)),u=t(6),d=a(t(41)),p=a(t(36)),h=t(40),f=a(t(38)),m=a(t(3)),g=a(t(39)),v=a(t(13)),y=(a(t(35)),{comment:"",nick:"",mail:"",link:"",ua:m.default.ua,url:"",QQAvatar:""}),b="",k={},w={cdn:"https://gravatar.loli.net/avatar/",ds:["mp","identicon","monsterid","wavatar","robohash","retro",""],params:"",hide:!1};r.prototype.init=function(n){if("undefined"==typeof document)throw new Error("Sorry, Valine does not support Server-side rendering.");var e=this;return n&&(n=m.default.extend(u.CONFIG,n),e.i18n=(0,l.default)(n.lang||m.default.lang,n.langMode),e.cfg=n,c.default.maps=!!n.emojiMaps&&n.emojiMaps||c.default.maps,c.default.cdn=!!n.emojiCDN&&n.emojiCDN||c.default.cdn,e._init()),e},r.prototype._init=function(){var n=this;try{var e=n.cfg,t=e.avatar,a=e.avatarForce,r=e.avatar_cdn,i=e.visitor,o=e.path,s=void 0===o?location.pathname:o,l=e.pageSize,c=e.recordIP;n.cfg.path=s.replace(/index\.html?$/,"");var d=w.ds,g=a?"&q="+(0,u.RandomStr)():"";w.params="?d="+(d.indexOf(t)>-1?t:"mp")+"&v="+u.VERSION+g,w.hide="hide"===t,w.cdn=/^https?\:\/\//.test(r)?r:w.cdn,n.cfg.pageSize=isNaN(l)||l<1?10:l,c&&(0,h.recordIPFn)((function(n){return y.ip=n}));var v=n.cfg.el||null,b=(0,m.default)(v);if(v=v instanceof HTMLElement?v:b[b.length-1]||null){n.$el=(0,m.default)(v),n.$el.addClass("v").attr("data-class","v"),w.hide&&n.$el.addClass("hide-avatar"),n.cfg.meta=(n.cfg.guest_info||n.cfg.meta||u.defaultMeta).filter((function(n){return u.defaultMeta.indexOf(n)>-1})),n.cfg.requiredFields=n.cfg.requiredFields.filter((function(n){return u.defaultMeta.indexOf(n)>-1}));var k=(0==n.cfg.meta.length?u.defaultMeta:n.cfg.meta).map((function(e){var t="mail"==e?"email":"text";return u.defaultMeta.indexOf(e)>-1?'<input name="'+e+'" placeholder="'+n.i18n.t(e)+'" class="v'+e+' vinput" type="'+t+'">':""})),x='<div class="vpanel"><div class="vwrap"><p class="cancel-reply text-right" style="display:none;" title="'+n.i18n.t("cancelReply")+'"><svg class="vicon cancel-reply-btn" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4220" width="22" height="22"><path d="M796.454 985H227.545c-50.183 0-97.481-19.662-133.183-55.363-35.7-35.701-55.362-83-55.362-133.183V227.545c0-50.183 19.662-97.481 55.363-133.183 35.701-35.7 83-55.362 133.182-55.362h568.909c50.183 0 97.481 19.662 133.183 55.363 35.701 35.702 55.363 83 55.363 133.183v568.909c0 50.183-19.662 97.481-55.363 133.183S846.637 985 796.454 985zM227.545 91C152.254 91 91 152.254 91 227.545v568.909C91 871.746 152.254 933 227.545 933h568.909C871.746 933 933 871.746 933 796.454V227.545C933 152.254 871.746 91 796.454 91H227.545z" p-id="4221"></path><path d="M568.569 512l170.267-170.267c15.556-15.556 15.556-41.012 0-56.569s-41.012-15.556-56.569 0L512 455.431 341.733 285.165c-15.556-15.556-41.012-15.556-56.569 0s-15.556 41.012 0 56.569L455.431 512 285.165 682.267c-15.556 15.556-15.556 41.012 0 56.569 15.556 15.556 41.012 15.556 56.569 0L512 568.569l170.267 170.267c15.556 15.556 41.012 15.556 56.569 0 15.556-15.556 15.556-41.012 0-56.569L568.569 512z" p-id="4222" ></path></svg></p><div class="vheader item'+k.length+'">'+k.join("")+'</div><div class="vedit"><textarea id="veditor" class="veditor vinput" placeholder="'+n.cfg.placeholder+'"></textarea><div class="vrow"><div class="vcol vcol-60 status-bar"></div><div class="vcol vcol-40 vctrl text-right"><span title="'+n.i18n.t("emoji")+'"  class="vicon vemoji-btn"><svg  viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16172" width="22" height="22" ><path d="M512 1024a512 512 0 1 1 512-512 512 512 0 0 1-512 512zM512 56.888889a455.111111 455.111111 0 1 0 455.111111 455.111111 455.111111 455.111111 0 0 0-455.111111-455.111111zM312.888889 512A85.333333 85.333333 0 1 1 398.222222 426.666667 85.333333 85.333333 0 0 1 312.888889 512z" p-id="16173"></path><path d="M512 768A142.222222 142.222222 0 0 1 369.777778 625.777778a28.444444 28.444444 0 0 1 56.888889 0 85.333333 85.333333 0 0 0 170.666666 0 28.444444 28.444444 0 0 1 56.888889 0A142.222222 142.222222 0 0 1 512 768z" p-id="16174"></path><path d="M782.222222 391.964444l-113.777778 59.733334a29.013333 29.013333 0 0 1-38.684444-10.808889 28.444444 28.444444 0 0 1 10.24-38.684445l113.777778-56.888888a28.444444 28.444444 0 0 1 38.684444 10.24 28.444444 28.444444 0 0 1-10.24 36.408888z" p-id="16175"></path><path d="M640.568889 451.697778l113.777778 56.888889a27.875556 27.875556 0 0 0 38.684444-10.24 27.875556 27.875556 0 0 0-10.24-38.684445l-113.777778-56.888889a28.444444 28.444444 0 0 0-38.684444 10.808889 28.444444 28.444444 0 0 0 10.24 38.115556z" p-id="16176"></path></svg></span><span title="'+n.i18n.t("preview")+'" class="vicon vpreview-btn"><svg  viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="17688" width="22" height="22"><path d="M502.390154 935.384615a29.538462 29.538462 0 1 1 0 59.076923H141.430154C79.911385 994.461538 29.538462 946.254769 29.538462 886.153846V137.846154C29.538462 77.745231 79.950769 29.538462 141.390769 29.538462h741.218462c61.44 0 111.852308 48.206769 111.852307 108.307692v300.268308a29.538462 29.538462 0 1 1-59.076923 0V137.846154c0-26.899692-23.355077-49.230769-52.775384-49.230769H141.390769c-29.420308 0-52.775385 22.331077-52.775384 49.230769v748.307692c0 26.899692 23.355077 49.230769 52.775384 49.230769h360.999385z" p-id="17689"></path><path d="M196.923077 216.615385m29.538461 0l374.153847 0q29.538462 0 29.538461 29.538461l0 0q0 29.538462-29.538461 29.538462l-374.153847 0q-29.538462 0-29.538461-29.538462l0 0q0-29.538462 29.538461-29.538461Z" p-id="17690"></path><path d="M649.846154 846.769231a216.615385 216.615385 0 1 0 0-433.230769 216.615385 216.615385 0 0 0 0 433.230769z m0 59.076923a275.692308 275.692308 0 1 1 0-551.384616 275.692308 275.692308 0 0 1 0 551.384616z" p-id="17691"></path><path d="M807.398383 829.479768m20.886847-20.886846l0 0q20.886846-20.886846 41.773692 0l125.321079 125.321079q20.886846 20.886846 0 41.773693l0 0q-20.886846 20.886846-41.773693 0l-125.321078-125.321079q-20.886846-20.886846 0-41.773693Z" p-id="17692"></path></svg></span></div></div></div><div class="vrow"><div class="vcol vcol-30" ><a alt="Markdown is supported" href="https://guides.github.com/features/mastering-markdown/" class="vicon" target="_blank"><svg class="markdown" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M14.85 3H1.15C.52 3 0 3.52 0 4.15v7.69C0 12.48.52 13 1.15 13h13.69c.64 0 1.15-.52 1.15-1.15v-7.7C16 3.52 15.48 3 14.85 3zM9 11H7V8L5.5 9.92 4 8v3H2V5h2l1.5 2L7 5h2v6zm2.99.5L9.5 8H11V5h2v3h1.5l-2.51 3.5z"></path></svg></a></div><div class="vcol vcol-70 text-right"><button type="button"  title="Cmd|Ctrl+Enter" class="vsubmit vbtn">'+n.i18n.t("submit")+'</button></div></div><div class="vemojis" style="display:none;"></div><div class="vinput vpreview" style="display:none;"></div></div></div><div class="vcount" style="display:none;"><span class="vnum">0</span> '+n.i18n.t("comments")+'</div><div class="vload-top text-center" style="display:none;"><i class="vspinner" style="width:30px;height:30px;"></i></div><div class="vcards"></div><div class="vload-bottom text-center" style="display:none;"><i class="vspinner" style="width:30px;height:30px;"></i></div><div class="vempty" style="display:none;"></div><div class="vpage txt-center" style="display:none"><button type="button" class="vmore vbtn">'+n.i18n.t("more")+'</button></div><div class="vpower txt-right">Powered By <a href="https://valine.js.org" target="_blank">Valine</a><br>v'+u.VERSION+"</div>";n.$el.html(x),n.$el.find(".cancel-reply").on("click",(function(e){n.reset()}));var _=n.$el.find(".vempty");n.$nodata={show:function(e){return _.html(e||n.i18n.t("sofa")).show(),n},hide:function(){return _.hide(),n}};var j=n.$el.find(".vload-bottom"),T=n.$el.find(".vload-top");n.$loading={show:function(e){return e&&T.show()||j.show(),n.$nodata.hide(),n},hide:function(){return T.hide(),j.hide(),0===n.$el.find(".vcard").length&&n.$nodata.show(),n}}}(0,p.default)(n.cfg,(function(e){var t=(0,m.default)(".valine-comment-count"),a=0;!function e(t){var r=t[a++];if(r){var i=(0,m.default)(r).attr("data-xid");i&&n.Q(i).count().then((function(n){r.innerText=n,e(t)})).catch((function(n){r.innerText=0}))}}(t),i&&S.add(AV.Object.extend("Counter"),n.cfg.path),n.$el&&n.bind()}))}catch(e){(0,f.default)(n,e,"init")}};var x=function(n,e){var t=new n,a=new AV.ACL;a.setPublicReadAccess(!0),a.setPublicWriteAccess(!0),t.setACL(a),t.set("url",e.url),t.set("xid",e.xid),t.set("title",e.title),t.set("time",1),t.save().then((function(n){(0,m.default)(e.el).find(".leancloud-visitors-count").text(1)})).catch((function(n){}))},S={add:function(n,e){var t=this,a=(0,m.default)(".leancloud_visitors,.leancloud-visitors");if(1===a.length){var r=a[0],i=decodeURI((0,m.default)(r).attr("id")),o=(0,m.default)(r).attr("data-flag-title"),s=encodeURI(i),l={el:r,url:i,xid:s,title:o};if(decodeURI(i)===decodeURI(e)){var c=new AV.Query(n);c.equalTo("url",i),c.find().then((function(e){if(e.length>0){var t=e[0];t.increment("time"),t.save().then((function(n){(0,m.default)(r).find(".leancloud-visitors-count").text(n.get("time"))})).catch((function(n){}))}else x(n,l)})).catch((function(e){101==e.code?x(n,l):(0,f.default)(t,e)}))}else S.show(n,a)}else S.show(n,a)},show:function(n,e){var t=[];if(e.forEach((function(n){var e=(0,m.default)(n).find(".leancloud-visitors-count");e&&e.text("0"),t.push(/\%/.test((0,m.default)(n).attr("id"))?decodeURI((0,m.default)(n).attr("id")):(0,m.default)(n).attr("id"))})),t.length){var a=new AV.Query(n);a.containedIn("url",t),a.find().then((function(n){n.length>0&&e.forEach((function(e){n.forEach((function(n){var t=n.get("xid")||encodeURI(n.get("url")),a=n.get("time"),r=(0,m.default)(e),i=r.attr("id");if((/\%/.test(i)?i:encodeURI(i))==t){var o=r.find(".leancloud-visitors-count");o&&o.text(a)}}))}))})).catch((function(n){}))}}};r.prototype.Q=function(n){var e=this,t=arguments.length,a=e.cfg.clazzName;if(1==t){var r=new AV.Query(a);r.doesNotExist("rid");var i=new AV.Query(a);i.equalTo("rid","");var o=AV.Query.or(r,i);return"*"===n?o.exists("url"):o.equalTo("url",decodeURI(n)),o.addDescending("createdAt"),o.addDescending("insertedAt"),o}var s=JSON.stringify(arguments[1]).replace(/(\[|\])/g,""),l="select * from "+a+" where rid in ("+s+") order by -createdAt,-createdAt";return AV.Query.doCloudQuery(l)},r.prototype.installLocale=function(n,e){return this.i18n(n,e),this},r.prototype.setPath=function(n){return this.config.path=n,this},r.prototype.bind=function(){var n=this,e=n.$el.find(".vemojis"),t=n.$el.find(".vpreview"),a=n.$el.find(".vemoji-btn"),r=n.$el.find(".vpreview-btn"),i=n.$el.find(".veditor"),l=c.default.maps,p=!1;n.$emoji={show:function(){return!p&&function(n){var t=[];for(var a in l)l.hasOwnProperty(a)&&c.default.build(a)&&t.push('<i title="'+a+'" >'+c.default.build(a)+"</i>");e.html(t.join("")),p=!0,e.find("i").on("click",(function(n){n.preventDefault(),A(i[0]," :"+(0,m.default)(this).attr("title")+":")}))}(),n.$preview.hide(),e.show(),a.addClass("actived"),n.$emoji},hide:function(){return a.removeClass("actived"),e.hide(),n.$emoji}},n.$preview={show:function(){return b?(n.$emoji.hide(),r.addClass("actived"),t.html((0,g.default)(b)).show(),D()):n.$preview.hide(),n.$preview},hide:function(){return r.removeClass("actived"),t.hide().html(""),n.$preview}};var x=function(e){var a=e.val()||"";a||n.$preview.hide(),b!=a&&(b=a,r.hasClass("actived")>-1&&b!=t.html()&&t.html((0,g.default)(b)),D())};a.on("click",(function(e){a.hasClass("actived")?n.$emoji.hide():n.$emoji.show()})),r.on("click",(function(e){r.hasClass("actived")?n.$preview.hide():n.$preview.show()}));var S=n.cfg.meta,_={},j={veditor:"comment"};for(var T in S.forEach((function(n){j["v"+n]=n})),j)j.hasOwnProperty(T)&&function(){var e=j[T],t=n.$el.find("."+T);_[e]=t,t.on("input change blur propertychange",(function(a){n.cfg.enableQQ&&"blur"===a.type&&"nick"===e&&(t.val()&&!isNaN(t.val())?(0,h.fetchQQFn)(t.val(),(function(n){var e=n.nick||t.val(),a=n.qq+"@qq.com";(0,m.default)(".vnick").val(e),(0,m.default)(".vmail").val(a),y.nick=e,y.mail=a,y.QQAvatar=n.pic})):m.default.store.get(u.QQCacheKey)&&m.default.store.get(u.QQCacheKey).nick!=t.val()&&(m.default.store.remove(u.QQCacheKey),y.nick=t.val(),y.mail="",y.QQAvatar="")),"comment"===e?((0,s.default)(t[0]),C((function(n){x(t)}))()):y[e]=(0,v.default)(t.val().replace(/(^\s*)|(\s*$)/g,"").substring(0,35))}))}();var C=function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:300,t=void 0;return function(){var a=this,r=arguments;t&&clearTimeout(t),t=setTimeout((function(){n.apply(a,r)}),e)}},A=function(n,e){if(document.selection)n.focus(),document.selection.createRange().text=e,n.focus();else if(n.selectionStart||"0"==n.selectionStart){var t=n.selectionStart,a=n.selectionEnd,r=n.scrollTop;n.value=n.value.substring(0,t)+e+n.value.substring(a,n.value.length),n.focus(),n.selectionStart=t+e.length,n.selectionEnd=t+e.length,n.scrollTop=r}else n.focus(),n.value+=e;C((function(e){x((0,m.default)(n))}))()},I={no:1,size:n.cfg.pageSize,skip:n.cfg.pageSize},E=n.$el.find(".vpage");E.on("click",(function(n){E.hide(),I.no++,O()}));var O=function(){var e=I.size,t=I.no,a=Number(n.$el.find(".vnum").text());n.$loading.show();var r=n.Q(n.cfg.path);r.limit(e),r.skip((t-1)*e),r.find().then((function(r){if(I.skip=I.size,r&&r.length){var i=[];r.forEach((function(e){i.push(e.id),$(e,n.$el.find(".vcards"),!0)})),n.Q(n.cfg.path,i).then((function(n){(n&&n.results||[]).forEach((function(n){$(n,(0,m.default)('.vquote[data-self-id="'+n.get("rid")+'"]'))}))})).catch((function(n){})),e*t<a?E.show():E.hide(),D()}else n.$nodata.show();n.$loading.hide()})).catch((function(e){n.$loading.hide(),(0,f.default)(n,e,"query")}))};n.Q(n.cfg.path).count().then((function(e){e>0?(n.$el.find(".vcount").show().find(".vnum").text(e),O()):n.$loading.hide()})).catch((function(e){(0,f.default)(n,e,"count")}));var L=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",e=/(https?|http):\/\/[-A-Za-z0-9+&@#/%?=~_|!:,.;]+[-A-Za-z0-9+&@#/%=~_|]/g,t=n.match(e)||[];return t.length>0?t[0]:""},$=function(e,t,a){var r=(0,m.default)('<div class="vcard" id="'+e.id+'"></div>'),i=(0,v.default)(e.get("ua")),s="";i&&!/ja/.test(n.cfg.lang)&&(s=(i=m.default.detect(i)).version?i.os?'<span class="vsys">'+i.browser+" "+i.version+'</span> <span class="vsys">'+i.os+" "+i.osVersion+"</span>":"":'<span class="vsys">'+i.browser+"</span>"),"*"===n.cfg.path&&(s='<a href="'+e.get("url")+'" class="vsys">'+e.get("url")+"</a>");var l=e.get("link")?/^https?\:\/\//.test(e.get("link"))?e.get("link"):"http://"+e.get("link"):"",c=m.default.escape((0,v.default)(e.get("nick").substring(0,30))),u=l?'<a class="vnick" rel="nofollow" href="'+L(l)+'" target="_blank" >'+c+"</a>":'<span class="vnick">'+c+"</span>",p=(w.hide?"":n.cfg.enableQQ&&e.get("QQAvatar")?(0,v.default)('<img class="vimg" src="'+L(e.get("QQAvatar"))+'" referrerPolicy="no-referrer"/>'):'<img class="vimg" src="'+(w.cdn+(0,o.default)(e.get("mail"))+w.params)+'">')+'<div class="vh"><div class="vhead">'+u+" "+s+'</div><div class="vmeta"><span class="vtime" >'+(0,d.default)(e.get("insertedAt"),n.i18n)+'</span><span class="vat" data-vm-id="'+(e.get("rid")||e.id)+'" data-self-id="'+e.id+'">'+n.i18n.t("reply")+'</span></div><div class="vcontent" data-expand="'+n.i18n.t("expand")+'">'+(0,g.default)(e.get("comment"))+'</div><div class="vreply-wrapper" data-self-id="'+e.id+'"></div><div class="vquote" data-self-id="'+e.id+'"></div></div>';r.html(p);var h=r.find(".vat");r.find("a:not(.at)").forEach((function(n){(0,m.default)(n).attr({target:"_blank",rel:"noopener"})})),a?t.append(r):t.prepend(r);var f=r.find(".vcontent");f&&M(f),h&&z(h,e)},P={},z=function(e,t){e.on("click",(function(a){var r=e.attr("data-vm-id"),i=e.attr("data-self-id"),o=n.$el.find(".vwrap"),s="@"+m.default.escape(t.get("nick"));(0,m.default)('.vreply-wrapper[data-self-id="'+i+'"]').append(o).find(".cancel-reply").show(),P={at:m.default.escape(s)+" ",rid:r,pid:i,rmail:t.get("mail")},_.comment.attr({placeholder:s})[0].focus()}))},D=function(){setTimeout((function(){try{n.cfg.mathjax&&"MathJax"in window&&"version"in window.MathJax&&(/^3.*/.test(window.MathJax.version)&&MathJax.typeset()||MathJax.Hub.Queue(["Typeset",MathJax.Hub,document.querySelector(".v")])),"renderMathInElement"in window&&renderMathInElement((0,m.default)(".v")[0],{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})}catch(n){}}),100)},M=function(n){setTimeout((function(){n[0].offsetHeight>200&&(n.addClass("expand"),n.on("click",(function(e){n.removeClass("expand")})))}))};!function(e){if(e=m.default.store.get(u.MetaCacheKey)||e)for(var t in S)if(S.hasOwnProperty(t)){var a=S[t];n.$el.find(".v"+a).val(m.default.unescape(e[a])),y[a]=e[a]}var r=m.default.store.get(u.QQCacheKey);y.QQAvatar=n.cfg.enableQQ&&!!r&&r.pic||""}(),n.reset=function(){y.comment="",_.comment.val(""),x(_.comment),_.comment.attr("placeholder",n.cfg.placeholder),P={},n.$preview.hide(),n.$el.find(".vpanel").append(n.$el.find(".vwrap")),n.$el.find(".cancel-reply").hide(),b="",s.default.update(_.comment[0])};var F=n.$el.find(".vsubmit"),R=function(e){if(n.cfg.requiredFields.indexOf("nick")>-1&&y.nick.length<3)return _.nick[0].focus(),void n.$el.find(".status-bar").text(""+n.i18n.t("nickFail")).empty(3e3);if(n.cfg.requiredFields.indexOf("mail")>-1&&!/[\w-\.]+@([\w-]+\.)+[a-z]{2,3}/.test(y.mail))return _.mail[0].focus(),void n.$el.find(".status-bar").text(""+n.i18n.t("mailFail")).empty(3e3);if(""!=b){for(var t in k)if(k.hasOwnProperty(t)){var a=k[t];b=b.replace(t,a),URL.revokeObjectURL(t)}k={},y.comment=(0,v.default)(b),y.nick=y.nick||"Anonymous";var r=m.default.store.get("vlx");r&&Date.now()/1e3-r/1e3<20?n.$el.find(".status-bar").text(n.i18n.t("busy")).empty(3e3):q()}else _.comment[0].focus()},q=function(){m.default.store.set("vlx",Date.now()),F.attr({disabled:!0}),n.$loading.show(!0);var e=new(AV.Object.extend(n.cfg.clazzName||"Comment"));if(y.url=decodeURI(n.cfg.path),y.insertedAt=new Date,P.rid){var t=P.pid||P.rid;e.set("rid",P.rid),e.set("pid",t),y.comment=b.replace("<p>",'<p><a class="at" href="#'+t+'">'+P.at+"</a> , ")}for(var a in y)if(y.hasOwnProperty(a)){var r=y[a];e.set(a,r)}e.setACL(function(){var n=new AV.ACL;return n.setPublicReadAccess(!0),n.setPublicWriteAccess(!1),n}()),e.save().then((function(e){"Anonymous"!=y.nick&&m.default.store.set(u.MetaCacheKey,{nick:y.nick,link:y.link,mail:y.mail});var t=n.$el.find(".vnum");try{P.rid?$(e,(0,m.default)('.vquote[data-self-id="'+P.rid+'"]'),!0):(Number(t.text())?t.text(Number(t.text())+1):n.$el.find(".vcount").show().find(".vnum").text(Number(t.text())+1),$(e,n.$el.find(".vcards")),I.skip++),F.removeAttr("disabled"),n.$loading.hide(),n.reset()}catch(e){(0,f.default)(n,e,"save")}})).catch((function(e){(0,f.default)(n,e,"commitEvt")}))};F.on("click",R),(0,m.default)(document).on("keydown",(function(n){var e=(n=window.event||n).keyCode||n.which||n.charCode;(n.ctrlKey||n.metaKey)&&13===e&&R(),9===e&&"veditor"==(document.activeElement.id||"")&&(n.preventDefault(),A(i[0],"    "))})).on("paste",(function(n){var e="clipboardData"in n?n.clipboardData:n.originalEvent&&n.originalEvent.clipboardData||window.clipboardData;e&&N(e.items,!0)})),i.on("dragenter dragleave dragover drop",(function(n){n.stopPropagation(),n.preventDefault(),"drop"===n.type&&N(n.dataTransfer.items)}));var N=function(n,e){for(var t=0,a=n.length;t<a;t++){var r=n[t];if("string"===r.kind&&r.type.match("^text/html"))!e&&r.getAsString((function(n){n&&A(i[0],n.replace(/<[^>]+>/g,""))}));else if(r.type.indexOf("image")>-1){B(r.getAsFile());continue}}},B=function(n){try{var e=URL.createObjectURL(n),t="![image]("+e+") ",a=new FileReader;A(i[0],t),a.onload=function(){k[e]=a.result},a.readAsDataURL(n)}catch(n){}}},n.exports=i,n.exports.default=i},function(n,e,t){"use strict";e.__esModule=!0;var a=function(n){return n&&n.__esModule?n:{default:n}}(t(3));e.default={getApi:function(n,e){a.default.ajax({url:"https://app-router.com/2/route",body:{appId:n}}).then((function(n){n.json().then((function(n){return e&&e("//"+n.api_server)}))}))}}},function(n,e,t){"use strict";e.__esModule=!0;var a=function(n){return n&&n.__esModule?n:{default:n}}(t(3)),r=!1;e.default=function(n,e){if("AV"in window){var t=window.AV.version||window.AV.VERSION;parseInt(t.split(".")[0])>2?r=!!AV.applicationId&&!!AV.applicationKey:a.default.deleteInWin("AV",0)}r?e&&e():a.default.sdkLoader("//unpkg.com/leancloud-storage@3/dist/av-min.js","AV",(function(t){var a,i="https://",o=n.app_id||n.appId,s=n.app_key||n.appKey;if(!n.serverURLs)switch(o.slice(-9)){case"-9Nh9j0Va":i+="tab.";break;case"-MdYXbMMI":i+="us."}a=n.serverURLs||i+"leancloud.cn",AV.init({appId:o,appKey:s,serverURLs:a}),r=!0,e&&e()}))}},function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{default:n}}e.__esModule=!0;var r=a(t(84)),i=a(t(100)),o=a(t(101)),s=a(t(98)),l=a(t(99)),c={zh:i.default,"zh-cn":i.default,"zh-CN":i.default,"zh-TW":o.default,en:s.default,"en-US":s.default,ja:l.default,"ja-JP":l.default};e.default=function(n,e){return!c[n]&&n&&e&&(c[n]=e),new r.default({phrases:c[n||"zh"],locale:n})}},function(n,e,t){"use strict";e.__esModule=!0,e.default=function(n,e){if(n.$el&&n.$loading.hide().$nodata.hide(),"[object Error]"==={}.toString.call(e)){var t=e.code||e.message||e.error||"";if(isNaN(t))n.$el&&n.$nodata.show('<pre style="text-align:left;"> '+JSON.stringify(e)+"</pre>");else{var a=n.i18n.t("code-"+t),r=(a=="code-"+t?void 0:a)||e.message||e.error||"";101==t||-1==t?n.$nodata.show():n.$el&&n.$nodata.show('<pre style="text-align:left;">Code '+t+": "+r+"</pre>")}}else n.$el&&n.$nodata.show('<pre style="text-align:left;">'+JSON.stringify(e)+"</pre>")}},function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{default:n}}e.__esModule=!0;var r=t(83),i=a(t(79)),o=a(t(3)),s=a(t(12)),l=a(t(13)),c=new r.marked.Renderer;c.code=function(n,e){return'<pre><code class="hljs language-'+e+'">'+(e&&hljs.getLanguage(e)?hljs.highlight(e,n).value:o.default.escape(n))+"</code></pre>"},r.marked.setOptions({renderer:"hljs"in window?c:new r.marked.Renderer,highlight:function(n,e){return"hljs"in window?e&&hljs.getLanguage(e)&&hljs.highlight(e,n,!0).value||hljs.highlightAuto(n).value:(0,i.default)(n)},gfm:!0,tables:!0,breaks:!0,pedantic:!1,sanitize:!1,smartLists:!0,smartypants:!0,headerPrefix:"v-"}),e.default=function(n){return(0,l.default)((0,r.marked)(s.default.parse(n,!0)))}},function(n,e,t){"use strict";e.__esModule=!0,e.recordIPFn=e.fetchQQFn=void 0;var a=function(n){return n&&n.__esModule?n:{default:n}}(t(3)),r=t(6);e.fetchQQFn=function(n,e){var t=a.default.store.get(r.QQCacheKey);t&&t.qq==n?e&&e(t):a.default.ajax({url:"//valine.api.ioliu.cn/getqqinfo",method:"POST",body:{qq:n}}).then((function(n){n.json().then((function(n){n.errmsg||(a.default.store.set(r.QQCacheKey,n),e&&e(n))}))}))},e.recordIPFn=function(n){a.default.ajax({url:"https://forge.speedtest.cn/api/location/info",method:"get"}).then((function(n){return n.json()})).then((function(e){n&&n(e.ip)}))}},function(n,e,t){"use strict";e.__esModule=!0,e.default=function(n,e){if(!n)return"Invalid Date.";try{var t=r(n).getTime();if(isNaN(t))return"Invalid Date.";var i=(new Date).getTime()-t,o=Math.floor(i/864e5);if(0===o){var s=i%864e5,l=Math.floor(s/36e5);if(0===l){var c=s%36e5,u=Math.floor(c/6e4);if(0===u){var d=c%6e4;return Math.round(d/1e3)+" "+e.t("seconds")}return u+" "+e.t("minutes")}return l+" "+e.t("hours")}return o<0?e.t("now"):o<8?o+" "+e.t("days"):a(n)}catch(n){}};var a=function(n){var e=i(n.getDate(),2),t=i(n.getMonth()+1,2);return i(n.getFullYear(),2)+"-"+t+"-"+e},r=function n(e){return e instanceof Date?e:!isNaN(e)||/^\d+$/.test(e)?new Date(parseInt(e)):/GMT/.test(e||"")?n(new Date(e).getTime()):(e=(e||"").replace(/(^\s*)|(\s*$)/g,"").replace(/\.\d+/,"").replace(/-/,"/").replace(/-/,"/").replace(/(\d)T(\d)/,"$1 $2").replace(/Z/," UTC").replace(/([+-]\d\d):?(\d\d)/," $1$2"),new Date(e))},i=function(n,e){for(var t=n.toString();t.length<e;)t="0"+t;return t}},function(n,e,t){var a;!function(r){"use strict";function i(n,e){var t=(65535&n)+(65535&e);return(n>>16)+(e>>16)+(t>>16)<<16|65535&t}function o(n,e,t,a,r,o){return i(function(n,e){return n<<e|n>>>32-e}(i(i(e,n),i(a,o)),r),t)}function s(n,e,t,a,r,i,s){return o(e&t|~e&a,n,e,r,i,s)}function l(n,e,t,a,r,i,s){return o(e&a|t&~a,n,e,r,i,s)}function c(n,e,t,a,r,i,s){return o(e^t^a,n,e,r,i,s)}function u(n,e,t,a,r,i,s){return o(t^(e|~a),n,e,r,i,s)}function d(n,e){n[e>>5]|=128<<e%32,n[14+(e+64>>>9<<4)]=e;var t,a,r,o,d,p=1732584193,h=-271733879,f=-1732584194,m=271733878;for(t=0;t<n.length;t+=16)a=p,r=h,o=f,d=m,p=s(p,h,f,m,n[t],7,-680876936),m=s(m,p,h,f,n[t+1],12,-389564586),f=s(f,m,p,h,n[t+2],17,606105819),h=s(h,f,m,p,n[t+3],22,-1044525330),p=s(p,h,f,m,n[t+4],7,-176418897),m=s(m,p,h,f,n[t+5],12,1200080426),f=s(f,m,p,h,n[t+6],17,-1473231341),h=s(h,f,m,p,n[t+7],22,-45705983),p=s(p,h,f,m,n[t+8],7,1770035416),m=s(m,p,h,f,n[t+9],12,-1958414417),f=s(f,m,p,h,n[t+10],17,-42063),h=s(h,f,m,p,n[t+11],22,-1990404162),p=s(p,h,f,m,n[t+12],7,1804603682),m=s(m,p,h,f,n[t+13],12,-40341101),f=s(f,m,p,h,n[t+14],17,-1502002290),p=l(p,h=s(h,f,m,p,n[t+15],22,1236535329),f,m,n[t+1],5,-165796510),m=l(m,p,h,f,n[t+6],9,-1069501632),f=l(f,m,p,h,n[t+11],14,643717713),h=l(h,f,m,p,n[t],20,-373897302),p=l(p,h,f,m,n[t+5],5,-701558691),m=l(m,p,h,f,n[t+10],9,38016083),f=l(f,m,p,h,n[t+15],14,-660478335),h=l(h,f,m,p,n[t+4],20,-405537848),p=l(p,h,f,m,n[t+9],5,568446438),m=l(m,p,h,f,n[t+14],9,-1019803690),f=l(f,m,p,h,n[t+3],14,-187363961),h=l(h,f,m,p,n[t+8],20,1163531501),p=l(p,h,f,m,n[t+13],5,-1444681467),m=l(m,p,h,f,n[t+2],9,-51403784),f=l(f,m,p,h,n[t+7],14,1735328473),p=c(p,h=l(h,f,m,p,n[t+12],20,-1926607734),f,m,n[t+5],4,-378558),m=c(m,p,h,f,n[t+8],11,-2022574463),f=c(f,m,p,h,n[t+11],16,1839030562),h=c(h,f,m,p,n[t+14],23,-35309556),p=c(p,h,f,m,n[t+1],4,-1530992060),m=c(m,p,h,f,n[t+4],11,1272893353),f=c(f,m,p,h,n[t+7],16,-155497632),h=c(h,f,m,p,n[t+10],23,-1094730640),p=c(p,h,f,m,n[t+13],4,681279174),m=c(m,p,h,f,n[t],11,-358537222),f=c(f,m,p,h,n[t+3],16,-722521979),h=c(h,f,m,p,n[t+6],23,76029189),p=c(p,h,f,m,n[t+9],4,-640364487),m=c(m,p,h,f,n[t+12],11,-421815835),f=c(f,m,p,h,n[t+15],16,530742520),p=u(p,h=c(h,f,m,p,n[t+2],23,-995338651),f,m,n[t],6,-198630844),m=u(m,p,h,f,n[t+7],10,1126891415),f=u(f,m,p,h,n[t+14],15,-1416354905),h=u(h,f,m,p,n[t+5],21,-57434055),p=u(p,h,f,m,n[t+12],6,1700485571),m=u(m,p,h,f,n[t+3],10,-1894986606),f=u(f,m,p,h,n[t+10],15,-1051523),h=u(h,f,m,p,n[t+1],21,-2054922799),p=u(p,h,f,m,n[t+8],6,1873313359),m=u(m,p,h,f,n[t+15],10,-30611744),f=u(f,m,p,h,n[t+6],15,-1560198380),h=u(h,f,m,p,n[t+13],21,1309151649),p=u(p,h,f,m,n[t+4],6,-145523070),m=u(m,p,h,f,n[t+11],10,-1120210379),f=u(f,m,p,h,n[t+2],15,718787259),h=u(h,f,m,p,n[t+9],21,-343485551),p=i(p,a),h=i(h,r),f=i(f,o),m=i(m,d);return[p,h,f,m]}function p(n){var e,t="",a=32*n.length;for(e=0;e<a;e+=8)t+=String.fromCharCode(n[e>>5]>>>e%32&255);return t}function h(n){var e,t=[];for(t[(n.length>>2)-1]=void 0,e=0;e<t.length;e+=1)t[e]=0;var a=8*n.length;for(e=0;e<a;e+=8)t[e>>5]|=(255&n.charCodeAt(e/8))<<e%32;return t}function f(n){var e,t,a="0123456789abcdef",r="";for(t=0;t<n.length;t+=1)e=n.charCodeAt(t),r+=a.charAt(e>>>4&15)+a.charAt(15&e);return r}function m(n){return unescape(encodeURIComponent(n))}function g(n){return function(n){return p(d(h(n),8*n.length))}(m(n))}function v(n,e){return function(n,e){var t,a,r=h(n),i=[],o=[];for(i[15]=o[15]=void 0,r.length>16&&(r=d(r,8*n.length)),t=0;t<16;t+=1)i[t]=909522486^r[t],o[t]=1549556828^r[t];return a=d(i.concat(h(e)),512+8*e.length),p(d(o.concat(a),640))}(m(n),m(e))}function y(n,e,t){return e?t?v(e,n):function(n,e){return f(v(n,e))}(e,n):t?g(n):function(n){return f(g(n))}(n)}void 0!==(a=function(){return y}.call(e,t,e,n))&&(n.exports=a)}()},function(n,e,t){"use strict";var a=t(2),r=t(4),i=t(1),o=t(5),s=t(14),l=t(15),c=l(),u=t(44),d=i("Array.prototype.slice"),p=r.apply(c),h=function(n,e){return o(n),p(n,d(arguments,1))};a(h,{getPolyfill:l,implementation:s,shim:u}),n.exports=h},function(n,e,t){"use strict";var a=t(2),r=t(15);n.exports=function(){var n=r();return a(Array.prototype,{forEach:n},{forEach:function(){return Array.prototype.forEach!==n}}),n}},function(n,e,t){"use strict";e.__esModule=!0;var a=function(n){return n&&n.__esModule?n:{default:n}}(t(47));e.default=function(n){return n=(0,a.default)({url:"",method:"get",body:{}},n),new Promise((function(e,t){if("jsonp"==n.method){var a="cb_"+(Date.now()+Math.round(1e3*Math.random())).toString(32),r=document,o=r.body,s=r.createElement("script");return s.async=!0,s.defer=!0,n.url.indexOf("?")>-1?n.url+="&"+i({callback:a,t:Date.now()}):n.url+="?"+i({callback:a,t:Date.now()}),s.src=n.url,window[a]=function(n){window[a]=null,o.removeChild(s),e(n)},void o.appendChild(s)}var l="XMLHttpRequest"in window?new XMLHttpRequest:new ActiveXObject("Microsoft.XMLHTTP"),c=[],u=[],d={};for(var p in i(n.body)&&(n.url=n.url+"?"+("get"==n.method?i(n.body):"")),l.open(n.method||"get",n.url),"blob"==n.dataType&&(l.responseType="blob"),l.onload=function(){l.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm,(function(n,e,t){c.push(e=e.toLowerCase()),u.push([e,t]),d[e]=d[e]?d[e]+","+t:t})),e(function n(){return{ok:2==(l.status/100|0),statusText:l.statusText,status:l.status,url:l.responseURL,text:function(){return Promise.resolve(l.responseText)},json:function(){return Promise.resolve(l.responseText).then(JSON.parse)},blob:function(){return Promise.resolve(new Blob([l.response]))},clone:n,headers:{keys:function(){return c},entries:function(){return u},get:function(n){return d[n.toLowerCase()]},has:function(n){return n.toLowerCase()in d}}}}())},l.onerror=t,l.withCredentials="include"==n.credentials,n.headers)l.setRequestHeader(p,n.headers[p]);l.send("post"==n.method?n.body:"get"==n.method?"":i(n.body))}))};var r=encodeURIComponent,i=function(n){var e=[];for(var t in n)n.hasOwnProperty(t)&&e.push(r(t)+"="+r(n[t]));return(e=e.join("&").replace(/%20/g,"+"))||""}},function(n,e,t){"use strict";e.__esModule=!0,e.default=function(n){var e={},t={Trident:(n=n||navigator.userAgent).indexOf("Trident")>-1||n.indexOf("NET CLR")>-1,Presto:n.indexOf("Presto")>-1,WebKit:n.indexOf("AppleWebKit")>-1,Gecko:n.indexOf("Gecko/")>-1,Safari:n.indexOf("Safari")>-1,Edge:n.indexOf("Edge")>-1||n.indexOf("Edg")>-1,Chrome:n.indexOf("Chrome")>-1||n.indexOf("CriOS")>-1,IE:n.indexOf("MSIE")>-1||n.indexOf("Trident")>-1,Firefox:n.indexOf("Firefox")>-1||n.indexOf("FxiOS")>-1,"Firefox Focus":n.indexOf("Focus")>-1,Chromium:n.indexOf("Chromium")>-1,Opera:n.indexOf("Opera")>-1||n.indexOf("OPR")>-1,Vivaldi:n.indexOf("Vivaldi")>-1,Yandex:n.indexOf("YaBrowser")>-1,Kindle:n.indexOf("Kindle")>-1||n.indexOf("Silk/")>-1,360:n.indexOf("360EE")>-1||n.indexOf("360SE")>-1,UC:n.indexOf("UC")>-1||n.indexOf(" UBrowser")>-1,QQBrowser:n.indexOf("QQBrowser")>-1,QQ:n.indexOf("QQ/")>-1,Baidu:n.indexOf("Baidu")>-1||n.indexOf("BIDUBrowser")>-1,Maxthon:n.indexOf("Maxthon")>-1,Sogou:n.indexOf("MetaSr")>-1||n.indexOf("Sogou")>-1,LBBROWSER:n.indexOf("LBBROWSER")>-1,"2345Explorer":n.indexOf("2345Explorer")>-1,TheWorld:n.indexOf("TheWorld")>-1,XiaoMi:n.indexOf("MiuiBrowser")>-1,Quark:n.indexOf("Quark")>-1,Qiyu:n.indexOf("Qiyu")>-1,Wechat:n.indexOf("MicroMessenger")>-1,Taobao:n.indexOf("AliApp(TB")>-1,Alipay:n.indexOf("AliApp(AP")>-1,Weibo:n.indexOf("Weibo")>-1,Douban:n.indexOf("com.douban.frodo")>-1,Suning:n.indexOf("SNEBUY-APP")>-1,iQiYi:n.indexOf("IqiyiApp")>-1,Windows:n.indexOf("Windows")>-1,Linux:n.indexOf("Linux")>-1||n.indexOf("X11")>-1,macOS:n.indexOf("Macintosh")>-1,Android:n.indexOf("Android")>-1||n.indexOf("Adr")>-1,Ubuntu:n.indexOf("Ubuntu")>-1,FreeBSD:n.indexOf("FreeBSD")>-1,Debian:n.indexOf("Debian")>-1,"Windows Phone":n.indexOf("IEMobile")>-1||n.indexOf("Windows Phone")>-1,BlackBerry:n.indexOf("BlackBerry")>-1||n.indexOf("RIM")>-1||n.indexOf("BB10")>-1,MeeGo:n.indexOf("MeeGo")>-1,Symbian:n.indexOf("Symbian")>-1,iOS:n.indexOf("like Mac OS X")>-1,"Chrome OS":n.indexOf("CrOS")>-1,WebOS:n.indexOf("hpwOS")>-1,Mobile:n.indexOf("Mobi")>-1||n.indexOf("iPh")>-1||n.indexOf("480")>-1,Tablet:n.indexOf("Tablet")>-1||n.indexOf("Pad")>-1||n.indexOf("Nexus 7")>-1};t.Mobile&&(t.Mobile=!(n.indexOf("iPad")>-1));var a={browser:["Safari","Chrome","Edge","IE","Firefox","Firefox Focus","Chromium","Opera","Vivaldi","Yandex","Kindle","360","UC","QQBrowser","QQ","Baidu","Maxthon","Sogou","LBBROWSER","2345Explorer","TheWorld","XiaoMi","Quark","Qiyu","Wechat","Taobao","Alipay","Weibo","Douban","Suning","iQiYi"],os:["Windows","Linux","Mac OS","macOS","Android","Ubuntu","FreeBSD","Debian","iOS","Windows Phone","BlackBerry","MeeGo","Symbian","Chrome OS","WebOS"]};for(var r in a)if(a.hasOwnProperty(r))for(var i=0,o=a[r].length;i<o;i++){var s=a[r][i];t[s]&&(e[r]=s)}var l={Windows:function(){return{"10.0":"11",6.4:"10",6.3:"8.1",6.2:"8",6.1:"7","6.0":"Vista",5.2:"XP",5.1:"XP","5.0":"2000"}[n.replace(/^.*Windows NT ([\d.]+).*$/,"$1")]},Android:n.replace(/^.*Android ([\d.]+);.*$/,"$1"),iOS:n.replace(/^.*OS ([\d_]+) like.*$/,"$1").replace(/_/g,"."),Debian:n.replace(/^.*Debian\/([\d.]+).*$/,"$1"),"Windows Phone":n.replace(/^.*Windows Phone( OS)? ([\d.]+);.*$/,"$2"),macOS:n.replace(/^.*Mac OS X ([\d_]+).*$/,"$1").replace(/_/g,"."),WebOS:n.replace(/^.*hpwOS\/([\d.]+);.*$/,"$1"),BlackBerry:n.replace(/^.*BB([\d.]+);*$/,"$1")};e.osVersion="";var c=l[e.os];c&&(e.osVersion="function"==typeof c?c():c==n?"":c);var u={Safari:n.replace(/^.*Version\/([\d.]+).*$/,"$1"),Chrome:n.replace(/^.*Chrome\/([\d.]+).*$/,"$1").replace(/^.*CriOS\/([\d.]+).*$/,"$1"),IE:n.replace(/^.*MSIE ([\d.]+).*$/,"$1").replace(/^.*rv:([\d.]+).*$/,"$1"),Edge:n.replace(/^.*Edge?\/([\d.]+).*$/,"$1"),Firefox:n.replace(/^.*Firefox\/([\d.]+).*$/,"$1").replace(/^.*FxiOS\/([\d.]+).*$/,"$1"),"Firefox Focus":n.replace(/^.*Focus\/([\d.]+).*$/,"$1"),Chromium:n.replace(/^.*Chromium\/([\d.]+).*$/,"$1"),Opera:n.replace(/^.*Opera\/([\d.]+).*$/,"$1").replace(/^.*OPR\/([\d.]+).*$/,"$1"),Vivaldi:n.replace(/^.*Vivaldi\/([\d.]+).*$/,"$1"),Yandex:n.replace(/^.*YaBrowser\/([\d.]+).*$/,"$1"),Kindle:n.replace(/^.*Version\/([\d.]+).*$/,"$1"),Maxthon:n.replace(/^.*Maxthon\/([\d.]+).*$/,"$1"),QQBrowser:n.replace(/^.*QQBrowser\/([\d.]+).*$/,"$1"),QQ:n.replace(/^.*QQ\/([\d.]+).*$/,"$1"),Baidu:n.replace(/^.*BIDUBrowser[\s\/]([\d.]+).*$/,"$1"),UC:n.replace(/^.*UC?Browser\/([\d.]+).*$/,"$1"),Sogou:n.replace(/^.*SE ([\d.X]+).*$/,"$1").replace(/^.*SogouMobileBrowser\/([\d.]+).*$/,"$1"),"2345Explorer":n.replace(/^.*2345Explorer\/([\d.]+).*$/,"$1"),TheWorld:n.replace(/^.*TheWorld ([\d.]+).*$/,"$1"),XiaoMi:n.replace(/^.*MiuiBrowser\/([\d.]+).*$/,"$1"),Quark:n.replace(/^.*Quark\/([\d.]+).*$/,"$1"),Qiyu:n.replace(/^.*Qiyu\/([\d.]+).*$/,"$1"),Wechat:n.replace(/^.*MicroMessenger\/([\d.]+).*$/,"$1"),Taobao:n.replace(/^.*AliApp\(TB\/([\d.]+).*$/,"$1"),Alipay:n.replace(/^.*AliApp\(AP\/([\d.]+).*$/,"$1"),Weibo:n.replace(/^.*weibo__([\d.]+).*$/,"$1"),Douban:n.replace(/^.*com.douban.frodo\/([\d.]+).*$/,"$1"),Suning:n.replace(/^.*SNEBUY-APP([\d.]+).*$/,"$1"),iQiYi:n.replace(/^.*IqiyiVersion\/([\d.]+).*$/,"$1")};e.version="";var d=u[e.browser];return d&&(e.version="function"==typeof d?d():d==n?"":d),null==e.browser&&(e.browser="Unknow App"),e}},function(n,e,t){"use strict";e.__esModule=!0,e.default=function(n){n=Object(n);for(var e=1,t=arguments.length;e<t;e++){var a=arguments[e];if(a)for(var r in a)Object.prototype.hasOwnProperty.call(a,r)&&(n[r]=a[r])}return n}},function(n,e,t){"use strict";function a(n){return/^\{[\s\S]*\}$/.test(JSON.stringify(n))}function r(n){return"[object Function]"==={}.toString.call(n)}function i(n){return"[object Array]"==={}.toString.call(n)}function o(n){if("string"==typeof n)try{return JSON.parse(n)}catch(e){return n}}function s(){if(!(this instanceof s))return new s}function l(n,e){var t=arguments,o=null;if(u||(u=s()),0===t.length)return u.get();if(1===t.length){if("string"==typeof n)return u.get(n);if(a(n))return u.set(n)}if(2===t.length&&"string"==typeof n){if(!e)return u.remove(n);if(e&&"string"==typeof e)return u.set(n,e);e&&r(e)&&(o=null,o=e(n,u.get(n)),l.set(n,o))}if(2===t.length&&i(n)&&r(e))for(var c=0,d=n.length;c<d;c++)o=e(n[c],u.get(n[c])),l.set(n[c],o);return l}e.__esModule=!0;var c=window.localStorage;c=function(n){var e="_Is_Incognit";try{n.setItem(e,"yes")}catch(e){if(["QuotaExceededError","NS_ERROR_DOM_QUOTA_REACHED"].indexOf(e.name)>-1){var t=function(){};n.__proto__={setItem:t,getItem:t,removeItem:t,clear:t}}}finally{"yes"===n.getItem(e)&&n.removeItem(e)}return n}(c),s.prototype={set:function(n,e){if(n&&!a(n))c.setItem(n,function(n){return void 0===n||"function"==typeof n?n+"":JSON.stringify(n)}(e));else if(a(n))for(var t in n)this.set(t,n[t]);return this},get:function(n){if(!n){var e={};return this.each((function(n,t){return e[n]=t})),e}if("?"===n.charAt(0))return this.has(n.substr(1));var t=arguments;if(t.length>1){for(var a={},r=0,i=t.length;r<i;r++){var s=o(c.getItem(t[r]));s&&(a[t[r]]=s)}return a}return o(c.getItem(n))},clear:function(){return c.clear(),this},remove:function(n){var e=this.get(n);return c.removeItem(n),e},has:function(n){return{}.hasOwnProperty.call(this.get(),n)},keys:function(){var n=[];return this.each((function(e){n.push(e)})),n},each:function(n){for(var e=0,t=c.length;e<t;e++){var a=c.key(e);n(a,this.get(a))}return this},search:function(n){for(var e=this.keys(),t={},a=0,r=e.length;a<r;a++)e[a].indexOf(n)>-1&&(t[e[a]]=this.get(e[a]));return t}};var u=null;for(var d in s.prototype)l[d]=s.prototype[d];e.default=l},function(n,e,t){var a,r;r=function(n,e,t){function a(e,r,i){return i=Object.create(a.fn),e&&i.push.apply(i,e.addEventListener?[e]:""+e===e?/</.test(e)?((r=n.createElement(r)).innerHTML=e,r.children):r?(r=a(r)[0])?r[t](e):i:n[t](e):e),i}return a.fn=[],a.one=function(n,e){return a(n,e)[0]||null},a}(document,0,"querySelectorAll"),void 0!==(a=function(){return r}.apply(e,[]))&&(n.exports=a)},function(n,e,t){function a(n){return null==n}function r(n){(n=function(n){var e={};for(var t in n)e[t]=n[t];return e}(n||{})).whiteList=n.whiteList||i.whiteList,n.onAttr=n.onAttr||i.onAttr,n.onIgnoreAttr=n.onIgnoreAttr||i.onIgnoreAttr,n.safeAttrValue=n.safeAttrValue||i.safeAttrValue,this.options=n}var i=t(16),o=t(51);t(17),r.prototype.process=function(n){if(!(n=(n=n||"").toString()))return"";var e=this.options,t=e.whiteList,r=e.onAttr,i=e.onIgnoreAttr,s=e.safeAttrValue;return o(n,(function(n,e,o,l,c){var u=t[o],d=!1;if(!0===u?d=u:"function"==typeof u?d=u(l):u instanceof RegExp&&(d=u.test(l)),!0!==d&&(d=!1),l=s(o,l)){var p,h={position:e,sourcePosition:n,source:c,isWhite:d};return d?a(p=r(o,l,h))?o+":"+l:p:a(p=i(o,l,h))?void 0:p}}))},n.exports=r},function(n,e,t){var a=t(17);n.exports=function(n,e){function t(){if(!i){var t=a.trim(n.slice(o,s)),r=t.indexOf(":");if(-1!==r){var c=a.trim(t.slice(0,r)),u=a.trim(t.slice(r+1));if(c){var d=e(o,l.length,c,u,t);d&&(l+=d+"; ")}}}o=s+1}";"!==(n=a.trimRight(n))[n.length-1]&&(n+=";");for(var r=n.length,i=!1,o=0,s=0,l="";s<r;s++){var c=n[s];if("/"===c&&"*"===n[s+1]){var u=n.indexOf("*/",s+2);if(-1===u)break;o=(s=u+1)+1,i=!1}else"("===c?i=!0:")"===c?i=!1:";"===c?i||t():"\n"===c&&t()}return a.trim(l)}},function(n,e,t){"use strict";var a=t(0),r=t(1),i=a("%TypeError%"),o=t(54),s=a("%Reflect.apply%",!0)||r("%Function.prototype.apply%");n.exports=function(n,e){var t=arguments.length>2?arguments[2]:[];if(!o(t))throw new i("Assertion failed: optional `argumentsList`, if provided, must be a List");return s(n,e,t)}},function(n,e,t){"use strict";var a=t(0)("%TypeError%"),r=t(19),i=t(8);n.exports=function(n,e){if("Object"!==i(n))throw new a("Assertion failed: `O` must be an Object");if(!r(e))throw new a("Assertion failed: `P` must be a Property Key");return e in n}},function(n,e,t){"use strict";var a=t(0)("%Array%"),r=!a.isArray&&t(1)("Object.prototype.toString");n.exports=a.isArray||function(n){return"[object Array]"===r(n)}},function(n,e,t){"use strict";n.exports=t(10)},function(n,e,t){"use strict";var a=t(0)("%TypeError%"),r=t(18),i=t(58),o=t(8);n.exports=function(n){if("Object"!==o(n))throw new a("Assertion failed: `obj` must be an Object");return i(r(n,"length"))}},function(n,e,t){"use strict";var a=t(63),r=t(59);n.exports=function(n){var e=r(n);return 0!==e&&(e=a(e)),0===e?0:e}},function(n,e,t){"use strict";var a=t(72),r=t(57);n.exports=function(n){var e=r(n);return e<=0?0:e>a?a:e}},function(n,e,t){"use strict";var a=t(0),r=a("%TypeError%"),i=a("%Number%"),o=a("%RegExp%"),s=a("%parseInt%"),l=t(1),c=t(73),u=t(71),d=l("String.prototype.slice"),p=c(/^0b[01]+$/i),h=c(/^0o[0-7]+$/i),f=c(/^[-+]0x[0-9a-f]+$/i),m=c(new o("["+["","​","￾"].join("")+"]","g")),g=["\t\n\v\f\r   ᠎    ","         　\u2028","\u2029\ufeff"].join(""),v=new RegExp("(^["+g+"]+)|(["+g+"]+$)","g"),y=l("String.prototype.replace"),b=t(61);n.exports=function n(e){var t=u(e)?e:b(e,i);if("symbol"==typeof t)throw new r("Cannot convert a Symbol value to a number");if("bigint"==typeof t)throw new r("Conversion from 'BigInt' to 'number' is not allowed.");if("string"==typeof t){if(p(t))return n(s(d(t,2),2));if(h(t))return n(s(d(t,2),8));if(m(t)||f(t))return NaN;var a=function(n){return y(n,v,"")}(t);if(a!==t)return n(a)}return i(t)}},function(n,e,t){"use strict";var a=t(0)("%Object%"),r=t(5);n.exports=function(n){return r(n),a(n)}},function(n,e,t){"use strict";var a=t(76);n.exports=function(n){return arguments.length>1?a(n,arguments[1]):a(n)}},function(n,e,t){"use strict";var a=t(0)("%TypeError%");n.exports=function(n,e){if(null==n)throw new a(e||"Cannot call method on "+n);return n}},function(n,e,t){"use strict";var a=t(67),r=t(68),i=t(64),o=t(70),s=t(69),l=t(74);n.exports=function(n){var e=i(n);return o(e)?0:0!==e&&s(e)?l(e)*r(a(e)):e}},function(n,e,t){"use strict";var a=t(65);n.exports=function(n){var e=a(n,Number);if("string"!=typeof e)return+e;var t=e.replace(/^[ \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u0085]+|[ \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u0085]+$/g,"");return/^0[ob]|^[+-]0x/.test(t)?NaN:+t}},function(n,e,t){"use strict";n.exports=t(77)},function(n,e,t){"use strict";n.exports=function(n){return null===n?"Null":void 0===n?"Undefined":"function"==typeof n||"object"==typeof n?"Object":"number"==typeof n?"Number":"boolean"==typeof n?"Boolean":"string"==typeof n?"String":void 0}},function(n,e,t){"use strict";var a=t(0)("%Math.abs%");n.exports=function(n){return a(n)}},function(n,e,t){"use strict";var a=Math.floor;n.exports=function(n){return a(n)}},function(n,e,t){"use strict";var a=Number.isNaN||function(n){return n!=n};n.exports=Number.isFinite||function(n){return"number"==typeof n&&!a(n)&&n!==1/0&&n!==-1/0}},function(n,e,t){"use strict";n.exports=Number.isNaN||function(n){return n!=n}},function(n,e,t){"use strict";n.exports=function(n){return null===n||"function"!=typeof n&&"object"!=typeof n}},function(n,e,t){"use strict";var a=t(0),r=a("%Math%"),i=a("%Number%");n.exports=i.MAX_SAFE_INTEGER||r.pow(2,53)-1},function(n,e,t){"use strict";var a=t(0)("RegExp.prototype.test"),r=t(4);n.exports=function(n){return r(a,n)}},function(n,e,t){"use strict";n.exports=function(n){return n>=0?1:-1}},function(n,e){n.exports=function(n){var e=!0,t=!0,a=!1;if("function"==typeof n){try{n.call("f",(function(n,t,a){"object"!=typeof a&&(e=!1)})),n.call([null],(function(){"use strict";t="string"==typeof this}),"x")}catch(n){a=!0}return!a&&e&&t}return!1}},function(n,e,t){"use strict";var a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator,r=t(21),i=t(10),o=t(80),s=t(82),l=function(n,e){if(null==n)throw new TypeError("Cannot call method on "+n);if("string"!=typeof e||"number"!==e&&"string"!==e)throw new TypeError('hint must be "string" or "number"');var t,a,o,s="string"===e?["toString","valueOf"]:["valueOf","toString"];for(o=0;o<s.length;++o)if(t=n[s[o]],i(t)&&(a=t.call(n),r(a)))return a;throw new TypeError("No default value")},c=function(n,e){var t=n[e];if(null!=t){if(!i(t))throw new TypeError(t+" returned for property "+e+" of object "+n+" is not a function");return t}};n.exports=function(n){if(r(n))return n;var e,t="default";if(arguments.length>1&&(arguments[1]===String?t="string":arguments[1]===Number&&(t="number")),a&&(Symbol.toPrimitive?e=c(n,Symbol.toPrimitive):s(n)&&(e=Symbol.prototype.valueOf)),void 0!==e){var i=e.call(n,t);if(r(i))return i;throw new TypeError("unable to convert exotic object to primitive")}return"default"===t&&(o(n)||s(n))&&(t="string"),l(n,"default"===t?"number":t)}},function(n,e,t){"use strict";var a=Object.prototype.toString,r=t(21),i=t(10),o=function(n){var e;if((e=arguments.length>1?arguments[1]:"[object Date]"===a.call(n)?String:Number)===String||e===Number){var t,o,s=e===String?["toString","valueOf"]:["valueOf","toString"];for(o=0;o<s.length;++o)if(i(n[s[o]])&&(t=n[s[o]](),r(t)))return t;throw new TypeError("No default value")}throw new TypeError("invalid [[DefaultValue]] hint supplied")};n.exports=function(n){return r(n)?n:arguments.length>1?o(n,arguments[1]):o(n)}},function(n,e,t){"use strict";var a=Array.prototype.slice,r=Object.prototype.toString;n.exports=function(n){var e=this;if("function"!=typeof e||"[object Function]"!==r.call(e))throw new TypeError("Function.prototype.bind called on incompatible "+e);for(var t,i=a.call(arguments,1),o=function(){if(this instanceof t){var r=e.apply(this,i.concat(a.call(arguments)));return Object(r)===r?r:this}return e.apply(n,i.concat(a.call(arguments)))},s=Math.max(0,e.length-i.length),l=[],c=0;c<s;c++)l.push("$"+c);if(t=Function("binder","return function ("+l.join(",")+"){ return binder.apply(this,arguments); }")(o),e.prototype){var u=function(){};u.prototype=e.prototype,t.prototype=new u,u.prototype=null}return t}},function(n,e,t){n.exports=function(){"use strict";var n=function(n,e){return function(n){var e=n.exports=function(){return new RegExp("(?:"+e.line().source+")|(?:"+e.block().source+")","gm")};e.line=function(){return/(?:^|\s)\/\/(.+?)$/gm},e.block=function(){return/\/\*([\S\s]*?)\*\//gm}}(e={exports:{}}),e.exports}(),e=["23AC69","91C132","F19726","E8552D","1AAB8E","E1147F","2980C1","1BA1E6","9FA0A0","F19726","E30B20","E30B20","A3338B"];return function(t,a){void 0===a&&(a={});var r=a.colors;void 0===r&&(r=e);var i=0,o={},s=new RegExp("("+/[\u4E00-\u9FFF\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\uac00-\ud7af\u0400-\u04FF]+|\w+/.source+"|"+/</.source+")|("+n().source+")","gmi");return t.replace(s,(function(n,e,t){if(t)return function(n){return'<span style="color: slategray">'+n+"</span>"}(t);if("<"===e)return"&lt;";var a;o[e]?a=o[e]:(a=r[i],o[e]=a);var s='<span style="color: #'+a+'">'+e+"</span>";return i=++i%r.length,s}))}}()},function(n,e,t){"use strict";var a=Date.prototype.getDay,r=Object.prototype.toString,i=t(24)();n.exports=function(n){return"object"==typeof n&&null!==n&&(i?function(n){try{return a.call(n),!0}catch(n){return!1}}(n):"[object Date]"===r.call(n))}},function(n,e,t){"use strict";var a=String.prototype.valueOf,r=Object.prototype.toString,i=t(24)();n.exports=function(n){return"string"==typeof n||"object"==typeof n&&(i?function(n){try{return a.call(n),!0}catch(n){return!1}}(n):"[object String]"===r.call(n))}},function(n,e,t){"use strict";var a=Object.prototype.toString;if(t(22)()){var r=Symbol.prototype.toString,i=/^Symbol\(.*\)$/;n.exports=function(n){if("symbol"==typeof n)return!0;if("[object Symbol]"!==a.call(n))return!1;try{return function(n){return"symbol"==typeof n.valueOf()&&i.test(r.call(n))}(n)}catch(n){return!1}}}else n.exports=function(n){return!1}},function(n,e,t){!function(n){"use strict";function e(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}function t(n,t,a){return t&&e(n.prototype,t),a&&e(n,a),Object.defineProperty(n,"prototype",{writable:!1}),n}function a(n,e){if(n){if("string"==typeof n)return r(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?r(n,e):void 0}}function r(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,a=new Array(e);t<e;t++)a[t]=n[t];return a}function i(n,e){var t="undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(t)return(t=t.call(n)).next.bind(t);if(Array.isArray(n)||(t=a(n))||e&&n&&"number"==typeof n.length){t&&(n=t);var r=0;return function(){return r>=n.length?{done:!0}:{done:!1,value:n[r++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function o(){return{baseUrl:null,breaks:!1,extensions:null,gfm:!0,headerIds:!0,headerPrefix:"",highlight:null,langPrefix:"language-",mangle:!0,pedantic:!1,renderer:null,sanitize:!1,sanitizer:null,silent:!1,smartLists:!1,smartypants:!1,tokenizer:null,walkTokens:null,xhtml:!1}}function s(e){n.defaults=e}function l(n,e){if(e){if(w.test(n))return n.replace(x,T)}else if(S.test(n))return n.replace(_,T);return n}function c(n){return n.replace(C,(function(n,e){return"colon"===(e=e.toLowerCase())?":":"#"===e.charAt(0)?"x"===e.charAt(1)?String.fromCharCode(parseInt(e.substring(2),16)):String.fromCharCode(+e.substring(1)):""}))}function u(n,e){n=n.source||n,e=e||"";var t={replace:function(e,a){return a=(a=a.source||a).replace(A,"$1"),n=n.replace(e,a),t},getRegex:function(){return new RegExp(n,e)}};return t}function d(n,e,t){if(n){var a;try{a=decodeURIComponent(c(t)).replace(I,"").toLowerCase()}catch(n){return null}if(0===a.indexOf("javascript:")||0===a.indexOf("vbscript:")||0===a.indexOf("data:"))return null}e&&!E.test(t)&&(t=function(n,e){O[" "+n]||(L.test(n)?O[" "+n]=n+"/":O[" "+n]=f(n,"/",!0));var t=-1===(n=O[" "+n]).indexOf(":");return"//"===e.substring(0,2)?t?e:n.replace($,"$1")+e:"/"===e.charAt(0)?t?e:n.replace(P,"$1")+e:n+e}(e,t));try{t=encodeURI(t).replace(/%25/g,"%")}catch(n){return null}return t}function p(n){for(var e,t,a=1;a<arguments.length;a++)for(t in e=arguments[a])Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n}function h(n,e){var t=n.replace(/\|/g,(function(n,e,t){for(var a=!1,r=e;--r>=0&&"\\"===t[r];)a=!a;return a?"|":" |"})).split(/ \|/),a=0;if(t[0].trim()||t.shift(),t.length>0&&!t[t.length-1].trim()&&t.pop(),t.length>e)t.splice(e);else for(;t.length<e;)t.push("");for(;a<t.length;a++)t[a]=t[a].trim().replace(/\\\|/g,"|");return t}function f(n,e,t){var a=n.length;if(0===a)return"";for(var r=0;r<a;){var i=n.charAt(a-r-1);if(i!==e||t){if(i===e||!t)break;r++}else r++}return n.substr(0,a-r)}function m(n){n&&n.sanitize&&n.silent}function g(n,e){if(e<1)return"";for(var t="";e>1;)1&e&&(t+=n),e>>=1,n+=n;return t+n}function v(n,e,t,a){var r=e.href,i=e.title?l(e.title):null,o=n[1].replace(/\\([\[\]])/g,"$1");if("!"!==n[0].charAt(0)){a.state.inLink=!0;var s={type:"link",raw:t,href:r,title:i,text:o,tokens:a.inlineTokens(o,[])};return a.state.inLink=!1,s}return{type:"image",raw:t,href:r,title:i,text:l(o)}}function y(n){return n.replace(/---/g,"—").replace(/--/g,"–").replace(/(^|[-\u2014/(\[{"\s])'/g,"$1‘").replace(/'/g,"’").replace(/(^|[-\u2014/(\[{\u2018\s])"/g,"$1“").replace(/"/g,"”").replace(/\.{3}/g,"…")}function b(n){var e,t,a="",r=n.length;for(e=0;e<r;e++)t=n.charCodeAt(e),Math.random()>.5&&(t="x"+t.toString(16)),a+="&#"+t+";";return a}function k(n,e,t){if(null==n)throw new Error("marked(): input parameter is undefined or null");if("string"!=typeof n)throw new Error("marked(): input parameter is of type "+Object.prototype.toString.call(n)+", string expected");if("function"==typeof e&&(t=e,e=null),m(e=p({},k.defaults,e||{})),t){var a,r=e.highlight;try{a=R.lex(n,e)}catch(n){return t(n)}var i=function(n){var i;if(!n)try{e.walkTokens&&k.walkTokens(a,e.walkTokens),i=U.parse(a,e)}catch(e){n=e}return e.highlight=r,n?t(n):t(null,i)};if(!r||r.length<3)return i();if(delete e.highlight,!a.length)return i();var o=0;return k.walkTokens(a,(function(n){"code"===n.type&&(o++,setTimeout((function(){r(n.text,n.lang,(function(e,t){if(e)return i(e);null!=t&&t!==n.text&&(n.text=t,n.escaped=!0),0==--o&&i()}))}),0))})),void(0===o&&i())}try{var s=R.lex(n,e);return e.walkTokens&&k.walkTokens(s,e.walkTokens),U.parse(s,e)}catch(n){if(n.message+="\nPlease report this to https://github.com/markedjs/marked.",e.silent)return"<p>An error occurred:</p><pre>"+l(n.message+"",!0)+"</pre>";throw n}}n.defaults={baseUrl:null,breaks:!1,extensions:null,gfm:!0,headerIds:!0,headerPrefix:"",highlight:null,langPrefix:"language-",mangle:!0,pedantic:!1,renderer:null,sanitize:!1,sanitizer:null,silent:!1,smartLists:!1,smartypants:!1,tokenizer:null,walkTokens:null,xhtml:!1};var w=/[&<>"']/,x=/[&<>"']/g,S=/[<>"']|&(?!#?\w+;)/,_=/[<>"']|&(?!#?\w+;)/g,j={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},T=function(n){return j[n]},C=/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi,A=/(^|[^\[])\^/g,I=/[^\w:]/g,E=/^$|^[a-z][a-z0-9+.-]*:|^[?#]/i,O={},L=/^[^:]+:\/*[^/]*$/,$=/^([^:]+:)[\s\S]*$/,P=/^([^:]+:\/*[^/]*)[\s\S]*$/,z={exec:function(){}},D=function(){function e(e){this.options=e||n.defaults}var t=e.prototype;return t.space=function(n){var e=this.rules.block.newline.exec(n);if(e&&e[0].length>0)return{type:"space",raw:e[0]}},t.code=function(n){var e=this.rules.block.code.exec(n);if(e){var t=e[0].replace(/^ {1,4}/gm,"");return{type:"code",raw:e[0],codeBlockStyle:"indented",text:this.options.pedantic?t:f(t,"\n")}}},t.fences=function(n){var e=this.rules.block.fences.exec(n);if(e){var t=e[0],a=function(n,e){var t=n.match(/^(\s+)(?:```)/);if(null===t)return e;var a=t[1];return e.split("\n").map((function(n){var e=n.match(/^\s+/);return null===e?n:e[0].length>=a.length?n.slice(a.length):n})).join("\n")}(t,e[3]||"");return{type:"code",raw:t,lang:e[2]?e[2].trim():e[2],text:a}}},t.heading=function(n){var e=this.rules.block.heading.exec(n);if(e){var t=e[2].trim();if(/#$/.test(t)){var a=f(t,"#");this.options.pedantic?t=a.trim():a&&!/ $/.test(a)||(t=a.trim())}var r={type:"heading",raw:e[0],depth:e[1].length,text:t,tokens:[]};return this.lexer.inline(r.text,r.tokens),r}},t.hr=function(n){var e=this.rules.block.hr.exec(n);if(e)return{type:"hr",raw:e[0]}},t.blockquote=function(n){var e=this.rules.block.blockquote.exec(n);if(e){var t=e[0].replace(/^ *> ?/gm,"");return{type:"blockquote",raw:e[0],tokens:this.lexer.blockTokens(t,[]),text:t}}},t.list=function(n){var e=this.rules.block.list.exec(n);if(e){var t,a,r,o,s,l,c,u,d,p,h,f,m=e[1].trim(),g=m.length>1,v={type:"list",raw:"",ordered:g,start:g?+m.slice(0,-1):"",loose:!1,items:[]};m=g?"\\d{1,9}\\"+m.slice(-1):"\\"+m,this.options.pedantic&&(m=g?m:"[*+-]");for(var y=new RegExp("^( {0,3}"+m+")((?: [^\\n]*)?(?:\\n|$))");n&&(f=!1,e=y.exec(n))&&!this.rules.block.hr.test(n);){if(t=e[0],n=n.substring(t.length),u=e[2].split("\n",1)[0],d=n.split("\n",1)[0],this.options.pedantic?(o=2,h=u.trimLeft()):(o=(o=e[2].search(/[^ ]/))>4?1:o,h=u.slice(o),o+=e[1].length),l=!1,!u&&/^ *$/.test(d)&&(t+=d+"\n",n=n.substring(d.length+1),f=!0),!f)for(var b=new RegExp("^ {0,"+Math.min(3,o-1)+"}(?:[*+-]|\\d{1,9}[.)])");n&&(u=p=n.split("\n",1)[0],this.options.pedantic&&(u=u.replace(/^ {1,4}(?=( {4})*[^ ])/g,"  ")),!b.test(u));){if(u.search(/[^ ]/)>=o||!u.trim())h+="\n"+u.slice(o);else{if(l)break;h+="\n"+u}l||u.trim()||(l=!0),t+=p+"\n",n=n.substring(p.length+1)}v.loose||(c?v.loose=!0:/\n *\n *$/.test(t)&&(c=!0)),this.options.gfm&&(a=/^\[[ xX]\] /.exec(h))&&(r="[ ] "!==a[0],h=h.replace(/^\[[ xX]\] +/,"")),v.items.push({type:"list_item",raw:t,task:!!a,checked:r,loose:!1,text:h}),v.raw+=t}v.items[v.items.length-1].raw=t.trimRight(),v.items[v.items.length-1].text=h.trimRight(),v.raw=v.raw.trimRight();var k=v.items.length;for(s=0;s<k;s++){this.lexer.state.top=!1,v.items[s].tokens=this.lexer.blockTokens(v.items[s].text,[]);var w=v.items[s].tokens.filter((function(n){return"space"===n.type})),x=w.every((function(n){for(var e,t=0,a=i(n.raw.split(""));!(e=a()).done;)if("\n"===e.value&&(t+=1),t>1)return!0;return!1}));!v.loose&&w.length&&x&&(v.loose=!0,v.items[s].loose=!0)}return v}},t.html=function(n){var e=this.rules.block.html.exec(n);if(e){var t={type:"html",raw:e[0],pre:!this.options.sanitizer&&("pre"===e[1]||"script"===e[1]||"style"===e[1]),text:e[0]};return this.options.sanitize&&(t.type="paragraph",t.text=this.options.sanitizer?this.options.sanitizer(e[0]):l(e[0]),t.tokens=[],this.lexer.inline(t.text,t.tokens)),t}},t.def=function(n){var e=this.rules.block.def.exec(n);if(e)return e[3]&&(e[3]=e[3].substring(1,e[3].length-1)),{type:"def",tag:e[1].toLowerCase().replace(/\s+/g," "),raw:e[0],href:e[2],title:e[3]}},t.table=function(n){var e=this.rules.block.table.exec(n);if(e){var t={type:"table",header:h(e[1]).map((function(n){return{text:n}})),align:e[2].replace(/^ *|\| *$/g,"").split(/ *\| */),rows:e[3]&&e[3].trim()?e[3].replace(/\n[ \t]*$/,"").split("\n"):[]};if(t.header.length===t.align.length){t.raw=e[0];var a,r,i,o,s=t.align.length;for(a=0;a<s;a++)/^ *-+: *$/.test(t.align[a])?t.align[a]="right":/^ *:-+: *$/.test(t.align[a])?t.align[a]="center":/^ *:-+ *$/.test(t.align[a])?t.align[a]="left":t.align[a]=null;for(s=t.rows.length,a=0;a<s;a++)t.rows[a]=h(t.rows[a],t.header.length).map((function(n){return{text:n}}));for(s=t.header.length,r=0;r<s;r++)t.header[r].tokens=[],this.lexer.inlineTokens(t.header[r].text,t.header[r].tokens);for(s=t.rows.length,r=0;r<s;r++)for(o=t.rows[r],i=0;i<o.length;i++)o[i].tokens=[],this.lexer.inlineTokens(o[i].text,o[i].tokens);return t}}},t.lheading=function(n){var e=this.rules.block.lheading.exec(n);if(e){var t={type:"heading",raw:e[0],depth:"="===e[2].charAt(0)?1:2,text:e[1],tokens:[]};return this.lexer.inline(t.text,t.tokens),t}},t.paragraph=function(n){var e=this.rules.block.paragraph.exec(n);if(e){var t={type:"paragraph",raw:e[0],text:"\n"===e[1].charAt(e[1].length-1)?e[1].slice(0,-1):e[1],tokens:[]};return this.lexer.inline(t.text,t.tokens),t}},t.text=function(n){var e=this.rules.block.text.exec(n);if(e){var t={type:"text",raw:e[0],text:e[0],tokens:[]};return this.lexer.inline(t.text,t.tokens),t}},t.escape=function(n){var e=this.rules.inline.escape.exec(n);if(e)return{type:"escape",raw:e[0],text:l(e[1])}},t.tag=function(n){var e=this.rules.inline.tag.exec(n);if(e)return!this.lexer.state.inLink&&/^<a /i.test(e[0])?this.lexer.state.inLink=!0:this.lexer.state.inLink&&/^<\/a>/i.test(e[0])&&(this.lexer.state.inLink=!1),!this.lexer.state.inRawBlock&&/^<(pre|code|kbd|script)(\s|>)/i.test(e[0])?this.lexer.state.inRawBlock=!0:this.lexer.state.inRawBlock&&/^<\/(pre|code|kbd|script)(\s|>)/i.test(e[0])&&(this.lexer.state.inRawBlock=!1),{type:this.options.sanitize?"text":"html",raw:e[0],inLink:this.lexer.state.inLink,inRawBlock:this.lexer.state.inRawBlock,text:this.options.sanitize?this.options.sanitizer?this.options.sanitizer(e[0]):l(e[0]):e[0]}},t.link=function(n){var e=this.rules.inline.link.exec(n);if(e){var t=e[2].trim();if(!this.options.pedantic&&/^</.test(t)){if(!/>$/.test(t))return;var a=f(t.slice(0,-1),"\\");if((t.length-a.length)%2==0)return}else{var r=function(n,e){if(-1===n.indexOf(e[1]))return-1;for(var t=n.length,a=0,r=0;r<t;r++)if("\\"===n[r])r++;else if(n[r]===e[0])a++;else if(n[r]===e[1]&&--a<0)return r;return-1}(e[2],"()");if(r>-1){var i=(0===e[0].indexOf("!")?5:4)+e[1].length+r;e[2]=e[2].substring(0,r),e[0]=e[0].substring(0,i).trim(),e[3]=""}}var o=e[2],s="";if(this.options.pedantic){var l=/^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(o);l&&(o=l[1],s=l[3])}else s=e[3]?e[3].slice(1,-1):"";return o=o.trim(),/^</.test(o)&&(o=this.options.pedantic&&!/>$/.test(t)?o.slice(1):o.slice(1,-1)),v(e,{href:o?o.replace(this.rules.inline._escapes,"$1"):o,title:s?s.replace(this.rules.inline._escapes,"$1"):s},e[0],this.lexer)}},t.reflink=function(n,e){var t;if((t=this.rules.inline.reflink.exec(n))||(t=this.rules.inline.nolink.exec(n))){var a=(t[2]||t[1]).replace(/\s+/g," ");if(!(a=e[a.toLowerCase()])||!a.href){var r=t[0].charAt(0);return{type:"text",raw:r,text:r}}return v(t,a,t[0],this.lexer)}},t.emStrong=function(n,e,t){void 0===t&&(t="");var a=this.rules.inline.emStrong.lDelim.exec(n);if(a&&(!a[3]||!t.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDF70-\uDF81\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/))){var r=a[1]||a[2]||"";if(!r||r&&(""===t||this.rules.inline.punctuation.exec(t))){var i,o,s=a[0].length-1,l=s,c=0,u="*"===a[0][0]?this.rules.inline.emStrong.rDelimAst:this.rules.inline.emStrong.rDelimUnd;for(u.lastIndex=0,e=e.slice(-1*n.length+s);null!=(a=u.exec(e));)if(i=a[1]||a[2]||a[3]||a[4]||a[5]||a[6])if(o=i.length,a[3]||a[4])l+=o;else if(!((a[5]||a[6])&&s%3)||(s+o)%3){if(!((l-=o)>0)){if(o=Math.min(o,o+l+c),Math.min(s,o)%2){var d=n.slice(1,s+a.index+o);return{type:"em",raw:n.slice(0,s+a.index+o+1),text:d,tokens:this.lexer.inlineTokens(d,[])}}var p=n.slice(2,s+a.index+o-1);return{type:"strong",raw:n.slice(0,s+a.index+o+1),text:p,tokens:this.lexer.inlineTokens(p,[])}}}else c+=o}}},t.codespan=function(n){var e=this.rules.inline.code.exec(n);if(e){var t=e[2].replace(/\n/g," "),a=/[^ ]/.test(t),r=/^ /.test(t)&&/ $/.test(t);return a&&r&&(t=t.substring(1,t.length-1)),t=l(t,!0),{type:"codespan",raw:e[0],text:t}}},t.br=function(n){var e=this.rules.inline.br.exec(n);if(e)return{type:"br",raw:e[0]}},t.del=function(n){var e=this.rules.inline.del.exec(n);if(e)return{type:"del",raw:e[0],text:e[2],tokens:this.lexer.inlineTokens(e[2],[])}},t.autolink=function(n,e){var t,a,r=this.rules.inline.autolink.exec(n);if(r)return a="@"===r[2]?"mailto:"+(t=l(this.options.mangle?e(r[1]):r[1])):t=l(r[1]),{type:"link",raw:r[0],text:t,href:a,tokens:[{type:"text",raw:t,text:t}]}},t.url=function(n,e){var t;if(t=this.rules.inline.url.exec(n)){var a,r;if("@"===t[2])r="mailto:"+(a=l(this.options.mangle?e(t[0]):t[0]));else{var i;do{i=t[0],t[0]=this.rules.inline._backpedal.exec(t[0])[0]}while(i!==t[0]);a=l(t[0]),r="www."===t[1]?"http://"+a:a}return{type:"link",raw:t[0],text:a,href:r,tokens:[{type:"text",raw:a,text:a}]}}},t.inlineText=function(n,e){var t,a=this.rules.inline.text.exec(n);if(a)return t=this.lexer.state.inRawBlock?this.options.sanitize?this.options.sanitizer?this.options.sanitizer(a[0]):l(a[0]):a[0]:l(this.options.smartypants?e(a[0]):a[0]),{type:"text",raw:a[0],text:t}},e}(),M={newline:/^(?: *(?:\n|$))+/,code:/^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,fences:/^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,hr:/^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,heading:/^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,blockquote:/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,list:/^( {0,3}bull)( [^\n]+?)?(?:\n|$)/,html:"^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",def:/^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,table:z,lheading:/^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,_paragraph:/^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,text:/^[^\n]+/,_label:/(?!\s*\])(?:\\.|[^\[\]\\])+/,_title:/(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/};M.def=u(M.def).replace("label",M._label).replace("title",M._title).getRegex(),M.bullet=/(?:[*+-]|\d{1,9}[.)])/,M.listItemStart=u(/^( *)(bull) */).replace("bull",M.bullet).getRegex(),M.list=u(M.list).replace(/bull/g,M.bullet).replace("hr","\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def","\\n+(?="+M.def.source+")").getRegex(),M._tag="address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul",M._comment=/<!--(?!-?>)[\s\S]*?(?:-->|$)/,M.html=u(M.html,"i").replace("comment",M._comment).replace("tag",M._tag).replace("attribute",/ +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(),M.paragraph=u(M._paragraph).replace("hr",M.hr).replace("heading"," {0,3}#{1,6} ").replace("|lheading","").replace("|table","").replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",M._tag).getRegex(),M.blockquote=u(M.blockquote).replace("paragraph",M.paragraph).getRegex(),M.normal=p({},M),M.gfm=p({},M.normal,{table:"^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"}),M.gfm.table=u(M.gfm.table).replace("hr",M.hr).replace("heading"," {0,3}#{1,6} ").replace("blockquote"," {0,3}>").replace("code"," {4}[^\\n]").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",M._tag).getRegex(),M.gfm.paragraph=u(M._paragraph).replace("hr",M.hr).replace("heading"," {0,3}#{1,6} ").replace("|lheading","").replace("table",M.gfm.table).replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",M._tag).getRegex(),M.pedantic=p({},M.normal,{html:u("^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:\"[^\"]*\"|'[^']*'|\\s[^'\"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))").replace("comment",M._comment).replace(/tag/g,"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,heading:/^(#{1,6})(.*)(?:\n+|$)/,fences:z,paragraph:u(M.normal._paragraph).replace("hr",M.hr).replace("heading"," *#{1,6} *[^\n]").replace("lheading",M.lheading).replace("blockquote"," {0,3}>").replace("|fences","").replace("|list","").replace("|html","").getRegex()});var F={escape:/^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,autolink:/^<(scheme:[^\s\x00-\x1f<>]*|email)>/,url:z,tag:"^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",link:/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,reflink:/^!?\[(label)\]\[(ref)\]/,nolink:/^!?\[(ref)\](?:\[\])?/,reflinkSearch:"reflink|nolink(?!\\()",emStrong:{lDelim:/^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,rDelimAst:/^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,rDelimUnd:/^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/},code:/^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,br:/^( {2,}|\\)\n(?!\s*$)/,del:z,text:/^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,punctuation:/^([\spunctuation])/,_punctuation:"!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~"};F.punctuation=u(F.punctuation).replace(/punctuation/g,F._punctuation).getRegex(),F.blockSkip=/\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g,F.escapedEmSt=/\\\*|\\_/g,F._comment=u(M._comment).replace("(?:--\x3e|$)","--\x3e").getRegex(),F.emStrong.lDelim=u(F.emStrong.lDelim).replace(/punct/g,F._punctuation).getRegex(),F.emStrong.rDelimAst=u(F.emStrong.rDelimAst,"g").replace(/punct/g,F._punctuation).getRegex(),F.emStrong.rDelimUnd=u(F.emStrong.rDelimUnd,"g").replace(/punct/g,F._punctuation).getRegex(),F._escapes=/\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g,F._scheme=/[a-zA-Z][a-zA-Z0-9+.-]{1,31}/,F._email=/[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/,F.autolink=u(F.autolink).replace("scheme",F._scheme).replace("email",F._email).getRegex(),F._attribute=/\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/,F.tag=u(F.tag).replace("comment",F._comment).replace("attribute",F._attribute).getRegex(),F._label=/(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/,F._href=/<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/,F._title=/"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/,F.link=u(F.link).replace("label",F._label).replace("href",F._href).replace("title",F._title).getRegex(),F.reflink=u(F.reflink).replace("label",F._label).replace("ref",M._label).getRegex(),F.nolink=u(F.nolink).replace("ref",M._label).getRegex(),F.reflinkSearch=u(F.reflinkSearch,"g").replace("reflink",F.reflink).replace("nolink",F.nolink).getRegex(),F.normal=p({},F),F.pedantic=p({},F.normal,{strong:{start:/^__|\*\*/,middle:/^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,endAst:/\*\*(?!\*)/g,endUnd:/__(?!_)/g},em:{start:/^_|\*/,middle:/^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,endAst:/\*(?!\*)/g,endUnd:/_(?!_)/g},link:u(/^!?\[(label)\]\((.*?)\)/).replace("label",F._label).getRegex(),reflink:u(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label",F._label).getRegex()}),F.gfm=p({},F.normal,{escape:u(F.escape).replace("])","~|])").getRegex(),_extended_email:/[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,url:/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,_backpedal:/(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,del:/^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,text:/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/}),F.gfm.url=u(F.gfm.url,"i").replace("email",F.gfm._extended_email).getRegex(),F.breaks=p({},F.gfm,{br:u(F.br).replace("{2,}","*").getRegex(),text:u(F.gfm.text).replace("\\b_","\\b_| {2,}\\n").replace(/\{2,\}/g,"*").getRegex()});var R=function(){function e(e){this.tokens=[],this.tokens.links=Object.create(null),this.options=e||n.defaults,this.options.tokenizer=this.options.tokenizer||new D,this.tokenizer=this.options.tokenizer,this.tokenizer.options=this.options,this.tokenizer.lexer=this,this.inlineQueue=[],this.state={inLink:!1,inRawBlock:!1,top:!0};var t={block:M.normal,inline:F.normal};this.options.pedantic?(t.block=M.pedantic,t.inline=F.pedantic):this.options.gfm&&(t.block=M.gfm,this.options.breaks?t.inline=F.breaks:t.inline=F.gfm),this.tokenizer.rules=t}e.lex=function(n,t){return new e(t).lex(n)},e.lexInline=function(n,t){return new e(t).inlineTokens(n)};var a=e.prototype;return a.lex=function(n){n=n.replace(/\r\n|\r/g,"\n").replace(/\t/g,"    "),this.blockTokens(n,this.tokens);for(var e;e=this.inlineQueue.shift();)this.inlineTokens(e.src,e.tokens);return this.tokens},a.blockTokens=function(n,e){var t,a,r,i,o=this;for(void 0===e&&(e=[]),this.options.pedantic&&(n=n.replace(/^ +$/gm,""));n;)if(!(this.options.extensions&&this.options.extensions.block&&this.options.extensions.block.some((function(a){return!!(t=a.call({lexer:o},n,e))&&(n=n.substring(t.raw.length),e.push(t),!0)}))))if(t=this.tokenizer.space(n))n=n.substring(t.raw.length),1===t.raw.length&&e.length>0?e[e.length-1].raw+="\n":e.push(t);else if(t=this.tokenizer.code(n))n=n.substring(t.raw.length),!(a=e[e.length-1])||"paragraph"!==a.type&&"text"!==a.type?e.push(t):(a.raw+="\n"+t.raw,a.text+="\n"+t.text,this.inlineQueue[this.inlineQueue.length-1].src=a.text);else if(t=this.tokenizer.fences(n))n=n.substring(t.raw.length),e.push(t);else if(t=this.tokenizer.heading(n))n=n.substring(t.raw.length),e.push(t);else if(t=this.tokenizer.hr(n))n=n.substring(t.raw.length),e.push(t);else if(t=this.tokenizer.blockquote(n))n=n.substring(t.raw.length),e.push(t);else if(t=this.tokenizer.list(n))n=n.substring(t.raw.length),e.push(t);else if(t=this.tokenizer.html(n))n=n.substring(t.raw.length),e.push(t);else if(t=this.tokenizer.def(n))n=n.substring(t.raw.length),!(a=e[e.length-1])||"paragraph"!==a.type&&"text"!==a.type?this.tokens.links[t.tag]||(this.tokens.links[t.tag]={href:t.href,title:t.title}):(a.raw+="\n"+t.raw,a.text+="\n"+t.raw,this.inlineQueue[this.inlineQueue.length-1].src=a.text);else if(t=this.tokenizer.table(n))n=n.substring(t.raw.length),e.push(t);else if(t=this.tokenizer.lheading(n))n=n.substring(t.raw.length),e.push(t);else if(r=n,this.options.extensions&&this.options.extensions.startBlock&&function(){var e=1/0,t=n.slice(1),a=void 0;o.options.extensions.startBlock.forEach((function(n){"number"==typeof(a=n.call({lexer:this},t))&&a>=0&&(e=Math.min(e,a))})),e<1/0&&e>=0&&(r=n.substring(0,e+1))}(),this.state.top&&(t=this.tokenizer.paragraph(r)))a=e[e.length-1],i&&"paragraph"===a.type?(a.raw+="\n"+t.raw,a.text+="\n"+t.text,this.inlineQueue.pop(),this.inlineQueue[this.inlineQueue.length-1].src=a.text):e.push(t),i=r.length!==n.length,n=n.substring(t.raw.length);else if(t=this.tokenizer.text(n))n=n.substring(t.raw.length),(a=e[e.length-1])&&"text"===a.type?(a.raw+="\n"+t.raw,a.text+="\n"+t.text,this.inlineQueue.pop(),this.inlineQueue[this.inlineQueue.length-1].src=a.text):e.push(t);else if(n){var s="Infinite loop on byte: "+n.charCodeAt(0);if(this.options.silent)break;throw new Error(s)}return this.state.top=!0,e},a.inline=function(n,e){this.inlineQueue.push({src:n,tokens:e})},a.inlineTokens=function(n,e){var t=this;void 0===e&&(e=[]);var a,r,i,o,s,l,c=n;if(this.tokens.links){var u=Object.keys(this.tokens.links);if(u.length>0)for(;null!=(o=this.tokenizer.rules.inline.reflinkSearch.exec(c));)u.includes(o[0].slice(o[0].lastIndexOf("[")+1,-1))&&(c=c.slice(0,o.index)+"["+g("a",o[0].length-2)+"]"+c.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex))}for(;null!=(o=this.tokenizer.rules.inline.blockSkip.exec(c));)c=c.slice(0,o.index)+"["+g("a",o[0].length-2)+"]"+c.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);for(;null!=(o=this.tokenizer.rules.inline.escapedEmSt.exec(c));)c=c.slice(0,o.index)+"++"+c.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);for(;n;)if(s||(l=""),s=!1,!(this.options.extensions&&this.options.extensions.inline&&this.options.extensions.inline.some((function(r){return!!(a=r.call({lexer:t},n,e))&&(n=n.substring(a.raw.length),e.push(a),!0)}))))if(a=this.tokenizer.escape(n))n=n.substring(a.raw.length),e.push(a);else if(a=this.tokenizer.tag(n))n=n.substring(a.raw.length),(r=e[e.length-1])&&"text"===a.type&&"text"===r.type?(r.raw+=a.raw,r.text+=a.text):e.push(a);else if(a=this.tokenizer.link(n))n=n.substring(a.raw.length),e.push(a);else if(a=this.tokenizer.reflink(n,this.tokens.links))n=n.substring(a.raw.length),(r=e[e.length-1])&&"text"===a.type&&"text"===r.type?(r.raw+=a.raw,r.text+=a.text):e.push(a);else if(a=this.tokenizer.emStrong(n,c,l))n=n.substring(a.raw.length),e.push(a);else if(a=this.tokenizer.codespan(n))n=n.substring(a.raw.length),e.push(a);else if(a=this.tokenizer.br(n))n=n.substring(a.raw.length),e.push(a);else if(a=this.tokenizer.del(n))n=n.substring(a.raw.length),e.push(a);else if(a=this.tokenizer.autolink(n,b))n=n.substring(a.raw.length),e.push(a);else if(this.state.inLink||!(a=this.tokenizer.url(n,b))){if(i=n,this.options.extensions&&this.options.extensions.startInline&&function(){var e=1/0,a=n.slice(1),r=void 0;t.options.extensions.startInline.forEach((function(n){"number"==typeof(r=n.call({lexer:this},a))&&r>=0&&(e=Math.min(e,r))})),e<1/0&&e>=0&&(i=n.substring(0,e+1))}(),a=this.tokenizer.inlineText(i,y))n=n.substring(a.raw.length),"_"!==a.raw.slice(-1)&&(l=a.raw.slice(-1)),s=!0,(r=e[e.length-1])&&"text"===r.type?(r.raw+=a.raw,r.text+=a.text):e.push(a);else if(n){var d="Infinite loop on byte: "+n.charCodeAt(0);if(this.options.silent)break;throw new Error(d)}}else n=n.substring(a.raw.length),e.push(a);return e},t(e,null,[{key:"rules",get:function(){return{block:M,inline:F}}}]),e}(),q=function(){function e(e){this.options=e||n.defaults}var t=e.prototype;return t.code=function(n,e,t){var a=(e||"").match(/\S*/)[0];if(this.options.highlight){var r=this.options.highlight(n,a);null!=r&&r!==n&&(t=!0,n=r)}return n=n.replace(/\n$/,"")+"\n",a?'<pre><code class="'+this.options.langPrefix+l(a,!0)+'">'+(t?n:l(n,!0))+"</code></pre>\n":"<pre><code>"+(t?n:l(n,!0))+"</code></pre>\n"},t.blockquote=function(n){return"<blockquote>\n"+n+"</blockquote>\n"},t.html=function(n){return n},t.heading=function(n,e,t,a){return this.options.headerIds?"<h"+e+' id="'+this.options.headerPrefix+a.slug(t)+'">'+n+"</h"+e+">\n":"<h"+e+">"+n+"</h"+e+">\n"},t.hr=function(){return this.options.xhtml?"<hr/>\n":"<hr>\n"},t.list=function(n,e,t){var a=e?"ol":"ul";return"<"+a+(e&&1!==t?' start="'+t+'"':"")+">\n"+n+"</"+a+">\n"},t.listitem=function(n){return"<li>"+n+"</li>\n"},t.checkbox=function(n){return"<input "+(n?'checked="" ':"")+'disabled="" type="checkbox"'+(this.options.xhtml?" /":"")+"> "},t.paragraph=function(n){return"<p>"+n+"</p>\n"},t.table=function(n,e){return e&&(e="<tbody>"+e+"</tbody>"),"<table>\n<thead>\n"+n+"</thead>\n"+e+"</table>\n"},t.tablerow=function(n){return"<tr>\n"+n+"</tr>\n"},t.tablecell=function(n,e){var t=e.header?"th":"td";return(e.align?"<"+t+' align="'+e.align+'">':"<"+t+">")+n+"</"+t+">\n"},t.strong=function(n){return"<strong>"+n+"</strong>"},t.em=function(n){return"<em>"+n+"</em>"},t.codespan=function(n){return"<code>"+n+"</code>"},t.br=function(){return this.options.xhtml?"<br/>":"<br>"},t.del=function(n){return"<del>"+n+"</del>"},t.link=function(n,e,t){if(null===(n=d(this.options.sanitize,this.options.baseUrl,n)))return t;var a='<a href="'+l(n)+'"';return e&&(a+=' title="'+e+'"'),a+">"+t+"</a>"},t.image=function(n,e,t){if(null===(n=d(this.options.sanitize,this.options.baseUrl,n)))return t;var a='<img src="'+n+'" alt="'+t+'"';return e&&(a+=' title="'+e+'"'),a+(this.options.xhtml?"/>":">")},t.text=function(n){return n},e}(),N=function(){function n(){}var e=n.prototype;return e.strong=function(n){return n},e.em=function(n){return n},e.codespan=function(n){return n},e.del=function(n){return n},e.html=function(n){return n},e.text=function(n){return n},e.link=function(n,e,t){return""+t},e.image=function(n,e,t){return""+t},e.br=function(){return""},n}(),B=function(){function n(){this.seen={}}var e=n.prototype;return e.serialize=function(n){return n.toLowerCase().trim().replace(/<[!\/a-z].*?>/gi,"").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g,"").replace(/\s/g,"-")},e.getNextSafeSlug=function(n,e){var t=n,a=0;if(this.seen.hasOwnProperty(t)){a=this.seen[n];do{t=n+"-"+ ++a}while(this.seen.hasOwnProperty(t))}return e||(this.seen[n]=a,this.seen[t]=0),t},e.slug=function(n,e){void 0===e&&(e={});var t=this.serialize(n);return this.getNextSafeSlug(t,e.dryrun)},n}(),U=function(){function e(e){this.options=e||n.defaults,this.options.renderer=this.options.renderer||new q,this.renderer=this.options.renderer,this.renderer.options=this.options,this.textRenderer=new N,this.slugger=new B}e.parse=function(n,t){return new e(t).parse(n)},e.parseInline=function(n,t){return new e(t).parseInline(n)};var t=e.prototype;return t.parse=function(n,e){void 0===e&&(e=!0);var t,a,r,i,o,s,l,u,d,p,h,f,m,g,v,y,b,k,w,x="",S=n.length;for(t=0;t<S;t++)if(p=n[t],!(this.options.extensions&&this.options.extensions.renderers&&this.options.extensions.renderers[p.type])||!1===(w=this.options.extensions.renderers[p.type].call({parser:this},p))&&["space","hr","heading","code","table","blockquote","list","html","paragraph","text"].includes(p.type))switch(p.type){case"space":continue;case"hr":x+=this.renderer.hr();continue;case"heading":x+=this.renderer.heading(this.parseInline(p.tokens),p.depth,c(this.parseInline(p.tokens,this.textRenderer)),this.slugger);continue;case"code":x+=this.renderer.code(p.text,p.lang,p.escaped);continue;case"table":for(u="",l="",i=p.header.length,a=0;a<i;a++)l+=this.renderer.tablecell(this.parseInline(p.header[a].tokens),{header:!0,align:p.align[a]});for(u+=this.renderer.tablerow(l),d="",i=p.rows.length,a=0;a<i;a++){for(l="",o=(s=p.rows[a]).length,r=0;r<o;r++)l+=this.renderer.tablecell(this.parseInline(s[r].tokens),{header:!1,align:p.align[r]});d+=this.renderer.tablerow(l)}x+=this.renderer.table(u,d);continue;case"blockquote":d=this.parse(p.tokens),x+=this.renderer.blockquote(d);continue;case"list":for(h=p.ordered,f=p.start,m=p.loose,i=p.items.length,d="",a=0;a<i;a++)y=(v=p.items[a]).checked,b=v.task,g="",v.task&&(k=this.renderer.checkbox(y),m?v.tokens.length>0&&"paragraph"===v.tokens[0].type?(v.tokens[0].text=k+" "+v.tokens[0].text,v.tokens[0].tokens&&v.tokens[0].tokens.length>0&&"text"===v.tokens[0].tokens[0].type&&(v.tokens[0].tokens[0].text=k+" "+v.tokens[0].tokens[0].text)):v.tokens.unshift({type:"text",text:k}):g+=k),g+=this.parse(v.tokens,m),d+=this.renderer.listitem(g,b,y);x+=this.renderer.list(d,h,f);continue;case"html":x+=this.renderer.html(p.text);continue;case"paragraph":x+=this.renderer.paragraph(this.parseInline(p.tokens));continue;case"text":for(d=p.tokens?this.parseInline(p.tokens):p.text;t+1<S&&"text"===n[t+1].type;)d+="\n"+((p=n[++t]).tokens?this.parseInline(p.tokens):p.text);x+=e?this.renderer.paragraph(d):d;continue;default:var _='Token with "'+p.type+'" type was not found.';if(this.options.silent)return;throw new Error(_)}else x+=w||"";return x},t.parseInline=function(n,e){e=e||this.renderer;var t,a,r,i="",o=n.length;for(t=0;t<o;t++)if(a=n[t],!(this.options.extensions&&this.options.extensions.renderers&&this.options.extensions.renderers[a.type])||!1===(r=this.options.extensions.renderers[a.type].call({parser:this},a))&&["escape","html","link","image","strong","em","codespan","br","del","text"].includes(a.type))switch(a.type){case"escape":i+=e.text(a.text);break;case"html":i+=e.html(a.text);break;case"link":i+=e.link(a.href,a.title,this.parseInline(a.tokens,e));break;case"image":i+=e.image(a.href,a.title,a.text);break;case"strong":i+=e.strong(this.parseInline(a.tokens,e));break;case"em":i+=e.em(this.parseInline(a.tokens,e));break;case"codespan":i+=e.codespan(a.text);break;case"br":i+=e.br();break;case"del":i+=e.del(this.parseInline(a.tokens,e));break;case"text":i+=e.text(a.text);break;default:var s='Token with "'+a.type+'" type was not found.';if(this.options.silent)return;throw new Error(s)}else i+=r||"";return i},e}();k.options=k.setOptions=function(n){return p(k.defaults,n),s(k.defaults),k},k.getDefaults=o,k.defaults=n.defaults,k.use=function(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];var a,r=p.apply(void 0,[{}].concat(e)),i=k.defaults.extensions||{renderers:{},childTokens:{}};e.forEach((function(n){if(n.extensions&&(a=!0,n.extensions.forEach((function(n){if(!n.name)throw new Error("extension name required");if(n.renderer){var e=i.renderers?i.renderers[n.name]:null;i.renderers[n.name]=e?function(){for(var t=arguments.length,a=new Array(t),r=0;r<t;r++)a[r]=arguments[r];var i=n.renderer.apply(this,a);return!1===i&&(i=e.apply(this,a)),i}:n.renderer}if(n.tokenizer){if(!n.level||"block"!==n.level&&"inline"!==n.level)throw new Error("extension level must be 'block' or 'inline'");i[n.level]?i[n.level].unshift(n.tokenizer):i[n.level]=[n.tokenizer],n.start&&("block"===n.level?i.startBlock?i.startBlock.push(n.start):i.startBlock=[n.start]:"inline"===n.level&&(i.startInline?i.startInline.push(n.start):i.startInline=[n.start]))}n.childTokens&&(i.childTokens[n.name]=n.childTokens)}))),n.renderer&&function(){var e=k.defaults.renderer||new q;for(var t in n.renderer)!function(t){var a=e[t];e[t]=function(){for(var r=arguments.length,i=new Array(r),o=0;o<r;o++)i[o]=arguments[o];var s=n.renderer[t].apply(e,i);return!1===s&&(s=a.apply(e,i)),s}}(t);r.renderer=e}(),n.tokenizer&&function(){var e=k.defaults.tokenizer||new D;for(var t in n.tokenizer)!function(t){var a=e[t];e[t]=function(){for(var r=arguments.length,i=new Array(r),o=0;o<r;o++)i[o]=arguments[o];var s=n.tokenizer[t].apply(e,i);return!1===s&&(s=a.apply(e,i)),s}}(t);r.tokenizer=e}(),n.walkTokens){var e=k.defaults.walkTokens;r.walkTokens=function(t){n.walkTokens.call(this,t),e&&e.call(this,t)}}a&&(r.extensions=i),k.setOptions(r)}))},k.walkTokens=function(n,e){for(var t,a=i(n);!(t=a()).done;)!function(){var n=t.value;switch(e.call(k,n),n.type){case"table":for(var a,r=i(n.header);!(a=r()).done;){var o=a.value;k.walkTokens(o.tokens,e)}for(var s,l=i(n.rows);!(s=l()).done;)for(var c,u=i(s.value);!(c=u()).done;){var d=c.value;k.walkTokens(d.tokens,e)}break;case"list":k.walkTokens(n.items,e);break;default:k.defaults.extensions&&k.defaults.extensions.childTokens&&k.defaults.extensions.childTokens[n.type]?k.defaults.extensions.childTokens[n.type].forEach((function(t){k.walkTokens(n[t],e)})):n.tokens&&k.walkTokens(n.tokens,e)}}()},k.parseInline=function(n,e){if(null==n)throw new Error("marked.parseInline(): input parameter is undefined or null");if("string"!=typeof n)throw new Error("marked.parseInline(): input parameter is of type "+Object.prototype.toString.call(n)+", string expected");m(e=p({},k.defaults,e||{}));try{var t=R.lexInline(n,e);return e.walkTokens&&k.walkTokens(t,e.walkTokens),U.parseInline(t,e)}catch(n){if(n.message+="\nPlease report this to https://github.com/markedjs/marked.",e.silent)return"<p>An error occurred:</p><pre>"+l(n.message+"",!0)+"</pre>";throw n}},k.Parser=U,k.parser=U.parse,k.Renderer=q,k.TextRenderer=N,k.Lexer=R,k.lexer=R.lex,k.Tokenizer=D,k.Slugger=B,k.parse=k;var J=k.options,V=k.setOptions,W=k.use,H=k.walkTokens,Q=k.parseInline,G=k,K=U.parse,Y=R.lex;n.Lexer=R,n.Parser=U,n.Renderer=q,n.Slugger=B,n.TextRenderer=N,n.Tokenizer=D,n.getDefaults=o,n.lexer=Y,n.marked=k,n.options=J,n.parse=G,n.parseInline=Q,n.parser=K,n.setOptions=V,n.use=W,n.walkTokens=H,Object.defineProperty(n,"__esModule",{value:!0})}(e)},function(n,e,t){"use strict";function a(n,e){var t=function(n){var e={};return s(l(n),(function(n){var t=n[0],a=n[1];s(a,(function(n){e[n]=t}))})),e}(n.pluralTypeToLanguages);return t[e]||t[f.call(e,/-/,1)[0]]||t.en}function r(n){return n.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function i(n,e,t,a,r){if("string"!=typeof n)throw new TypeError("Polyglot.transformPhrase expects argument #1 to be string");if(null==e)return n;var i=n,o=a||b,s="number"==typeof e?{smart_count:e}:e;if(null!=s.smart_count&&n){var l=r||v,c=f.call(n,m),p=function(n,e,t){return n.pluralTypes[e](t)}(l,y(l,t||"en"),s.smart_count);i=d(c[p]||c[0])}return h.call(i,o,(function(n,e){return u(s,e)&&null!=s[e]?s[e]:n}))}function o(n){var e=n||{};this.phrases={},this.extend(e.phrases||{}),this.currentLocale=e.locale||"en";var t=e.allowMissing?i:null;this.onMissingKey="function"==typeof e.onMissingKey?e.onMissingKey:t,this.warn=e.warn||p,this.tokenRegex=function(n){var e=n&&n.prefix||"%{",t=n&&n.suffix||"}";if(e===m||t===m)throw new RangeError('"'+m+'" token is reserved for pluralization');return new RegExp(r(e)+"(.*?)"+r(t),"g")}(e.interpolation),this.pluralRules=e.pluralRules||v}var s=t(43),l=t(89),c=t(94),u=t(25),d=t(92),p=function(n){c(!1,n)},h=String.prototype.replace,f=String.prototype.split,m="||||",g=function(n){var e=n%100,t=e%10;return 11!==e&&1===t?0:2<=t&&t<=4&&!(e>=12&&e<=14)?1:2},v={pluralTypes:{arabic:function(n){if(n<3)return n;var e=n%100;return e>=3&&e<=10?3:e>=11?4:5},bosnian_serbian:g,chinese:function(){return 0},croatian:g,french:function(n){return n>=2?1:0},german:function(n){return 1!==n?1:0},russian:g,lithuanian:function(n){return n%10==1&&n%100!=11?0:n%10>=2&&n%10<=9&&(n%100<11||n%100>19)?1:2},czech:function(n){return 1===n?0:n>=2&&n<=4?1:2},polish:function(n){if(1===n)return 0;var e=n%10;return 2<=e&&e<=4&&(n%100<10||n%100>=20)?1:2},icelandic:function(n){return n%10!=1||n%100==11?1:0},slovenian:function(n){var e=n%100;return 1===e?0:2===e?1:3===e||4===e?2:3}},pluralTypeToLanguages:{arabic:["ar"],bosnian_serbian:["bs-Latn-BA","bs-Cyrl-BA","srl-RS","sr-RS"],chinese:["id","id-ID","ja","ko","ko-KR","lo","ms","th","th-TH","zh"],croatian:["hr","hr-HR"],german:["fa","da","de","en","es","fi","el","he","hi-IN","hu","hu-HU","it","nl","no","pt","sv","tr"],french:["fr","tl","pt-br"],russian:["ru","ru-RU"],lithuanian:["lt"],czech:["cs","cs-CZ","sk"],polish:["pl"],icelandic:["is"],slovenian:["sl-SL"]}},y=function(){var n={};return function(e,t){var r=n[t];return r&&!e.pluralTypes[r]&&(r=null,n[t]=r),r||(r=a(e,t))&&(n[t]=r),r}}(),b=/%\{(.*?)\}/g;o.prototype.locale=function(n){return n&&(this.currentLocale=n),this.currentLocale},o.prototype.extend=function(n,e){s(l(n||{}),(function(n){var t=n[0],a=n[1],r=e?e+"."+t:t;"object"==typeof a?this.extend(a,r):this.phrases[r]=a}),this)},o.prototype.unset=function(n,e){"string"==typeof n?delete this.phrases[n]:s(l(n||{}),(function(n){var t=n[0],a=n[1],r=e?e+"."+t:t;"object"==typeof a?this.unset(a,r):delete this.phrases[r]}),this)},o.prototype.clear=function(){this.phrases={}},o.prototype.replace=function(n){this.clear(),this.extend(n)},o.prototype.t=function(n,e){var t,a,r=null==e?{}:e;return"string"==typeof this.phrases[n]?t=this.phrases[n]:"string"==typeof r._?t=r._:this.onMissingKey?a=(0,this.onMissingKey)(n,r,this.currentLocale,this.tokenRegex,this.pluralRules):(this.warn('Missing translation for key: "'+n+'"'),a=n),"string"==typeof t&&(a=i(t,r,this.currentLocale,this.tokenRegex,this.pluralRules)),a},o.prototype.has=function(n){return u(this.phrases,n)},o.transformPhrase=function(n,e,t){return i(n,e,t)},n.exports=o},function(n,e,t){"use strict";function a(n){if(null==n)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(n)}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/var r=Object.getOwnPropertySymbols,i=Object.prototype.hasOwnProperty,o=Object.prototype.propertyIsEnumerable;n.exports=function(){try{if(!Object.assign)return!1;var n=new String("abc");if(n[5]="de","5"===Object.getOwnPropertyNames(n)[0])return!1;for(var e={},t=0;t<10;t++)e["_"+String.fromCharCode(t)]=t;if("0123456789"!==Object.getOwnPropertyNames(e).map((function(n){return e[n]})).join(""))return!1;var a={};return"abcdefghijklmnopqrst".split("").forEach((function(n){a[n]=n})),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},a)).join("")}catch(n){return!1}}()?Object.assign:function(n,e){for(var t,s,l=a(n),c=1;c<arguments.length;c++){for(var u in t=Object(arguments[c]))i.call(t,u)&&(l[u]=t[u]);if(r){s=r(t);for(var d=0;d<s.length;d++)o.call(t,s[d])&&(l[s[d]]=t[s[d]])}}return l}},function(n,e,t){function a(n,e){if(n===1/0||n===-1/0||n!=n||n&&n>-1e3&&n<1e3||N.call(/e/,e))return e;var t=/[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;if("number"==typeof n){var a=n<0?-V(-n):V(n);if(a!==n){var r=String(a),i=M.call(e,r.length+1);return F.call(r,t,"$&_")+"."+F.call(F.call(i,/([0-9]{3})/g,"$&_"),/_$/,"")}}return F.call(e,t,"$&_")}function r(n,e,t){var a="double"===(t.quoteStyle||e)?'"':"'";return a+n+a}function i(n){return F.call(String(n),/"/g,"&quot;")}function o(n){return!("[object Array]"!==c(n)||K&&"object"==typeof n&&K in n)}function s(n){if(G)return n&&"object"==typeof n&&n instanceof Symbol;if("symbol"==typeof n)return!0;if(!n||"object"!=typeof n||!Q)return!1;try{return Q.call(n),!0}catch(n){}return!1}function l(n,e){return en.call(n,e)}function c(n){return P.call(n)}function u(n){if(n.name)return n.name;var e=D.call(z.call(n),/^function\s*([\w$]+)/);return e?e[1]:null}function d(n,e){if(n.indexOf)return n.indexOf(e);for(var t=0,a=n.length;t<a;t++)if(n[t]===e)return t;return-1}function p(n){if(!E||!n||"object"!=typeof n)return!1;try{E.call(n,E);try{O.call(n,O)}catch(n){return!0}return n instanceof WeakMap}catch(n){}return!1}function h(n){if(!L||!n||"object"!=typeof n)return!1;try{return L.call(n),!0}catch(n){}return!1}function f(n){if(!O||!n||"object"!=typeof n)return!1;try{O.call(n,O);try{E.call(n,E)}catch(n){return!0}return n instanceof WeakSet}catch(n){}return!1}function m(n,e){if(n.length>e.maxStringLength){var t=n.length-e.maxStringLength,a="... "+t+" more character"+(t>1?"s":"");return m(M.call(n,0,e.maxStringLength),e)+a}return r(F.call(F.call(n,/(['\\])/g,"\\$1"),/[\x00-\x1f]/g,g),"single",e)}function g(n){var e=n.charCodeAt(0),t={8:"b",9:"t",10:"n",12:"f",13:"r"}[e];return t?"\\"+t:"\\x"+(e<16?"0":"")+R.call(e.toString(16))}function v(n){return"Object("+n+")"}function y(n){return n+" { ? }"}function b(n,e,t,a){return n+" ("+e+") {"+(a?k(t,a):U.call(t,", "))+"}"}function k(n,e){if(0===n.length)return"";var t="\n"+e.prev+e.base;return t+U.call(n,","+t)+"\n"+e.prev}function w(n,e){var t=o(n),a=[];if(t){a.length=n.length;for(var r=0;r<n.length;r++)a[r]=l(n,r)?e(n[r],n):""}var i,s="function"==typeof H?H(n):[];if(G){i={};for(var c=0;c<s.length;c++)i["$"+s[c]]=s[c]}for(var u in n)l(n,u)&&(t&&String(Number(u))===u&&u<n.length||G&&i["$"+u]instanceof Symbol||(N.call(/[^\w$]/,u)?a.push(e(u,n)+": "+e(n[u],n)):a.push(u+": "+e(n[u],n))));if("function"==typeof H)for(var d=0;d<s.length;d++)Y.call(n,s[d])&&a.push("["+e(s[d])+"]: "+e(n[s[d]],n));return a}var x="function"==typeof Map&&Map.prototype,S=Object.getOwnPropertyDescriptor&&x?Object.getOwnPropertyDescriptor(Map.prototype,"size"):null,_=x&&S&&"function"==typeof S.get?S.get:null,j=x&&Map.prototype.forEach,T="function"==typeof Set&&Set.prototype,C=Object.getOwnPropertyDescriptor&&T?Object.getOwnPropertyDescriptor(Set.prototype,"size"):null,A=T&&C&&"function"==typeof C.get?C.get:null,I=T&&Set.prototype.forEach,E="function"==typeof WeakMap&&WeakMap.prototype?WeakMap.prototype.has:null,O="function"==typeof WeakSet&&WeakSet.prototype?WeakSet.prototype.has:null,L="function"==typeof WeakRef&&WeakRef.prototype?WeakRef.prototype.deref:null,$=Boolean.prototype.valueOf,P=Object.prototype.toString,z=Function.prototype.toString,D=String.prototype.match,M=String.prototype.slice,F=String.prototype.replace,R=String.prototype.toUpperCase,q=String.prototype.toLowerCase,N=RegExp.prototype.test,B=Array.prototype.concat,U=Array.prototype.join,J=Array.prototype.slice,V=Math.floor,W="function"==typeof BigInt?BigInt.prototype.valueOf:null,H=Object.getOwnPropertySymbols,Q="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?Symbol.prototype.toString:null,G="function"==typeof Symbol&&"object"==typeof Symbol.iterator,K="function"==typeof Symbol&&Symbol.toStringTag&&(Symbol.toStringTag,1)?Symbol.toStringTag:null,Y=Object.prototype.propertyIsEnumerable,X=("function"==typeof Reflect?Reflect.getPrototypeOf:Object.getPrototypeOf)||([].__proto__===Array.prototype?function(n){return n.__proto__}:null),Z=t(102).custom,nn=Z&&s(Z)?Z:null;n.exports=function n(e,t,g,x){function S(e,t,a){if(t&&(x=J.call(x)).push(t),a){var r={depth:T.depth};return l(T,"quoteStyle")&&(r.quoteStyle=T.quoteStyle),n(e,r,g+1,x)}return n(e,T,g+1,x)}var T=t||{};if(l(T,"quoteStyle")&&"single"!==T.quoteStyle&&"double"!==T.quoteStyle)throw new TypeError('option "quoteStyle" must be "single" or "double"');if(l(T,"maxStringLength")&&("number"==typeof T.maxStringLength?T.maxStringLength<0&&T.maxStringLength!==1/0:null!==T.maxStringLength))throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');var C=!l(T,"customInspect")||T.customInspect;if("boolean"!=typeof C&&"symbol"!==C)throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");if(l(T,"indent")&&null!==T.indent&&"\t"!==T.indent&&!(parseInt(T.indent,10)===T.indent&&T.indent>0))throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');if(l(T,"numericSeparator")&&"boolean"!=typeof T.numericSeparator)throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');var E=T.numericSeparator;if(void 0===e)return"undefined";if(null===e)return"null";if("boolean"==typeof e)return e?"true":"false";if("string"==typeof e)return m(e,T);if("number"==typeof e){if(0===e)return 1/0/e>0?"0":"-0";var O=String(e);return E?a(e,O):O}if("bigint"==typeof e){var L=String(e)+"n";return E?a(e,L):L}var P=void 0===T.depth?5:T.depth;if(void 0===g&&(g=0),g>=P&&P>0&&"object"==typeof e)return o(e)?"[Array]":"[Object]";var z=function(n,e){var t;if("\t"===n.indent)t="\t";else{if(!("number"==typeof n.indent&&n.indent>0))return null;t=U.call(Array(n.indent+1)," ")}return{base:t,prev:U.call(Array(e+1),t)}}(T,g);if(void 0===x)x=[];else if(d(x,e)>=0)return"[Circular]";if("function"==typeof e){var D=u(e),R=w(e,S);return"[Function"+(D?": "+D:" (anonymous)")+"]"+(R.length>0?" { "+U.call(R,", ")+" }":"")}if(s(e)){var N=G?F.call(String(e),/^(Symbol\(.*\))_[^)]*$/,"$1"):Q.call(e);return"object"!=typeof e||G?N:v(N)}if(function(n){return!(!n||"object"!=typeof n)&&("undefined"!=typeof HTMLElement&&n instanceof HTMLElement||"string"==typeof n.nodeName&&"function"==typeof n.getAttribute)}(e)){for(var V="<"+q.call(String(e.nodeName)),H=e.attributes||[],Z=0;Z<H.length;Z++)V+=" "+H[Z].name+"="+r(i(H[Z].value),"double",T);return V+=">",e.childNodes&&e.childNodes.length&&(V+="..."),V+"</"+q.call(String(e.nodeName))+">"}if(o(e)){if(0===e.length)return"[]";var en=w(e,S);return z&&!function(n){for(var e=0;e<n.length;e++)if(d(n[e],"\n")>=0)return!1;return!0}(en)?"["+k(en,z)+"]":"[ "+U.call(en,", ")+" ]"}if(function(n){return!("[object Error]"!==c(n)||K&&"object"==typeof n&&K in n)}(e)){var tn=w(e,S);return"cause"in e&&!Y.call(e,"cause")?"{ ["+String(e)+"] "+U.call(B.call("[cause]: "+S(e.cause),tn),", ")+" }":0===tn.length?"["+String(e)+"]":"{ ["+String(e)+"] "+U.call(tn,", ")+" }"}if("object"==typeof e&&C){if(nn&&"function"==typeof e[nn])return e[nn]();if("symbol"!==C&&"function"==typeof e.inspect)return e.inspect()}if(function(n){if(!_||!n||"object"!=typeof n)return!1;try{_.call(n);try{A.call(n)}catch(n){return!0}return n instanceof Map}catch(n){}return!1}(e)){var an=[];return j.call(e,(function(n,t){an.push(S(t,e,!0)+" => "+S(n,e))})),b("Map",_.call(e),an,z)}if(function(n){if(!A||!n||"object"!=typeof n)return!1;try{A.call(n);try{_.call(n)}catch(n){return!0}return n instanceof Set}catch(n){}return!1}(e)){var rn=[];return I.call(e,(function(n){rn.push(S(n,e))})),b("Set",A.call(e),rn,z)}if(p(e))return y("WeakMap");if(f(e))return y("WeakSet");if(h(e))return y("WeakRef");if(function(n){return!("[object Number]"!==c(n)||K&&"object"==typeof n&&K in n)}(e))return v(S(Number(e)));if(function(n){if(!n||"object"!=typeof n||!W)return!1;try{return W.call(n),!0}catch(n){}return!1}(e))return v(S(W.call(e)));if(function(n){return!("[object Boolean]"!==c(n)||K&&"object"==typeof n&&K in n)}(e))return v($.call(e));if(function(n){return!("[object String]"!==c(n)||K&&"object"==typeof n&&K in n)}(e))return v(S(String(e)));if(!function(n){return!("[object Date]"!==c(n)||K&&"object"==typeof n&&K in n)}(e)&&!function(n){return!("[object RegExp]"!==c(n)||K&&"object"==typeof n&&K in n)}(e)){var on=w(e,S),sn=X?X(e)===Object.prototype:e instanceof Object||e.constructor===Object,ln=e instanceof Object?"":"null prototype",cn=!sn&&K&&Object(e)===e&&K in e?M.call(c(e),8,-1):ln?"Object":"",un=(sn||"function"!=typeof e.constructor?"":e.constructor.name?e.constructor.name+" ":"")+(cn||ln?"["+U.call(B.call([],cn||[],ln||[]),": ")+"] ":"");return 0===on.length?un+"{}":z?un+"{"+k(on,z)+"}":un+"{ "+U.call(on,", ")+" }"}return String(e)};var en=Object.prototype.hasOwnProperty||function(n){return n in this}},function(n,e,t){"use strict";var a;if(!Object.keys){var r=Object.prototype.hasOwnProperty,i=Object.prototype.toString,o=t(26),s=Object.prototype.propertyIsEnumerable,l=!s.call({toString:null},"toString"),c=s.call((function(){}),"prototype"),u=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],d=function(n){var e=n.constructor;return e&&e.prototype===n},p={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},h=function(){if("undefined"==typeof window)return!1;for(var n in window)try{if(!p["$"+n]&&r.call(window,n)&&null!==window[n]&&"object"==typeof window[n])try{d(window[n])}catch(n){return!0}}catch(n){return!0}return!1}(),f=function(n){if("undefined"==typeof window||!h)return d(n);try{return d(n)}catch(n){return!1}};a=function(n){var e=null!==n&&"object"==typeof n,t="[object Function]"===i.call(n),a=o(n),s=e&&"[object String]"===i.call(n),d=[];if(!e&&!t&&!a)throw new TypeError("Object.keys called on a non-object");var p=c&&t;if(s&&n.length>0&&!r.call(n,0))for(var h=0;h<n.length;++h)d.push(String(h));if(a&&n.length>0)for(var m=0;m<n.length;++m)d.push(String(m));else for(var g in n)p&&"prototype"===g||!r.call(n,g)||d.push(String(g));if(l)for(var v=f(n),y=0;y<u.length;++y)v&&"constructor"===u[y]||!r.call(n,u[y])||d.push(u[y]);return d}}n.exports=a},function(n,e,t){"use strict";var a=Array.prototype.slice,r=t(26),i=Object.keys,o=i?function(n){return i(n)}:t(87),s=Object.keys;o.shim=function(){return Object.keys?function(){var n=Object.keys(arguments);return n&&n.length===arguments.length}(1,2)||(Object.keys=function(n){return s(r(n)?a.call(n):n)}):Object.keys=o,Object.keys||o},n.exports=o},function(n,e,t){"use strict";var a=t(2),r=t(4),i=t(27),o=t(28),s=t(90),l=r(o(),Object);a(l,{getPolyfill:o,implementation:i,shim:s}),n.exports=l},function(n,e,t){"use strict";var a=t(28),r=t(2);n.exports=function(){var n=a();return r(Object,{entries:n},{entries:function(){return Object.entries!==n}}),n}},function(n,e){function t(){throw new Error("setTimeout has not been defined")}function a(){throw new Error("clearTimeout has not been defined")}function r(n){if(c===setTimeout)return setTimeout(n,0);if((c===t||!c)&&setTimeout)return c=setTimeout,setTimeout(n,0);try{return c(n,0)}catch(e){try{return c.call(null,n,0)}catch(e){return c.call(this,n,0)}}}function i(){f&&p&&(f=!1,p.length?h=p.concat(h):m=-1,h.length&&o())}function o(){if(!f){var n=r(i);f=!0;for(var e=h.length;e;){for(p=h,h=[];++m<e;)p&&p[m].run();m=-1,e=h.length}p=null,f=!1,function(n){if(u===clearTimeout)return clearTimeout(n);if((u===a||!u)&&clearTimeout)return u=clearTimeout,clearTimeout(n);try{u(n)}catch(e){try{return u.call(null,n)}catch(e){return u.call(this,n)}}}(n)}}function s(n,e){this.fun=n,this.array=e}function l(){}var c,u,d=n.exports={};!function(){try{c="function"==typeof setTimeout?setTimeout:t}catch(n){c=t}try{u="function"==typeof clearTimeout?clearTimeout:a}catch(n){u=a}}();var p,h=[],f=!1,m=-1;d.nextTick=function(n){var e=new Array(arguments.length-1);if(arguments.length>1)for(var t=1;t<arguments.length;t++)e[t-1]=arguments[t];h.push(new s(n,e)),1!==h.length||f||r(o)},s.prototype.run=function(){this.fun.apply(null,this.array)},d.title="browser",d.browser=!0,d.env={},d.argv=[],d.version="",d.versions={},d.on=l,d.addListener=l,d.once=l,d.off=l,d.removeListener=l,d.removeAllListeners=l,d.emit=l,d.prependListener=l,d.prependOnceListener=l,d.listeners=function(n){return[]},d.binding=function(n){throw new Error("process.binding is not supported")},d.cwd=function(){return"/"},d.chdir=function(n){throw new Error("process.chdir is not supported")},d.umask=function(){return 0}},function(n,e,t){"use strict";var a=t(4),r=t(2),i=t(29),o=t(30),s=t(93),l=a(o());r(l,{getPolyfill:o,implementation:i,shim:s}),n.exports=l},function(n,e,t){"use strict";var a=t(2),r=t(30);n.exports=function(){var n=r();return a(String.prototype,{trim:n},{trim:function(){return String.prototype.trim!==n}}),n}},function(n,e,t){"use strict";(function(e){var t=function(){};if("production"!==e.env.NODE_ENV){var a=function(n,e){var t=arguments.length;e=new Array(t>1?t-1:0);for(var a=1;a<t;a++)e[a-1]=arguments[a];var r=0,i="Warning: "+n.replace(/%s/g,(function(){return e[r++]}));try{throw new Error(i)}catch(n){}};t=function(n,e,t){var r=arguments.length;t=new Array(r>2?r-2:0);for(var i=2;i<r;i++)t[i-2]=arguments[i];if(void 0===e)throw new Error("`warning(condition, format, ...args)` requires a warning message argument");n||a.apply(null,[e].concat(t))}}n.exports=t}).call(e,t(91))},function(n,e,t){function a(n,e){return new o(e).process(n)}var r=t(31),i=t(32),o=t(96);for(var s in(e=n.exports=a).filterXSS=a,e.FilterXSS=o,r)e[s]=r[s];for(var s in i)e[s]=i[s];"undefined"!=typeof window&&(window.filterXSS=n.exports),"undefined"!=typeof self&&"undefined"!=typeof DedicatedWorkerGlobalScope&&self instanceof DedicatedWorkerGlobalScope&&(self.filterXSS=n.exports)},function(n,e,t){function a(n){return null==n}function r(n){(n=function(n){var e={};for(var t in n)e[t]=n[t];return e}(n||{})).stripIgnoreTag&&(n.onIgnoreTag,n.onIgnoreTag=o.onIgnoreTagStripAll),n.whiteList=n.whiteList||n.allowList||o.whiteList,n.onTag=n.onTag||o.onTag,n.onTagAttr=n.onTagAttr||o.onTagAttr,n.onIgnoreTag=n.onIgnoreTag||o.onIgnoreTag,n.onIgnoreTagAttr=n.onIgnoreTagAttr||o.onIgnoreTagAttr,n.safeAttrValue=n.safeAttrValue||o.safeAttrValue,n.escapeHtml=n.escapeHtml||o.escapeHtml,this.options=n,!1===n.css?this.cssFilter=!1:(n.css=n.css||{},this.cssFilter=new i(n.css))}var i=t(7).FilterCSS,o=t(31),s=t(32),l=s.parseTag,c=s.parseAttr,u=t(11);r.prototype.process=function(n){if(!(n=(n=n||"").toString()))return"";var e=this.options,t=e.whiteList,r=e.onTag,i=e.onIgnoreTag,s=e.onTagAttr,d=e.onIgnoreTagAttr,p=e.safeAttrValue,h=e.escapeHtml,f=this.cssFilter;e.stripBlankChar&&(n=o.stripBlankChar(n)),e.allowCommentTag||(n=o.stripCommentTag(n));var m=!1;e.stripIgnoreTagBody&&(m=o.StripTagBody(e.stripIgnoreTagBody,i),i=m.onIgnoreTag);var g=l(n,(function(n,e,o,l,m){var g,v={sourcePosition:n,position:e,isClosing:m,isWhite:t.hasOwnProperty(o)};if(!a(g=r(o,l,v)))return g;if(v.isWhite){if(v.isClosing)return"</"+o+">";var y=function(n){var e=u.spaceIndex(n);if(-1===e)return{html:"",closing:"/"===n[n.length-2]};var t="/"===(n=u.trim(n.slice(e+1,-1)))[n.length-1];return t&&(n=u.trim(n.slice(0,-1))),{html:n,closing:t}}(l),b=t[o],k=c(y.html,(function(n,e){var t,r=-1!==u.indexOf(b,n);return a(t=s(o,n,e,r))?r?(e=p(o,n,e,f))?n+'="'+e+'"':n:a(t=d(o,n,e,r))?void 0:t:t}));return l="<"+o,k&&(l+=" "+k),y.closing&&(l+=" /"),l+">"}return a(g=i(o,l,v))?h(l):g}),h);return m&&(g=m.remove(g)),g},n.exports=r},function(n,e){n.exports={smile:"e3/2018new_weixioa02_org.png",lovely:"09/2018new_keai_org.png",happy:"1e/2018new_taikaixin_org.png",clap:"6e/2018new_guzhang_thumb.png",whee:"33/2018new_xixi_thumb.png",haha:"8f/2018new_haha_thumb.png","laugh and cry":"4a/2018new_xiaoku_thumb.png",wink:"43/2018new_jiyan_org.png",greddy:"fa/2018new_chanzui_org.png",awkward:"a3/2018new_heixian_thumb.png",sweat:"28/2018new_han_org.png","pick nose":"9a/2018new_wabi_thumb.png",hum:"7c/2018new_heng_thumb.png",angry:"f6/2018new_nu_thumb.png",grievance:"a5/2018new_weiqu_thumb.png",poor:"96/2018new_kelian_org.png",disappoint:"aa/2018new_shiwang_thumb.png",sad:"ee/2018new_beishang_org.png",tear:"6e/2018new_leimu_org.png","no way":"83/2018new_kuxiao_org.png",shy:"c1/2018new_haixiu_org.png",dirt:"10/2018new_wu_thumb.png","love you":"f6/2018new_aini_org.png",kiss:"2c/2018new_qinqin_thumb.png",amorousness:"9d/2018new_huaxin_org.png",longing:"c9/2018new_chongjing_org.png",desire:"3e/2018new_tianping_thumb.png","bad laugh":"4d/2018new_huaixiao_org.png",blackness:"9e/2018new_yinxian_org.png","laugh without word":"2d/2018new_xiaoerbuyu_org.png",titter:"71/2018new_touxiao_org.png",cool:"c4/2018new_ku_org.png","not easy":"aa/2018new_bingbujiandan_thumb.png",think:"30/2018new_sikao_org.png",question:"b8/2018new_ningwen_org.png","no idea":"2a/2018new_wenhao_thumb.png",dizzy:"07/2018new_yun_thumb.png",bomb:"a2/2018new_shuai_thumb.png",bone:"a1/2018new_kulou_thumb.png","be quiet":"b0/2018new_xu_org.png","shut up":"62/2018new_bizui_org.png",stupid:"dd/2018new_shayan_org.png","surprise ":"49/2018new_chijing_org.png",vomit:"08/2018new_tu_org.png",cold:"40/2018new_kouzhao_thumb.png",sick:"3b/2018new_shengbing_thumb.png",bye:"fd/2018new_baibai_thumb.png","look down on":"da/2018new_bishi_org.png","white eye":"ef/2018new_landelini_org.png","left hum":"43/2018new_zuohengheng_thumb.png","right hum":"c1/2018new_youhengheng_thumb.png",crazy:"17/2018new_zhuakuang_org.png","scold ":"87/2018new_zhouma_thumb.png","hit on face":"cb/2018new_dalian_org.png",wow:"ae/2018new_ding_org.png",fan:"86/2018new_hufen02_org.png",money:"a2/2018new_qian_thumb.png",yawn:"55/2018new_dahaqian_org.png",sleepy:"3c/2018new_kun_thumb.png",sleep:"e2/2018new_shuijiao_thumb.png","watermelon ":"01/2018new_chigua_thumb.png",doge:"a1/2018new_doge02_org.png",dog:"22/2018new_erha_org.png",cat:"7b/2018new_miaomiao_thumb.png",thumb:"e6/2018new_zan_org.png",good:"8a/2018new_good_org.png",ok:"45/2018new_ok_org.png",yeah:"29/2018new_ye_thumb.png","shack hand":"e9/2018new_woshou_thumb.png",bow:"e7/2018new_zuoyi_org.png",come:"42/2018new_guolai_thumb.png",punch:"86/2018new_quantou_thumb.png"}},function(n,e){n.exports={nick:"NickName",mail:"E-Mail",link:"Website(http://)",nickFail:"NickName cannot be less than 3 bytes.",mailFail:"Please confirm your email address.",sofa:"No comment yet.",submit:"Submit",reply:"Reply",cancelReply:"Cancel reply",comments:"Comments",cancel:"Cancel",confirm:"Confirm",continue:"Continue",more:"Load More...",preview:"Preview",emoji:"Emoji",expand:"See more....",seconds:"seconds ago",minutes:"minutes ago",hours:"hours ago",days:"days ago",now:"just now",uploading:"Uploading ...",uploadDone:"Upload completed!",busy:"Submit is busy, please wait...","code-98":"Valine initialization failed, please check your version of av-min.js.","code-99":"Valine initialization failed, Please check the `el` element in the init method.","code-100":"Valine initialization failed, Please check your appId and appKey.","code-140":"The total number of API calls today has exceeded the development version limit.","code-401":"Unauthorized operation, Please check your appId and appKey.","code-403":"Access denied by API domain white list, Please check your security domain."}},function(n,e){n.exports={nick:"ニックネーム",mail:"メールアドレス",link:"サイト(http://)",nickFail:"3バイト以上のニックネームをご入力ください.",mailFail:"メールアドレスをご確認ください.",sofa:"コメントしましょう~",submit:"提出する",reply:"返信する",cancelReply:"キャンセル",comments:"コメント",cancel:"キャンセル",confirm:"確認する",continue:"继续",more:"さらに読み込む...",preview:"プレビュー",emoji:"絵文字",expand:"もっと見る",seconds:"秒前",minutes:"分前",hours:"時間前",days:"日前",now:"たっだ今",uploading:"アップロード中...",uploadDone:"アップロードが完了しました!",busy:"20 秒間隔で提出してください    ...","code-98":"ロードエラーです。av-min.js のバージョンを確認してください.","code-99":"ロードエラーです。initにある`el`エレメントを確認ください.","code-100":"ロードエラーです。AppIdとAppKeyを確認ください.","code-140":"今日のAPIコールの総数が開発バージョンの上限を超えた.","code-401":"権限が制限されています。AppIdとAppKeyを確認ください.","code-403":"アクセスがAPIなどに制限されました、ドメイン名のセキュリティ設定を確認ください"}},function(n,e){n.exports={nick:"昵称",mail:"邮箱",link:"网址(http://)",nickFail:"昵称不能少于3个字符",mailFail:"请填写正确的邮件地址",sofa:"来发评论吧~",submit:"提交",reply:"回复",cancelReply:"取消回复",comments:"评论",cancel:"取消",confirm:"确认",continue:"继续",more:"加载更多...",preview:"预览",emoji:"表情",expand:"查看更多...",seconds:"秒前",minutes:"分钟前",hours:"小时前",days:"天前",now:"刚刚",uploading:"正在传输...",uploadDone:"传输完成!",busy:"操作频繁，请稍候再试...","code-98":"Valine 初始化失败，请检查 av-min.js 版本","code-99":"Valine 初始化失败，请检查init中的`el`元素.","code-100":"Valine 初始化失败，请检查你的AppId和AppKey.","code-140":"今日 API 调用总次数已超过开发版限制.","code-401":"未经授权的操作，请检查你的AppId和AppKey.","code-403":"访问被API域名白名单拒绝，请检查你的安全域名设置."}},function(n,e){n.exports={nick:"暱稱",mail:"郵箱",link:"網址(http://)",nickFail:"昵稱不能少於3個字符",mailFail:"請填寫正確的郵件地址",sofa:"來發評論吧~",submit:"提交",reply:"回覆",cancelReply:"取消回覆",comments:"評論",cancel:"取消",confirm:"確認",continue:"繼續",more:"加載更多...",preview:"預覽",emoji:"表情",expand:"查看更多...",seconds:"秒前",minutes:"分鐘前",hours:"小時前",days:"天前",now:"剛剛",uploading:"正在上傳...",uploadDone:"上傳完成!",busy:"操作頻繁，請稍候再試...","code-98":"Valine 初始化失敗，請檢查 av-min.js 版本","code-99":"Valine 初始化失敗，請檢查init中的`el`元素.","code-100":"Valine 初始化失敗，請檢查你的AppId和AppKey.","code-140":"今日 API 調用總次數已超過開發版限制.","code-401":"未經授權的操作，請檢查你的AppId和AppKey.","code-403":"訪問被API域名白名單拒絕，請檢查你的安全域名設置."}},function(n,e){},function(n,e,t){var a=t(104);"string"==typeof a&&(a=[[n.i,a,""]]);var r={transform:void 0};t(106)(a,r),a.locals&&(n.exports=a.locals)},function(n,e,t){(e=t(105)(!1)).push([n.i,'.v[data-class=v]{font-size:16px;text-align:left}.v[data-class=v] *{-webkit-box-sizing:border-box;box-sizing:border-box;line-height:1.75}.v[data-class=v] .vinput,.v[data-class=v] .veditor,.v[data-class=v] p,.v[data-class=v] pre code,.v[data-class=v] .status-bar{color:#555}.v[data-class=v] .vtime,.v[data-class=v] .vsys{color:#b3b3b3}.v[data-class=v] .text-right{text-align:right}.v[data-class=v] .text-center{text-align:center}.v[data-class=v] img{max-width:100%;border:none}.v[data-class=v] hr{margin:.825em 0;border-color:#f6f6f6;border-style:dashed}.v[data-class=v].hide-avatar .vimg{display:none}.v[data-class=v] a{position:relative;cursor:pointer;color:#1abc9c;text-decoration:none;display:inline-block}.v[data-class=v] a:hover{color:#d7191a}.v[data-class=v] pre,.v[data-class=v] code{background-color:#f8f8f8;padding:.2em .4em;border-radius:3px;font-size:85%;margin:0}.v[data-class=v] pre{padding:10px;overflow:auto;line-height:1.45}.v[data-class=v] pre code{padding:0;background:transparent;white-space:pre-wrap;word-break:keep-all}.v[data-class=v] blockquote{color:#666;margin:.5em 0;padding:0 0 0 1em;border-left:8px solid rgba(238,238,238,.5)}.v[data-class=v] .vinput{border:none;resize:none;outline:none;padding:10px 5px;max-width:100%;font-size:.775em;-webkit-box-sizing:border-box;box-sizing:border-box}.v[data-class=v] input[type=checkbox],.v[data-class=v] input[type=radio]{display:inline-block;vertical-align:middle;margin-top:-2px}.v[data-class=v] .vicon{cursor:pointer;display:inline-block;overflow:hidden;fill:#555;vertical-align:middle}.v[data-class=v] .vicon+.vicon{margin-left:10px}.v[data-class=v] .vicon.actived{fill:#66b1ff}.v[data-class=v] .vrow{font-size:0;padding:10px 0}.v[data-class=v] .vrow .vcol{display:inline-block;vertical-align:middle;font-size:14px}.v[data-class=v] .vrow .vcol.vcol-20{width:20%}.v[data-class=v] .vrow .vcol.vcol-30{width:30%}.v[data-class=v] .vrow .vcol.vcol-40{width:40%}.v[data-class=v] .vrow .vcol.vcol-50{width:50%}.v[data-class=v] .vrow .vcol.vcol-60{width:60%}.v[data-class=v] .vrow .vcol.vcol-70{width:70%}.v[data-class=v] .vrow .vcol.vcol-80{width:80%}.v[data-class=v] .vrow .vcol.vctrl{font-size:12px}.v[data-class=v] .vemoji,.v[data-class=v] .emoji{width:26px;height:26px;overflow:hidden;vertical-align:middle;margin:0 1px;display:inline-block}.v[data-class=v] .vwrap{border:1px solid #f0f0f0;border-radius:4px;margin-bottom:10px;overflow:hidden;position:relative;padding:10px}.v[data-class=v] .vwrap input{background:transparent}.v[data-class=v] .vwrap .vedit{position:relative;padding-top:10px}.v[data-class=v] .vwrap .cancel-reply-btn{position:absolute;right:5px;top:5px;cursor:pointer}.v[data-class=v] .vwrap .vemojis{display:none;font-size:18px;max-height:145px;overflow:auto;padding-bottom:10px;-webkit-box-shadow:0px 0 1px #f0f0f0;box-shadow:0px 0 1px #f0f0f0}.v[data-class=v] .vwrap .vemojis i{font-style:normal;padding-top:7px;width:36px;cursor:pointer;text-align:center;display:inline-block;vertical-align:middle}.v[data-class=v] .vwrap .vpreview{padding:7px;-webkit-box-shadow:0px 0 1px #f0f0f0;box-shadow:0px 0 1px #f0f0f0}.v[data-class=v] .vwrap .vheader .vinput{width:33.33%;border-bottom:1px #dedede dashed}.v[data-class=v] .vwrap .vheader.item2 .vinput{width:50%}.v[data-class=v] .vwrap .vheader.item1 .vinput{width:100%}.v[data-class=v] .vwrap .vheader .vinput:focus{border-bottom-color:#eb5055}@media screen and (max-width: 520px){.v[data-class=v] .vwrap .vheader .vinput{width:100%}.v[data-class=v] .vwrap .vheader.item2 .vinput{width:100%}}.v[data-class=v] .vpower{color:#999;font-size:.75em;padding:.5em 0}.v[data-class=v] .vpower a{font-size:.75em}.v[data-class=v] .vcount{padding:5px;font-weight:600;font-size:1.25em}.v[data-class=v] ul,.v[data-class=v] ol{padding:0;margin-left:1.25em}.v[data-class=v] .txt-center{text-align:center}.v[data-class=v] .txt-right{text-align:right}.v[data-class=v] .veditor{width:100%;min-height:8.75em;font-size:.875em;background:transparent;resize:vertical;-webkit-transition:all .25s ease;transition:all .25s ease}.v[data-class=v] .vbtn{-webkit-transition-duration:.4s;transition-duration:.4s;text-align:center;color:#555;border:1px solid #ededed;border-radius:.3em;display:inline-block;background:transparent;margin-bottom:0;font-weight:400;vertical-align:middle;-ms-touch-action:manipulation;touch-action:manipulation;cursor:pointer;white-space:nowrap;padding:.5em 1.25em;font-size:.875em;line-height:1.42857143;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:none}.v[data-class=v] .vbtn+.vbtn{margin-left:1.25em}.v[data-class=v] .vbtn:active,.v[data-class=v] .vbtn:hover{color:#3090e4;border-color:#3090e4}.v[data-class=v] .vbtn:disabled{border-color:#e1e1e1;color:#e1e1e1;background-color:#fdfafa;cursor:not-allowed}.v[data-class=v] .vempty{padding:1.25em;text-align:center;color:#555;overflow:auto}.v[data-class=v] .vsys{display:inline-block;padding:.2em .5em;font-size:.75em;border-radius:.2em;margin-right:.3em}@media screen and (max-width: 520px){.v[data-class=v] .vsys{display:none}}.v[data-class=v] .vcards{width:100%}.v[data-class=v] .vcards .vcard{padding-top:1.25em;position:relative;display:block}.v[data-class=v] .vcards .vcard:after{content:"";clear:both;display:block}.v[data-class=v] .vcards .vcard .vimg{width:3.125em;height:3.125em;float:left;border-radius:50%;margin-right:.7525em;border:1px solid #f5f5f5;padding:.125em}@media screen and (max-width: 720px){.v[data-class=v] .vcards .vcard .vimg{width:2.5em;height:2.5em}}.v[data-class=v] .vcards .vcard .vhead{line-height:1.5;margin-top:0}.v[data-class=v] .vcards .vcard .vhead .vnick{position:relative;font-size:.875em;font-weight:500;margin-right:.875em;cursor:pointer;text-decoration:none;display:inline-block}.v[data-class=v] .vcards .vcard .vhead .vnick:hover{color:#d7191a}.v[data-class=v] .vcards .vcard .vh{overflow:hidden;padding-bottom:.5em;border-bottom:1px dashed #f5f5f5}.v[data-class=v] .vcards .vcard .vh .vtime{font-size:.75em;margin-right:.875em}.v[data-class=v] .vcards .vcard .vh .vmeta{line-height:1;position:relative}.v[data-class=v] .vcards .vcard .vh .vmeta .vat{font-size:.8125em;color:#ef2f11;cursor:pointer;float:right}.v[data-class=v] .vcards .vcard:last-child .vh{border-bottom:none}.v[data-class=v] .vcards .vcard .vcontent{word-wrap:break-word;word-break:break-all;font-size:.875em;line-height:2;position:relative;margin-bottom:.75em;padding-top:.625em}.v[data-class=v] .vcards .vcard .vcontent.expand{cursor:pointer;max-height:8em;overflow:hidden}.v[data-class=v] .vcards .vcard .vcontent.expand::before{display:block;content:"";position:absolute;width:100%;left:0;top:0;bottom:3.15em;background:-webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0)), to(rgba(255, 255, 255, 0.9)));background:linear-gradient(180deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.9));z-index:999}.v[data-class=v] .vcards .vcard .vcontent.expand::after{display:block;content:attr(data-expand);text-align:center;color:#828586;position:absolute;width:100%;height:3.15em;line-height:3.15em;left:0;bottom:0;z-index:999;background:rgba(255,255,255,.9)}.v[data-class=v] .vcards .vcard .vquote{padding-left:1em;border-left:1px dashed rgba(238,238,238,.5)}.v[data-class=v] .vcards .vcard .vquote .vimg{width:2.225em;height:2.225em}.v[data-class=v] .vpage .vmore{margin:1em 0}.v[data-class=v] .clear{content:"";display:block;clear:both}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@-webkit-keyframes pulse{50%{background:#dcdcdc}}@keyframes pulse{50%{background:#dcdcdc}}.v[data-class=v] .vspinner{width:22px;height:22px;display:inline-block;border:6px double #a0a0a0;border-top-color:transparent;border-bottom-color:transparent;border-radius:50%;-webkit-animation:spin 1s infinite linear;animation:spin 1s infinite linear;position:relative;vertical-align:middle;margin:0 5px}[data-theme=dark] .v[data-class=v] .vinput,[data-theme=dark] .v[data-class=v] .veditor,[data-theme=dark] .v[data-class=v] p,[data-theme=dark] .v[data-class=v] pre code,[data-theme=dark] .v[data-class=v] .status-bar,.dark .v[data-class=v] .vinput,.dark .v[data-class=v] .veditor,.dark .v[data-class=v] p,.dark .v[data-class=v] pre code,.dark .v[data-class=v] .status-bar,.theme__dark .v[data-class=v] .vinput,.theme__dark .v[data-class=v] .veditor,.theme__dark .v[data-class=v] p,.theme__dark .v[data-class=v] pre code,.theme__dark .v[data-class=v] .status-bar,.night .v[data-class=v] .vinput,.night .v[data-class=v] .veditor,.night .v[data-class=v] p,.night .v[data-class=v] pre code,.night .v[data-class=v] .status-bar{color:#b2b2b5}[data-theme=dark] .v[data-class=v] .vtime,[data-theme=dark] .v[data-class=v] .vsys,.dark .v[data-class=v] .vtime,.dark .v[data-class=v] .vsys,.theme__dark .v[data-class=v] .vtime,.theme__dark .v[data-class=v] .vsys,.night .v[data-class=v] .vtime,.night .v[data-class=v] .vsys{color:#929298}[data-theme=dark] .v[data-class=v] pre,[data-theme=dark] .v[data-class=v] code,[data-theme=dark] .v[data-class=v] pre code,.dark .v[data-class=v] pre,.dark .v[data-class=v] code,.dark .v[data-class=v] pre code,.theme__dark .v[data-class=v] pre,.theme__dark .v[data-class=v] code,.theme__dark .v[data-class=v] pre code,.night .v[data-class=v] pre,.night .v[data-class=v] code,.night .v[data-class=v] pre code{color:#929298;background-color:#151414}[data-theme=dark] .v[data-class=v] .vwrap,.dark .v[data-class=v] .vwrap,.theme__dark .v[data-class=v] .vwrap,.night .v[data-class=v] .vwrap{border-color:#b2b2b5}[data-theme=dark] .v[data-class=v] .vicon,.dark .v[data-class=v] .vicon,.theme__dark .v[data-class=v] .vicon,.night .v[data-class=v] .vicon{fill:#b2b2b5}[data-theme=dark] .v[data-class=v] .vicon.actived,.dark .v[data-class=v] .vicon.actived,.theme__dark .v[data-class=v] .vicon.actived,.night .v[data-class=v] .vicon.actived{fill:#66b1ff}[data-theme=dark] .v[data-class=v] .vbtn,.dark .v[data-class=v] .vbtn,.theme__dark .v[data-class=v] .vbtn,.night .v[data-class=v] .vbtn{color:#b2b2b5;border-color:#b2b2b5}[data-theme=dark] .v[data-class=v] .vbtn:hover,.dark .v[data-class=v] .vbtn:hover,.theme__dark .v[data-class=v] .vbtn:hover,.night .v[data-class=v] .vbtn:hover{color:#66b1ff;border-color:#66b1ff}[data-theme=dark] .v[data-class=v] a:hover,.dark .v[data-class=v] a:hover,.theme__dark .v[data-class=v] a:hover,.night .v[data-class=v] a:hover{color:#d7191a}[data-theme=dark] .v[data-class=v] .vcards .vcard .vcontent.expand::before,.dark .v[data-class=v] .vcards .vcard .vcontent.expand::before,.theme__dark .v[data-class=v] .vcards .vcard .vcontent.expand::before,.night .v[data-class=v] .vcards .vcard .vcontent.expand::before{background:-webkit-gradient(linear, left top, left bottom, from(rgba(0, 0, 0, 0.3)), to(rgba(0, 0, 0, 0.7)));background:linear-gradient(180deg, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.7))}[data-theme=dark] .v[data-class=v] .vcards .vcard .vcontent.expand::after,.dark .v[data-class=v] .vcards .vcard .vcontent.expand::after,.theme__dark .v[data-class=v] .vcards .vcard .vcontent.expand::after,.night .v[data-class=v] .vcards .vcard .vcontent.expand::after{background:rgba(0,0,0,.7)}@media(prefers-color-scheme: dark){.v[data-class=v] .vinput,.v[data-class=v] .veditor,.v[data-class=v] p,.v[data-class=v] pre code,.v[data-class=v] .status-bar{color:#b2b2b5}.v[data-class=v] .vtime,.v[data-class=v] .vsys{color:#929298}.v[data-class=v] pre,.v[data-class=v] code,.v[data-class=v] pre code{color:#929298;background-color:#151414}.v[data-class=v] .vwrap{border-color:#b2b2b5}.v[data-class=v] .vicon{fill:#b2b2b5}.v[data-class=v] .vicon.actived{fill:#66b1ff}.v[data-class=v] .vbtn{color:#b2b2b5;border-color:#b2b2b5}.v[data-class=v] .vbtn:hover{color:#66b1ff;border-color:#66b1ff}.v[data-class=v] a:hover{color:#d7191a}.v[data-class=v] .vcards .vcard .vcontent.expand::before{background:-webkit-gradient(linear, left top, left bottom, from(rgba(0, 0, 0, 0.3)), to(rgba(0, 0, 0, 0.7)));background:linear-gradient(180deg, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.7))}.v[data-class=v] .vcards .vcard .vcontent.expand::after{background:rgba(0,0,0,.7)}}',""]),n.exports=e},function(n,e,t){"use strict";function a(n,e){var t=n[1]||"",a=n[3];if(!a)return t;if(e&&"function"==typeof btoa){var r=function(n){return"/*# ".concat("sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(n)))))," */")}(a);return[t].concat(a.sources.map((function(n){return"/*# sourceURL=".concat(a.sourceRoot||"").concat(n," */")}))).concat([r]).join("\n")}return[t].join("\n")}n.exports=function(n){var e=[];return e.toString=function(){return this.map((function(e){var t=a(e,n);return e[2]?"@media ".concat(e[2]," {").concat(t,"}"):t})).join("")},e.i=function(n,t,a){"string"==typeof n&&(n=[[null,n,""]]);var r={};if(a)for(var i=0;i<this.length;i++){var o=this[i][0];null!=o&&(r[o]=!0)}for(var s=0;s<n.length;s++){var l=[].concat(n[s]);a&&r[l[0]]||(t&&(l[2]?l[2]="".concat(t," and ").concat(l[2]):l[2]=t),e.push(l))}},e}},function(n,e,t){function a(n,e){for(var t=0;t<n.length;t++){var a=n[t],r=f[a.id];if(r){r.refs++;for(var i=0;i<r.parts.length;i++)r.parts[i](a.parts[i]);for(;i<a.parts.length;i++)r.parts.push(u(a.parts[i],e))}else{var o=[];for(i=0;i<a.parts.length;i++)o.push(u(a.parts[i],e));f[a.id]={id:a.id,refs:1,parts:o}}}}function r(n,e){for(var t=[],a={},r=0;r<n.length;r++){var i=n[r],o=e.base?i[0]+e.base:i[0],s={css:i[1],media:i[2],sourceMap:i[3]};a[o]?a[o].parts.push(s):t.push(a[o]={id:o,parts:[s]})}return t}function i(n,e){var t=g(n.insertInto);if(!t)throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");var a=b[b.length-1];if("top"===n.insertAt)a?a.nextSibling?t.insertBefore(e,a.nextSibling):t.appendChild(e):t.insertBefore(e,t.firstChild),b.push(e);else{if("bottom"!==n.insertAt)throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");t.appendChild(e)}}function o(n){if(null===n.parentNode)return!1;n.parentNode.removeChild(n);var e=b.indexOf(n);e>=0&&b.splice(e,1)}function s(n){var e=document.createElement("style");return n.attrs.type="text/css",c(e,n.attrs),i(n,e),e}function l(n){var e=document.createElement("link");return n.attrs.type="text/css",n.attrs.rel="stylesheet",c(e,n.attrs),i(n,e),e}function c(n,e){Object.keys(e).forEach((function(t){n.setAttribute(t,e[t])}))}function u(n,e){var t,a,r,i;if(e.transform&&n.css){if(!(i=e.transform(n.css)))return function(){};n.css=i}if(e.singleton){var c=y++;t=v||(v=s(e)),a=d.bind(null,t,c,!1),r=d.bind(null,t,c,!0)}else n.sourceMap&&"function"==typeof URL&&"function"==typeof URL.createObjectURL&&"function"==typeof URL.revokeObjectURL&&"function"==typeof Blob&&"function"==typeof btoa?(t=l(e),a=h.bind(null,t,e),r=function(){o(t),t.href&&URL.revokeObjectURL(t.href)}):(t=s(e),a=p.bind(null,t),r=function(){o(t)});return a(n),function(e){if(e){if(e.css===n.css&&e.media===n.media&&e.sourceMap===n.sourceMap)return;a(n=e)}else r()}}function d(n,e,t,a){var r=t?"":a.css;if(n.styleSheet)n.styleSheet.cssText=w(e,r);else{var i=document.createTextNode(r),o=n.childNodes;o[e]&&n.removeChild(o[e]),o.length?n.insertBefore(i,o[e]):n.appendChild(i)}}function p(n,e){var t=e.css,a=e.media;if(a&&n.setAttribute("media",a),n.styleSheet)n.styleSheet.cssText=t;else{for(;n.firstChild;)n.removeChild(n.firstChild);n.appendChild(document.createTextNode(t))}}function h(n,e,t){var a=t.css,r=t.sourceMap,i=void 0===e.convertToAbsoluteUrls&&r;(e.convertToAbsoluteUrls||i)&&(a=k(a)),r&&(a+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(r))))+" */");var o=new Blob([a],{type:"text/css"}),s=n.href;n.href=URL.createObjectURL(o),s&&URL.revokeObjectURL(s)}var f={},m=function(n){var e;return function(){return void 0===e&&(e=n.apply(this,arguments)),e}}((function(){return window&&document&&document.all&&!window.atob})),g=function(n){var e={};return function(t){return void 0===e[t]&&(e[t]=n.call(this,t)),e[t]}}((function(n){return document.querySelector(n)})),v=null,y=0,b=[],k=t(107);n.exports=function(n,e){if("undefined"!=typeof DEBUG&&DEBUG&&"object"!=typeof document)throw new Error("The style-loader cannot be used in a non-browser environment");(e=e||{}).attrs="object"==typeof e.attrs?e.attrs:{},e.singleton||(e.singleton=m()),e.insertInto||(e.insertInto="head"),e.insertAt||(e.insertAt="bottom");var t=r(n,e);return a(t,e),function(n){for(var i=[],o=0;o<t.length;o++){var s=t[o];(l=f[s.id]).refs--,i.push(l)}for(n&&a(r(n,e),e),o=0;o<i.length;o++){var l;if(0===(l=i[o]).refs){for(var c=0;c<l.parts.length;c++)l.parts[c]();delete f[l.id]}}}};var w=function(){var n=[];return function(e,t){return n[e]=t,n.filter(Boolean).join("\n")}}()},function(n,e){n.exports=function(n){var e="undefined"!=typeof window&&window.location;if(!e)throw new Error("fixUrls requires window.location");if(!n||"string"!=typeof n)return n;var t=e.protocol+"//"+e.host,a=t+e.pathname.replace(/\/[^\/]*$/,"/");return n.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi,(function(n,e){var r,i=e.trim().replace(/^"(.*)"$/,(function(n,e){return e})).replace(/^'(.*)'$/,(function(n,e){return e}));return/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(i)?n:(r=0===i.indexOf("//")?i:0===i.indexOf("/")?t+i:a+i.replace(/^\.\//,""),"url("+JSON.stringify(r)+")")}))}},function(n,e,t){t(103),n.exports=t(34)}])},function(n,e,t){"use strict";t(110)},function(n,e,t){"use strict";var a=t(287),r=t(111),i=t(61),o=Object.prototype.hasOwnProperty,s={brackets:function(n){return n+"[]"},comma:"comma",indices:function(n,e){return n+"["+e+"]"},repeat:function(n){return n}},l=Array.isArray,c=String.prototype.split,u=Array.prototype.push,d=function(n,e){u.apply(n,l(e)?e:[e])},p=Date.prototype.toISOString,h=i.default,f={addQueryPrefix:!1,allowDots:!1,charset:"utf-8",charsetSentinel:!1,delimiter:"&",encode:!0,encoder:r.encode,encodeValuesOnly:!1,format:h,formatter:i.formatters[h],indices:!1,serializeDate:function(n){return p.call(n)},skipNulls:!1,strictNullHandling:!1},m={},g=function n(e,t,i,o,s,u,p,h,g,v,y,b,k,w,x,S){for(var _,j=e,T=S,C=0,A=!1;void 0!==(T=T.get(m))&&!A;){var I=T.get(e);if(C+=1,void 0!==I){if(I===C)throw new RangeError("Cyclic object value");A=!0}void 0===T.get(m)&&(C=0)}if("function"==typeof h?j=h(t,j):j instanceof Date?j=y(j):"comma"===i&&l(j)&&(j=r.maybeMap(j,(function(n){return n instanceof Date?y(n):n}))),null===j){if(s)return p&&!w?p(t,f.encoder,x,"key",b):t;j=""}if("string"==typeof(_=j)||"number"==typeof _||"boolean"==typeof _||"symbol"==typeof _||"bigint"==typeof _||r.isBuffer(j)){if(p){var E=w?t:p(t,f.encoder,x,"key",b);if("comma"===i&&w){for(var O=c.call(String(j),","),L="",$=0;$<O.length;++$)L+=(0===$?"":",")+k(p(O[$],f.encoder,x,"value",b));return[k(E)+(o&&l(j)&&1===O.length?"[]":"")+"="+L]}return[k(E)+"="+k(p(j,f.encoder,x,"value",b))]}return[k(t)+"="+k(String(j))]}var P,z=[];if(void 0===j)return z;if("comma"===i&&l(j))P=[{value:j.length>0?j.join(",")||null:void 0}];else if(l(h))P=h;else{var D=Object.keys(j);P=g?D.sort(g):D}for(var M=o&&l(j)&&1===j.length?t+"[]":t,F=0;F<P.length;++F){var R=P[F],q="object"==typeof R&&void 0!==R.value?R.value:j[R];if(!u||null!==q){var N=l(j)?"function"==typeof i?i(M,R):M:M+(v?"."+R:"["+R+"]");S.set(e,C);var B=a();B.set(m,S),d(z,n(q,N,i,o,s,u,p,h,g,v,y,b,k,w,x,B))}}return z};n.exports=function(n,e){var t,r=n,c=function(n){if(!n)return f;if(null!==n.encoder&&void 0!==n.encoder&&"function"!=typeof n.encoder)throw new TypeError("Encoder has to be a function.");var e=n.charset||f.charset;if(void 0!==n.charset&&"utf-8"!==n.charset&&"iso-8859-1"!==n.charset)throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");var t=i.default;if(void 0!==n.format){if(!o.call(i.formatters,n.format))throw new TypeError("Unknown format option provided.");t=n.format}var a=i.formatters[t],r=f.filter;return("function"==typeof n.filter||l(n.filter))&&(r=n.filter),{addQueryPrefix:"boolean"==typeof n.addQueryPrefix?n.addQueryPrefix:f.addQueryPrefix,allowDots:void 0===n.allowDots?f.allowDots:!!n.allowDots,charset:e,charsetSentinel:"boolean"==typeof n.charsetSentinel?n.charsetSentinel:f.charsetSentinel,delimiter:void 0===n.delimiter?f.delimiter:n.delimiter,encode:"boolean"==typeof n.encode?n.encode:f.encode,encoder:"function"==typeof n.encoder?n.encoder:f.encoder,encodeValuesOnly:"boolean"==typeof n.encodeValuesOnly?n.encodeValuesOnly:f.encodeValuesOnly,filter:r,format:t,formatter:a,serializeDate:"function"==typeof n.serializeDate?n.serializeDate:f.serializeDate,skipNulls:"boolean"==typeof n.skipNulls?n.skipNulls:f.skipNulls,sort:"function"==typeof n.sort?n.sort:null,strictNullHandling:"boolean"==typeof n.strictNullHandling?n.strictNullHandling:f.strictNullHandling}}(e);"function"==typeof c.filter?r=(0,c.filter)("",r):l(c.filter)&&(t=c.filter);var u,p=[];if("object"!=typeof r||null===r)return"";u=e&&e.arrayFormat in s?e.arrayFormat:e&&"indices"in e?e.indices?"indices":"repeat":"indices";var h=s[u];if(e&&"commaRoundTrip"in e&&"boolean"!=typeof e.commaRoundTrip)throw new TypeError("`commaRoundTrip` must be a boolean, or absent");var m="comma"===h&&e&&e.commaRoundTrip;t||(t=Object.keys(r)),c.sort&&t.sort(c.sort);for(var v=a(),y=0;y<t.length;++y){var b=t[y];c.skipNulls&&null===r[b]||d(p,g(r[b],b,h,m,c.strictNullHandling,c.skipNulls,c.encode?c.encoder:null,c.filter,c.sort,c.allowDots,c.serializeDate,c.format,c.formatter,c.encodeValuesOnly,c.charset,v))}var k=p.join(c.delimiter),w=!0===c.addQueryPrefix?"?":"";return c.charsetSentinel&&("iso-8859-1"===c.charset?w+="utf8=%26%2310003%3B&":w+="utf8=%E2%9C%93&"),k.length>0?w+k:""}},function(n,e,t){"use strict";var a=t(59),r=t(292),i=t(294),o=a("%TypeError%"),s=a("%WeakMap%",!0),l=a("%Map%",!0),c=r("WeakMap.prototype.get",!0),u=r("WeakMap.prototype.set",!0),d=r("WeakMap.prototype.has",!0),p=r("Map.prototype.get",!0),h=r("Map.prototype.set",!0),f=r("Map.prototype.has",!0),m=function(n,e){for(var t,a=n;null!==(t=a.next);a=t)if(t.key===e)return a.next=t.next,t.next=n.next,n.next=t,t};n.exports=function(){var n,e,t,a={assert:function(n){if(!a.has(n))throw new o("Side channel does not contain "+i(n))},get:function(a){if(s&&a&&("object"==typeof a||"function"==typeof a)){if(n)return c(n,a)}else if(l){if(e)return p(e,a)}else if(t)return function(n,e){var t=m(n,e);return t&&t.value}(t,a)},has:function(a){if(s&&a&&("object"==typeof a||"function"==typeof a)){if(n)return d(n,a)}else if(l){if(e)return f(e,a)}else if(t)return function(n,e){return!!m(n,e)}(t,a);return!1},set:function(a,r){s&&a&&("object"==typeof a||"function"==typeof a)?(n||(n=new s),u(n,a,r)):l?(e||(e=new l),h(e,a,r)):(t||(t={key:{},next:null}),function(n,e,t){var a=m(n,e);a?a.value=t:n.next={key:e,next:n.next,value:t}}(t,a,r))}};return a}},function(n,e,t){"use strict";var a="undefined"!=typeof Symbol&&Symbol,r=t(289);n.exports=function(){return"function"==typeof a&&("function"==typeof Symbol&&("symbol"==typeof a("foo")&&("symbol"==typeof Symbol("bar")&&r())))}},function(n,e,t){"use strict";n.exports=function(){if("function"!=typeof Symbol||"function"!=typeof Object.getOwnPropertySymbols)return!1;if("symbol"==typeof Symbol.iterator)return!0;var n={},e=Symbol("test"),t=Object(e);if("string"==typeof e)return!1;if("[object Symbol]"!==Object.prototype.toString.call(e))return!1;if("[object Symbol]"!==Object.prototype.toString.call(t))return!1;for(e in n[e]=42,n)return!1;if("function"==typeof Object.keys&&0!==Object.keys(n).length)return!1;if("function"==typeof Object.getOwnPropertyNames&&0!==Object.getOwnPropertyNames(n).length)return!1;var a=Object.getOwnPropertySymbols(n);if(1!==a.length||a[0]!==e)return!1;if(!Object.prototype.propertyIsEnumerable.call(n,e))return!1;if("function"==typeof Object.getOwnPropertyDescriptor){var r=Object.getOwnPropertyDescriptor(n,e);if(42!==r.value||!0!==r.enumerable)return!1}return!0}},function(n,e,t){"use strict";var a="Function.prototype.bind called on incompatible ",r=Array.prototype.slice,i=Object.prototype.toString;n.exports=function(n){var e=this;if("function"!=typeof e||"[object Function]"!==i.call(e))throw new TypeError(a+e);for(var t,o=r.call(arguments,1),s=function(){if(this instanceof t){var a=e.apply(this,o.concat(r.call(arguments)));return Object(a)===a?a:this}return e.apply(n,o.concat(r.call(arguments)))},l=Math.max(0,e.length-o.length),c=[],u=0;u<l;u++)c.push("$"+u);if(t=Function("binder","return function ("+c.join(",")+"){ return binder.apply(this,arguments); }")(s),e.prototype){var d=function(){};d.prototype=e.prototype,t.prototype=new d,d.prototype=null}return t}},function(n,e,t){"use strict";var a=t(60);n.exports=a.call(Function.call,Object.prototype.hasOwnProperty)},function(n,e,t){"use strict";var a=t(59),r=t(293),i=r(a("String.prototype.indexOf"));n.exports=function(n,e){var t=a(n,!!e);return"function"==typeof t&&i(n,".prototype.")>-1?r(t):t}},function(n,e,t){"use strict";var a=t(60),r=t(59),i=r("%Function.prototype.apply%"),o=r("%Function.prototype.call%"),s=r("%Reflect.apply%",!0)||a.call(o,i),l=r("%Object.getOwnPropertyDescriptor%",!0),c=r("%Object.defineProperty%",!0),u=r("%Math.max%");if(c)try{c({},"a",{value:1})}catch(n){c=null}n.exports=function(n){var e=s(a,o,arguments);if(l&&c){var t=l(e,"length");t.configurable&&c(e,"length",{value:1+u(0,n.length-(arguments.length-1))})}return e};var d=function(){return s(a,i,arguments)};c?c(n.exports,"apply",{value:d}):n.exports.apply=d},function(n,e,t){var a="function"==typeof Map&&Map.prototype,r=Object.getOwnPropertyDescriptor&&a?Object.getOwnPropertyDescriptor(Map.prototype,"size"):null,i=a&&r&&"function"==typeof r.get?r.get:null,o=a&&Map.prototype.forEach,s="function"==typeof Set&&Set.prototype,l=Object.getOwnPropertyDescriptor&&s?Object.getOwnPropertyDescriptor(Set.prototype,"size"):null,c=s&&l&&"function"==typeof l.get?l.get:null,u=s&&Set.prototype.forEach,d="function"==typeof WeakMap&&WeakMap.prototype?WeakMap.prototype.has:null,p="function"==typeof WeakSet&&WeakSet.prototype?WeakSet.prototype.has:null,h="function"==typeof WeakRef&&WeakRef.prototype?WeakRef.prototype.deref:null,f=Boolean.prototype.valueOf,m=Object.prototype.toString,g=Function.prototype.toString,v=String.prototype.match,y=String.prototype.slice,b=String.prototype.replace,k=String.prototype.toUpperCase,w=String.prototype.toLowerCase,x=RegExp.prototype.test,S=Array.prototype.concat,_=Array.prototype.join,j=Array.prototype.slice,T=Math.floor,C="function"==typeof BigInt?BigInt.prototype.valueOf:null,A=Object.getOwnPropertySymbols,I="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?Symbol.prototype.toString:null,E="function"==typeof Symbol&&"object"==typeof Symbol.iterator,O="function"==typeof Symbol&&Symbol.toStringTag&&(typeof Symbol.toStringTag===E||"symbol")?Symbol.toStringTag:null,L=Object.prototype.propertyIsEnumerable,$=("function"==typeof Reflect?Reflect.getPrototypeOf:Object.getPrototypeOf)||([].__proto__===Array.prototype?function(n){return n.__proto__}:null);function P(n,e){if(n===1/0||n===-1/0||n!=n||n&&n>-1e3&&n<1e3||x.call(/e/,e))return e;var t=/[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;if("number"==typeof n){var a=n<0?-T(-n):T(n);if(a!==n){var r=String(a),i=y.call(e,r.length+1);return b.call(r,t,"$&_")+"."+b.call(b.call(i,/([0-9]{3})/g,"$&_"),/_$/,"")}}return b.call(e,t,"$&_")}var z=t(295),D=z.custom,M=B(D)?D:null;function F(n,e,t){var a="double"===(t.quoteStyle||e)?'"':"'";return a+n+a}function R(n){return b.call(String(n),/"/g,"&quot;")}function q(n){return!("[object Array]"!==V(n)||O&&"object"==typeof n&&O in n)}function N(n){return!("[object RegExp]"!==V(n)||O&&"object"==typeof n&&O in n)}function B(n){if(E)return n&&"object"==typeof n&&n instanceof Symbol;if("symbol"==typeof n)return!0;if(!n||"object"!=typeof n||!I)return!1;try{return I.call(n),!0}catch(n){}return!1}n.exports=function n(e,t,a,r){var s=t||{};if(J(s,"quoteStyle")&&"single"!==s.quoteStyle&&"double"!==s.quoteStyle)throw new TypeError('option "quoteStyle" must be "single" or "double"');if(J(s,"maxStringLength")&&("number"==typeof s.maxStringLength?s.maxStringLength<0&&s.maxStringLength!==1/0:null!==s.maxStringLength))throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');var l=!J(s,"customInspect")||s.customInspect;if("boolean"!=typeof l&&"symbol"!==l)throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");if(J(s,"indent")&&null!==s.indent&&"\t"!==s.indent&&!(parseInt(s.indent,10)===s.indent&&s.indent>0))throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');if(J(s,"numericSeparator")&&"boolean"!=typeof s.numericSeparator)throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');var m=s.numericSeparator;if(void 0===e)return"undefined";if(null===e)return"null";if("boolean"==typeof e)return e?"true":"false";if("string"==typeof e)return function n(e,t){if(e.length>t.maxStringLength){var a=e.length-t.maxStringLength,r="... "+a+" more character"+(a>1?"s":"");return n(y.call(e,0,t.maxStringLength),t)+r}return F(b.call(b.call(e,/(['\\])/g,"\\$1"),/[\x00-\x1f]/g,H),"single",t)}(e,s);if("number"==typeof e){if(0===e)return 1/0/e>0?"0":"-0";var k=String(e);return m?P(e,k):k}if("bigint"==typeof e){var x=String(e)+"n";return m?P(e,x):x}var T=void 0===s.depth?5:s.depth;if(void 0===a&&(a=0),a>=T&&T>0&&"object"==typeof e)return q(e)?"[Array]":"[Object]";var A=function(n,e){var t;if("\t"===n.indent)t="\t";else{if(!("number"==typeof n.indent&&n.indent>0))return null;t=_.call(Array(n.indent+1)," ")}return{base:t,prev:_.call(Array(e+1),t)}}(s,a);if(void 0===r)r=[];else if(W(r,e)>=0)return"[Circular]";function D(e,t,i){if(t&&(r=j.call(r)).push(t),i){var o={depth:s.depth};return J(s,"quoteStyle")&&(o.quoteStyle=s.quoteStyle),n(e,o,a+1,r)}return n(e,s,a+1,r)}if("function"==typeof e&&!N(e)){var U=function(n){if(n.name)return n.name;var e=v.call(g.call(n),/^function\s*([\w$]+)/);if(e)return e[1];return null}(e),Z=X(e,D);return"[Function"+(U?": "+U:" (anonymous)")+"]"+(Z.length>0?" { "+_.call(Z,", ")+" }":"")}if(B(e)){var nn=E?b.call(String(e),/^(Symbol\(.*\))_[^)]*$/,"$1"):I.call(e);return"object"!=typeof e||E?nn:Q(nn)}if(function(n){if(!n||"object"!=typeof n)return!1;if("undefined"!=typeof HTMLElement&&n instanceof HTMLElement)return!0;return"string"==typeof n.nodeName&&"function"==typeof n.getAttribute}(e)){for(var en="<"+w.call(String(e.nodeName)),tn=e.attributes||[],an=0;an<tn.length;an++)en+=" "+tn[an].name+"="+F(R(tn[an].value),"double",s);return en+=">",e.childNodes&&e.childNodes.length&&(en+="..."),en+="</"+w.call(String(e.nodeName))+">"}if(q(e)){if(0===e.length)return"[]";var rn=X(e,D);return A&&!function(n){for(var e=0;e<n.length;e++)if(W(n[e],"\n")>=0)return!1;return!0}(rn)?"["+Y(rn,A)+"]":"[ "+_.call(rn,", ")+" ]"}if(function(n){return!("[object Error]"!==V(n)||O&&"object"==typeof n&&O in n)}(e)){var on=X(e,D);return"cause"in Error.prototype||!("cause"in e)||L.call(e,"cause")?0===on.length?"["+String(e)+"]":"{ ["+String(e)+"] "+_.call(on,", ")+" }":"{ ["+String(e)+"] "+_.call(S.call("[cause]: "+D(e.cause),on),", ")+" }"}if("object"==typeof e&&l){if(M&&"function"==typeof e[M]&&z)return z(e,{depth:T-a});if("symbol"!==l&&"function"==typeof e.inspect)return e.inspect()}if(function(n){if(!i||!n||"object"!=typeof n)return!1;try{i.call(n);try{c.call(n)}catch(n){return!0}return n instanceof Map}catch(n){}return!1}(e)){var sn=[];return o&&o.call(e,(function(n,t){sn.push(D(t,e,!0)+" => "+D(n,e))})),K("Map",i.call(e),sn,A)}if(function(n){if(!c||!n||"object"!=typeof n)return!1;try{c.call(n);try{i.call(n)}catch(n){return!0}return n instanceof Set}catch(n){}return!1}(e)){var ln=[];return u&&u.call(e,(function(n){ln.push(D(n,e))})),K("Set",c.call(e),ln,A)}if(function(n){if(!d||!n||"object"!=typeof n)return!1;try{d.call(n,d);try{p.call(n,p)}catch(n){return!0}return n instanceof WeakMap}catch(n){}return!1}(e))return G("WeakMap");if(function(n){if(!p||!n||"object"!=typeof n)return!1;try{p.call(n,p);try{d.call(n,d)}catch(n){return!0}return n instanceof WeakSet}catch(n){}return!1}(e))return G("WeakSet");if(function(n){if(!h||!n||"object"!=typeof n)return!1;try{return h.call(n),!0}catch(n){}return!1}(e))return G("WeakRef");if(function(n){return!("[object Number]"!==V(n)||O&&"object"==typeof n&&O in n)}(e))return Q(D(Number(e)));if(function(n){if(!n||"object"!=typeof n||!C)return!1;try{return C.call(n),!0}catch(n){}return!1}(e))return Q(D(C.call(e)));if(function(n){return!("[object Boolean]"!==V(n)||O&&"object"==typeof n&&O in n)}(e))return Q(f.call(e));if(function(n){return!("[object String]"!==V(n)||O&&"object"==typeof n&&O in n)}(e))return Q(D(String(e)));if(!function(n){return!("[object Date]"!==V(n)||O&&"object"==typeof n&&O in n)}(e)&&!N(e)){var cn=X(e,D),un=$?$(e)===Object.prototype:e instanceof Object||e.constructor===Object,dn=e instanceof Object?"":"null prototype",pn=!un&&O&&Object(e)===e&&O in e?y.call(V(e),8,-1):dn?"Object":"",hn=(un||"function"!=typeof e.constructor?"":e.constructor.name?e.constructor.name+" ":"")+(pn||dn?"["+_.call(S.call([],pn||[],dn||[]),": ")+"] ":"");return 0===cn.length?hn+"{}":A?hn+"{"+Y(cn,A)+"}":hn+"{ "+_.call(cn,", ")+" }"}return String(e)};var U=Object.prototype.hasOwnProperty||function(n){return n in this};function J(n,e){return U.call(n,e)}function V(n){return m.call(n)}function W(n,e){if(n.indexOf)return n.indexOf(e);for(var t=0,a=n.length;t<a;t++)if(n[t]===e)return t;return-1}function H(n){var e=n.charCodeAt(0),t={8:"b",9:"t",10:"n",12:"f",13:"r"}[e];return t?"\\"+t:"\\x"+(e<16?"0":"")+k.call(e.toString(16))}function Q(n){return"Object("+n+")"}function G(n){return n+" { ? }"}function K(n,e,t,a){return n+" ("+e+") {"+(a?Y(t,a):_.call(t,", "))+"}"}function Y(n,e){if(0===n.length)return"";var t="\n"+e.prev+e.base;return t+_.call(n,","+t)+"\n"+e.prev}function X(n,e){var t=q(n),a=[];if(t){a.length=n.length;for(var r=0;r<n.length;r++)a[r]=J(n,r)?e(n[r],n):""}var i,o="function"==typeof A?A(n):[];if(E){i={};for(var s=0;s<o.length;s++)i["$"+o[s]]=o[s]}for(var l in n)J(n,l)&&(t&&String(Number(l))===l&&l<n.length||E&&i["$"+l]instanceof Symbol||(x.call(/[^\w$]/,l)?a.push(e(l,n)+": "+e(n[l],n)):a.push(l+": "+e(n[l],n))));if("function"==typeof A)for(var c=0;c<o.length;c++)L.call(n,o[c])&&a.push("["+e(o[c])+"]: "+e(n[o[c]],n));return a}},function(n,e){},function(n,e,t){"use strict";var a=t(111),r=Object.prototype.hasOwnProperty,i=Array.isArray,o={allowDots:!1,allowPrototypes:!1,allowSparse:!1,arrayLimit:20,charset:"utf-8",charsetSentinel:!1,comma:!1,decoder:a.decode,delimiter:"&",depth:5,ignoreQueryPrefix:!1,interpretNumericEntities:!1,parameterLimit:1e3,parseArrays:!0,plainObjects:!1,strictNullHandling:!1},s=function(n){return n.replace(/&#(\d+);/g,(function(n,e){return String.fromCharCode(parseInt(e,10))}))},l=function(n,e){return n&&"string"==typeof n&&e.comma&&n.indexOf(",")>-1?n.split(","):n},c=function(n,e,t,a){if(n){var i=t.allowDots?n.replace(/\.([^.[]+)/g,"[$1]"):n,o=/(\[[^[\]]*])/g,s=t.depth>0&&/(\[[^[\]]*])/.exec(i),c=s?i.slice(0,s.index):i,u=[];if(c){if(!t.plainObjects&&r.call(Object.prototype,c)&&!t.allowPrototypes)return;u.push(c)}for(var d=0;t.depth>0&&null!==(s=o.exec(i))&&d<t.depth;){if(d+=1,!t.plainObjects&&r.call(Object.prototype,s[1].slice(1,-1))&&!t.allowPrototypes)return;u.push(s[1])}return s&&u.push("["+i.slice(s.index)+"]"),function(n,e,t,a){for(var r=a?e:l(e,t),i=n.length-1;i>=0;--i){var o,s=n[i];if("[]"===s&&t.parseArrays)o=[].concat(r);else{o=t.plainObjects?Object.create(null):{};var c="["===s.charAt(0)&&"]"===s.charAt(s.length-1)?s.slice(1,-1):s,u=parseInt(c,10);t.parseArrays||""!==c?!isNaN(u)&&s!==c&&String(u)===c&&u>=0&&t.parseArrays&&u<=t.arrayLimit?(o=[])[u]=r:"__proto__"!==c&&(o[c]=r):o={0:r}}r=o}return r}(u,e,t,a)}};n.exports=function(n,e){var t=function(n){if(!n)return o;if(null!==n.decoder&&void 0!==n.decoder&&"function"!=typeof n.decoder)throw new TypeError("Decoder has to be a function.");if(void 0!==n.charset&&"utf-8"!==n.charset&&"iso-8859-1"!==n.charset)throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");var e=void 0===n.charset?o.charset:n.charset;return{allowDots:void 0===n.allowDots?o.allowDots:!!n.allowDots,allowPrototypes:"boolean"==typeof n.allowPrototypes?n.allowPrototypes:o.allowPrototypes,allowSparse:"boolean"==typeof n.allowSparse?n.allowSparse:o.allowSparse,arrayLimit:"number"==typeof n.arrayLimit?n.arrayLimit:o.arrayLimit,charset:e,charsetSentinel:"boolean"==typeof n.charsetSentinel?n.charsetSentinel:o.charsetSentinel,comma:"boolean"==typeof n.comma?n.comma:o.comma,decoder:"function"==typeof n.decoder?n.decoder:o.decoder,delimiter:"string"==typeof n.delimiter||a.isRegExp(n.delimiter)?n.delimiter:o.delimiter,depth:"number"==typeof n.depth||!1===n.depth?+n.depth:o.depth,ignoreQueryPrefix:!0===n.ignoreQueryPrefix,interpretNumericEntities:"boolean"==typeof n.interpretNumericEntities?n.interpretNumericEntities:o.interpretNumericEntities,parameterLimit:"number"==typeof n.parameterLimit?n.parameterLimit:o.parameterLimit,parseArrays:!1!==n.parseArrays,plainObjects:"boolean"==typeof n.plainObjects?n.plainObjects:o.plainObjects,strictNullHandling:"boolean"==typeof n.strictNullHandling?n.strictNullHandling:o.strictNullHandling}}(e);if(""===n||null==n)return t.plainObjects?Object.create(null):{};for(var u="string"==typeof n?function(n,e){var t,c={},u=e.ignoreQueryPrefix?n.replace(/^\?/,""):n,d=e.parameterLimit===1/0?void 0:e.parameterLimit,p=u.split(e.delimiter,d),h=-1,f=e.charset;if(e.charsetSentinel)for(t=0;t<p.length;++t)0===p[t].indexOf("utf8=")&&("utf8=%E2%9C%93"===p[t]?f="utf-8":"utf8=%26%2310003%3B"===p[t]&&(f="iso-8859-1"),h=t,t=p.length);for(t=0;t<p.length;++t)if(t!==h){var m,g,v=p[t],y=v.indexOf("]="),b=-1===y?v.indexOf("="):y+1;-1===b?(m=e.decoder(v,o.decoder,f,"key"),g=e.strictNullHandling?null:""):(m=e.decoder(v.slice(0,b),o.decoder,f,"key"),g=a.maybeMap(l(v.slice(b+1),e),(function(n){return e.decoder(n,o.decoder,f,"value")}))),g&&e.interpretNumericEntities&&"iso-8859-1"===f&&(g=s(g)),v.indexOf("[]=")>-1&&(g=i(g)?[g]:g),r.call(c,m)?c[m]=a.combine(c[m],g):c[m]=g}return c}(n,t):n,d=t.plainObjects?Object.create(null):{},p=Object.keys(u),h=0;h<p.length;++h){var f=p[h],m=c(f,u[f],t,"string"==typeof n);d=a.merge(d,m,t)}return!0===t.allowSparse?d:a.compact(d)}},function(n,e,t){var a=t(16),r=t(299),i=t(300);n.exports=function(n){var e=a(n);return i(e,r(e))+1}},function(n,e){n.exports=function(n){var e=new Date(n.getTime()),t=e.getTimezoneOffset();return e.setSeconds(0,0),6e4*t+e.getTime()%6e4}},function(n,e,t){var a=t(16);n.exports=function(n){var e=a(n),t=new Date(0);return t.setFullYear(e.getFullYear(),0,1),t.setHours(0,0,0,0),t}},function(n,e,t){var a=t(301);n.exports=function(n,e){var t=a(n),r=a(e),i=t.getTime()-6e4*t.getTimezoneOffset(),o=r.getTime()-6e4*r.getTimezoneOffset();return Math.round((i-o)/864e5)}},function(n,e,t){var a=t(16);n.exports=function(n){var e=a(n);return e.setHours(0,0,0,0),e}},function(n,e,t){var a=t(16),r=t(62),i=t(304);n.exports=function(n){var e=a(n),t=r(e).getTime()-i(e).getTime();return Math.round(t/6048e5)+1}},function(n,e,t){var a=t(16);n.exports=function(n,e){var t=e&&Number(e.weekStartsOn)||0,r=a(n),i=r.getDay(),o=(i<t?7:0)+i-t;return r.setDate(r.getDate()-o),r.setHours(0,0,0,0),r}},function(n,e,t){var a=t(113),r=t(62);n.exports=function(n){var e=a(n),t=new Date(0);return t.setFullYear(e,0,4),t.setHours(0,0,0,0),r(t)}},function(n,e,t){var a=t(112);n.exports=function(n){if(a(n))return!isNaN(n);throw new TypeError(toString.call(n)+" is not an instance of Date")}},function(n,e,t){var a=t(307),r=t(308);n.exports={distanceInWords:a(),format:r()}},function(n,e){n.exports=function(){var n={lessThanXSeconds:{one:"less than a second",other:"less than {{count}} seconds"},xSeconds:{one:"1 second",other:"{{count}} seconds"},halfAMinute:"half a minute",lessThanXMinutes:{one:"less than a minute",other:"less than {{count}} minutes"},xMinutes:{one:"1 minute",other:"{{count}} minutes"},aboutXHours:{one:"about 1 hour",other:"about {{count}} hours"},xHours:{one:"1 hour",other:"{{count}} hours"},xDays:{one:"1 day",other:"{{count}} days"},aboutXMonths:{one:"about 1 month",other:"about {{count}} months"},xMonths:{one:"1 month",other:"{{count}} months"},aboutXYears:{one:"about 1 year",other:"about {{count}} years"},xYears:{one:"1 year",other:"{{count}} years"},overXYears:{one:"over 1 year",other:"over {{count}} years"},almostXYears:{one:"almost 1 year",other:"almost {{count}} years"}};return{localize:function(e,t,a){var r;return a=a||{},r="string"==typeof n[e]?n[e]:1===t?n[e].one:n[e].other.replace("{{count}}",t),a.addSuffix?a.comparison>0?"in "+r:r+" ago":r}}}},function(n,e,t){var a=t(309);n.exports=function(){var n=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],e=["January","February","March","April","May","June","July","August","September","October","November","December"],t=["Su","Mo","Tu","We","Th","Fr","Sa"],r=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],i=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],o=["AM","PM"],s=["am","pm"],l=["a.m.","p.m."],c={MMM:function(e){return n[e.getMonth()]},MMMM:function(n){return e[n.getMonth()]},dd:function(n){return t[n.getDay()]},ddd:function(n){return r[n.getDay()]},dddd:function(n){return i[n.getDay()]},A:function(n){return n.getHours()/12>=1?o[1]:o[0]},a:function(n){return n.getHours()/12>=1?s[1]:s[0]},aa:function(n){return n.getHours()/12>=1?l[1]:l[0]}};return["M","D","DDD","d","Q","W"].forEach((function(n){c[n+"o"]=function(e,t){return function(n){var e=n%100;if(e>20||e<10)switch(e%10){case 1:return n+"st";case 2:return n+"nd";case 3:return n+"rd"}return n+"th"}(t[n](e))}})),{formatters:c,formattingTokensRegExp:a(c)}}},function(n,e){var t=["M","MM","Q","D","DD","DDD","DDDD","d","E","W","WW","YY","YYYY","GG","GGGG","H","HH","h","hh","m","mm","s","ss","S","SS","SSS","Z","ZZ","X","x"];n.exports=function(n){var e=[];for(var a in n)n.hasOwnProperty(a)&&e.push(a);var r=t.concat(e).sort().reverse();return new RegExp("(\\[[^\\[]*\\])|(\\\\)?("+r.join("|")+"|.)","g")}},function(n,e,t){"use strict";var a=t(3),r=t(114),i=t(311),o=t(120);function s(n){var e=new i(n),t=r(i.prototype.request,e);return a.extend(t,i.prototype,e),a.extend(t,e),t}var l=s(t(63));l.Axios=i,l.create=function(n){return s(o(l.defaults,n))},l.Cancel=t(121),l.CancelToken=t(325),l.isCancel=t(119),l.all=function(n){return Promise.all(n)},l.spread=t(326),l.isAxiosError=t(327),n.exports=l,n.exports.default=l},function(n,e,t){"use strict";var a=t(3),r=t(115),i=t(312),o=t(313),s=t(120),l=t(323),c=l.validators;function u(n){this.defaults=n,this.interceptors={request:new i,response:new i}}u.prototype.request=function(n){"string"==typeof n?(n=arguments[1]||{}).url=arguments[0]:n=n||{},(n=s(this.defaults,n)).method?n.method=n.method.toLowerCase():this.defaults.method?n.method=this.defaults.method.toLowerCase():n.method="get";var e=n.transitional;void 0!==e&&l.assertOptions(e,{silentJSONParsing:c.transitional(c.boolean,"1.0.0"),forcedJSONParsing:c.transitional(c.boolean,"1.0.0"),clarifyTimeoutError:c.transitional(c.boolean,"1.0.0")},!1);var t=[],a=!0;this.interceptors.request.forEach((function(e){"function"==typeof e.runWhen&&!1===e.runWhen(n)||(a=a&&e.synchronous,t.unshift(e.fulfilled,e.rejected))}));var r,i=[];if(this.interceptors.response.forEach((function(n){i.push(n.fulfilled,n.rejected)})),!a){var u=[o,void 0];for(Array.prototype.unshift.apply(u,t),u=u.concat(i),r=Promise.resolve(n);u.length;)r=r.then(u.shift(),u.shift());return r}for(var d=n;t.length;){var p=t.shift(),h=t.shift();try{d=p(d)}catch(n){h(n);break}}try{r=o(d)}catch(n){return Promise.reject(n)}for(;i.length;)r=r.then(i.shift(),i.shift());return r},u.prototype.getUri=function(n){return n=s(this.defaults,n),r(n.url,n.params,n.paramsSerializer).replace(/^\?/,"")},a.forEach(["delete","get","head","options"],(function(n){u.prototype[n]=function(e,t){return this.request(s(t||{},{method:n,url:e,data:(t||{}).data}))}})),a.forEach(["post","put","patch"],(function(n){u.prototype[n]=function(e,t,a){return this.request(s(a||{},{method:n,url:e,data:t}))}})),n.exports=u},function(n,e,t){"use strict";var a=t(3);function r(){this.handlers=[]}r.prototype.use=function(n,e,t){return this.handlers.push({fulfilled:n,rejected:e,synchronous:!!t&&t.synchronous,runWhen:t?t.runWhen:null}),this.handlers.length-1},r.prototype.eject=function(n){this.handlers[n]&&(this.handlers[n]=null)},r.prototype.forEach=function(n){a.forEach(this.handlers,(function(e){null!==e&&n(e)}))},n.exports=r},function(n,e,t){"use strict";var a=t(3),r=t(314),i=t(119),o=t(63);function s(n){n.cancelToken&&n.cancelToken.throwIfRequested()}n.exports=function(n){return s(n),n.headers=n.headers||{},n.data=r.call(n,n.data,n.headers,n.transformRequest),n.headers=a.merge(n.headers.common||{},n.headers[n.method]||{},n.headers),a.forEach(["delete","get","head","post","put","patch","common"],(function(e){delete n.headers[e]})),(n.adapter||o.adapter)(n).then((function(e){return s(n),e.data=r.call(n,e.data,e.headers,n.transformResponse),e}),(function(e){return i(e)||(s(n),e&&e.response&&(e.response.data=r.call(n,e.response.data,e.response.headers,n.transformResponse))),Promise.reject(e)}))}},function(n,e,t){"use strict";var a=t(3),r=t(63);n.exports=function(n,e,t){var i=this||r;return a.forEach(t,(function(t){n=t.call(i,n,e)})),n}},function(n,e,t){"use strict";var a=t(3);n.exports=function(n,e){a.forEach(n,(function(t,a){a!==e&&a.toUpperCase()===e.toUpperCase()&&(n[e]=t,delete n[a])}))}},function(n,e,t){"use strict";var a=t(118);n.exports=function(n,e,t){var r=t.config.validateStatus;t.status&&r&&!r(t.status)?e(a("Request failed with status code "+t.status,t.config,null,t.request,t)):n(t)}},function(n,e,t){"use strict";var a=t(3);n.exports=a.isStandardBrowserEnv()?{write:function(n,e,t,r,i,o){var s=[];s.push(n+"="+encodeURIComponent(e)),a.isNumber(t)&&s.push("expires="+new Date(t).toGMTString()),a.isString(r)&&s.push("path="+r),a.isString(i)&&s.push("domain="+i),!0===o&&s.push("secure"),document.cookie=s.join("; ")},read:function(n){var e=document.cookie.match(new RegExp("(^|;\\s*)("+n+")=([^;]*)"));return e?decodeURIComponent(e[3]):null},remove:function(n){this.write(n,"",Date.now()-864e5)}}:{write:function(){},read:function(){return null},remove:function(){}}},function(n,e,t){"use strict";var a=t(319),r=t(320);n.exports=function(n,e){return n&&!a(e)?r(n,e):e}},function(n,e,t){"use strict";n.exports=function(n){return/^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(n)}},function(n,e,t){"use strict";n.exports=function(n,e){return e?n.replace(/\/+$/,"")+"/"+e.replace(/^\/+/,""):n}},function(n,e,t){"use strict";var a=t(3),r=["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"];n.exports=function(n){var e,t,i,o={};return n?(a.forEach(n.split("\n"),(function(n){if(i=n.indexOf(":"),e=a.trim(n.substr(0,i)).toLowerCase(),t=a.trim(n.substr(i+1)),e){if(o[e]&&r.indexOf(e)>=0)return;o[e]="set-cookie"===e?(o[e]?o[e]:[]).concat([t]):o[e]?o[e]+", "+t:t}})),o):o}},function(n,e,t){"use strict";var a=t(3);n.exports=a.isStandardBrowserEnv()?function(){var n,e=/(msie|trident)/i.test(navigator.userAgent),t=document.createElement("a");function r(n){var a=n;return e&&(t.setAttribute("href",a),a=t.href),t.setAttribute("href",a),{href:t.href,protocol:t.protocol?t.protocol.replace(/:$/,""):"",host:t.host,search:t.search?t.search.replace(/^\?/,""):"",hash:t.hash?t.hash.replace(/^#/,""):"",hostname:t.hostname,port:t.port,pathname:"/"===t.pathname.charAt(0)?t.pathname:"/"+t.pathname}}return n=r(window.location.href),function(e){var t=a.isString(e)?r(e):e;return t.protocol===n.protocol&&t.host===n.host}}():function(){return!0}},function(n,e,t){"use strict";var a=t(324),r={};["object","boolean","number","function","string","symbol"].forEach((function(n,e){r[n]=function(t){return typeof t===n||"a"+(e<1?"n ":" ")+n}}));var i={},o=a.version.split(".");function s(n,e){for(var t=e?e.split("."):o,a=n.split("."),r=0;r<3;r++){if(t[r]>a[r])return!0;if(t[r]<a[r])return!1}return!1}r.transitional=function(n,e,t){var r=e&&s(e);function o(n,e){return"[Axios v"+a.version+"] Transitional option '"+n+"'"+e+(t?". "+t:"")}return function(t,a,s){if(!1===n)throw new Error(o(a," has been removed in "+e));return r&&!i[a]&&(i[a]=!0,console.warn(o(a," has been deprecated since v"+e+" and will be removed in the near future"))),!n||n(t,a,s)}},n.exports={isOlderVersion:s,assertOptions:function(n,e,t){if("object"!=typeof n)throw new TypeError("options must be an object");for(var a=Object.keys(n),r=a.length;r-- >0;){var i=a[r],o=e[i];if(o){var s=n[i],l=void 0===s||o(s,i,n);if(!0!==l)throw new TypeError("option "+i+" must be "+l)}else if(!0!==t)throw Error("Unknown option "+i)}},validators:r}},function(n){n.exports=JSON.parse('{"name":"axios","version":"0.21.4","description":"Promise based HTTP client for the browser and node.js","main":"index.js","scripts":{"test":"grunt test","start":"node ./sandbox/server.js","build":"NODE_ENV=production grunt build","preversion":"npm test","version":"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json","postversion":"git push && git push --tags","examples":"node ./examples/server.js","coveralls":"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","fix":"eslint --fix lib/**/*.js"},"repository":{"type":"git","url":"https://github.com/axios/axios.git"},"keywords":["xhr","http","ajax","promise","node"],"author":"Matt Zabriskie","license":"MIT","bugs":{"url":"https://github.com/axios/axios/issues"},"homepage":"https://axios-http.com","devDependencies":{"coveralls":"^3.0.0","es6-promise":"^4.2.4","grunt":"^1.3.0","grunt-banner":"^0.6.0","grunt-cli":"^1.2.0","grunt-contrib-clean":"^1.1.0","grunt-contrib-watch":"^1.0.0","grunt-eslint":"^23.0.0","grunt-karma":"^4.0.0","grunt-mocha-test":"^0.13.3","grunt-ts":"^6.0.0-beta.19","grunt-webpack":"^4.0.2","istanbul-instrumenter-loader":"^1.0.0","jasmine-core":"^2.4.1","karma":"^6.3.2","karma-chrome-launcher":"^3.1.0","karma-firefox-launcher":"^2.1.0","karma-jasmine":"^1.1.1","karma-jasmine-ajax":"^0.1.13","karma-safari-launcher":"^1.0.0","karma-sauce-launcher":"^4.3.6","karma-sinon":"^1.0.5","karma-sourcemap-loader":"^0.3.8","karma-webpack":"^4.0.2","load-grunt-tasks":"^3.5.2","minimist":"^1.2.0","mocha":"^8.2.1","sinon":"^4.5.0","terser-webpack-plugin":"^4.2.3","typescript":"^4.0.5","url-search-params":"^0.10.0","webpack":"^4.44.2","webpack-dev-server":"^3.11.0"},"browser":{"./lib/adapters/http.js":"./lib/adapters/xhr.js"},"jsdelivr":"dist/axios.min.js","unpkg":"dist/axios.min.js","typings":"./index.d.ts","dependencies":{"follow-redirects":"^1.14.0"},"bundlesize":[{"path":"./dist/axios.min.js","threshold":"5kB"}]}')},function(n,e,t){"use strict";var a=t(121);function r(n){if("function"!=typeof n)throw new TypeError("executor must be a function.");var e;this.promise=new Promise((function(n){e=n}));var t=this;n((function(n){t.reason||(t.reason=new a(n),e(t.reason))}))}r.prototype.throwIfRequested=function(){if(this.reason)throw this.reason},r.source=function(){var n;return{token:new r((function(e){n=e})),cancel:n}},n.exports=r},function(n,e,t){"use strict";n.exports=function(n){return function(e){return n.apply(null,e)}}},function(n,e,t){"use strict";n.exports=function(n){return"object"==typeof n&&!0===n.isAxiosError}},function(n,e,t){},function(n,e,t){"use strict";t(122)},function(n,e,t){"use strict";t(123)},function(n,e,t){"use strict";t(124)},function(n,e,t){"use strict";t(125)},function(n,e,t){"use strict";t.r(e);var a=t(0);
/*!
  * vue-router v3.6.5
  * (c) 2022 Evan You
  * @license MIT
  */function r(n,e){for(var t in e)n[t]=e[t];return n}var i=/[!'()*]/g,o=function(n){return"%"+n.charCodeAt(0).toString(16)},s=/%2C/g,l=function(n){return encodeURIComponent(n).replace(i,o).replace(s,",")};function c(n){try{return decodeURIComponent(n)}catch(n){0}return n}var u=function(n){return null==n||"object"==typeof n?n:String(n)};function d(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),a=c(t.shift()),r=t.length>0?c(t.join("=")):null;void 0===e[a]?e[a]=r:Array.isArray(e[a])?e[a].push(r):e[a]=[e[a],r]})),e):e}function p(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return l(e);if(Array.isArray(t)){var a=[];return t.forEach((function(n){void 0!==n&&(null===n?a.push(l(e)):a.push(l(e)+"="+l(n)))})),a.join("&")}return l(e)+"="+l(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var h=/\/?$/;function f(n,e,t,a){var r=a&&a.options.stringifyQuery,i=e.query||{};try{i=m(i)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:i,params:e.params||{},fullPath:y(e,r),matched:n?v(n):[]};return t&&(o.redirectedFrom=y(t,r)),Object.freeze(o)}function m(n){if(Array.isArray(n))return n.map(m);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=m(n[t]);return e}return n}var g=f(null,{path:"/"});function v(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function y(n,e){var t=n.path,a=n.query;void 0===a&&(a={});var r=n.hash;return void 0===r&&(r=""),(t||"/")+(e||p)(a)+r}function b(n,e,t){return e===g?n===e:!!e&&(n.path&&e.path?n.path.replace(h,"")===e.path.replace(h,"")&&(t||n.hash===e.hash&&k(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&k(n.query,e.query)&&k(n.params,e.params))))}function k(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),a=Object.keys(e).sort();return t.length===a.length&&t.every((function(t,r){var i=n[t];if(a[r]!==t)return!1;var o=e[t];return null==i||null==o?i===o:"object"==typeof i&&"object"==typeof o?k(i,o):String(i)===String(o)}))}function w(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var a in t.instances){var r=t.instances[a],i=t.enteredCbs[a];if(r&&i){delete t.enteredCbs[a];for(var o=0;o<i.length;o++)r._isBeingDestroyed||i[o](r)}}}}var x={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,a=e.children,i=e.parent,o=e.data;o.routerView=!0;for(var s=i.$createElement,l=t.name,c=i.$route,u=i._routerViewCache||(i._routerViewCache={}),d=0,p=!1;i&&i._routerRoot!==i;){var h=i.$vnode?i.$vnode.data:{};h.routerView&&d++,h.keepAlive&&i._directInactive&&i._inactive&&(p=!0),i=i.$parent}if(o.routerViewDepth=d,p){var f=u[l],m=f&&f.component;return m?(f.configProps&&S(m,o,f.route,f.configProps),s(m,o,a)):s()}var g=c.matched[d],v=g&&g.components[l];if(!g||!v)return u[l]=null,s();u[l]={component:v},o.registerRouteInstance=function(n,e){var t=g.instances[l];(e&&t!==n||!e&&t===n)&&(g.instances[l]=e)},(o.hook||(o.hook={})).prepatch=function(n,e){g.instances[l]=e.componentInstance},o.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==g.instances[l]&&(g.instances[l]=n.componentInstance),w(c)};var y=g.props&&g.props[l];return y&&(r(u[l],{route:c,configProps:y}),S(v,o,c,y)),s(v,o,a)}};function S(n,e,t,a){var i=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,a);if(i){i=e.props=r({},i);var o=e.attrs=e.attrs||{};for(var s in i)n.props&&s in n.props||(o[s]=i[s],delete i[s])}}function _(n,e,t){var a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;var r=e.split("/");t&&r[r.length-1]||r.pop();for(var i=n.replace(/^\//,"").split("/"),o=0;o<i.length;o++){var s=i[o];".."===s?r.pop():"."!==s&&r.push(s)}return""!==r[0]&&r.unshift(""),r.join("/")}function j(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var T=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},C=N,A=$,I=function(n,e){return z($(n,e),e)},E=z,O=q,L=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function $(n,e){for(var t,a=[],r=0,i=0,o="",s=e&&e.delimiter||"/";null!=(t=L.exec(n));){var l=t[0],c=t[1],u=t.index;if(o+=n.slice(i,u),i=u+l.length,c)o+=c[1];else{var d=n[i],p=t[2],h=t[3],f=t[4],m=t[5],g=t[6],v=t[7];o&&(a.push(o),o="");var y=null!=p&&null!=d&&d!==p,b="+"===g||"*"===g,k="?"===g||"*"===g,w=t[2]||s,x=f||m;a.push({name:h||r++,prefix:p||"",delimiter:w,optional:k,repeat:b,partial:y,asterisk:!!v,pattern:x?M(x):v?".*":"[^"+D(w)+"]+?"})}}return i<n.length&&(o+=n.substr(i)),o&&a.push(o),a}function P(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function z(n,e){for(var t=new Array(n.length),a=0;a<n.length;a++)"object"==typeof n[a]&&(t[a]=new RegExp("^(?:"+n[a].pattern+")$",R(e)));return function(e,a){for(var r="",i=e||{},o=(a||{}).pretty?P:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,u=i[l.name];if(null==u){if(l.optional){l.partial&&(r+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(T(u)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(u)+"`");if(0===u.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<u.length;d++){if(c=o(u[d]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");r+=(0===d?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(u).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(u),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');r+=l.prefix+c}}else r+=l}return r}}function D(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function M(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function F(n,e){return n.keys=e,n}function R(n){return n&&n.sensitive?"":"i"}function q(n,e,t){T(e)||(t=e||t,e=[]);for(var a=(t=t||{}).strict,r=!1!==t.end,i="",o=0;o<n.length;o++){var s=n[o];if("string"==typeof s)i+=D(s);else{var l=D(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),i+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var u=D(t.delimiter||"/"),d=i.slice(-u.length)===u;return a||(i=(d?i.slice(0,-u.length):i)+"(?:"+u+"(?=$))?"),i+=r?"$":a&&d?"":"(?="+u+"|$)",F(new RegExp("^"+i,R(t)),e)}function N(n,e,t){return T(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var a=0;a<t.length;a++)e.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return F(n,e)}(n,e):T(n)?function(n,e,t){for(var a=[],r=0;r<n.length;r++)a.push(N(n[r],e,t).source);return F(new RegExp("(?:"+a.join("|")+")",R(t)),e)}(n,e,t):function(n,e,t){return q($(n,t),e,t)}(n,e,t)}C.parse=A,C.compile=I,C.tokensToFunction=E,C.tokensToRegExp=O;var B=Object.create(null);function U(n,e,t){e=e||{};try{var a=B[n]||(B[n]=C.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),a(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function J(n,e,t,a){var i="string"==typeof n?{path:n}:n;if(i._normalized)return i;if(i.name){var o=(i=r({},n)).params;return o&&"object"==typeof o&&(i.params=r({},o)),i}if(!i.path&&i.params&&e){(i=r({},i))._normalized=!0;var s=r(r({},e.params),i.params);if(e.name)i.name=e.name,i.params=s;else if(e.matched.length){var l=e.matched[e.matched.length-1].path;i.path=U(l,s,e.path)}else 0;return i}var c=function(n){var e="",t="",a=n.indexOf("#");a>=0&&(e=n.slice(a),n=n.slice(0,a));var r=n.indexOf("?");return r>=0&&(t=n.slice(r+1),n=n.slice(0,r)),{path:n,query:t,hash:e}}(i.path||""),p=e&&e.path||"/",h=c.path?_(c.path,p,t||i.append):p,f=function(n,e,t){void 0===e&&(e={});var a,r=t||d;try{a=r(n||"")}catch(n){a={}}for(var i in e){var o=e[i];a[i]=Array.isArray(o)?o.map(u):u(o)}return a}(c.query,i.query,a&&a.options.parseQuery),m=i.hash||c.hash;return m&&"#"!==m.charAt(0)&&(m="#"+m),{_normalized:!0,path:h,query:f,hash:m}}var V,W=function(){},H={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,a=this.$route,i=t.resolve(this.to,a,this.append),o=i.location,s=i.route,l=i.href,c={},u=t.options.linkActiveClass,d=t.options.linkExactActiveClass,p=null==u?"router-link-active":u,m=null==d?"router-link-exact-active":d,g=null==this.activeClass?p:this.activeClass,v=null==this.exactActiveClass?m:this.exactActiveClass,y=s.redirectedFrom?f(null,J(s.redirectedFrom),null,t):s;c[v]=b(a,y,this.exactPath),c[g]=this.exact||this.exactPath?c[v]:function(n,e){return 0===n.path.replace(h,"/").indexOf(e.path.replace(h,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(a,y);var k=c[v]?this.ariaCurrentValue:null,w=function(n){Q(n)&&(e.replace?t.replace(o,W):t.push(o,W))},x={click:Q};Array.isArray(this.event)?this.event.forEach((function(n){x[n]=w})):x[this.event]=w;var S={class:c},_=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:l,route:s,navigate:w,isActive:c[g],isExactActive:c[v]});if(_){if(1===_.length)return _[0];if(_.length>1||!_.length)return 0===_.length?n():n("span",{},_)}if("a"===this.tag)S.on=x,S.attrs={href:l,"aria-current":k};else{var j=function n(e){var t;if(e)for(var a=0;a<e.length;a++){if("a"===(t=e[a]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(j){j.isStatic=!1;var T=j.data=r({},j.data);for(var C in T.on=T.on||{},T.on){var A=T.on[C];C in x&&(T.on[C]=Array.isArray(A)?A:[A])}for(var I in x)I in T.on?T.on[I].push(x[I]):T.on[I]=w;var E=j.data.attrs=r({},j.data.attrs);E.href=l,E["aria-current"]=k}else S.on=x}return n(this.tag,S,this.$slots.default)}};function Q(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var G="undefined"!=typeof window;function K(n,e,t,a,r){var i=e||[],o=t||Object.create(null),s=a||Object.create(null);n.forEach((function(n){!function n(e,t,a,r,i,o){var s=r.path,l=r.name;0;var c=r.pathToRegexpOptions||{},u=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return j(e.path+"/"+n)}(s,i,c.strict);"boolean"==typeof r.caseSensitive&&(c.sensitive=r.caseSensitive);var d={path:u,regex:Y(u,c),components:r.components||{default:r.component},alias:r.alias?"string"==typeof r.alias?[r.alias]:r.alias:[],instances:{},enteredCbs:{},name:l,parent:i,matchAs:o,redirect:r.redirect,beforeEnter:r.beforeEnter,meta:r.meta||{},props:null==r.props?{}:r.components?r.props:{default:r.props}};r.children&&r.children.forEach((function(r){var i=o?j(o+"/"+r.path):void 0;n(e,t,a,r,d,i)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==r.alias)for(var p=Array.isArray(r.alias)?r.alias:[r.alias],h=0;h<p.length;++h){0;var f={path:p[h],children:r.children};n(e,t,a,f,i,d.path||"/")}l&&(a[l]||(a[l]=d))}(i,o,s,n,r)}));for(var l=0,c=i.length;l<c;l++)"*"===i[l]&&(i.push(i.splice(l,1)[0]),c--,l--);return{pathList:i,pathMap:o,nameMap:s}}function Y(n,e){return C(n,[],e)}function X(n,e){var t=K(n),a=t.pathList,r=t.pathMap,i=t.nameMap;function o(n,t,o){var s=J(n,t,!1,e),c=s.name;if(c){var u=i[c];if(!u)return l(null,s);var d=u.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in s.params)&&d.indexOf(p)>-1&&(s.params[p]=t.params[p]);return s.path=U(u.path,s.params),l(u,s,o)}if(s.path){s.params={};for(var h=0;h<a.length;h++){var f=a[h],m=r[f];if(Z(m.regex,s.path,s.params))return l(m,s,o)}}return l(null,s)}function s(n,t){var a=n.redirect,r="function"==typeof a?a(f(n,t,null,e)):a;if("string"==typeof r&&(r={path:r}),!r||"object"!=typeof r)return l(null,t);var s=r,c=s.name,u=s.path,d=t.query,p=t.hash,h=t.params;if(d=s.hasOwnProperty("query")?s.query:d,p=s.hasOwnProperty("hash")?s.hash:p,h=s.hasOwnProperty("params")?s.params:h,c){i[c];return o({_normalized:!0,name:c,query:d,hash:p,params:h},void 0,t)}if(u){var m=function(n,e){return _(n,e.parent?e.parent.path:"/",!0)}(u,n);return o({_normalized:!0,path:U(m,h),query:d,hash:p},void 0,t)}return l(null,t)}function l(n,t,a){return n&&n.redirect?s(n,a||t):n&&n.matchAs?function(n,e,t){var a=o({_normalized:!0,path:U(t,e.params)});if(a){var r=a.matched,i=r[r.length-1];return e.params=a.params,l(i,e)}return l(null,e)}(0,t,n.matchAs):f(n,t,a,e)}return{match:o,addRoute:function(n,e){var t="object"!=typeof n?i[n]:void 0;K([e||n],a,r,i,t),t&&t.alias.length&&K(t.alias.map((function(n){return{path:n,children:[e]}})),a,r,i,t)},getRoutes:function(){return a.map((function(n){return r[n]}))},addRoutes:function(n){K(n,a,r,i)}}}function Z(n,e,t){var a=e.match(n);if(!a)return!1;if(!t)return!0;for(var r=1,i=a.length;r<i;++r){var o=n.keys[r-1];o&&(t[o.name||"pathMatch"]="string"==typeof a[r]?c(a[r]):a[r])}return!0}var nn=G&&window.performance&&window.performance.now?window.performance:Date;function en(){return nn.now().toFixed(3)}var tn=en();function an(){return tn}function rn(n){return tn=n}var on=Object.create(null);function sn(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=r({},window.history.state);return t.key=an(),window.history.replaceState(t,"",e),window.addEventListener("popstate",un),function(){window.removeEventListener("popstate",un)}}function ln(n,e,t,a){if(n.app){var r=n.options.scrollBehavior;r&&n.app.$nextTick((function(){var i=function(){var n=an();if(n)return on[n]}(),o=r.call(n,e,t,a?i:null);o&&("function"==typeof o.then?o.then((function(n){mn(n,i)})).catch((function(n){0})):mn(o,i))}))}}function cn(){var n=an();n&&(on[n]={x:window.pageXOffset,y:window.pageYOffset})}function un(n){cn(),n.state&&n.state.key&&rn(n.state.key)}function dn(n){return hn(n.x)||hn(n.y)}function pn(n){return{x:hn(n.x)?n.x:window.pageXOffset,y:hn(n.y)?n.y:window.pageYOffset}}function hn(n){return"number"==typeof n}var fn=/^#\d/;function mn(n,e){var t,a="object"==typeof n;if(a&&"string"==typeof n.selector){var r=fn.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(r){var i=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),a=n.getBoundingClientRect();return{x:a.left-t.left-e.x,y:a.top-t.top-e.y}}(r,i={x:hn((t=i).x)?t.x:0,y:hn(t.y)?t.y:0})}else dn(n)&&(e=pn(n))}else a&&dn(n)&&(e=pn(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var gn,vn=G&&((-1===(gn=window.navigator.userAgent).indexOf("Android 2.")&&-1===gn.indexOf("Android 4.0")||-1===gn.indexOf("Mobile Safari")||-1!==gn.indexOf("Chrome")||-1!==gn.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function yn(n,e){cn();var t=window.history;try{if(e){var a=r({},t.state);a.key=an(),t.replaceState(a,"",n)}else t.pushState({key:rn(en())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function bn(n){yn(n,!0)}var kn={redirected:2,aborted:4,cancelled:8,duplicated:16};function wn(n,e){return Sn(n,e,kn.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return _n.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function xn(n,e){return Sn(n,e,kn.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function Sn(n,e,t,a){var r=new Error(a);return r._isRouter=!0,r.from=n,r.to=e,r.type=t,r}var _n=["params","query","hash"];function jn(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function Tn(n,e){return jn(n)&&n._isRouter&&(null==e||n.type===e)}function Cn(n,e,t){var a=function(r){r>=n.length?t():n[r]?e(n[r],(function(){a(r+1)})):a(r+1)};a(0)}function An(n){return function(e,t,a){var r=!1,i=0,o=null;In(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){r=!0,i++;var l,c=Ln((function(e){var r;((r=e).__esModule||On&&"Module"===r[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:V.extend(e),t.components[s]=e,--i<=0&&a()})),u=Ln((function(n){var e="Failed to resolve async component "+s+": "+n;o||(o=jn(n)?n:new Error(e),a(o))}));try{l=n(c,u)}catch(n){u(n)}if(l)if("function"==typeof l.then)l.then(c,u);else{var d=l.component;d&&"function"==typeof d.then&&d.then(c,u)}}})),r||a()}}function In(n,e){return En(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function En(n){return Array.prototype.concat.apply([],n)}var On="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Ln(n){var e=!1;return function(){for(var t=[],a=arguments.length;a--;)t[a]=arguments[a];if(!e)return e=!0,n.apply(this,t)}}var $n=function(n,e){this.router=n,this.base=function(n){if(!n)if(G){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=g,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Pn(n,e,t,a){var r=In(n,(function(n,a,r,i){var o=function(n,e){"function"!=typeof n&&(n=V.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,a,r,i)})):t(o,a,r,i)}));return En(a?r.reverse():r)}function zn(n,e){if(e)return function(){return n.apply(e,arguments)}}$n.prototype.listen=function(n){this.cb=n},$n.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},$n.prototype.onError=function(n){this.errorCbs.push(n)},$n.prototype.transitionTo=function(n,e,t){var a,r=this;try{a=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var i=this.current;this.confirmTransition(a,(function(){r.updateRoute(a),e&&e(a),r.ensureURL(),r.router.afterHooks.forEach((function(n){n&&n(a,i)})),r.ready||(r.ready=!0,r.readyCbs.forEach((function(n){n(a)})))}),(function(n){t&&t(n),n&&!r.ready&&(Tn(n,kn.redirected)&&i===g||(r.ready=!0,r.readyErrorCbs.forEach((function(e){e(n)}))))}))},$n.prototype.confirmTransition=function(n,e,t){var a=this,r=this.current;this.pending=n;var i=function(n){!Tn(n)&&jn(n)&&(a.errorCbs.length?a.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},o=n.matched.length-1,s=r.matched.length-1;if(b(n,r)&&o===s&&n.matched[o]===r.matched[s])return this.ensureURL(),n.hash&&ln(this.router,r,n,!1),i(function(n,e){var t=Sn(n,e,kn.duplicated,'Avoided redundant navigation to current location: "'+n.fullPath+'".');return t.name="NavigationDuplicated",t}(r,n));var l=function(n,e){var t,a=Math.max(n.length,e.length);for(t=0;t<a&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),c=l.updated,u=l.deactivated,d=l.activated,p=[].concat(function(n){return Pn(n,"beforeRouteLeave",zn,!0)}(u),this.router.beforeHooks,function(n){return Pn(n,"beforeRouteUpdate",zn)}(c),d.map((function(n){return n.beforeEnter})),An(d)),h=function(e,t){if(a.pending!==n)return i(xn(r,n));try{e(n,r,(function(e){!1===e?(a.ensureURL(!0),i(function(n,e){return Sn(n,e,kn.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(r,n))):jn(e)?(a.ensureURL(!0),i(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(i(wn(r,n)),"object"==typeof e&&e.replace?a.replace(e):a.push(e)):t(e)}))}catch(n){i(n)}};Cn(p,h,(function(){Cn(function(n){return Pn(n,"beforeRouteEnter",(function(n,e,t,a){return function(n,e,t){return function(a,r,i){return n(a,r,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),i(n)}))}}(n,t,a)}))}(d).concat(a.router.resolveHooks),h,(function(){if(a.pending!==n)return i(xn(r,n));a.pending=null,e(n),a.router.app&&a.router.app.$nextTick((function(){w(n)}))}))}))},$n.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},$n.prototype.setupListeners=function(){},$n.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=g,this.pending=null};var Dn=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Mn(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,a=vn&&t;a&&this.listeners.push(sn());var r=function(){var t=n.current,r=Mn(n.base);n.current===g&&r===n._startLocation||n.transitionTo(r,(function(n){a&&ln(e,n,t,!0)}))};window.addEventListener("popstate",r),this.listeners.push((function(){window.removeEventListener("popstate",r)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){yn(j(a.base+n.fullPath)),ln(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){bn(j(a.base+n.fullPath)),ln(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Mn(this.base)!==this.current.fullPath){var e=j(this.base+this.current.fullPath);n?yn(e):bn(e)}},e.prototype.getCurrentLocation=function(){return Mn(this.base)},e}($n);function Mn(n){var e=window.location.pathname,t=e.toLowerCase(),a=n.toLowerCase();return!n||t!==a&&0!==t.indexOf(j(a+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Fn=function(n){function e(e,t,a){n.call(this,e,t),a&&function(n){var e=Mn(n);if(!/^\/#/.test(e))return window.location.replace(j(n+"/#"+e)),!0}(this.base)||Rn()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=vn&&e;t&&this.listeners.push(sn());var a=function(){var e=n.current;Rn()&&n.transitionTo(qn(),(function(a){t&&ln(n.router,a,e,!0),vn||Un(a.fullPath)}))},r=vn?"popstate":"hashchange";window.addEventListener(r,a),this.listeners.push((function(){window.removeEventListener(r,a)}))}},e.prototype.push=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){Bn(n.fullPath),ln(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){Un(n.fullPath),ln(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;qn()!==e&&(n?Bn(e):Un(e))},e.prototype.getCurrentLocation=function(){return qn()},e}($n);function Rn(){var n=qn();return"/"===n.charAt(0)||(Un("/"+n),!1)}function qn(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Nn(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Bn(n){vn?yn(Nn(n)):window.location.hash=n}function Un(n){vn?bn(Nn(n)):window.location.replace(Nn(n))}var Jn=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index+1).concat(n),a.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var a=this.stack[t];this.confirmTransition(a,(function(){var n=e.current;e.index=t,e.updateRoute(a),e.router.afterHooks.forEach((function(e){e&&e(a,n)}))}),(function(n){Tn(n,kn.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}($n),Vn=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=X(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!vn&&!1!==n.fallback,this.fallback&&(e="hash"),G||(e="abstract"),this.mode=e,e){case"history":this.history=new Dn(this,n.base);break;case"hash":this.history=new Fn(this,n.base,this.fallback);break;case"abstract":this.history=new Jn(this,n.base);break;default:0}},Wn={currentRoute:{configurable:!0}};Vn.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Wn.currentRoute.get=function(){return this.history&&this.history.current},Vn.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Dn||t instanceof Fn){var a=function(n){t.setupListeners(),function(n){var a=t.current,r=e.options.scrollBehavior;vn&&r&&"fullPath"in n&&ln(e,n,a,!1)}(n)};t.transitionTo(t.getCurrentLocation(),a,a)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Vn.prototype.beforeEach=function(n){return Qn(this.beforeHooks,n)},Vn.prototype.beforeResolve=function(n){return Qn(this.resolveHooks,n)},Vn.prototype.afterEach=function(n){return Qn(this.afterHooks,n)},Vn.prototype.onReady=function(n,e){this.history.onReady(n,e)},Vn.prototype.onError=function(n){this.history.onError(n)},Vn.prototype.push=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.push(n,e,t)}));this.history.push(n,e,t)},Vn.prototype.replace=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.replace(n,e,t)}));this.history.replace(n,e,t)},Vn.prototype.go=function(n){this.history.go(n)},Vn.prototype.back=function(){this.go(-1)},Vn.prototype.forward=function(){this.go(1)},Vn.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Vn.prototype.resolve=function(n,e,t){var a=J(n,e=e||this.history.current,t,this),r=this.match(a,e),i=r.redirectedFrom||r.fullPath;return{location:a,route:r,href:function(n,e,t){var a="hash"===t?"#"+e:e;return n?j(n+"/"+a):a}(this.history.base,i,this.mode),normalizedTo:a,resolved:r}},Vn.prototype.getRoutes=function(){return this.matcher.getRoutes()},Vn.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==g&&this.history.transitionTo(this.history.getCurrentLocation())},Vn.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==g&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Vn.prototype,Wn);var Hn=Vn;function Qn(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Vn.install=function n(e){if(!n.installed||V!==e){n.installed=!0,V=e;var t=function(n){return void 0!==n},a=function(n,e){var a=n.$options._parentVnode;t(a)&&t(a=a.data)&&t(a=a.registerRouteInstance)&&a(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",x),e.component("RouterLink",H);var r=e.config.optionMergeStrategies;r.beforeRouteEnter=r.beforeRouteLeave=r.beforeRouteUpdate=r.created}},Vn.version="3.6.5",Vn.isNavigationFailure=Tn,Vn.NavigationFailureType=kn,Vn.START_LOCATION=g,G&&window.Vue&&window.Vue.use(Vn);t(66);t(13),t(132);var Gn={NotFound:()=>Promise.all([t.e(0),t.e(10)]).then(t.bind(null,432)),Category:()=>Promise.all([t.e(0),t.e(2),t.e(1),t.e(7)]).then(t.bind(null,433)),Layout:()=>Promise.all([t.e(0),t.e(2),t.e(1),t.e(4)]).then(t.bind(null,431)),Tag:()=>Promise.all([t.e(0),t.e(2),t.e(1),t.e(5)]).then(t.bind(null,434)),Tags:()=>Promise.all([t.e(0),t.e(2),t.e(1),t.e(6)]).then(t.bind(null,435)),TimeLines:()=>Promise.all([t.e(0),t.e(2),t.e(1),t.e(8)]).then(t.bind(null,436))},Kn={"v-5e2a9a26":()=>t.e(11).then(t.bind(null,437)),"v-6f983ce8":()=>t.e(13).then(t.bind(null,438)),"v-44275e2e":()=>t.e(12).then(t.bind(null,439)),"v-96320d50":()=>t.e(14).then(t.bind(null,440)),"v-24391208":()=>t.e(16).then(t.bind(null,441)),"v-7989f230":()=>t.e(17).then(t.bind(null,442)),"v-433786d8":()=>t.e(18).then(t.bind(null,443)),"v-85306db0":()=>t.e(15).then(t.bind(null,444)),"v-be2976b0":()=>t.e(19).then(t.bind(null,445)),"v-cdde13b0":()=>t.e(20).then(t.bind(null,446)),"v-a5a02d48":()=>t.e(23).then(t.bind(null,447)),"v-52bd9ac8":()=>t.e(21).then(t.bind(null,448)),"v-38eee2e4":()=>t.e(22).then(t.bind(null,449)),"v-1cc09c4e":()=>t.e(24).then(t.bind(null,450)),"v-b2e6d364":()=>t.e(25).then(t.bind(null,451)),"v-07a8195c":()=>t.e(27).then(t.bind(null,452)),"v-b516cde4":()=>t.e(26).then(t.bind(null,453)),"v-7b0a2d92":()=>t.e(29).then(t.bind(null,454)),"v-6c3f60b6":()=>t.e(28).then(t.bind(null,455)),"v-7b44edde":()=>t.e(30).then(t.bind(null,456)),"v-3d73bcce":()=>t.e(31).then(t.bind(null,457)),"v-5764f320":()=>t.e(32).then(t.bind(null,458)),"v-4eee7d98":()=>t.e(33).then(t.bind(null,459)),"v-b4527ba4":()=>t.e(34).then(t.bind(null,460)),"v-e0f7392c":()=>t.e(35).then(t.bind(null,461)),"v-8b849c24":()=>t.e(37).then(t.bind(null,462)),"v-3ff5c12e":()=>t.e(36).then(t.bind(null,463)),"v-4b0b72ce":()=>t.e(38).then(t.bind(null,464)),"v-5391637e":()=>t.e(41).then(t.bind(null,465)),"v-d895a124":()=>t.e(42).then(t.bind(null,466)),"v-bf576b64":()=>t.e(39).then(t.bind(null,467)),"v-2d139d12":()=>t.e(40).then(t.bind(null,468)),"v-2c08e938":()=>t.e(43).then(t.bind(null,469)),"v-681ae11a":()=>t.e(44).then(t.bind(null,470)),"v-79b9f78c":()=>t.e(45).then(t.bind(null,471)),"v-428b51f0":()=>t.e(46).then(t.bind(null,472)),"v-46722458":()=>t.e(47).then(t.bind(null,473)),"v-c5de697c":()=>t.e(48).then(t.bind(null,474)),"v-57df1a48":()=>t.e(49).then(t.bind(null,475)),"v-08deb28e":()=>t.e(51).then(t.bind(null,476)),"v-f4a06f18":()=>t.e(52).then(t.bind(null,477)),"v-3a16cf30":()=>t.e(50).then(t.bind(null,478)),"v-fd7622f0":()=>t.e(53).then(t.bind(null,479)),"v-66e98988":()=>t.e(55).then(t.bind(null,480)),"v-58b25868":()=>t.e(54).then(t.bind(null,481)),"v-6b101374":()=>t.e(56).then(t.bind(null,482)),"v-4a34de8e":()=>t.e(57).then(t.bind(null,483)),"v-4c4bcd8c":()=>t.e(58).then(t.bind(null,484)),"v-781a7d54":()=>t.e(59).then(t.bind(null,485)),"v-2cb56542":()=>t.e(60).then(t.bind(null,486)),"v-2f00794e":()=>t.e(61).then(t.bind(null,487)),"v-6690af24":()=>t.e(63).then(t.bind(null,488)),"v-039b744e":()=>t.e(64).then(t.bind(null,489)),"v-695fc26e":()=>t.e(62).then(t.bind(null,490)),"v-4ac8f434":()=>t.e(66).then(t.bind(null,491)),"v-3969da64":()=>t.e(65).then(t.bind(null,492)),"v-6403e0ae":()=>t.e(67).then(t.bind(null,493)),"v-120dde14":()=>t.e(68).then(t.bind(null,494)),"v-0751ed32":()=>t.e(69).then(t.bind(null,495)),"v-58f4b370":()=>t.e(71).then(t.bind(null,496)),"v-57dda42e":()=>t.e(70).then(t.bind(null,497)),"v-32f9ea64":()=>t.e(72).then(t.bind(null,498)),"v-a5b25408":()=>t.e(74).then(t.bind(null,499)),"v-21f7fb68":()=>t.e(76).then(t.bind(null,500)),"v-e8b8e8e8":()=>t.e(73).then(t.bind(null,501)),"v-4212a3b8":()=>t.e(77).then(t.bind(null,502)),"v-2bc4f624":()=>t.e(75).then(t.bind(null,503)),"v-a53cce24":()=>t.e(78).then(t.bind(null,504)),"v-57973fdc":()=>t.e(79).then(t.bind(null,505)),"v-3fa2451e":()=>t.e(80).then(t.bind(null,506)),"v-88e9c230":()=>t.e(84).then(t.bind(null,507)),"v-4ffe6dba":()=>t.e(82).then(t.bind(null,508)),"v-064549ee":()=>t.e(83).then(t.bind(null,509)),"v-c2b654bc":()=>t.e(85).then(t.bind(null,510)),"v-07d81cee":()=>t.e(81).then(t.bind(null,511))};function Yn(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Xn=/-(\w)/g,Zn=Yn(n=>n.replace(Xn,(n,e)=>e?e.toUpperCase():"")),ne=/\B([A-Z])/g,ee=Yn(n=>n.replace(ne,"-$1").toLowerCase()),te=Yn(n=>n.charAt(0).toUpperCase()+n.slice(1));function ae(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(te(Zn(e))):n(te(e))||n(ee(e))}const re=Object.assign({},Gn,Kn),ie=n=>re[n],oe=n=>Kn[n],se=n=>Gn[n],le=n=>a.b.component(n);function ce(n){return ae(oe,n)}function ue(n){return ae(se,n)}function de(n){return ae(ie,n)}function pe(n){return ae(le,n)}function he(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!pe(n)&&de(n)){const e=await de(n)();a.b.component(n,e.default)}}))}function fe(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var me=t(126),ge=t.n(me),ve=t(127),ye=t.n(ve),be={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${ye()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=we(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=xe(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return ge()([{name:"description",content:this.$description}],n,this.siteMeta,Se)},updateCanonicalLink(){ke(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",we(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){xe(null,this.currentMetaTags),ke()}};function ke(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function we(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function xe(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function Se(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var _e=t(128),je={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(_e)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),r=window.innerHeight+t;for(let n=0;n<e.length;n++){const i=e[n],o=e[n+1],s=0===n&&0===t||t>=i.parentElement.offsetTop+10&&(!o||t<o.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(i.hash)){const t=i;if(r===a)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},Te=(t(269),Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(n[a]=t[a])}return n}),Ce=function(n){return"IMG"===n.tagName},Ae=function(n){return n&&1===n.nodeType},Ie=function(n){return".svg"===(n.currentSrc||n.src).substr(-4).toLowerCase()},Ee=function(n){try{return Array.isArray(n)?n.filter(Ce):function(n){return NodeList.prototype.isPrototypeOf(n)}(n)?[].slice.call(n).filter(Ce):Ae(n)?[n].filter(Ce):"string"==typeof n?[].slice.call(document.querySelectorAll(n)).filter(Ce):[]}catch(n){throw new TypeError("The provided selector is invalid.\nExpects a CSS selector, a Node element, a NodeList or an array.\nSee: https://github.com/francoischalifour/medium-zoom")}},Oe=function(n){var e=document.createElement("div");return e.classList.add("medium-zoom-overlay"),e.style.background=n,e},Le=function(n){var e=n.getBoundingClientRect(),t=e.top,a=e.left,r=e.width,i=e.height,o=n.cloneNode(),s=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,l=window.pageXOffset||document.documentElement.scrollLeft||document.body.scrollLeft||0;return o.removeAttribute("id"),o.style.position="absolute",o.style.top=t+s+"px",o.style.left=a+l+"px",o.style.width=r+"px",o.style.height=i+"px",o.style.transform="",o},$e=function(n,e){var t=Te({bubbles:!1,cancelable:!1,detail:void 0},e);if("function"==typeof window.CustomEvent)return new CustomEvent(n,t);var a=document.createEvent("CustomEvent");return a.initCustomEvent(n,t.bubbles,t.cancelable,t.detail),a};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var a=document.head||document.getElementsByTagName("head")[0],r=document.createElement("style");r.type="text/css","top"===t&&a.firstChild?a.insertBefore(r,a.firstChild):a.appendChild(r),r.styleSheet?r.styleSheet.cssText=n:r.appendChild(document.createTextNode(n))}}(".medium-zoom-overlay{position:fixed;top:0;right:0;bottom:0;left:0;opacity:0;transition:opacity .3s;will-change:opacity}.medium-zoom--opened .medium-zoom-overlay{cursor:pointer;cursor:zoom-out;opacity:1}.medium-zoom-image{cursor:pointer;cursor:zoom-in;transition:transform .3s cubic-bezier(.2,0,.2,1)!important}.medium-zoom-image--hidden{visibility:hidden}.medium-zoom-image--opened{position:relative;cursor:pointer;cursor:zoom-out;will-change:transform}");var Pe=function n(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},a=window.Promise||function(n){function e(){}n(e,e)},r=function(n){var e=n.target;e!==j?-1!==b.indexOf(e)&&m({target:e}):f()},i=function(){if(!w&&_.original){var n=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0;Math.abs(x-n)>S.scrollOffset&&setTimeout(f,150)}},o=function(n){var e=n.key||n.keyCode;"Escape"!==e&&"Esc"!==e&&27!==e||f()},s=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n;if(n.background&&(j.style.background=n.background),n.container&&n.container instanceof Object&&(e.container=Te({},S.container,n.container)),n.template){var t=Ae(n.template)?n.template:document.querySelector(n.template);e.template=t}return S=Te({},S,e),b.forEach((function(n){n.dispatchEvent($e("medium-zoom:update",{detail:{zoom:T}}))})),T},l=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return n(Te({},S,e))},c=function(){for(var n=arguments.length,e=Array(n),t=0;t<n;t++)e[t]=arguments[t];var a=e.reduce((function(n,e){return[].concat(n,Ee(e))}),[]);return a.filter((function(n){return-1===b.indexOf(n)})).forEach((function(n){b.push(n),n.classList.add("medium-zoom-image")})),k.forEach((function(n){var e=n.type,t=n.listener,r=n.options;a.forEach((function(n){n.addEventListener(e,t,r)}))})),T},u=function(){for(var n=arguments.length,e=Array(n),t=0;t<n;t++)e[t]=arguments[t];_.zoomed&&f();var a=e.length>0?e.reduce((function(n,e){return[].concat(n,Ee(e))}),[]):b;return a.forEach((function(n){n.classList.remove("medium-zoom-image"),n.dispatchEvent($e("medium-zoom:detach",{detail:{zoom:T}}))})),b=b.filter((function(n){return-1===a.indexOf(n)})),T},d=function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return b.forEach((function(a){a.addEventListener("medium-zoom:"+n,e,t)})),k.push({type:"medium-zoom:"+n,listener:e,options:t}),T},p=function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return b.forEach((function(a){a.removeEventListener("medium-zoom:"+n,e,t)})),k=k.filter((function(t){return!(t.type==="medium-zoom:"+n&&t.listener.toString()===e.toString())})),T},h=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.target,t=function(){var n={width:document.documentElement.clientWidth,height:document.documentElement.clientHeight,left:0,top:0,right:0,bottom:0},e=void 0,t=void 0;if(S.container)if(S.container instanceof Object)e=(n=Te({},n,S.container)).width-n.left-n.right-2*S.margin,t=n.height-n.top-n.bottom-2*S.margin;else{var a=(Ae(S.container)?S.container:document.querySelector(S.container)).getBoundingClientRect(),r=a.width,i=a.height,o=a.left,s=a.top;n=Te({},n,{width:r,height:i,left:o,top:s})}e=e||n.width-2*S.margin,t=t||n.height-2*S.margin;var l=_.zoomedHd||_.original,c=Ie(l)?e:l.naturalWidth||e,u=Ie(l)?t:l.naturalHeight||t,d=l.getBoundingClientRect(),p=d.top,h=d.left,f=d.width,m=d.height,g=Math.min(Math.max(f,c),e)/f,v=Math.min(Math.max(m,u),t)/m,y=Math.min(g,v),b="scale("+y+") translate3d("+((e-f)/2-h+S.margin+n.left)/y+"px, "+((t-m)/2-p+S.margin+n.top)/y+"px, 0)";_.zoomed.style.transform=b,_.zoomedHd&&(_.zoomedHd.style.transform=b)};return new a((function(n){if(e&&-1===b.indexOf(e))n(T);else{if(_.zoomed)n(T);else{if(e)_.original=e;else{if(!(b.length>0))return void n(T);var a=b;_.original=a[0]}if(_.original.dispatchEvent($e("medium-zoom:open",{detail:{zoom:T}})),x=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,w=!0,_.zoomed=Le(_.original),document.body.appendChild(j),S.template){var r=Ae(S.template)?S.template:document.querySelector(S.template);_.template=document.createElement("div"),_.template.appendChild(r.content.cloneNode(!0)),document.body.appendChild(_.template)}if(_.original.parentElement&&"PICTURE"===_.original.parentElement.tagName&&_.original.currentSrc&&(_.zoomed.src=_.original.currentSrc),document.body.appendChild(_.zoomed),window.requestAnimationFrame((function(){document.body.classList.add("medium-zoom--opened")})),_.original.classList.add("medium-zoom-image--hidden"),_.zoomed.classList.add("medium-zoom-image--opened"),_.zoomed.addEventListener("click",f),_.zoomed.addEventListener("transitionend",(function e(){w=!1,_.zoomed.removeEventListener("transitionend",e),_.original.dispatchEvent($e("medium-zoom:opened",{detail:{zoom:T}})),n(T)})),_.original.getAttribute("data-zoom-src")){_.zoomedHd=_.zoomed.cloneNode(),_.zoomedHd.removeAttribute("srcset"),_.zoomedHd.removeAttribute("sizes"),_.zoomedHd.removeAttribute("loading"),_.zoomedHd.src=_.zoomed.getAttribute("data-zoom-src"),_.zoomedHd.onerror=function(){clearInterval(i),console.warn("Unable to reach the zoom image target "+_.zoomedHd.src),_.zoomedHd=null,t()};var i=setInterval((function(){_.zoomedHd.complete&&(clearInterval(i),_.zoomedHd.classList.add("medium-zoom-image--opened"),_.zoomedHd.addEventListener("click",f),document.body.appendChild(_.zoomedHd),t())}),10)}else if(_.original.hasAttribute("srcset")){_.zoomedHd=_.zoomed.cloneNode(),_.zoomedHd.removeAttribute("sizes"),_.zoomedHd.removeAttribute("loading");var o=_.zoomedHd.addEventListener("load",(function(){_.zoomedHd.removeEventListener("load",o),_.zoomedHd.classList.add("medium-zoom-image--opened"),_.zoomedHd.addEventListener("click",f),document.body.appendChild(_.zoomedHd),t()}))}else t()}}}))},f=function(){return new a((function(n){if(!w&&_.original){w=!0,document.body.classList.remove("medium-zoom--opened"),_.zoomed.style.transform="",_.zoomedHd&&(_.zoomedHd.style.transform=""),_.template&&(_.template.style.transition="opacity 150ms",_.template.style.opacity=0),_.original.dispatchEvent($e("medium-zoom:close",{detail:{zoom:T}})),_.zoomed.addEventListener("transitionend",(function e(){_.original.classList.remove("medium-zoom-image--hidden"),document.body.removeChild(_.zoomed),_.zoomedHd&&document.body.removeChild(_.zoomedHd),document.body.removeChild(j),_.zoomed.classList.remove("medium-zoom-image--opened"),_.template&&document.body.removeChild(_.template),w=!1,_.zoomed.removeEventListener("transitionend",e),_.original.dispatchEvent($e("medium-zoom:closed",{detail:{zoom:T}})),_.original=null,_.zoomed=null,_.zoomedHd=null,_.template=null,n(T)}))}else n(T)}))},m=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.target;return _.original?f():h({target:e})},g=function(){return S},v=function(){return b},y=function(){return _.original},b=[],k=[],w=!1,x=0,S=t,_={original:null,zoomed:null,zoomedHd:null,template:null};"[object Object]"===Object.prototype.toString.call(e)?S=e:(e||"string"==typeof e)&&c(e),S=Te({margin:0,background:"#fff",scrollOffset:40,container:null,template:null},S);var j=Oe(S.background);document.addEventListener("click",r),document.addEventListener("keyup",o),document.addEventListener("scroll",i),window.addEventListener("resize",f);var T={open:h,close:f,toggle:m,update:s,clone:l,attach:c,detach:u,on:d,off:p,getOptions:g,getImages:v,getZoomedImage:y};return T},ze={data:()=>({zoom:null}),mounted(){this.updateZoom()},updated(){this.updateZoom()},methods:{updateZoom(){setTimeout(()=>{this.zoom&&this.zoom.detach(),this.zoom=Pe(".theme-reco-content :not(a) > img",{})},1e3)}}},De=t(39),Me=t.n(De),Fe={mounted(){Me.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||a.b.component(n.name)||Me.a.start(),t()}),this.$router.afterEach(()=>{Me.a.done(),this.isSidebarOpen=!1})}},Re=t(129),qe=t.n(Re),Ne=(t(270),[be,je,ze,Fe,{mounted(){qe.a.polyfill()}}]),Be={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return fe("layout",n),a.b.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},Ue=t(1),Je=Object(Ue.a)(Be,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(Je,"mixins",Ne);const Ve=[{name:"v-5e2a9a26",path:"/",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-5e2a9a26").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-6f983ce8",path:"/algorithm/basic/alg-basic-overview.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-6f983ce8").then(t)}},{name:"v-44275e2e",path:"/about.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-44275e2e").then(t)}},{name:"v-96320d50",path:"/java/basic/java-advanced-spi.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-96320d50").then(t)}},{name:"v-24391208",path:"/java/basic/java-basic-lan-sum.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-24391208").then(t)}},{name:"v-7989f230",path:"/java/basic/java-basic-oop.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-7989f230").then(t)}},{name:"v-433786d8",path:"/java/basic/java-basic-x-annotation.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-433786d8").then(t)}},{name:"v-85306db0",path:"/java/basic/java-basic-lan-basic.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-85306db0").then(t)}},{name:"v-be2976b0",path:"/java/basic/java-basic-x-exception.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-be2976b0").then(t)}},{name:"v-cdde13b0",path:"/java/basic/java-basic-x-generic.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-cdde13b0").then(t)}},{name:"v-a5a02d48",path:"/java/collection/java-collection-LinkedList.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-a5a02d48").then(t)}},{name:"v-52bd9ac8",path:"/java/basic/java-basic-x-reflection.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-52bd9ac8").then(t)}},{name:"v-38eee2e4",path:"/java/collection/java-collection-ArrayList.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-38eee2e4").then(t)}},{name:"v-1cc09c4e",path:"/java/collection/java-collection-PriorityQueue.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-1cc09c4e").then(t)}},{name:"v-b2e6d364",path:"/java/collection/java-collection-Queue&Stack.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-b2e6d364").then(t)}},{name:"v-07a8195c",path:"/java/collection/java-map-HashMap&HashSet.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-07a8195c").then(t)}},{name:"v-b516cde4",path:"/java/collection/java-collection-all.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-b516cde4").then(t)}},{name:"v-7b0a2d92",path:"/java/collection/java-map-TreeMap&TreeSet.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-7b0a2d92").then(t)}},{name:"v-6c3f60b6",path:"/java/collection/java-map-LinkedHashMap&LinkedHashSet.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-6c3f60b6").then(t)}},{name:"v-7b44edde",path:"/java/collection/java-map-WeakHashMap.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-7b44edde").then(t)}},{name:"v-3d73bcce",path:"/java/io/java-io-aio.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-3d73bcce").then(t)}},{name:"v-5764f320",path:"/java/io/java-io-basic-category.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-5764f320").then(t)}},{name:"v-4eee7d98",path:"/java/io/java-io-basic-code-inputstream.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-4eee7d98").then(t)}},{name:"v-b4527ba4",path:"/java/io/java-io-basic-code-outputstream.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-b4527ba4").then(t)}},{name:"v-e0f7392c",path:"/java/io/java-io-basic-design-pattern.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-e0f7392c").then(t)}},{name:"v-8b849c24",path:"/java/io/java-io-bio.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-8b849c24").then(t)}},{name:"v-3ff5c12e",path:"/java/io/java-io-basic-usage.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-3ff5c12e").then(t)}},{name:"v-4b0b72ce",path:"/java/io/java-io-model.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-4b0b72ce").then(t)}},{name:"v-5391637e",path:"/java/io/java-io-nio-zerocopy.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-5391637e").then(t)}},{name:"v-d895a124",path:"/java/io/java-io-nio.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-d895a124").then(t)}},{name:"v-bf576b64",path:"/java/io/java-io-nio-netty.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-bf576b64").then(t)}},{name:"v-2d139d12",path:"/java/io/java-io-nio-select-epoll.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-2d139d12").then(t)}},{name:"v-2c08e938",path:"/java/io/java-io-overview.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-2c08e938").then(t)}},{name:"v-681ae11a",path:"/java/java8/java8-anno-repeat.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-681ae11a").then(t)}},{name:"v-79b9f78c",path:"/java/java8/java8-default.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-79b9f78c").then(t)}},{name:"v-428b51f0",path:"/java/java8/java8-javafx.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-428b51f0").then(t)}},{name:"v-46722458",path:"/java/java8/java8-jre.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-46722458").then(t)}},{name:"v-c5de697c",path:"/java/java8/java8-localdatetime.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-c5de697c").then(t)}},{name:"v-57df1a48",path:"/java/java8/java8-optional.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-57df1a48").then(t)}},{name:"v-08deb28e",path:"/java/java8/java8-permgen.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-08deb28e").then(t)}},{name:"v-f4a06f18",path:"/java/java8/java8-stampedlock.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-f4a06f18").then(t)}},{name:"v-3a16cf30",path:"/java/java8/java8-others.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-3a16cf30").then(t)}},{name:"v-fd7622f0",path:"/java/java8/java8-stream.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-fd7622f0").then(t)}},{name:"v-66e98988",path:"/java/java8/java8-type.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-66e98988").then(t)}},{name:"v-58b25868",path:"/java/java8/java8-type-anno.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-58b25868").then(t)}},{name:"v-6b101374",path:"/java/java8/java8.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-6b101374").then(t)}},{name:"v-4a34de8e",path:"/java/thread/java-thread-x-juc-AtomicInteger.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-4a34de8e").then(t)}},{name:"v-4c4bcd8c",path:"/java/thread/java-thread-x-juc-collection-BlockingQueue.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-4c4bcd8c").then(t)}},{name:"v-781a7d54",path:"/java/thread/java-thread-x-juc-collection-ConcurrentHashMap.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-781a7d54").then(t)}},{name:"v-2cb56542",path:"/java/thread/java-thread-x-juc-collection-ConcurrentLinkedQueue.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-2cb56542").then(t)}},{name:"v-2f00794e",path:"/java/thread/java-thread-x-juc-collection-CopyOnWriteArrayList.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-2f00794e").then(t)}},{name:"v-6690af24",path:"/java/thread/java-thread-x-juc-executor-FutureTask.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-6690af24").then(t)}},{name:"v-039b744e",path:"/java/thread/java-thread-x-juc-executor-ScheduledThreadPoolExecutor.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-039b744e").then(t)}},{name:"v-695fc26e",path:"/java/thread/java-thread-x-juc-executor-ForkJoinPool.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-695fc26e").then(t)}},{name:"v-4ac8f434",path:"/java/thread/java-thread-x-juc-overview.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-4ac8f434").then(t)}},{name:"v-3969da64",path:"/java/thread/java-thread-x-juc-executor-ThreadPoolExecutor.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-3969da64").then(t)}},{name:"v-6403e0ae",path:"/java/thread/java-thread-x-juc-tool-countdownlatch.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-6403e0ae").then(t)}},{name:"v-120dde14",path:"/java/thread/java-thread-x-juc-tool-cyclicbarrier.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-120dde14").then(t)}},{name:"v-0751ed32",path:"/java/thread/java-thread-x-juc-tool-exchanger.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-0751ed32").then(t)}},{name:"v-58f4b370",path:"/java/thread/java-thread-x-juc-tool-semaphore.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-58f4b370").then(t)}},{name:"v-57dda42e",path:"/java/thread/java-thread-x-juc-tool-phaser.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-57dda42e").then(t)}},{name:"v-32f9ea64",path:"/java/thread/java-thread-x-key-final.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-32f9ea64").then(t)}},{name:"v-a5b25408",path:"/java/thread/java-thread-x-key-volatile.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-a5b25408").then(t)}},{name:"v-21f7fb68",path:"/java/thread/java-thread-x-lock-LockSupport.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-21f7fb68").then(t)}},{name:"v-e8b8e8e8",path:"/java/thread/java-thread-x-key-synchronized.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-e8b8e8e8").then(t)}},{name:"v-4212a3b8",path:"/java/thread/java-thread-x-lock-ReentrantLock.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-4212a3b8").then(t)}},{name:"v-2bc4f624",path:"/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-2bc4f624").then(t)}},{name:"v-a53cce24",path:"/java/thread/java-thread-x-lock-ReentrantReadWriteLock.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-a53cce24").then(t)}},{name:"v-57973fdc",path:"/java/thread/java-thread-x-lock-all.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-57973fdc").then(t)}},{name:"v-3fa2451e",path:"/java/thread/java-thread-x-overview.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-3fa2451e").then(t)}},{name:"v-88e9c230",path:"/spring/basic/spring.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-88e9c230").then(t)}},{name:"v-4ffe6dba",path:"/java/thread/java-thread-x-thread-basic.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-4ffe6dba").then(t)}},{name:"v-064549ee",path:"/java/thread/java-thread-x-threadlocal.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-064549ee").then(t)}},{name:"v-c2b654bc",path:"/sql/basic/sql-db.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-c2b654bc").then(t)}},{name:"v-07d81cee",path:"/java/thread/java-thread-x-theorty.html",component:Je,beforeEnter:(n,e,t)=>{he("Layout","v-07d81cee").then(t)}},{name:"v-b1564aac",path:"/tag/",component:Je,beforeEnter:(n,e,t)=>{he("Tags","v-b1564aac").then(t)},meta:{pid:"tags",id:"tags"}},{path:"/tag/index.html",redirect:"/tag/"},{name:"v-ef9325c4",path:"/categories/",component:Je,beforeEnter:(n,e,t)=>{he("FrontmatterKey","v-ef9325c4").then(t)},meta:{pid:"categories",id:"categories"}},{path:"/categories/index.html",redirect:"/categories/"},{name:"v-6319eb4e",path:"/timeline/",component:Je,beforeEnter:(n,e,t)=>{he("TimeLines","v-6319eb4e").then(t)},meta:{pid:"timeline",id:"timeline"}},{path:"/timeline/index.html",redirect:"/timeline/"},{path:"*",component:Je}],We={title:"Lowsky's blog",description:"",base:"/vblog/",headTags:[["link",{rel:"icon",href:"/vblog/Eminem.svg"}]],pages:[{title:"Home",frontmatter:{home:!0,heroImage:"/hero.png",heroText:"个人学习文档",tagline:null,actionText:"快速开始 →",actionLink:"/java/basic/java-basic-oop",features:[{title:"简洁至上",details:"以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。"},{title:"Vue驱动",details:"享受 Vue + webpack 的开发体验，在 Markdown 中使用 Vue 组件，同时可以使用 Vue 来开发自定义主题。"},{title:"高性能",details:"VuePress 为每个页面预渲染生成静态的 HTML，同时在页面被加载的时候，将作为 SPA 运行。"}],footer:"MIT Licensed | Copyright © 2018-present Evan You"},regularPath:"/",relativePath:"README.md",key:"v-5e2a9a26",path:"/",lastUpdated:"2023/4/10 01:17:23",lastUpdatedTimestamp:1681060643e3,headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"♥数据结构基础知识体系详解♥",frontmatter:{},regularPath:"/algorithm/basic/alg-basic-overview.html",relativePath:"algorithm/basic/alg-basic-overview.md",key:"v-6f983ce8",path:"/algorithm/basic/alg-basic-overview.html",headers:[{level:2,title:"♥数据结构基础知识体系详解♥",slug:"♥数据结构基础知识体系详解♥",normalizedTitle:"♥数据结构基础知识体系详解♥",charIndex:2},{level:2,title:"知识体系",slug:"知识体系",normalizedTitle:"知识体系",charIndex:9},{level:2,title:"入门推荐",slug:"入门推荐",normalizedTitle:"入门推荐",charIndex:138},{level:2,title:"进阶推荐",slug:"进阶推荐",normalizedTitle:"进阶推荐",charIndex:146},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:154}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"♥数据结构基础知识体系详解♥ 知识体系 入门推荐 进阶推荐 参考文章",content:'# ♥数据结构基础知识体系详解♥\n\n提示\n\n对于数据结构这种基础内容，在构建其知识体系时要避免自己再造轮子，需要高一点层次整体上去理解它(格局要大一点，不要盯着代码)，要了解算法思想，性能及适用场景，用一些工具和别人梳理的结果帮助自己构建知识体系等。\n\n * 知识体系\n * 入门推荐\n * 进阶推荐\n * 参考文章\n\n\n# 知识体系\n\n知识体系系统性梳理\n\n\n\n学习思路\n\n> 避免孤立的学习知识点，要关联学习。比如实际应用当中，我们经常使用的是查找和排序操作，这在我们的各种管理系统、数据库系统、操作系统等当中，十分常用，我们通过这个线索将知识点串联起来：\n\n数组的下标寻址十分迅速，但计算机的内存是有限的，故数组的长度也是有限的，实际应用当中的数据往往十分庞大；而且无序数组的查找最坏情况需要遍历整个数组；后来人们提出了二分查找，二分查找要求数组的构造一定有序，二分法查找解决了普通数组查找复杂度过高的问题。任何一种数组无法解决的问题就是插入、删除操作比较复杂，因此，在一个增删查改比较频繁的数据结构中，数组不会被优先考虑\n\n普通链表由于它的结构特点被证明根本不适合进行查找\n\n哈希表是数组和链表的折中，同时它的设计依赖散列函数的设计，数组不能无限长、链表也不适合查找，所以也不适合大规模的查找\n\n二叉查找树因为可能退化成链表，同样不适合进行查找\n\nAVL树是为了解决可能退化成链表问题，但是AVL树的旋转过程非常麻烦，因此插入和删除很慢，也就是构建AVL树比较麻烦\n\n红黑树是平衡二叉树和AVL树的折中，因此是比较合适的。集合类中的Map、关联数组具有较高的查询效率，它们的底层实现就是红黑树。\n\n多路查找树 是大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的(如果元素数量非常多的话，查找就退化成节点内部的线性查找了)，这样导致二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下。\n\nB树与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。它的应用是文件系统及部分非关系型数据库索引。\n\nB+树在B树基础上，为叶子结点增加链表指针(B树+叶子有序链表)，所有关键字都在叶子结点 中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中。通常用于关系型数据库(如Mysql)和操作系统的文件系统中。\n\nB*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针, 在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3。\n\nR树是用来做空间数据存储的树状数据结构。例如给地理位置，矩形和多边形这类多维数据建立索引。\n\nTrie树是自然语言处理中最常用的数据结构，很多字符串处理任务都会用到。Trie树本身是一种有限状态自动机，还有很多变体。什么模式匹配、正则表达式，都与这有关。\n\n相关文章\n\n> A. 数据结构 知识点：数据结构是基础中的基础，任何进阶都逃不开这些知识点。\n\n * 数据结构 - Overview\n\n> B. 数据结构之 线性结构：首先理解数据结构中线性结构及其延伸：数组和矩阵，链表，栈和队列等。\n\n * 线性表 - 数组和矩阵\n   * 数组是一种连续存储线性结构，元素类型相同，大小相等，数组是多维的，通过使用整型索引值来访问他们的元素，数组尺寸不能改变\n * 线性表 - 链表\n   * n个节点离散分配，彼此通过指针相连，每个节点只有一个前驱节点，每个节点只有一个后续节点，首节点没有前驱节点，尾节点没有后续节点。确定一个链表我们只需要头指针，通过头指针就可以把整个链表都能推出来\n * 线性表(散列) - 哈希表\n   * 散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。\n * 线性表 - 栈和队列\n   * 数组和链表都是线性存储结构的基础，栈和队列都是线性存储结构的应用\n\n> C. 数据结构之 逻辑结构：树：然后理解数据结构中逻辑结构之树：二叉搜索树(BST)，平衡二叉树(AVL)，红黑树(R-B Tree)，哈夫曼树，前缀树(Trie)等。\n\n * 树 - 基础和Overview\n   * 树在数据结构中至关重要，这里展示树的整体知识体系结构和几种常见树类型\n * 树 - 二叉搜索树(BST)\n   * 本文主要介绍 二叉树中最基本的二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。\n * 树 - 平衡二叉树(AVL)\n   * 平衡二叉树（Balanced Binary Tree）具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 最小二叉平衡树的节点的公式如下 F(n)=F(n-1)+F(n-2)+1 这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。\n * 树 - 红黑树(R-B Tree)\n   * 红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组，是平衡二叉树和AVL树的折中。\n * 树 - 哈夫曼树\n   * 哈夫曼又称最优二叉树, 是一种带权路径长度最短的二叉树。\n * 树 - 前缀树(Trie)\n   * Trie，又称字典树、单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。\n\n> D. 数据结构之 逻辑结构：图：最后理解数据结构中逻辑结构之图：图基础，图的遍历，最小生成树(Prim & Kruskal)，最短路径(Dijkstra & Frolyd)，拓扑排序(Topological sort)，AOE & 关键路径等。\n\n * 图 - 基础和Overview\n   * 图(Graph)是由顶点和连接顶点的边构成的离散结构。在计算机科学中，图是最灵活的数据结构之一，很多问题都可以使用图模型进行建模求解。例如: 生态环境中不同物种的相互竞争、人与人之间的社交与关系网络、化学上用图区分结构不同但分子式相同的同分异构体、分析计算机网络的拓扑结构确定两台计算机是否可以通信、找到两个城市之间的最短路径等等。\n * 图 - 遍历(BFS & DFS)\n   * 图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似; 广度优先搜索算法(Breadth First Search)，又称为"宽度优先搜索"或"横向优先搜索"\n * 图 - 最小生成树(Prim & Kruskal)\n   * Kruskal算法是从最小权重边着手，将森林里的树逐渐合并；prim算法是从顶点出发，在根结点的基础上建起一棵树\n * 图 - 最短路径(Dijkstra & Frolyd)\n   * 最短路径有着广泛的应用，比如地图两点间距离计算，公交查询系统，路由选择等\n * 图 - 拓扑排序(Topological sort)\n   * 拓扑排序主要用来解决有向图中的依赖解析(dependency resolution)问题\n * 图 - AOE & 关键路径\n   * 关键路径在项目管理计算工期等方面有广泛等应用，提升工期就是所见缩减所有关键路径上的工期，并且在实现时需要应用到之前拓扑排序的算法(前提: 有向无环图，有依赖关系)\n\n\n# 入门推荐\n\n * 强烈推荐用动画学习算法 Data Structure Visualizations在新窗口打开\n\n * 推荐一个学习数据结构的英文网站 Java Point - DS在新窗口打开\n\n * 推荐Github上java算法集合 TheAlgorithms - Java在新窗口打开\n\n * 推荐@skywang12345写的数据结构 skywang12345 - DS在新窗口打开\n\n * 推荐@QG-whz数据结构图画的好(本章节中有部分图源于这位作者) QG-whz在新窗口打开\n\n * 推荐@亦海数据结构的文章，写的很清晰 亦海 - DS在新窗口打开\n\n\n# 进阶推荐\n\n * 首推@July结构之法 算法之道 July - 结构之法 算法之道在新窗口打开\n\n\n# 参考文章\n\n * https://www.cnblogs.com/small-boy/p/8039007.html\n\n * https://www.jianshu.com/p/5c84f7b6c354\n\n * https://blog.csdn.net/flowing_wind/article/details/81431354\n\n * 转载 https://www.pdai.tech/md/algorithm/alg-basic-overview.html',normalizedContent:'# ♥数据结构基础知识体系详解♥\n\n提示\n\n对于数据结构这种基础内容，在构建其知识体系时要避免自己再造轮子，需要高一点层次整体上去理解它(格局要大一点，不要盯着代码)，要了解算法思想，性能及适用场景，用一些工具和别人梳理的结果帮助自己构建知识体系等。\n\n * 知识体系\n * 入门推荐\n * 进阶推荐\n * 参考文章\n\n\n# 知识体系\n\n知识体系系统性梳理\n\n\n\n学习思路\n\n> 避免孤立的学习知识点，要关联学习。比如实际应用当中，我们经常使用的是查找和排序操作，这在我们的各种管理系统、数据库系统、操作系统等当中，十分常用，我们通过这个线索将知识点串联起来：\n\n数组的下标寻址十分迅速，但计算机的内存是有限的，故数组的长度也是有限的，实际应用当中的数据往往十分庞大；而且无序数组的查找最坏情况需要遍历整个数组；后来人们提出了二分查找，二分查找要求数组的构造一定有序，二分法查找解决了普通数组查找复杂度过高的问题。任何一种数组无法解决的问题就是插入、删除操作比较复杂，因此，在一个增删查改比较频繁的数据结构中，数组不会被优先考虑\n\n普通链表由于它的结构特点被证明根本不适合进行查找\n\n哈希表是数组和链表的折中，同时它的设计依赖散列函数的设计，数组不能无限长、链表也不适合查找，所以也不适合大规模的查找\n\n二叉查找树因为可能退化成链表，同样不适合进行查找\n\navl树是为了解决可能退化成链表问题，但是avl树的旋转过程非常麻烦，因此插入和删除很慢，也就是构建avl树比较麻烦\n\n红黑树是平衡二叉树和avl树的折中，因此是比较合适的。集合类中的map、关联数组具有较高的查询效率，它们的底层实现就是红黑树。\n\n多路查找树 是大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的(如果元素数量非常多的话，查找就退化成节点内部的线性查找了)，这样导致二叉查找树结构由于树的深度过大而造成磁盘i/o读写过于频繁，进而导致查询效率低下。\n\nb树与自平衡二叉查找树不同，b树适用于读写相对大的数据块的存储系统，例如磁盘。它的应用是文件系统及部分非关系型数据库索引。\n\nb+树在b树基础上，为叶子结点增加链表指针(b树+叶子有序链表)，所有关键字都在叶子结点 中出现，非叶子结点作为叶子结点的索引；b+树总是到叶子结点才命中。通常用于关系型数据库(如mysql)和操作系统的文件系统中。\n\nb*树是b+树的变体，在b+树的非根和非叶子结点再增加指向兄弟的指针, 在b+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3。\n\nr树是用来做空间数据存储的树状数据结构。例如给地理位置，矩形和多边形这类多维数据建立索引。\n\ntrie树是自然语言处理中最常用的数据结构，很多字符串处理任务都会用到。trie树本身是一种有限状态自动机，还有很多变体。什么模式匹配、正则表达式，都与这有关。\n\n相关文章\n\n> a. 数据结构 知识点：数据结构是基础中的基础，任何进阶都逃不开这些知识点。\n\n * 数据结构 - overview\n\n> b. 数据结构之 线性结构：首先理解数据结构中线性结构及其延伸：数组和矩阵，链表，栈和队列等。\n\n * 线性表 - 数组和矩阵\n   * 数组是一种连续存储线性结构，元素类型相同，大小相等，数组是多维的，通过使用整型索引值来访问他们的元素，数组尺寸不能改变\n * 线性表 - 链表\n   * n个节点离散分配，彼此通过指针相连，每个节点只有一个前驱节点，每个节点只有一个后续节点，首节点没有前驱节点，尾节点没有后续节点。确定一个链表我们只需要头指针，通过头指针就可以把整个链表都能推出来\n * 线性表(散列) - 哈希表\n   * 散列表（hash table，也叫哈希表），是根据关键码值(key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。\n * 线性表 - 栈和队列\n   * 数组和链表都是线性存储结构的基础，栈和队列都是线性存储结构的应用\n\n> c. 数据结构之 逻辑结构：树：然后理解数据结构中逻辑结构之树：二叉搜索树(bst)，平衡二叉树(avl)，红黑树(r-b tree)，哈夫曼树，前缀树(trie)等。\n\n * 树 - 基础和overview\n   * 树在数据结构中至关重要，这里展示树的整体知识体系结构和几种常见树类型\n * 树 - 二叉搜索树(bst)\n   * 本文主要介绍 二叉树中最基本的二叉查找树（binary search tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。\n * 树 - 平衡二叉树(avl)\n   * 平衡二叉树（balanced binary tree）具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、avl、替罪羊树、treap、伸展树等。 最小二叉平衡树的节点的公式如下 f(n)=f(n-1)+f(n-2)+1 这个类似于一个递归的数列，可以参考fibonacci数列，1是根节点，f(n-1)是左子树的节点数量，f(n-2)是右子树的节点数量。\n * 树 - 红黑树(r-b tree)\n   * 红黑树（red black tree） 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组，是平衡二叉树和avl树的折中。\n * 树 - 哈夫曼树\n   * 哈夫曼又称最优二叉树, 是一种带权路径长度最短的二叉树。\n * 树 - 前缀树(trie)\n   * trie，又称字典树、单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。\n\n> d. 数据结构之 逻辑结构：图：最后理解数据结构中逻辑结构之图：图基础，图的遍历，最小生成树(prim & kruskal)，最短路径(dijkstra & frolyd)，拓扑排序(topological sort)，aoe & 关键路径等。\n\n * 图 - 基础和overview\n   * 图(graph)是由顶点和连接顶点的边构成的离散结构。在计算机科学中，图是最灵活的数据结构之一，很多问题都可以使用图模型进行建模求解。例如: 生态环境中不同物种的相互竞争、人与人之间的社交与关系网络、化学上用图区分结构不同但分子式相同的同分异构体、分析计算机网络的拓扑结构确定两台计算机是否可以通信、找到两个城市之间的最短路径等等。\n * 图 - 遍历(bfs & dfs)\n   * 图的深度优先搜索(depth first search)，和树的先序遍历比较类似; 广度优先搜索算法(breadth first search)，又称为"宽度优先搜索"或"横向优先搜索"\n * 图 - 最小生成树(prim & kruskal)\n   * kruskal算法是从最小权重边着手，将森林里的树逐渐合并；prim算法是从顶点出发，在根结点的基础上建起一棵树\n * 图 - 最短路径(dijkstra & frolyd)\n   * 最短路径有着广泛的应用，比如地图两点间距离计算，公交查询系统，路由选择等\n * 图 - 拓扑排序(topological sort)\n   * 拓扑排序主要用来解决有向图中的依赖解析(dependency resolution)问题\n * 图 - aoe & 关键路径\n   * 关键路径在项目管理计算工期等方面有广泛等应用，提升工期就是所见缩减所有关键路径上的工期，并且在实现时需要应用到之前拓扑排序的算法(前提: 有向无环图，有依赖关系)\n\n\n# 入门推荐\n\n * 强烈推荐用动画学习算法 data structure visualizations在新窗口打开\n\n * 推荐一个学习数据结构的英文网站 java point - ds在新窗口打开\n\n * 推荐github上java算法集合 thealgorithms - java在新窗口打开\n\n * 推荐@skywang12345写的数据结构 skywang12345 - ds在新窗口打开\n\n * 推荐@qg-whz数据结构图画的好(本章节中有部分图源于这位作者) qg-whz在新窗口打开\n\n * 推荐@亦海数据结构的文章，写的很清晰 亦海 - ds在新窗口打开\n\n\n# 进阶推荐\n\n * 首推@july结构之法 算法之道 july - 结构之法 算法之道在新窗口打开\n\n\n# 参考文章\n\n * https://www.cnblogs.com/small-boy/p/8039007.html\n\n * https://www.jianshu.com/p/5c84f7b6c354\n\n * https://blog.csdn.net/flowing_wind/article/details/81431354\n\n * 转载 https://www.pdai.tech/md/algorithm/alg-basic-overview.html',charsets:{cjk:!0}},{frontmatter:{},regularPath:"/about.html",relativePath:"about.md",key:"v-44275e2e",path:"/about.html",lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:null,content:"想搭建自己的博客, 文章内容转载自大佬@pdai https://www.pdai.tech/\n\n很多开发者面临这样的场景：\n\n * 每天知识碎片化\n * 忙于业务代码，忙到忘记思考\n * 在焦虑和碎片化学习中艰难前行\n\n我也是这样的，本着对未来美好生活的向往，是可以做一些系统化的学习来提升自我的认知效率的事的；从而提高我们自我独立性概率的，直接体现在技能提高后的回报（说概率是因为小富靠努力，大富靠机遇）。",normalizedContent:"想搭建自己的博客, 文章内容转载自大佬@pdai https://www.pdai.tech/\n\n很多开发者面临这样的场景：\n\n * 每天知识碎片化\n * 忙于业务代码，忙到忘记思考\n * 在焦虑和碎片化学习中艰难前行\n\n我也是这样的，本着对未来美好生活的向往，是可以做一些系统化的学习来提升自我的认知效率的事的；从而提高我们自我独立性概率的，直接体现在技能提高后的回报（说概率是因为小富靠努力，大富靠机遇）。",charsets:{cjk:!0}},{title:"Java常用机制 - SPI机制详解",frontmatter:{},regularPath:"/java/basic/java-advanced-spi.html",relativePath:"java/basic/java-advanced-spi.md",key:"v-96320d50",path:"/java/basic/java-advanced-spi.html",headers:[{level:2,title:"Java常用机制 - SPI机制详解",slug:"java常用机制-spi机制详解",normalizedTitle:"java常用机制 - spi机制详解",charIndex:2},{level:2,title:"什么是SPI机制",slug:"什么是spi机制",normalizedTitle:"什么是spi机制",charIndex:132},{level:2,title:"SPI机制的简单示例",slug:"spi机制的简单示例",normalizedTitle:"spi机制的简单示例",charIndex:146},{level:2,title:"SPI机制的广泛应用",slug:"spi机制的广泛应用",normalizedTitle:"spi机制的广泛应用",charIndex:162},{level:3,title:"SPI机制 - JDBC DriverManager",slug:"spi机制-jdbc-drivermanager",normalizedTitle:"spi机制 - jdbc drivermanager",charIndex:180},{level:3,title:"SPI机制 - Common-Logging",slug:"spi机制-common-logging",normalizedTitle:"spi机制 - common-logging",charIndex:299},{level:3,title:"SPI机制 - 插件体系",slug:"spi机制-插件体系",normalizedTitle:"spi机制 - 插件体系",charIndex:329},{level:3,title:"SPI机制 - Spring中SPI机制",slug:"spi机制-spring中spi机制",normalizedTitle:"spi机制 - spring中spi机制",charIndex:349},{level:2,title:"SPI机制深入理解",slug:"spi机制深入理解",normalizedTitle:"spi机制深入理解",charIndex:375},{level:3,title:"SPI机制通常怎么使用",slug:"spi机制通常怎么使用",normalizedTitle:"spi机制通常怎么使用",charIndex:392},{level:3,title:"SPI和API的区别是什么",slug:"spi和api的区别是什么",normalizedTitle:"spi和api的区别是什么",charIndex:477},{level:3,title:"SPI机制实现原理",slug:"spi机制实现原理",normalizedTitle:"spi机制实现原理",charIndex:498},{level:3,title:"SPI机制的缺陷",slug:"spi机制的缺陷",normalizedTitle:"spi机制的缺陷",charIndex:515},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:529}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java常用机制 - SPI机制详解 什么是SPI机制 SPI机制的简单示例 SPI机制的广泛应用 SPI机制 - JDBC DriverManager SPI机制 - Common-Logging SPI机制 - 插件体系 SPI机制 - Spring中SPI机制 SPI机制深入理解 SPI机制通常怎么使用 SPI和API的区别是什么 SPI机制实现原理 SPI机制的缺陷 参考文章",content:'# Java常用机制 - SPI机制详解\n\n> SPI（Service Provider Interface），是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用。\n\n * Java常用机制 - SPI机制\n   * 什么是SPI机制\n   * SPI机制的简单示例\n   * SPI机制的广泛应用\n     * SPI机制 - JDBC DriverManager\n       * JDBC接口定义\n       * mysql实现\n       * postgresql实现\n       * 使用方法\n       * 源码实现\n     * SPI机制 - Common-Logging\n     * SPI机制 - 插件体系\n     * SPI机制 - Spring中SPI机制\n   * SPI机制深入理解\n     * SPI机制通常怎么使用\n       * 定义标准\n       * 具体厂商或者框架开发者实现\n       * 程序猿使用\n       * 使用规范\n     * SPI和API的区别是什么\n     * SPI机制实现原理\n     * SPI机制的缺陷\n   * 参考文章\n\n\n# 什么是SPI机制\n\nSPI（Service Provider Interface），是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，比如java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，MySQL和PostgreSQL都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。Java中SPI机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是 解耦。\n\nSPI整体机制图如下：\n\n\n\n当服务的提供者提供了一种接口的实现之后，需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的META-INF/services/中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：java.util.ServiceLoader。\n\n\n# SPI机制的简单示例\n\n> 网上找了个例子：这里在新窗口打开\n\n我们现在需要使用一个内容搜索接口，搜索的实现可能是基于文件系统的搜索，也可能是基于数据库的搜索。\n\n * 先定义好接口\n\npublic interface Search {\n    public List<String> searchDoc(String keyword);   \n}\n\n\n * 文件搜索实现\n\npublic class FileSearch implements Search{\n    @Override\n    public List<String> searchDoc(String keyword) {\n        System.out.println("文件搜索 "+keyword);\n        return null;\n    }\n}\n\n\n * 数据库搜索实现\n\npublic class DatabaseSearch implements Search{\n    @Override\n    public List<String> searchDoc(String keyword) {\n        System.out.println("数据搜索 "+keyword);\n        return null;\n    }\n}\n\n\n * resources 接下来可以在resources下新建META-INF/services/目录，然后新建接口全限定名的文件：com.cainiao.ys.spi.learn.Search，里面加上我们需要用到的实现类\n\ncom.cainiao.ys.spi.learn.FileSearch\n\n\n * 测试方法\n\npublic class TestCase {\n    public static void main(String[] args) {\n        ServiceLoader<Search> s = ServiceLoader.load(Search.class);\n        Iterator<Search> iterator = s.iterator();\n        while (iterator.hasNext()) {\n           Search search =  iterator.next();\n           search.searchDoc("hello world");\n        }\n    }\n}\n\n\n可以看到输出结果：文件搜索 hello world\n\n如果在com.cainiao.ys.spi.learn.Search文件里写上两个实现类，那最后的输出结果就是两行了。\n\n这就是因为ServiceLoader.load(Search.class)在加载某接口时，会去META-INF/services下找接口的全限定名文件，再根据里面的内容加载相应的实现类。\n\n这就是spi的思想，接口的实现由provider实现，provider只用在提交的jar包里的META-INF/services下根据平台定义的接口新建文件，并添加进相应的实现类内容就好。\n\n\n# SPI机制的广泛应用\n\n\n# SPI机制 - JDBC DriverManager\n\n> 在JDBC4.0之前，我们开发有连接数据库的时候，通常会用Class.forName("com.mysql.jdbc.Driver")这句先加载数据库相关的驱动，然后再进行获取连接等的操作。而JDBC4.0之后不需要用Class.forName("com.mysql.jdbc.Driver")来加载驱动，直接获取连接就可以了，现在这种方式就是使用了Java的SPI扩展机制来实现。\n\n# JDBC接口定义\n\n首先在java中定义了接口java.sql.Driver，并没有具体的实现，具体的实现都是由不同厂商来提供的。\n\n# mysql实现\n\n在mysql的jar包mysql-connector-java-6.0.6.jar中，可以找到META-INF/services目录，该目录下会有一个名字为java.sql.Driver的文件，文件内容是com.mysql.cj.jdbc.Driver，这里面的内容就是针对Java中定义的接口的实现。\n\n# postgresql实现\n\n同样在postgresql的jar包postgresql-42.0.0.jar中，也可以找到同样的配置文件，文件内容是org.postgresql.Driver，这是postgresql对Java的java.sql.Driver的实现。\n\n# 使用方法\n\n上面说了，现在使用SPI扩展来加载具体的驱动，我们在Java中写连接数据库的代码的时候，不需要再使用Class.forName("com.mysql.jdbc.Driver")来加载驱动了，而是直接使用如下代码：\n\nString url = "jdbc:xxxx://xxxx:xxxx/xxxx";\nConnection conn = DriverManager.getConnection(url,username,password);\n.....\n\n\n这里并没有涉及到spi的使用，接着看下面的解析。\n\n# 源码实现\n\n上面的使用方法，就是我们普通的连接数据库的代码，并没有涉及到SPI的东西，但是有一点我们可以确定的是，我们没有写有关具体驱动的硬编码Class.forName("com.mysql.jdbc.Driver")！\n\n上面的代码可以直接获取数据库连接进行操作，但是跟SPI有啥关系呢？上面代码没有了加载驱动的代码，我们怎么去确定使用哪个数据库连接的驱动呢？这里就涉及到使用Java的SPI扩展机制来查找相关驱动的东西了，关于驱动的查找其实都在DriverManager中，DriverManager是Java中的实现，用来获取数据库连接，在DriverManager中有一个静态代码块如下：\n\nstatic {\n    loadInitialDrivers();\n    println("JDBC DriverManager initialized");\n}\n\n\n可以看到是加载实例化驱动的，接着看loadInitialDrivers方法：\n\nprivate static void loadInitialDrivers() {\n    String drivers;\n    try {\n        drivers = AccessController.doPrivileged(new PrivilegedAction<String>() {\n            public String run() {\n                return System.getProperty("jdbc.drivers");\n            }\n        });\n    } catch (Exception ex) {\n        drivers = null;\n    }\n\n    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n        public Void run() {\n\t\t\t//使用SPI的ServiceLoader来加载接口的实现\n            ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);\n            Iterator<Driver> driversIterator = loadedDrivers.iterator();\n            try{\n                while(driversIterator.hasNext()) {\n                    driversIterator.next();\n                }\n            } catch(Throwable t) {\n            // Do nothing\n            }\n            return null;\n        }\n    });\n\n    println("DriverManager.initialize: jdbc.drivers = " + drivers);\n\n    if (drivers == null || drivers.equals("")) {\n        return;\n    }\n    String[] driversList = drivers.split(":");\n    println("number of Drivers:" + driversList.length);\n    for (String aDriver : driversList) {\n        try {\n            println("DriverManager.Initialize: loading " + aDriver);\n            Class.forName(aDriver, true,\n                    ClassLoader.getSystemClassLoader());\n        } catch (Exception ex) {\n            println("DriverManager.Initialize: load failed: " + ex);\n        }\n    }\n}\n\n\n上面的代码主要步骤是：\n\n * 从系统变量中获取有关驱动的定义。\n * 使用SPI来获取驱动的实现。\n * 遍历使用SPI获取到的具体实现，实例化各个实现类。\n * 根据第一步获取到的驱动列表来实例化具体实现类。\n\n我们主要关注2,3步，这两步是SPI的用法，首先看第二步，使用SPI来获取驱动的实现，对应的代码是：\n\nServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);\n\n\n这里没有去META-INF/services目录下查找配置文件，也没有加载具体实现类，做的事情就是封装了我们的接口类型和类加载器，并初始化了一个迭代器。\n\n接着看第三步，遍历使用SPI获取到的具体实现，实例化各个实现类，对应的代码如下：\n\n//获取迭代器\nIterator<Driver> driversIterator = loadedDrivers.iterator();\n//遍历所有的驱动实现\nwhile(driversIterator.hasNext()) {\n    driversIterator.next();\n}\n\n\n在遍历的时候，首先调用driversIterator.hasNext()方法，这里会搜索classpath下以及jar包中所有的META-INF/services目录下的java.sql.Driver文件，并找到文件中的实现类的名字，此时并没有实例化具体的实现类（ServiceLoader具体的源码实现在下面）。\n\n然后是调用driversIterator.next();方法，此时就会根据驱动名字具体实例化各个实现类了。现在驱动就被找到并实例化了。\n\n可以看下截图，我在测试项目中添加了两个jar包，mysql-connector-java-6.0.6.jar和postgresql-42.0.0.0.jar，跟踪到DriverManager中之后：\n\n\n\n可以看到此时迭代器中有两个驱动，mysql和postgresql的都被加载了。\n\n\n# SPI机制 - Common-Logging\n\n> common-logging（也称Jakarta Commons Logging，缩写 JCL）是常用的日志库门面，具体日志库相关可以看这篇。我们看下它是怎么解耦的。\n\n首先，日志实例是通过LogFactory的getLog(String)方法创建的：\n\npublic static getLog(Class clazz) throws LogConfigurationException {\n    return getFactory().getInstance(clazz);\n}\n\n\nLogFatory是一个抽象类，它负责加载具体的日志实现，分析其Factory getFactory()方法：\n\npublic static org.apache.commons.logging.LogFactory getFactory() throws LogConfigurationException {\n    // Identify the class loader we will be using\n    ClassLoader contextClassLoader = getContextClassLoaderInternal();\n\n    if (contextClassLoader == null) {\n        // This is an odd enough situation to report about. This\n        // output will be a nuisance on JDK1.1, as the system\n        // classloader is null in that environment.\n        if (isDiagnosticsEnabled()) {\n            logDiagnostic("Context classloader is null.");\n        }\n    }\n\n    // Return any previously registered factory for this class loader\n    org.apache.commons.logging.LogFactory factory = getCachedFactory(contextClassLoader);\n    if (factory != null) {\n        return factory;\n    }\n\n    if (isDiagnosticsEnabled()) {\n        logDiagnostic(\n                "[LOOKUP] LogFactory implementation requested for the first time for context classloader " +\n                        objectId(contextClassLoader));\n        logHierarchy("[LOOKUP] ", contextClassLoader);\n    }\n\n    // Load properties file.\n    //\n    // If the properties file exists, then its contents are used as\n    // "attributes" on the LogFactory implementation class. One particular\n    // property may also control which LogFactory concrete subclass is\n    // used, but only if other discovery mechanisms fail..\n    //\n    // As the properties file (if it exists) will be used one way or\n    // another in the end we may as well look for it first.\n    // classpath根目录下寻找commons-logging.properties\n    Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES);\n\n    // Determine whether we will be using the thread context class loader to\n    // load logging classes or not by checking the loaded properties file (if any).\n    // classpath根目录下commons-logging.properties是否配置use_tccl\n    ClassLoader baseClassLoader = contextClassLoader;\n    if (props != null) {\n        String useTCCLStr = props.getProperty(TCCL_KEY);\n        if (useTCCLStr != null) {\n            // The Boolean.valueOf(useTCCLStr).booleanValue() formulation\n            // is required for Java 1.2 compatibility.\n            if (Boolean.valueOf(useTCCLStr).booleanValue() == false) {\n                // Don\'t use current context classloader when locating any\n                // LogFactory or Log classes, just use the class that loaded\n                // this abstract class. When this class is deployed in a shared\n                // classpath of a container, it means webapps cannot deploy their\n                // own logging implementations. It also means that it is up to the\n                // implementation whether to load library-specific config files\n                // from the TCCL or not.\n                baseClassLoader = thisClassLoader;\n            }\n        }\n    }\n\n    // 这里真正开始决定使用哪个factory\n    // 首先，尝试查找vm系统属性org.apache.commons.logging.LogFactory，其是否指定factory\n    // Determine which concrete LogFactory subclass to use.\n    // First, try a global system property\n    if (isDiagnosticsEnabled()) {\n        logDiagnostic("[LOOKUP] Looking for system property [" + FACTORY_PROPERTY +\n                "] to define the LogFactory subclass to use...");\n    }\n\n    try {\n        String factoryClass = getSystemProperty(FACTORY_PROPERTY, null);\n        if (factoryClass != null) {\n            if (isDiagnosticsEnabled()) {\n                logDiagnostic("[LOOKUP] Creating an instance of LogFactory class \'" + factoryClass +\n                        "\' as specified by system property " + FACTORY_PROPERTY);\n            }\n            factory = newFactory(factoryClass, baseClassLoader, contextClassLoader);\n        } else {\n            if (isDiagnosticsEnabled()) {\n                logDiagnostic("[LOOKUP] No system property [" + FACTORY_PROPERTY + "] defined.");\n            }\n        }\n    } catch (SecurityException e) {\n        if (isDiagnosticsEnabled()) {\n            logDiagnostic("[LOOKUP] A security exception occurred while trying to create an" +\n                    " instance of the custom factory class" + ": [" + trim(e.getMessage()) +\n                    "]. Trying alternative implementations...");\n        }\n        // ignore\n    } catch (RuntimeException e) {\n        // This is not consistent with the behaviour when a bad LogFactory class is\n        // specified in a services file.\n        //\n        // One possible exception that can occur here is a ClassCastException when\n        // the specified class wasn\'t castable to this LogFactory type.\n        if (isDiagnosticsEnabled()) {\n            logDiagnostic("[LOOKUP] An exception occurred while trying to create an" +\n                    " instance of the custom factory class" + ": [" +\n                    trim(e.getMessage()) +\n                    "] as specified by a system property.");\n        }\n        throw e;\n    }\n\n    // 第二，尝试使用java spi服务发现机制，载META-INF/services下寻找org.apache.commons.logging.LogFactory实现\n    // Second, try to find a service by using the JDK1.3 class\n    // discovery mechanism, which involves putting a file with the name\n    // of an interface class in the META-INF/services directory, where the\n    // contents of the file is a single line specifying a concrete class\n    // that implements the desired interface.\n\n    if (factory == null) {\n        if (isDiagnosticsEnabled()) {\n            logDiagnostic("[LOOKUP] Looking for a resource file of name [" + SERVICE_ID +\n                    "] to define the LogFactory subclass to use...");\n        }\n        try {\n            // META-INF/services/org.apache.commons.logging.LogFactory, SERVICE_ID\n            final InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID);\n\n            if (is != null) {\n                // This code is needed by EBCDIC and other strange systems.\n                // It\'s a fix for bugs reported in xerces\n                BufferedReader rd;\n                try {\n                    rd = new BufferedReader(new InputStreamReader(is, "UTF-8"));\n                } catch (java.io.UnsupportedEncodingException e) {\n                    rd = new BufferedReader(new InputStreamReader(is));\n                }\n\n                String factoryClassName = rd.readLine();\n                rd.close();\n\n                if (factoryClassName != null && !"".equals(factoryClassName)) {\n                    if (isDiagnosticsEnabled()) {\n                        logDiagnostic("[LOOKUP]  Creating an instance of LogFactory class " +\n                                factoryClassName +\n                                " as specified by file \'" + SERVICE_ID +\n                                "\' which was present in the path of the context classloader.");\n                    }\n                    factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader);\n                }\n            } else {\n                // is == null\n                if (isDiagnosticsEnabled()) {\n                    logDiagnostic("[LOOKUP] No resource file with name \'" + SERVICE_ID + "\' found.");\n                }\n            }\n        } catch (Exception ex) {\n            // note: if the specified LogFactory class wasn\'t compatible with LogFactory\n            // for some reason, a ClassCastException will be caught here, and attempts will\n            // continue to find a compatible class.\n            if (isDiagnosticsEnabled()) {\n                logDiagnostic(\n                        "[LOOKUP] A security exception occurred while trying to create an" +\n                                " instance of the custom factory class" +\n                                ": [" + trim(ex.getMessage()) +\n                                "]. Trying alternative implementations...");\n            }\n            // ignore\n        }\n    }\n\n    // 第三，尝试从classpath根目录下的commons-logging.properties中查找org.apache.commons.logging.LogFactory属性指定的factory\n    // Third try looking into the properties file read earlier (if found)\n\n    if (factory == null) {\n        if (props != null) {\n            if (isDiagnosticsEnabled()) {\n                logDiagnostic(\n                        "[LOOKUP] Looking in properties file for entry with key \'" + FACTORY_PROPERTY +\n                                "\' to define the LogFactory subclass to use...");\n            }\n            String factoryClass = props.getProperty(FACTORY_PROPERTY);\n            if (factoryClass != null) {\n                if (isDiagnosticsEnabled()) {\n                    logDiagnostic(\n                            "[LOOKUP] Properties file specifies LogFactory subclass \'" + factoryClass + "\'");\n                }\n                factory = newFactory(factoryClass, baseClassLoader, contextClassLoader);\n\n                // TODO: think about whether we need to handle exceptions from newFactory\n            } else {\n                if (isDiagnosticsEnabled()) {\n                    logDiagnostic("[LOOKUP] Properties file has no entry specifying LogFactory subclass.");\n                }\n            }\n        } else {\n            if (isDiagnosticsEnabled()) {\n                logDiagnostic("[LOOKUP] No properties file available to determine" + " LogFactory subclass from..");\n            }\n        }\n    }\n\n    // 最后，使用后备factory实现，org.apache.commons.logging.impl.LogFactoryImpl\n    // Fourth, try the fallback implementation class\n\n    if (factory == null) {\n        if (isDiagnosticsEnabled()) {\n            logDiagnostic(\n                    "[LOOKUP] Loading the default LogFactory implementation \'" + FACTORY_DEFAULT +\n                            "\' via the same classloader that loaded this LogFactory" +\n                            " class (ie not looking in the context classloader).");\n        }\n\n        // Note: unlike the above code which can try to load custom LogFactory\n        // implementations via the TCCL, we don\'t try to load the default LogFactory\n        // implementation via the context classloader because:\n        // * that can cause problems (see comments in newFactory method)\n        // * no-one should be customising the code of the default class\n        // Yes, we do give up the ability for the child to ship a newer\n        // version of the LogFactoryImpl class and have it used dynamically\n        // by an old LogFactory class in the parent, but that isn\'t\n        // necessarily a good idea anyway.\n        factory = newFactory(FACTORY_DEFAULT, thisClassLoader, contextClassLoader);\n    }\n\n    if (factory != null) {\n        /**\n            * Always cache using context class loader.\n            */\n        cacheFactory(contextClassLoader, factory);\n\n        if (props != null) {\n            Enumeration names = props.propertyNames();\n            while (names.hasMoreElements()) {\n                String name = (String) names.nextElement();\n                String value = props.getProperty(name);\n                factory.setAttribute(name, value);\n            }\n        }\n    }\n\n    return factory;\n}\n\n\n可以看出，抽象类LogFactory加载具体实现的步骤如下：\n\n * 从vm系统属性org.apache.commons.logging.LogFactory\n * 使用SPI服务发现机制，发现org.apache.commons.logging.LogFactory的实现\n * 查找classpath根目录commons-logging.properties的org.apache.commons.logging.LogFactory属性是否指定factory实现\n * 使用默认factory实现，org.apache.commons.logging.impl.LogFactoryImpl\n\n> LogFactory的getLog()方法返回类型是org.apache.commons.logging.Log接口，提供了从trace到fatal方法。可以确定，如果日志实现提供者只要实现该接口，并且使用继承自org.apache.commons.logging.LogFactory的子类创建Log，必然可以构建一个松耦合的日志系统。\n\n\n# SPI机制 - 插件体系\n\n> 其实最具spi思想的应该属于插件开发，我们项目中也用到的这种思想，后面再说，这里具体说一下eclipse的插件思想。\n\nEclipse使用OSGi作为插件系统的基础，动态添加新插件和停止现有插件，以动态的方式管理组件生命周期。\n\n一般来说，插件的文件结构必须在指定目录下包含以下三个文件：\n\n * META-INF/MANIFEST.MF: 项目基本配置信息，版本、名称、启动器等\n * build.properties: 项目的编译配置信息，包括，源代码路径、输出路径\n * plugin.xml：插件的操作配置信息，包含弹出菜单及点击菜单后对应的操作执行类等\n\n当eclipse启动时，会遍历plugins文件夹中的目录，扫描每个插件的清单文件MANIFEST.MF，并建立一个内部模型来记录它所找到的每个插件的信息，就实现了动态添加新的插件。\n\n这也意味着是eclipse制定了一系列的规则，像是文件结构、类型、参数等。插件开发者遵循这些规则去开发自己的插件，eclipse并不需要知道插件具体是怎样开发的，只需要在启动的时候根据配置文件解析、加载到系统里就好了，是spi思想的一种体现。\n\n\n# SPI机制 - Spring中SPI机制\n\n在springboot的自动装配过程中，最终会加载META-INF/spring.factories文件，而加载的过程是由SpringFactoriesLoader加载的。从CLASSPATH下的每个Jar包中搜寻所有META-INF/spring.factories配置文件，然后将解析properties文件，找到指定名称的配置后返回。需要注意的是，其实这里不仅仅是会去ClassPath路径下查找，会扫描所有路径下的Jar包，只不过这个文件只会在Classpath下的jar包中。\n\npublic static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";\n// spring.factories文件的格式为：key=value1,value2,value3\n// 从所有的jar包中找到META-INF/spring.factories文件\n// 然后从文件中解析出key=factoryClass类名称的所有value值\npublic static List<String> loadFactoryNames(Class<?> factoryClass, ClassLoader classLoader) {\n    String factoryClassName = factoryClass.getName();\n    // 取得资源文件的URL\n    Enumeration<URL> urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));\n    List<String> result = new ArrayList<String>();\n    // 遍历所有的URL\n    while (urls.hasMoreElements()) {\n        URL url = urls.nextElement();\n        // 根据资源文件URL解析properties文件，得到对应的一组@Configuration类\n        Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url));\n        String factoryClassNames = properties.getProperty(factoryClassName);\n        // 组装数据，并返回\n        result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));\n    }\n    return result;\n}\n\n\n\n# SPI机制深入理解\n\n\n# SPI机制通常怎么使用\n\n看完上面的几个例子解析，应该都能知道大概的流程了：\n\n * 有关组织或者公司定义标准。\n * 具体厂商或者框架开发者实现。\n * 程序猿使用。\n\n# 定义标准\n\n定义标准，就是定义接口。比如接口java.sql.Driver\n\n# 具体厂商或者框架开发者实现\n\n厂商或者框架开发者开发具体的实现：\n\n在META-INF/services目录下定义一个名字为接口全限定名的文件，比如java.sql.Driver文件，文件内容是具体的实现名字，比如me.cxis.sql.MyDriver。\n\n写具体的实现me.cxis.sql.MyDriver，都是对接口Driver的实现。\n\n# 程序猿使用\n\n我们会引用具体厂商的jar包来实现我们的功能：\n\nServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);\n//获取迭代器\nIterator<Driver> driversIterator = loadedDrivers.iterator();\n//遍历\nwhile(driversIterator.hasNext()) {\n    driversIterator.next();\n    //可以做具体的业务逻辑\n}\n\n\n# 使用规范\n\n最后总结一下jdk spi需要遵循的规范\n\n\n\n\n# SPI和API的区别是什么\n\n> 这里实际包含两个问题，第一个SPI和API的区别？第二个什么时候用API，什么时候用SPI？\n\n> SPI - “接口”位于“调用方”所在的“包”中\n\n * 概念上更依赖调用方。\n * 组织上位于调用方所在的包中。\n * 实现位于独立的包中。\n * 常见的例子是：插件模式的插件。\n\n> API - “接口”位于“实现方”所在的“包”中\n\n * 概念上更接近实现方。\n * 组织上位于实现方所在的包中。\n * 实现和接口在一个包中。\n\n参考：\n\n * difference-between-spi-and-api在新窗口打开\n * 设计原则：小议 SPI 和 API在新窗口打开\n\n\n\n\n\n\n# SPI机制实现原理\n\n不妨看下JDK中ServiceLoader<S>方法的具体实现：\n\n//ServiceLoader实现了Iterable接口，可以遍历所有的服务实现者\npublic final class ServiceLoader<S>\n    implements Iterable<S>\n{\n\n    //查找配置文件的目录\n    private static final String PREFIX = "META-INF/services/";\n\n    //表示要被加载的服务的类或接口\n    private final Class<S> service;\n\n    //这个ClassLoader用来定位，加载，实例化服务提供者\n    private final ClassLoader loader;\n\n    // 访问控制上下文\n    private final AccessControlContext acc;\n\n    // 缓存已经被实例化的服务提供者，按照实例化的顺序存储\n    private LinkedHashMap<String,S> providers = new LinkedHashMap<>();\n\n    // 迭代器\n    private LazyIterator lookupIterator;\n\n\n    //重新加载，就相当于重新创建ServiceLoader了，用于新的服务提供者安装到正在运行的Java虚拟机中的情况。\n    public void reload() {\n        //清空缓存中所有已实例化的服务提供者\n        providers.clear();\n        //新建一个迭代器，该迭代器会从头查找和实例化服务提供者\n        lookupIterator = new LazyIterator(service, loader);\n    }\n\n    //私有构造器\n    //使用指定的类加载器和服务创建服务加载器\n    //如果没有指定类加载器，使用系统类加载器，就是应用类加载器。\n    private ServiceLoader(Class<S> svc, ClassLoader cl) {\n        service = Objects.requireNonNull(svc, "Service interface cannot be null");\n        loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl;\n        acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null;\n        reload();\n    }\n\n    //解析失败处理的方法\n    private static void fail(Class<?> service, String msg, Throwable cause)\n        throws ServiceConfigurationError\n    {\n        throw new ServiceConfigurationError(service.getName() + ": " + msg,\n                                            cause);\n    }\n\n    private static void fail(Class<?> service, String msg)\n        throws ServiceConfigurationError\n    {\n        throw new ServiceConfigurationError(service.getName() + ": " + msg);\n    }\n\n    private static void fail(Class<?> service, URL u, int line, String msg)\n        throws ServiceConfigurationError\n    {\n        fail(service, u + ":" + line + ": " + msg);\n    }\n\n    //解析服务提供者配置文件中的一行\n    //首先去掉注释校验，然后保存\n    //返回下一行行号\n    //重复的配置项和已经被实例化的配置项不会被保存\n    private int parseLine(Class<?> service, URL u, BufferedReader r, int lc,\n                          List<String> names)\n        throws IOException, ServiceConfigurationError\n    {\n        //读取一行\n        String ln = r.readLine();\n        if (ln == null) {\n            return -1;\n        }\n        //#号代表注释行\n        int ci = ln.indexOf(\'#\');\n        if (ci >= 0) ln = ln.substring(0, ci);\n        ln = ln.trim();\n        int n = ln.length();\n        if (n != 0) {\n            if ((ln.indexOf(\' \') >= 0) || (ln.indexOf(\'\\t\') >= 0))\n                fail(service, u, lc, "Illegal configuration-file syntax");\n            int cp = ln.codePointAt(0);\n            if (!Character.isJavaIdentifierStart(cp))\n                fail(service, u, lc, "Illegal provider-class name: " + ln);\n            for (int i = Character.charCount(cp); i < n; i += Character.charCount(cp)) {\n                cp = ln.codePointAt(i);\n                if (!Character.isJavaIdentifierPart(cp) && (cp != \'.\'))\n                    fail(service, u, lc, "Illegal provider-class name: " + ln);\n            }\n            if (!providers.containsKey(ln) && !names.contains(ln))\n                names.add(ln);\n        }\n        return lc + 1;\n    }\n\n    //解析配置文件，解析指定的url配置文件\n    //使用parseLine方法进行解析，未被实例化的服务提供者会被保存到缓存中去\n    private Iterator<String> parse(Class<?> service, URL u)\n        throws ServiceConfigurationError\n    {\n        InputStream in = null;\n        BufferedReader r = null;\n        ArrayList<String> names = new ArrayList<>();\n        try {\n            in = u.openStream();\n            r = new BufferedReader(new InputStreamReader(in, "utf-8"));\n            int lc = 1;\n            while ((lc = parseLine(service, u, r, lc, names)) >= 0);\n        }\n        return names.iterator();\n    }\n\n    //服务提供者查找的迭代器\n    private class LazyIterator\n        implements Iterator<S>\n    {\n\n        Class<S> service;//服务提供者接口\n        ClassLoader loader;//类加载器\n        Enumeration<URL> configs = null;//保存实现类的url\n        Iterator<String> pending = null;//保存实现类的全名\n        String nextName = null;//迭代器中下一个实现类的全名\n\n        private LazyIterator(Class<S> service, ClassLoader loader) {\n            this.service = service;\n            this.loader = loader;\n        }\n\n        private boolean hasNextService() {\n            if (nextName != null) {\n                return true;\n            }\n            if (configs == null) {\n                try {\n                    String fullName = PREFIX + service.getName();\n                    if (loader == null)\n                        configs = ClassLoader.getSystemResources(fullName);\n                    else\n                        configs = loader.getResources(fullName);\n                }\n            }\n            while ((pending == null) || !pending.hasNext()) {\n                if (!configs.hasMoreElements()) {\n                    return false;\n                }\n                pending = parse(service, configs.nextElement());\n            }\n            nextName = pending.next();\n            return true;\n        }\n\n        private S nextService() {\n            if (!hasNextService())\n                throw new NoSuchElementException();\n            String cn = nextName;\n            nextName = null;\n            Class<?> c = null;\n            try {\n                c = Class.forName(cn, false, loader);\n            }\n            if (!service.isAssignableFrom(c)) {\n                fail(service, "Provider " + cn  + " not a subtype");\n            }\n            try {\n                S p = service.cast(c.newInstance());\n                providers.put(cn, p);\n                return p;\n            }\n        }\n\n        public boolean hasNext() {\n            if (acc == null) {\n                return hasNextService();\n            } else {\n                PrivilegedAction<Boolean> action = new PrivilegedAction<Boolean>() {\n                    public Boolean run() { return hasNextService(); }\n                };\n                return AccessController.doPrivileged(action, acc);\n            }\n        }\n\n        public S next() {\n            if (acc == null) {\n                return nextService();\n            } else {\n                PrivilegedAction<S> action = new PrivilegedAction<S>() {\n                    public S run() { return nextService(); }\n                };\n                return AccessController.doPrivileged(action, acc);\n            }\n        }\n\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n    }\n\n    //获取迭代器\n    //返回遍历服务提供者的迭代器\n    //以懒加载的方式加载可用的服务提供者\n    //懒加载的实现是：解析配置文件和实例化服务提供者的工作由迭代器本身完成\n    public Iterator<S> iterator() {\n        return new Iterator<S>() {\n            //按照实例化顺序返回已经缓存的服务提供者实例\n            Iterator<Map.Entry<String,S>> knownProviders\n                = providers.entrySet().iterator();\n\n            public boolean hasNext() {\n                if (knownProviders.hasNext())\n                    return true;\n                return lookupIterator.hasNext();\n            }\n\n            public S next() {\n                if (knownProviders.hasNext())\n                    return knownProviders.next().getValue();\n                return lookupIterator.next();\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n\n        };\n    }\n\n    //为指定的服务使用指定的类加载器来创建一个ServiceLoader\n    public static <S> ServiceLoader<S> load(Class<S> service,\n                                            ClassLoader loader)\n    {\n        return new ServiceLoader<>(service, loader);\n    }\n\n    //使用线程上下文的类加载器来创建ServiceLoader\n    public static <S> ServiceLoader<S> load(Class<S> service) {\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        return ServiceLoader.load(service, cl);\n    }\n\n    //使用扩展类加载器为指定的服务创建ServiceLoader\n    //只能找到并加载已经安装到当前Java虚拟机中的服务提供者，应用程序类路径中的服务提供者将被忽略\n    public static <S> ServiceLoader<S> loadInstalled(Class<S> service) {\n        ClassLoader cl = ClassLoader.getSystemClassLoader();\n        ClassLoader prev = null;\n        while (cl != null) {\n            prev = cl;\n            cl = cl.getParent();\n        }\n        return ServiceLoader.load(service, prev);\n    }\n\n    public String toString() {\n        return "java.util.ServiceLoader[" + service.getName() + "]";\n    }\n\n}\n\n\n首先，ServiceLoader实现了Iterable接口，所以它有迭代器的属性，这里主要都是实现了迭代器的hasNext和next方法。这里主要都是调用的lookupIterator的相应hasNext和next方法，lookupIterator是懒加载迭代器。\n\n其次，LazyIterator中的hasNext方法，静态变量PREFIX就是”META-INF/services/”目录，这也就是为什么需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件。\n\n最后，通过反射方法Class.forName()加载类对象，并用newInstance方法将类实例化，并把实例化后的类缓存到providers对象中，(LinkedHashMap<String,S>类型）然后返回实例对象。\n\n所以我们可以看到ServiceLoader不是实例化以后，就去读取配置文件中的具体实现，并进行实例化。而是等到使用迭代器去遍历的时候，才会加载对应的配置文件去解析，调用hasNext方法的时候会去加载配置文件进行解析，调用next方法的时候进行实例化并缓存。\n\n所有的配置文件只会加载一次，服务提供者也只会被实例化一次，重新加载配置文件可使用reload方法。\n\n\n# SPI机制的缺陷\n\n通过上面的解析，可以发现，我们使用SPI机制的缺陷：\n\n * 不能按需加载，需要遍历所有的实现，并实例化，然后在循环中才能找到我们需要的实现。如果不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。\n\n * 获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。\n\n * 多个并发多线程使用 ServiceLoader 类的实例是不安全的。\n\n\n# 参考文章\n\n * https://cxis.me/2017/04/17/Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/\n * https://stackoverflow.com/questions/2954372/difference-between-spi-and-api?answertab=votes#tab-top\n * https://zhuanlan.zhihu.com/p/28909673\n * http://blog.itpub.net/69912579/viewspace-2656555/\n * https://www.cnblogs.com/happyframework/archive/2013/09/17/3325560.html\n * https://blog.csdn.net/sakurainluojia/article/details/53534949\n * https://www.jianshu.com/p/0d196ad23915\n * 转载 https://www.pdai.tech/md/java/advanced/java-advanced-spi.html',normalizedContent:'# java常用机制 - spi机制详解\n\n> spi（service provider interface），是jdk内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用。\n\n * java常用机制 - spi机制\n   * 什么是spi机制\n   * spi机制的简单示例\n   * spi机制的广泛应用\n     * spi机制 - jdbc drivermanager\n       * jdbc接口定义\n       * mysql实现\n       * postgresql实现\n       * 使用方法\n       * 源码实现\n     * spi机制 - common-logging\n     * spi机制 - 插件体系\n     * spi机制 - spring中spi机制\n   * spi机制深入理解\n     * spi机制通常怎么使用\n       * 定义标准\n       * 具体厂商或者框架开发者实现\n       * 程序猿使用\n       * 使用规范\n     * spi和api的区别是什么\n     * spi机制实现原理\n     * spi机制的缺陷\n   * 参考文章\n\n\n# 什么是spi机制\n\nspi（service provider interface），是jdk内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，比如java.sql.driver接口，其他不同厂商可以针对同一接口做出不同的实现，mysql和postgresql都有不同的实现提供给用户，而java的spi机制可以为某个接口寻找服务实现。java中spi机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是 解耦。\n\nspi整体机制图如下：\n\n\n\n当服务的提供者提供了一种接口的实现之后，需要在classpath下的meta-inf/services/目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的meta-inf/services/中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。jdk中查找服务的实现的工具类是：java.util.serviceloader。\n\n\n# spi机制的简单示例\n\n> 网上找了个例子：这里在新窗口打开\n\n我们现在需要使用一个内容搜索接口，搜索的实现可能是基于文件系统的搜索，也可能是基于数据库的搜索。\n\n * 先定义好接口\n\npublic interface search {\n    public list<string> searchdoc(string keyword);   \n}\n\n\n * 文件搜索实现\n\npublic class filesearch implements search{\n    @override\n    public list<string> searchdoc(string keyword) {\n        system.out.println("文件搜索 "+keyword);\n        return null;\n    }\n}\n\n\n * 数据库搜索实现\n\npublic class databasesearch implements search{\n    @override\n    public list<string> searchdoc(string keyword) {\n        system.out.println("数据搜索 "+keyword);\n        return null;\n    }\n}\n\n\n * resources 接下来可以在resources下新建meta-inf/services/目录，然后新建接口全限定名的文件：com.cainiao.ys.spi.learn.search，里面加上我们需要用到的实现类\n\ncom.cainiao.ys.spi.learn.filesearch\n\n\n * 测试方法\n\npublic class testcase {\n    public static void main(string[] args) {\n        serviceloader<search> s = serviceloader.load(search.class);\n        iterator<search> iterator = s.iterator();\n        while (iterator.hasnext()) {\n           search search =  iterator.next();\n           search.searchdoc("hello world");\n        }\n    }\n}\n\n\n可以看到输出结果：文件搜索 hello world\n\n如果在com.cainiao.ys.spi.learn.search文件里写上两个实现类，那最后的输出结果就是两行了。\n\n这就是因为serviceloader.load(search.class)在加载某接口时，会去meta-inf/services下找接口的全限定名文件，再根据里面的内容加载相应的实现类。\n\n这就是spi的思想，接口的实现由provider实现，provider只用在提交的jar包里的meta-inf/services下根据平台定义的接口新建文件，并添加进相应的实现类内容就好。\n\n\n# spi机制的广泛应用\n\n\n# spi机制 - jdbc drivermanager\n\n> 在jdbc4.0之前，我们开发有连接数据库的时候，通常会用class.forname("com.mysql.jdbc.driver")这句先加载数据库相关的驱动，然后再进行获取连接等的操作。而jdbc4.0之后不需要用class.forname("com.mysql.jdbc.driver")来加载驱动，直接获取连接就可以了，现在这种方式就是使用了java的spi扩展机制来实现。\n\n# jdbc接口定义\n\n首先在java中定义了接口java.sql.driver，并没有具体的实现，具体的实现都是由不同厂商来提供的。\n\n# mysql实现\n\n在mysql的jar包mysql-connector-java-6.0.6.jar中，可以找到meta-inf/services目录，该目录下会有一个名字为java.sql.driver的文件，文件内容是com.mysql.cj.jdbc.driver，这里面的内容就是针对java中定义的接口的实现。\n\n# postgresql实现\n\n同样在postgresql的jar包postgresql-42.0.0.jar中，也可以找到同样的配置文件，文件内容是org.postgresql.driver，这是postgresql对java的java.sql.driver的实现。\n\n# 使用方法\n\n上面说了，现在使用spi扩展来加载具体的驱动，我们在java中写连接数据库的代码的时候，不需要再使用class.forname("com.mysql.jdbc.driver")来加载驱动了，而是直接使用如下代码：\n\nstring url = "jdbc:xxxx://xxxx:xxxx/xxxx";\nconnection conn = drivermanager.getconnection(url,username,password);\n.....\n\n\n这里并没有涉及到spi的使用，接着看下面的解析。\n\n# 源码实现\n\n上面的使用方法，就是我们普通的连接数据库的代码，并没有涉及到spi的东西，但是有一点我们可以确定的是，我们没有写有关具体驱动的硬编码class.forname("com.mysql.jdbc.driver")！\n\n上面的代码可以直接获取数据库连接进行操作，但是跟spi有啥关系呢？上面代码没有了加载驱动的代码，我们怎么去确定使用哪个数据库连接的驱动呢？这里就涉及到使用java的spi扩展机制来查找相关驱动的东西了，关于驱动的查找其实都在drivermanager中，drivermanager是java中的实现，用来获取数据库连接，在drivermanager中有一个静态代码块如下：\n\nstatic {\n    loadinitialdrivers();\n    println("jdbc drivermanager initialized");\n}\n\n\n可以看到是加载实例化驱动的，接着看loadinitialdrivers方法：\n\nprivate static void loadinitialdrivers() {\n    string drivers;\n    try {\n        drivers = accesscontroller.doprivileged(new privilegedaction<string>() {\n            public string run() {\n                return system.getproperty("jdbc.drivers");\n            }\n        });\n    } catch (exception ex) {\n        drivers = null;\n    }\n\n    accesscontroller.doprivileged(new privilegedaction<void>() {\n        public void run() {\n\t\t\t//使用spi的serviceloader来加载接口的实现\n            serviceloader<driver> loadeddrivers = serviceloader.load(driver.class);\n            iterator<driver> driversiterator = loadeddrivers.iterator();\n            try{\n                while(driversiterator.hasnext()) {\n                    driversiterator.next();\n                }\n            } catch(throwable t) {\n            // do nothing\n            }\n            return null;\n        }\n    });\n\n    println("drivermanager.initialize: jdbc.drivers = " + drivers);\n\n    if (drivers == null || drivers.equals("")) {\n        return;\n    }\n    string[] driverslist = drivers.split(":");\n    println("number of drivers:" + driverslist.length);\n    for (string adriver : driverslist) {\n        try {\n            println("drivermanager.initialize: loading " + adriver);\n            class.forname(adriver, true,\n                    classloader.getsystemclassloader());\n        } catch (exception ex) {\n            println("drivermanager.initialize: load failed: " + ex);\n        }\n    }\n}\n\n\n上面的代码主要步骤是：\n\n * 从系统变量中获取有关驱动的定义。\n * 使用spi来获取驱动的实现。\n * 遍历使用spi获取到的具体实现，实例化各个实现类。\n * 根据第一步获取到的驱动列表来实例化具体实现类。\n\n我们主要关注2,3步，这两步是spi的用法，首先看第二步，使用spi来获取驱动的实现，对应的代码是：\n\nserviceloader<driver> loadeddrivers = serviceloader.load(driver.class);\n\n\n这里没有去meta-inf/services目录下查找配置文件，也没有加载具体实现类，做的事情就是封装了我们的接口类型和类加载器，并初始化了一个迭代器。\n\n接着看第三步，遍历使用spi获取到的具体实现，实例化各个实现类，对应的代码如下：\n\n//获取迭代器\niterator<driver> driversiterator = loadeddrivers.iterator();\n//遍历所有的驱动实现\nwhile(driversiterator.hasnext()) {\n    driversiterator.next();\n}\n\n\n在遍历的时候，首先调用driversiterator.hasnext()方法，这里会搜索classpath下以及jar包中所有的meta-inf/services目录下的java.sql.driver文件，并找到文件中的实现类的名字，此时并没有实例化具体的实现类（serviceloader具体的源码实现在下面）。\n\n然后是调用driversiterator.next();方法，此时就会根据驱动名字具体实例化各个实现类了。现在驱动就被找到并实例化了。\n\n可以看下截图，我在测试项目中添加了两个jar包，mysql-connector-java-6.0.6.jar和postgresql-42.0.0.0.jar，跟踪到drivermanager中之后：\n\n\n\n可以看到此时迭代器中有两个驱动，mysql和postgresql的都被加载了。\n\n\n# spi机制 - common-logging\n\n> common-logging（也称jakarta commons logging，缩写 jcl）是常用的日志库门面，具体日志库相关可以看这篇。我们看下它是怎么解耦的。\n\n首先，日志实例是通过logfactory的getlog(string)方法创建的：\n\npublic static getlog(class clazz) throws logconfigurationexception {\n    return getfactory().getinstance(clazz);\n}\n\n\nlogfatory是一个抽象类，它负责加载具体的日志实现，分析其factory getfactory()方法：\n\npublic static org.apache.commons.logging.logfactory getfactory() throws logconfigurationexception {\n    // identify the class loader we will be using\n    classloader contextclassloader = getcontextclassloaderinternal();\n\n    if (contextclassloader == null) {\n        // this is an odd enough situation to report about. this\n        // output will be a nuisance on jdk1.1, as the system\n        // classloader is null in that environment.\n        if (isdiagnosticsenabled()) {\n            logdiagnostic("context classloader is null.");\n        }\n    }\n\n    // return any previously registered factory for this class loader\n    org.apache.commons.logging.logfactory factory = getcachedfactory(contextclassloader);\n    if (factory != null) {\n        return factory;\n    }\n\n    if (isdiagnosticsenabled()) {\n        logdiagnostic(\n                "[lookup] logfactory implementation requested for the first time for context classloader " +\n                        objectid(contextclassloader));\n        loghierarchy("[lookup] ", contextclassloader);\n    }\n\n    // load properties file.\n    //\n    // if the properties file exists, then its contents are used as\n    // "attributes" on the logfactory implementation class. one particular\n    // property may also control which logfactory concrete subclass is\n    // used, but only if other discovery mechanisms fail..\n    //\n    // as the properties file (if it exists) will be used one way or\n    // another in the end we may as well look for it first.\n    // classpath根目录下寻找commons-logging.properties\n    properties props = getconfigurationfile(contextclassloader, factory_properties);\n\n    // determine whether we will be using the thread context class loader to\n    // load logging classes or not by checking the loaded properties file (if any).\n    // classpath根目录下commons-logging.properties是否配置use_tccl\n    classloader baseclassloader = contextclassloader;\n    if (props != null) {\n        string usetcclstr = props.getproperty(tccl_key);\n        if (usetcclstr != null) {\n            // the boolean.valueof(usetcclstr).booleanvalue() formulation\n            // is required for java 1.2 compatibility.\n            if (boolean.valueof(usetcclstr).booleanvalue() == false) {\n                // don\'t use current context classloader when locating any\n                // logfactory or log classes, just use the class that loaded\n                // this abstract class. when this class is deployed in a shared\n                // classpath of a container, it means webapps cannot deploy their\n                // own logging implementations. it also means that it is up to the\n                // implementation whether to load library-specific config files\n                // from the tccl or not.\n                baseclassloader = thisclassloader;\n            }\n        }\n    }\n\n    // 这里真正开始决定使用哪个factory\n    // 首先，尝试查找vm系统属性org.apache.commons.logging.logfactory，其是否指定factory\n    // determine which concrete logfactory subclass to use.\n    // first, try a global system property\n    if (isdiagnosticsenabled()) {\n        logdiagnostic("[lookup] looking for system property [" + factory_property +\n                "] to define the logfactory subclass to use...");\n    }\n\n    try {\n        string factoryclass = getsystemproperty(factory_property, null);\n        if (factoryclass != null) {\n            if (isdiagnosticsenabled()) {\n                logdiagnostic("[lookup] creating an instance of logfactory class \'" + factoryclass +\n                        "\' as specified by system property " + factory_property);\n            }\n            factory = newfactory(factoryclass, baseclassloader, contextclassloader);\n        } else {\n            if (isdiagnosticsenabled()) {\n                logdiagnostic("[lookup] no system property [" + factory_property + "] defined.");\n            }\n        }\n    } catch (securityexception e) {\n        if (isdiagnosticsenabled()) {\n            logdiagnostic("[lookup] a security exception occurred while trying to create an" +\n                    " instance of the custom factory class" + ": [" + trim(e.getmessage()) +\n                    "]. trying alternative implementations...");\n        }\n        // ignore\n    } catch (runtimeexception e) {\n        // this is not consistent with the behaviour when a bad logfactory class is\n        // specified in a services file.\n        //\n        // one possible exception that can occur here is a classcastexception when\n        // the specified class wasn\'t castable to this logfactory type.\n        if (isdiagnosticsenabled()) {\n            logdiagnostic("[lookup] an exception occurred while trying to create an" +\n                    " instance of the custom factory class" + ": [" +\n                    trim(e.getmessage()) +\n                    "] as specified by a system property.");\n        }\n        throw e;\n    }\n\n    // 第二，尝试使用java spi服务发现机制，载meta-inf/services下寻找org.apache.commons.logging.logfactory实现\n    // second, try to find a service by using the jdk1.3 class\n    // discovery mechanism, which involves putting a file with the name\n    // of an interface class in the meta-inf/services directory, where the\n    // contents of the file is a single line specifying a concrete class\n    // that implements the desired interface.\n\n    if (factory == null) {\n        if (isdiagnosticsenabled()) {\n            logdiagnostic("[lookup] looking for a resource file of name [" + service_id +\n                    "] to define the logfactory subclass to use...");\n        }\n        try {\n            // meta-inf/services/org.apache.commons.logging.logfactory, service_id\n            final inputstream is = getresourceasstream(contextclassloader, service_id);\n\n            if (is != null) {\n                // this code is needed by ebcdic and other strange systems.\n                // it\'s a fix for bugs reported in xerces\n                bufferedreader rd;\n                try {\n                    rd = new bufferedreader(new inputstreamreader(is, "utf-8"));\n                } catch (java.io.unsupportedencodingexception e) {\n                    rd = new bufferedreader(new inputstreamreader(is));\n                }\n\n                string factoryclassname = rd.readline();\n                rd.close();\n\n                if (factoryclassname != null && !"".equals(factoryclassname)) {\n                    if (isdiagnosticsenabled()) {\n                        logdiagnostic("[lookup]  creating an instance of logfactory class " +\n                                factoryclassname +\n                                " as specified by file \'" + service_id +\n                                "\' which was present in the path of the context classloader.");\n                    }\n                    factory = newfactory(factoryclassname, baseclassloader, contextclassloader);\n                }\n            } else {\n                // is == null\n                if (isdiagnosticsenabled()) {\n                    logdiagnostic("[lookup] no resource file with name \'" + service_id + "\' found.");\n                }\n            }\n        } catch (exception ex) {\n            // note: if the specified logfactory class wasn\'t compatible with logfactory\n            // for some reason, a classcastexception will be caught here, and attempts will\n            // continue to find a compatible class.\n            if (isdiagnosticsenabled()) {\n                logdiagnostic(\n                        "[lookup] a security exception occurred while trying to create an" +\n                                " instance of the custom factory class" +\n                                ": [" + trim(ex.getmessage()) +\n                                "]. trying alternative implementations...");\n            }\n            // ignore\n        }\n    }\n\n    // 第三，尝试从classpath根目录下的commons-logging.properties中查找org.apache.commons.logging.logfactory属性指定的factory\n    // third try looking into the properties file read earlier (if found)\n\n    if (factory == null) {\n        if (props != null) {\n            if (isdiagnosticsenabled()) {\n                logdiagnostic(\n                        "[lookup] looking in properties file for entry with key \'" + factory_property +\n                                "\' to define the logfactory subclass to use...");\n            }\n            string factoryclass = props.getproperty(factory_property);\n            if (factoryclass != null) {\n                if (isdiagnosticsenabled()) {\n                    logdiagnostic(\n                            "[lookup] properties file specifies logfactory subclass \'" + factoryclass + "\'");\n                }\n                factory = newfactory(factoryclass, baseclassloader, contextclassloader);\n\n                // todo: think about whether we need to handle exceptions from newfactory\n            } else {\n                if (isdiagnosticsenabled()) {\n                    logdiagnostic("[lookup] properties file has no entry specifying logfactory subclass.");\n                }\n            }\n        } else {\n            if (isdiagnosticsenabled()) {\n                logdiagnostic("[lookup] no properties file available to determine" + " logfactory subclass from..");\n            }\n        }\n    }\n\n    // 最后，使用后备factory实现，org.apache.commons.logging.impl.logfactoryimpl\n    // fourth, try the fallback implementation class\n\n    if (factory == null) {\n        if (isdiagnosticsenabled()) {\n            logdiagnostic(\n                    "[lookup] loading the default logfactory implementation \'" + factory_default +\n                            "\' via the same classloader that loaded this logfactory" +\n                            " class (ie not looking in the context classloader).");\n        }\n\n        // note: unlike the above code which can try to load custom logfactory\n        // implementations via the tccl, we don\'t try to load the default logfactory\n        // implementation via the context classloader because:\n        // * that can cause problems (see comments in newfactory method)\n        // * no-one should be customising the code of the default class\n        // yes, we do give up the ability for the child to ship a newer\n        // version of the logfactoryimpl class and have it used dynamically\n        // by an old logfactory class in the parent, but that isn\'t\n        // necessarily a good idea anyway.\n        factory = newfactory(factory_default, thisclassloader, contextclassloader);\n    }\n\n    if (factory != null) {\n        /**\n            * always cache using context class loader.\n            */\n        cachefactory(contextclassloader, factory);\n\n        if (props != null) {\n            enumeration names = props.propertynames();\n            while (names.hasmoreelements()) {\n                string name = (string) names.nextelement();\n                string value = props.getproperty(name);\n                factory.setattribute(name, value);\n            }\n        }\n    }\n\n    return factory;\n}\n\n\n可以看出，抽象类logfactory加载具体实现的步骤如下：\n\n * 从vm系统属性org.apache.commons.logging.logfactory\n * 使用spi服务发现机制，发现org.apache.commons.logging.logfactory的实现\n * 查找classpath根目录commons-logging.properties的org.apache.commons.logging.logfactory属性是否指定factory实现\n * 使用默认factory实现，org.apache.commons.logging.impl.logfactoryimpl\n\n> logfactory的getlog()方法返回类型是org.apache.commons.logging.log接口，提供了从trace到fatal方法。可以确定，如果日志实现提供者只要实现该接口，并且使用继承自org.apache.commons.logging.logfactory的子类创建log，必然可以构建一个松耦合的日志系统。\n\n\n# spi机制 - 插件体系\n\n> 其实最具spi思想的应该属于插件开发，我们项目中也用到的这种思想，后面再说，这里具体说一下eclipse的插件思想。\n\neclipse使用osgi作为插件系统的基础，动态添加新插件和停止现有插件，以动态的方式管理组件生命周期。\n\n一般来说，插件的文件结构必须在指定目录下包含以下三个文件：\n\n * meta-inf/manifest.mf: 项目基本配置信息，版本、名称、启动器等\n * build.properties: 项目的编译配置信息，包括，源代码路径、输出路径\n * plugin.xml：插件的操作配置信息，包含弹出菜单及点击菜单后对应的操作执行类等\n\n当eclipse启动时，会遍历plugins文件夹中的目录，扫描每个插件的清单文件manifest.mf，并建立一个内部模型来记录它所找到的每个插件的信息，就实现了动态添加新的插件。\n\n这也意味着是eclipse制定了一系列的规则，像是文件结构、类型、参数等。插件开发者遵循这些规则去开发自己的插件，eclipse并不需要知道插件具体是怎样开发的，只需要在启动的时候根据配置文件解析、加载到系统里就好了，是spi思想的一种体现。\n\n\n# spi机制 - spring中spi机制\n\n在springboot的自动装配过程中，最终会加载meta-inf/spring.factories文件，而加载的过程是由springfactoriesloader加载的。从classpath下的每个jar包中搜寻所有meta-inf/spring.factories配置文件，然后将解析properties文件，找到指定名称的配置后返回。需要注意的是，其实这里不仅仅是会去classpath路径下查找，会扫描所有路径下的jar包，只不过这个文件只会在classpath下的jar包中。\n\npublic static final string factories_resource_location = "meta-inf/spring.factories";\n// spring.factories文件的格式为：key=value1,value2,value3\n// 从所有的jar包中找到meta-inf/spring.factories文件\n// 然后从文件中解析出key=factoryclass类名称的所有value值\npublic static list<string> loadfactorynames(class<?> factoryclass, classloader classloader) {\n    string factoryclassname = factoryclass.getname();\n    // 取得资源文件的url\n    enumeration<url> urls = (classloader != null ? classloader.getresources(factories_resource_location) : classloader.getsystemresources(factories_resource_location));\n    list<string> result = new arraylist<string>();\n    // 遍历所有的url\n    while (urls.hasmoreelements()) {\n        url url = urls.nextelement();\n        // 根据资源文件url解析properties文件，得到对应的一组@configuration类\n        properties properties = propertiesloaderutils.loadproperties(new urlresource(url));\n        string factoryclassnames = properties.getproperty(factoryclassname);\n        // 组装数据，并返回\n        result.addall(arrays.aslist(stringutils.commadelimitedlisttostringarray(factoryclassnames)));\n    }\n    return result;\n}\n\n\n\n# spi机制深入理解\n\n\n# spi机制通常怎么使用\n\n看完上面的几个例子解析，应该都能知道大概的流程了：\n\n * 有关组织或者公司定义标准。\n * 具体厂商或者框架开发者实现。\n * 程序猿使用。\n\n# 定义标准\n\n定义标准，就是定义接口。比如接口java.sql.driver\n\n# 具体厂商或者框架开发者实现\n\n厂商或者框架开发者开发具体的实现：\n\n在meta-inf/services目录下定义一个名字为接口全限定名的文件，比如java.sql.driver文件，文件内容是具体的实现名字，比如me.cxis.sql.mydriver。\n\n写具体的实现me.cxis.sql.mydriver，都是对接口driver的实现。\n\n# 程序猿使用\n\n我们会引用具体厂商的jar包来实现我们的功能：\n\nserviceloader<driver> loadeddrivers = serviceloader.load(driver.class);\n//获取迭代器\niterator<driver> driversiterator = loadeddrivers.iterator();\n//遍历\nwhile(driversiterator.hasnext()) {\n    driversiterator.next();\n    //可以做具体的业务逻辑\n}\n\n\n# 使用规范\n\n最后总结一下jdk spi需要遵循的规范\n\n\n\n\n# spi和api的区别是什么\n\n> 这里实际包含两个问题，第一个spi和api的区别？第二个什么时候用api，什么时候用spi？\n\n> spi - “接口”位于“调用方”所在的“包”中\n\n * 概念上更依赖调用方。\n * 组织上位于调用方所在的包中。\n * 实现位于独立的包中。\n * 常见的例子是：插件模式的插件。\n\n> api - “接口”位于“实现方”所在的“包”中\n\n * 概念上更接近实现方。\n * 组织上位于实现方所在的包中。\n * 实现和接口在一个包中。\n\n参考：\n\n * difference-between-spi-and-api在新窗口打开\n * 设计原则：小议 spi 和 api在新窗口打开\n\n\n\n\n\n\n# spi机制实现原理\n\n不妨看下jdk中serviceloader<s>方法的具体实现：\n\n//serviceloader实现了iterable接口，可以遍历所有的服务实现者\npublic final class serviceloader<s>\n    implements iterable<s>\n{\n\n    //查找配置文件的目录\n    private static final string prefix = "meta-inf/services/";\n\n    //表示要被加载的服务的类或接口\n    private final class<s> service;\n\n    //这个classloader用来定位，加载，实例化服务提供者\n    private final classloader loader;\n\n    // 访问控制上下文\n    private final accesscontrolcontext acc;\n\n    // 缓存已经被实例化的服务提供者，按照实例化的顺序存储\n    private linkedhashmap<string,s> providers = new linkedhashmap<>();\n\n    // 迭代器\n    private lazyiterator lookupiterator;\n\n\n    //重新加载，就相当于重新创建serviceloader了，用于新的服务提供者安装到正在运行的java虚拟机中的情况。\n    public void reload() {\n        //清空缓存中所有已实例化的服务提供者\n        providers.clear();\n        //新建一个迭代器，该迭代器会从头查找和实例化服务提供者\n        lookupiterator = new lazyiterator(service, loader);\n    }\n\n    //私有构造器\n    //使用指定的类加载器和服务创建服务加载器\n    //如果没有指定类加载器，使用系统类加载器，就是应用类加载器。\n    private serviceloader(class<s> svc, classloader cl) {\n        service = objects.requirenonnull(svc, "service interface cannot be null");\n        loader = (cl == null) ? classloader.getsystemclassloader() : cl;\n        acc = (system.getsecuritymanager() != null) ? accesscontroller.getcontext() : null;\n        reload();\n    }\n\n    //解析失败处理的方法\n    private static void fail(class<?> service, string msg, throwable cause)\n        throws serviceconfigurationerror\n    {\n        throw new serviceconfigurationerror(service.getname() + ": " + msg,\n                                            cause);\n    }\n\n    private static void fail(class<?> service, string msg)\n        throws serviceconfigurationerror\n    {\n        throw new serviceconfigurationerror(service.getname() + ": " + msg);\n    }\n\n    private static void fail(class<?> service, url u, int line, string msg)\n        throws serviceconfigurationerror\n    {\n        fail(service, u + ":" + line + ": " + msg);\n    }\n\n    //解析服务提供者配置文件中的一行\n    //首先去掉注释校验，然后保存\n    //返回下一行行号\n    //重复的配置项和已经被实例化的配置项不会被保存\n    private int parseline(class<?> service, url u, bufferedreader r, int lc,\n                          list<string> names)\n        throws ioexception, serviceconfigurationerror\n    {\n        //读取一行\n        string ln = r.readline();\n        if (ln == null) {\n            return -1;\n        }\n        //#号代表注释行\n        int ci = ln.indexof(\'#\');\n        if (ci >= 0) ln = ln.substring(0, ci);\n        ln = ln.trim();\n        int n = ln.length();\n        if (n != 0) {\n            if ((ln.indexof(\' \') >= 0) || (ln.indexof(\'\\t\') >= 0))\n                fail(service, u, lc, "illegal configuration-file syntax");\n            int cp = ln.codepointat(0);\n            if (!character.isjavaidentifierstart(cp))\n                fail(service, u, lc, "illegal provider-class name: " + ln);\n            for (int i = character.charcount(cp); i < n; i += character.charcount(cp)) {\n                cp = ln.codepointat(i);\n                if (!character.isjavaidentifierpart(cp) && (cp != \'.\'))\n                    fail(service, u, lc, "illegal provider-class name: " + ln);\n            }\n            if (!providers.containskey(ln) && !names.contains(ln))\n                names.add(ln);\n        }\n        return lc + 1;\n    }\n\n    //解析配置文件，解析指定的url配置文件\n    //使用parseline方法进行解析，未被实例化的服务提供者会被保存到缓存中去\n    private iterator<string> parse(class<?> service, url u)\n        throws serviceconfigurationerror\n    {\n        inputstream in = null;\n        bufferedreader r = null;\n        arraylist<string> names = new arraylist<>();\n        try {\n            in = u.openstream();\n            r = new bufferedreader(new inputstreamreader(in, "utf-8"));\n            int lc = 1;\n            while ((lc = parseline(service, u, r, lc, names)) >= 0);\n        }\n        return names.iterator();\n    }\n\n    //服务提供者查找的迭代器\n    private class lazyiterator\n        implements iterator<s>\n    {\n\n        class<s> service;//服务提供者接口\n        classloader loader;//类加载器\n        enumeration<url> configs = null;//保存实现类的url\n        iterator<string> pending = null;//保存实现类的全名\n        string nextname = null;//迭代器中下一个实现类的全名\n\n        private lazyiterator(class<s> service, classloader loader) {\n            this.service = service;\n            this.loader = loader;\n        }\n\n        private boolean hasnextservice() {\n            if (nextname != null) {\n                return true;\n            }\n            if (configs == null) {\n                try {\n                    string fullname = prefix + service.getname();\n                    if (loader == null)\n                        configs = classloader.getsystemresources(fullname);\n                    else\n                        configs = loader.getresources(fullname);\n                }\n            }\n            while ((pending == null) || !pending.hasnext()) {\n                if (!configs.hasmoreelements()) {\n                    return false;\n                }\n                pending = parse(service, configs.nextelement());\n            }\n            nextname = pending.next();\n            return true;\n        }\n\n        private s nextservice() {\n            if (!hasnextservice())\n                throw new nosuchelementexception();\n            string cn = nextname;\n            nextname = null;\n            class<?> c = null;\n            try {\n                c = class.forname(cn, false, loader);\n            }\n            if (!service.isassignablefrom(c)) {\n                fail(service, "provider " + cn  + " not a subtype");\n            }\n            try {\n                s p = service.cast(c.newinstance());\n                providers.put(cn, p);\n                return p;\n            }\n        }\n\n        public boolean hasnext() {\n            if (acc == null) {\n                return hasnextservice();\n            } else {\n                privilegedaction<boolean> action = new privilegedaction<boolean>() {\n                    public boolean run() { return hasnextservice(); }\n                };\n                return accesscontroller.doprivileged(action, acc);\n            }\n        }\n\n        public s next() {\n            if (acc == null) {\n                return nextservice();\n            } else {\n                privilegedaction<s> action = new privilegedaction<s>() {\n                    public s run() { return nextservice(); }\n                };\n                return accesscontroller.doprivileged(action, acc);\n            }\n        }\n\n        public void remove() {\n            throw new unsupportedoperationexception();\n        }\n\n    }\n\n    //获取迭代器\n    //返回遍历服务提供者的迭代器\n    //以懒加载的方式加载可用的服务提供者\n    //懒加载的实现是：解析配置文件和实例化服务提供者的工作由迭代器本身完成\n    public iterator<s> iterator() {\n        return new iterator<s>() {\n            //按照实例化顺序返回已经缓存的服务提供者实例\n            iterator<map.entry<string,s>> knownproviders\n                = providers.entryset().iterator();\n\n            public boolean hasnext() {\n                if (knownproviders.hasnext())\n                    return true;\n                return lookupiterator.hasnext();\n            }\n\n            public s next() {\n                if (knownproviders.hasnext())\n                    return knownproviders.next().getvalue();\n                return lookupiterator.next();\n            }\n\n            public void remove() {\n                throw new unsupportedoperationexception();\n            }\n\n        };\n    }\n\n    //为指定的服务使用指定的类加载器来创建一个serviceloader\n    public static <s> serviceloader<s> load(class<s> service,\n                                            classloader loader)\n    {\n        return new serviceloader<>(service, loader);\n    }\n\n    //使用线程上下文的类加载器来创建serviceloader\n    public static <s> serviceloader<s> load(class<s> service) {\n        classloader cl = thread.currentthread().getcontextclassloader();\n        return serviceloader.load(service, cl);\n    }\n\n    //使用扩展类加载器为指定的服务创建serviceloader\n    //只能找到并加载已经安装到当前java虚拟机中的服务提供者，应用程序类路径中的服务提供者将被忽略\n    public static <s> serviceloader<s> loadinstalled(class<s> service) {\n        classloader cl = classloader.getsystemclassloader();\n        classloader prev = null;\n        while (cl != null) {\n            prev = cl;\n            cl = cl.getparent();\n        }\n        return serviceloader.load(service, prev);\n    }\n\n    public string tostring() {\n        return "java.util.serviceloader[" + service.getname() + "]";\n    }\n\n}\n\n\n首先，serviceloader实现了iterable接口，所以它有迭代器的属性，这里主要都是实现了迭代器的hasnext和next方法。这里主要都是调用的lookupiterator的相应hasnext和next方法，lookupiterator是懒加载迭代器。\n\n其次，lazyiterator中的hasnext方法，静态变量prefix就是”meta-inf/services/”目录，这也就是为什么需要在classpath下的meta-inf/services/目录里创建一个以服务接口命名的文件。\n\n最后，通过反射方法class.forname()加载类对象，并用newinstance方法将类实例化，并把实例化后的类缓存到providers对象中，(linkedhashmap<string,s>类型）然后返回实例对象。\n\n所以我们可以看到serviceloader不是实例化以后，就去读取配置文件中的具体实现，并进行实例化。而是等到使用迭代器去遍历的时候，才会加载对应的配置文件去解析，调用hasnext方法的时候会去加载配置文件进行解析，调用next方法的时候进行实例化并缓存。\n\n所有的配置文件只会加载一次，服务提供者也只会被实例化一次，重新加载配置文件可使用reload方法。\n\n\n# spi机制的缺陷\n\n通过上面的解析，可以发现，我们使用spi机制的缺陷：\n\n * 不能按需加载，需要遍历所有的实现，并实例化，然后在循环中才能找到我们需要的实现。如果不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。\n\n * 获取某个实现类的方式不够灵活，只能通过 iterator 形式获取，不能根据某个参数来获取对应的实现类。\n\n * 多个并发多线程使用 serviceloader 类的实例是不安全的。\n\n\n# 参考文章\n\n * https://cxis.me/2017/04/17/java%e4%b8%adspi%e6%9c%ba%e5%88%b6%e6%b7%b1%e5%85%a5%e5%8f%8a%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90/\n * https://stackoverflow.com/questions/2954372/difference-between-spi-and-api?answertab=votes#tab-top\n * https://zhuanlan.zhihu.com/p/28909673\n * http://blog.itpub.net/69912579/viewspace-2656555/\n * https://www.cnblogs.com/happyframework/archive/2013/09/17/3325560.html\n * https://blog.csdn.net/sakurainluojia/article/details/53534949\n * https://www.jianshu.com/p/0d196ad23915\n * 转载 https://www.pdai.tech/md/java/advanced/java-advanced-spi.html',charsets:{cjk:!0}},{title:"Java 基础 - 图谱 & Q/A",frontmatter:{},regularPath:"/java/basic/java-basic-lan-sum.html",relativePath:"java/basic/java-basic-lan-sum.md",key:"v-24391208",path:"/java/basic/java-basic-lan-sum.html",headers:[{level:2,title:"Java 基础 - 图谱 & Q/A",slug:"java-基础-图谱-q-a",normalizedTitle:"java 基础 - 图谱 &amp; q/a",charIndex:null},{level:2,title:"参考文档",slug:"参考文档",normalizedTitle:"参考文档",charIndex:85},{level:2,title:"知识体系",slug:"知识体系",normalizedTitle:"知识体系",charIndex:35},{level:2,title:"Q&A",slug:"q-a",normalizedTitle:"q&amp;a",charIndex:null},{level:3,title:"Java 中应该使用什么数据类型来代表价格?",slug:"java-中应该使用什么数据类型来代表价格",normalizedTitle:"java 中应该使用什么数据类型来代表价格?",charIndex:116},{level:3,title:"怎么将 byte 转换为 String?",slug:"怎么将-byte-转换为-string",normalizedTitle:"怎么将 byte 转换为 string?",charIndex:146},{level:3,title:"Java 中怎样将 bytes 转换为 long 类型?",slug:"java-中怎样将-bytes-转换为-long-类型",normalizedTitle:"java 中怎样将 bytes 转换为 long 类型?",charIndex:174},{level:3,title:"我们能将 int 强制转换为 byte 类型的变量吗? 如果该值大于 byte 类型的范围，将会出现什么现象?",slug:"我们能将-int-强制转换为-byte-类型的变量吗-如果该值大于-byte-类型的范围-将会出现什么现象",normalizedTitle:"我们能将 int 强制转换为 byte 类型的变量吗? 如果该值大于 byte 类型的范围，将会出现什么现象?",charIndex:210},{level:3,title:"存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为 C 么? 如 C = (C) B；",slug:"存在两个类-b-继承-a-c-继承-b-我们能将-b-转换为-c-么-如-c-c-b",normalizedTitle:"存在两个类，b 继承 a，c 继承 b，我们能将 b 转换为 c 么? 如 c = (c) b；",charIndex:273},{level:3,title:"哪个类包含 clone 方法? 是 Cloneable 还是 Object?",slug:"哪个类包含-clone-方法-是-cloneable-还是-object",normalizedTitle:"哪个类包含 clone 方法? 是 cloneable 还是 object?",charIndex:329},{level:3,title:"Java 中 ++ 操作符是线程安全的吗?",slug:"java-中-操作符是线程安全的吗",normalizedTitle:"java 中 ++ 操作符是线程安全的吗?",charIndex:375},{level:3,title:"a = a + b 与 a += b 的区别",slug:"a-a-b-与-a-b-的区别",normalizedTitle:"a = a + b 与 a += b 的区别",charIndex:404},{level:3,title:"我能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗?",slug:"我能在不进行强制转换的情况下将一个-double-值赋值给-long-类型的变量吗",normalizedTitle:"我能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗?",charIndex:434},{level:3,title:"3*0.1 == 0.3 将会返回什么? true 还是 false?",slug:"_3-0-1-0-3-将会返回什么-true-还是-false",normalizedTitle:"3*0.1 == 0.3 将会返回什么? true 还是 false?",charIndex:484},{level:3,title:"int 和 Integer 哪个会占用更多的内存?",slug:"int-和-integer-哪个会占用更多的内存",normalizedTitle:"int 和 integer 哪个会占用更多的内存?",charIndex:527},{level:3,title:"为什么 Java 中的 String 是不可变的(Immutable)?",slug:"为什么-java-中的-string-是不可变的-immutable",normalizedTitle:"为什么 java 中的 string 是不可变的(immutable)?",charIndex:560},{level:3,title:"我们能在 Switch 中使用 String 吗?",slug:"我们能在-switch-中使用-string-吗",normalizedTitle:"我们能在 switch 中使用 string 吗?",charIndex:604},{level:3,title:"Java 中的构造器链是什么?",slug:"java-中的构造器链是什么",normalizedTitle:"java 中的构造器链是什么?",charIndex:637},{level:3,title:"枚举类",slug:"枚举类",normalizedTitle:"枚举类",charIndex:660},{level:3,title:"什么是不可变对象(immutable object)? Java 中怎么创建一个不可变对象?",slug:"什么是不可变对象-immutable-object-java-中怎么创建一个不可变对象",normalizedTitle:"什么是不可变对象(immutable object)? java 中怎么创建一个不可变对象?",charIndex:671},{level:3,title:"我们能创建一个包含可变对象的不可变对象吗?",slug:"我们能创建一个包含可变对象的不可变对象吗",normalizedTitle:"我们能创建一个包含可变对象的不可变对象吗?",charIndex:725},{level:3,title:"有没有可能两个不相等的对象有相同的 hashcode?",slug:"有没有可能两个不相等的对象有相同的-hashcode",normalizedTitle:"有没有可能两个不相等的对象有相同的 hashcode?",charIndex:754},{level:3,title:"两个相同的对象会有不同的 hash code 吗?",slug:"两个相同的对象会有不同的-hash-code-吗",normalizedTitle:"两个相同的对象会有不同的 hash code 吗?",charIndex:789},{level:3,title:"我们可以在 hashcode() 中使用随机数字吗?",slug:"我们可以在-hashcode-中使用随机数字吗",normalizedTitle:"我们可以在 hashcode() 中使用随机数字吗?",charIndex:822},{level:3,title:"Java 中，Comparator 与 Comparable 有什么不同?",slug:"java-中-comparator-与-comparable-有什么不同",normalizedTitle:"java 中，comparator 与 comparable 有什么不同?",charIndex:856},{level:3,title:"为什么在重写 equals 方法的时候需要重写 hashCode 方法?",slug:"为什么在重写-equals-方法的时候需要重写-hashcode-方法",normalizedTitle:"为什么在重写 equals 方法的时候需要重写 hashcode 方法?",charIndex:901},{level:3,title:"“a==b”和”a.equals(b)”有什么区别?",slug:"a-b-和-a-equals-b-有什么区别",normalizedTitle:"“a==b”和”a.equals(b)”有什么区别?",charIndex:945},{level:3,title:"a.hashCode() 有什么用? 与 a.equals(b) 有什么关系?",slug:"a-hashcode-有什么用-与-a-equals-b-有什么关系",normalizedTitle:"a.hashcode() 有什么用? 与 a.equals(b) 有什么关系?",charIndex:979},{level:3,title:"final、finalize 和 finally 的不同之处?",slug:"final、finalize-和-finally-的不同之处",normalizedTitle:"final、finalize 和 finally 的不同之处?",charIndex:1026},{level:3,title:"Java 中的编译期常量是什么? 使用它又什么风险?",slug:"java-中的编译期常量是什么-使用它又什么风险",normalizedTitle:"java 中的编译期常量是什么? 使用它又什么风险?",charIndex:1065},{level:3,title:"静态内部类与顶级类有什么区别?",slug:"静态内部类与顶级类有什么区别",normalizedTitle:"静态内部类与顶级类有什么区别?",charIndex:1099},{level:3,title:"Java 中，Serializable 与 Externalizable 的区别?",slug:"java-中-serializable-与-externalizable-的区别",normalizedTitle:"java 中，serializable 与 externalizable 的区别?",charIndex:1122},{level:3,title:"说出 JDK 1.7 中的三个新特性?",slug:"说出-jdk-1-7-中的三个新特性",normalizedTitle:"说出 jdk 1.7 中的三个新特性?",charIndex:1171},{level:3,title:"说出 5 个 JDK 1.8 引入的新特性?",slug:"说出-5-个-jdk-1-8-引入的新特性",normalizedTitle:"说出 5 个 jdk 1.8 引入的新特性?",charIndex:1198},{level:3,title:"接口是什么? 为什么要使用接口而不是直接使用具体类?",slug:"接口是什么-为什么要使用接口而不是直接使用具体类",normalizedTitle:"接口是什么? 为什么要使用接口而不是直接使用具体类?",charIndex:1228},{level:3,title:"Java 中，抽象类与接口之间有什么不同?",slug:"java-中-抽象类与接口之间有什么不同",normalizedTitle:"java 中，抽象类与接口之间有什么不同?",charIndex:1262},{level:3,title:"Object有哪些公用方法?",slug:"object有哪些公用方法",normalizedTitle:"object有哪些公用方法?",charIndex:1291},{level:3,title:"equals与==的区别",slug:"equals与-的区别",normalizedTitle:"equals与==的区别",charIndex:1313},{level:3,title:"String、StringBuffer与StringBuilder的区别",slug:"string、stringbuffer与stringbuilder的区别",normalizedTitle:"string、stringbuffer与stringbuilder的区别",charIndex:1333},{level:3,title:"switch能否用String做参数",slug:"switch能否用string做参数",normalizedTitle:"switch能否用string做参数",charIndex:1377},{level:3,title:"接口与抽象类",slug:"接口与抽象类",normalizedTitle:"接口与抽象类",charIndex:1403},{level:3,title:"抽象类和最终类",slug:"抽象类和最终类",normalizedTitle:"抽象类和最终类",charIndex:1417},{level:3,title:"异常",slug:"异常",normalizedTitle:"异常",charIndex:1432},{level:3,title:"关于finally",slug:"关于finally",normalizedTitle:"关于finally",charIndex:1442},{level:3,title:"受检查异常和运行时异常",slug:"受检查异常和运行时异常",normalizedTitle:"受检查异常和运行时异常",charIndex:1459},{level:3,title:"super出现在父类的子类中。有三种存在方式",slug:"super出现在父类的子类中。有三种存在方式",normalizedTitle:"super出现在父类的子类中。有三种存在方式",charIndex:1478},{level:3,title:"this() & super()在构造方法中的区别",slug:"this-super-在构造方法中的区别",normalizedTitle:"this() &amp; super()在构造方法中的区别",charIndex:null},{level:3,title:"构造内部类和静态内部类对象",slug:"构造内部类和静态内部类对象",normalizedTitle:"构造内部类和静态内部类对象",charIndex:1541},{level:3,title:"序列化",slug:"序列化",normalizedTitle:"序列化",charIndex:1562},{level:3,title:"Java移位运算符",slug:"java移位运算符",normalizedTitle:"java移位运算符",charIndex:1573},{level:3,title:"形参&实参",slug:"形参-实参",normalizedTitle:"形参&amp;实参",charIndex:null},{level:3,title:"局部变量为什么要初始化",slug:"局部变量为什么要初始化",normalizedTitle:"局部变量为什么要初始化",charIndex:1603},{level:3,title:"Java语言的鲁棒性",slug:"java语言的鲁棒性",normalizedTitle:"java语言的鲁棒性",charIndex:1622}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java 基础 - 图谱 & Q/A 参考文档 知识体系 Q&A Java 中应该使用什么数据类型来代表价格? 怎么将 byte 转换为 String? Java 中怎样将 bytes 转换为 long 类型? 我们能将 int 强制转换为 byte 类型的变量吗? 如果该值大于 byte 类型的范围，将会出现什么现象? 存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为 C 么? 如 C = (C) B； 哪个类包含 clone 方法? 是 Cloneable 还是 Object? Java 中 ++ 操作符是线程安全的吗? a = a + b 与 a += b 的区别 我能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗? 3*0.1 == 0.3 将会返回什么? true 还是 false? int 和 Integer 哪个会占用更多的内存? 为什么 Java 中的 String 是不可变的(Immutable)? 我们能在 Switch 中使用 String 吗? Java 中的构造器链是什么? 枚举类 什么是不可变对象(immutable object)? Java 中怎么创建一个不可变对象? 我们能创建一个包含可变对象的不可变对象吗? 有没有可能两个不相等的对象有相同的 hashcode? 两个相同的对象会有不同的 hash code 吗? 我们可以在 hashcode() 中使用随机数字吗? Java 中，Comparator 与 Comparable 有什么不同? 为什么在重写 equals 方法的时候需要重写 hashCode 方法? “a==b”和”a.equals(b)”有什么区别? a.hashCode() 有什么用? 与 a.equals(b) 有什么关系? final、finalize 和 finally 的不同之处? Java 中的编译期常量是什么? 使用它又什么风险? 静态内部类与顶级类有什么区别? Java 中，Serializable 与 Externalizable 的区别? 说出 JDK 1.7 中的三个新特性? 说出 5 个 JDK 1.8 引入的新特性? 接口是什么? 为什么要使用接口而不是直接使用具体类? Java 中，抽象类与接口之间有什么不同? Object有哪些公用方法? equals与==的区别 String、StringBuffer与StringBuilder的区别 switch能否用String做参数 接口与抽象类 抽象类和最终类 异常 关于finally 受检查异常和运行时异常 super出现在父类的子类中。有三种存在方式 this() & super()在构造方法中的区别 构造内部类和静态内部类对象 序列化 Java移位运算符 形参&实参 局部变量为什么要初始化 Java语言的鲁棒性",content:"# Java 基础 - 图谱 & Q/A\n\n> 本文主要对Java基础知识体系小结，同时结合一些Q&A进行理解。\n\n * Java 基础 - 图谱 & Q/A\n   * 参考文档\n   * 知识体系\n   * Q&A\n     * Java 中应该使用什么数据类型来代表价格?\n     * 怎么将 byte 转换为 String?\n     * Java 中怎样将 bytes 转换为 long 类型?\n     * 我们能将 int 强制转换为 byte 类型的变量吗? 如果该值大于 byte 类型的范围，将会出现什么现象?\n     * 存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为 C 么? 如 C = (C) B；\n     * 哪个类包含 clone 方法? 是 Cloneable 还是 Object?\n     * Java 中 ++ 操作符是线程安全的吗?\n     * a = a + b 与 a += b 的区别\n     * 我能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗?\n     * 3*0.1 == 0.3 将会返回什么? true 还是 false?\n     * int 和 Integer 哪个会占用更多的内存?\n     * 为什么 Java 中的 String 是不可变的(Immutable)?\n     * 我们能在 Switch 中使用 String 吗?\n     * Java 中的构造器链是什么?\n     * 枚举类\n     * 什么是不可变对象(immutable object)? Java 中怎么创建一个不可变对象?\n     * 我们能创建一个包含可变对象的不可变对象吗?\n     * 有没有可能两个不相等的对象有相同的 hashcode?\n     * 两个相同的对象会有不同的 hash code 吗?\n     * 我们可以在 hashcode() 中使用随机数字吗?\n     * Java 中，Comparator 与 Comparable 有什么不同?\n     * 为什么在重写 equals 方法的时候需要重写 hashCode 方法?\n     * “a==b”和”a.equals(b)”有什么区别?\n     * a.hashCode() 有什么用? 与 a.equals(b) 有什么关系?\n     * final、finalize 和 finally 的不同之处?\n     * Java 中的编译期常量是什么? 使用它又什么风险?\n     * 静态内部类与顶级类有什么区别?\n     * Java 中，Serializable 与 Externalizable 的区别?\n     * 说出 JDK 1.7 中的三个新特性?\n     * 说出 5 个 JDK 1.8 引入的新特性?\n     * 接口是什么? 为什么要使用接口而不是直接使用具体类?\n     * Java 中，抽象类与接口之间有什么不同?\n     * Object有哪些公用方法?\n     * equals与==的区别\n     * String、StringBuffer与StringBuilder的区别\n     * switch能否用String做参数\n     * 接口与抽象类\n     * 抽象类和最终类\n     * 异常\n     * 关于finally\n     * 受检查异常和运行时异常\n     * super出现在父类的子类中。有三种存在方式\n     * this() & super()在构造方法中的区别\n     * 构造内部类和静态内部类对象\n     * 序列化\n     * Java移位运算符\n     * 形参&实参\n     * 局部变量为什么要初始化\n     * Java语言的鲁棒性\n\n\n# 参考文档\n\n * Thinking in Java (Java 编程思想) Gitbook中文文档 https://java.quanke.name/\n * Thinking in Java (Java 编程思想) Github https://github.com/quanke/think-in-java\n * Thinking in Java (Java 编程思想) Gitbook2 https://www.gitbook.com/book/wizardforcel/thinking-in-java/details\n * 转载 https://www.pdai.tech/md/java/basic/java-basic-lan-sum.html\n\n\n# 知识体系\n\n\n\n\n# Q&A\n\n\n# Java 中应该使用什么数据类型来代表价格?\n\n如果不是特别关心内存和性能的话，使用BigDecimal，否则使用预定义精度的 double 类型。\n\n\n# 怎么将 byte 转换为 String?\n\n可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。\n\n\n# Java 中怎样将 bytes 转换为 long 类型?\n\nString接收bytes的构造器转成String，再Long.parseLong\n\n\n# 我们能将 int 强制转换为 byte 类型的变量吗? 如果该值大于 byte 类型的范围，将会出现什么现象?\n\n是的，我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化是，int 类型的高 24 位将会被丢弃，byte 类型的范围是从 -128 到 127。\n\n\n# 存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为 C 么? 如 C = (C) B；\n\n可以，向下转型。但是不建议使用，容易出现类型转型异常.\n\n\n# 哪个类包含 clone 方法? 是 Cloneable 还是 Object?\n\njava.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在 object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由 c 或 c++ 或 其他本地语言实现的。\n\n\n# Java 中 ++ 操作符是线程安全的吗?\n\n不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。还会存在竞态条件(读取-修改-写入)。\n\n\n# a = a + b 与 a += b 的区别\n\n+= 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。\n\nbyte a = 127;\nbyte b = 127;\nb = a + b; // error : cannot convert from int to byte\nb += a; // ok\n\n\n(因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错)\n\n\n# 我能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗?\n\n不行，你不能在没有强制类型转换的前提下将一个 double 值赋值给 long 类型的变量，因为 double 类型的范围比 long 类型更广，所以必须要进行强制转换。\n\n\n# 3*0.1 == 0.3 将会返回什么? true 还是 false?\n\nfalse，因为有些浮点数不能完全精确的表示出来。\n\n\n# int 和 Integer 哪个会占用更多的内存?\n\nInteger 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间更少。\n\n\n# 为什么 Java 中的 String 是不可变的(Immutable)?\n\nJava 中的 String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串。更详细的内容参见答案。\n\n\n# 我们能在 Switch 中使用 String 吗?\n\n从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。\n\n\n# Java 中的构造器链是什么?\n\n当你从一个构造器中调用另一个构造器，就是Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现。\n\n\n# 枚举类\n\nJDK1.5出现 每个枚举值都需要调用一次构造函数\n\n\n# 什么是不可变对象(immutable object)? Java 中怎么创建一个不可变对象?\n\n不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。\n\n如何在Java中写出Immutable的类?\n\n要写出这样的类，需要遵循以下几个原则:\n\n1)immutable对象的状态在创建之后就不能发生改变，任何对它的改变都应该产生一个新的对象。\n\n2)Immutable类的所有的属性都应该是final的。\n\n3)对象必须被正确的创建，比如: 对象引用在对象创建过程中不能泄露(leak)。\n\n4)对象应该是final的，以此来限制子类继承父类，以避免子类改变了父类的immutable特性。\n\n5)如果类中包含mutable类对象，那么返回给客户端的时候，返回该对象的一个拷贝，而不是该对象本身(该条可以归为第一条中的一个特例)\n\n\n# 我们能创建一个包含可变对象的不可变对象吗?\n\n是的，我们是可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用。\n\n\n# 有没有可能两个不相等的对象有相同的 hashcode?\n\n有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。\n\n\n# 两个相同的对象会有不同的 hash code 吗?\n\n不能，根据 hash code 的规定，这是不可能的。\n\n\n# 我们可以在 hashcode() 中使用随机数字吗?\n\n不行，因为对象的 hashcode 值必须是相同的。\n\n\n# Java 中，Comparator 与 Comparable 有什么不同?\n\nComparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。\n\n\n# 为什么在重写 equals 方法的时候需要重写 hashCode 方法?\n\n因为有强制的规范指定需要同时重写 hashcode 与 equals 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。\n\n\n# “a==b”和”a.equals(b)”有什么区别?\n\n如果 a 和 b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。\n\n\n# a.hashCode() 有什么用? 与 a.equals(b) 有什么关系?\n\n简介: hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equals() 方法来判断相等的对象，必须具有相同的 hash code。\n\n1、hashcode的作用\n\nList和Set，如何保证Set不重复呢? 通过迭代使用equals方法来判断，数据量小还可以接受，数据量大怎么解决? 引入hashcode，实际上hashcode扮演的角色就是寻址，大大减少查询匹配次数。\n\n2、hashcode重要吗\n\n对于数组、List集合就是一个累赘。而对于hashmap, hashset, hashtable就异常重要了。\n\n3、equals方法遵循的原则\n\n * 对称性 若x.equals(y)true，则y.equals(x)true\n * 自反性 x.equals(x)必须true\n * 传递性 若x.equals(y)true,y.equals(z)true,则x.equals(z)必为true\n * 一致性 只要x,y内容不变，无论调用多少次结果不变\n * 其他 x.equals(null) 永远false，x.equals(和x数据类型不同)始终false\n\n\n# final、finalize 和 finally 的不同之处?\n\n * final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。\n * Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的，但是什么时候调用 finalize 没有保证。\n * finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。\n\n\n# Java 中的编译期常量是什么? 使用它又什么风险?\n\n变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。\n\n\n# 静态内部类与顶级类有什么区别?\n\n一个公共的顶级类的源文件名称与类名相同，而嵌套静态类没有这个要求。一个嵌套类位于顶级类内部，需要使用顶级类的名称来引用嵌套静态类，如 HashMap.Entry 是一个嵌套静态类，HashMap 是一个顶级类，Entry是一个嵌套静态类。\n\n\n# Java 中，Serializable 与 Externalizable 的区别?\n\nSerializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。\n\n\n# 说出 JDK 1.7 中的三个新特性?\n\n虽然 JDK 1.7 不像 JDK 5 和 8 一样的大版本，但是，还是有很多新的特性，如 try-with-resource 语句，这样你在使用流或者资源的时候，就不需要手动关闭，Java 会自动关闭。Fork-Join 池某种程度上实现 Java 版的 Map-reduce。允许 Switch 中有 String 变量和文本。菱形操作符(<>)用于泛型推断，不再需要在变量声明的右边申明泛型，因此可以写出可读写更强、更简洁的代码。另一个值得一提的特性是改善异常处理，如允许在同一个 catch 块中捕获多个异常。\n\n\n# 说出 5 个 JDK 1.8 引入的新特性?\n\nJava 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性: Lambda 表达式，允许像对象一样传递匿名函数 Stream API，充分利用现代多核 CPU，可以写出很简洁的代码 Date 与 Time API，最终，有一个稳定、简单的日期和时间库可供你使用 扩展方法，现在，接口中可以有静态、默认方法。 重复注解，现在你可以将相同的注解在同一类型上使用多次。\n\n下述包含 Java 面试过程中关于 SOLID 的设计原则，OOP 基础，如类，对象，接口，继承，多态，封装，抽象以及更高级的一些概念，如组合、聚合及关联。也包含了 GOF 设计模式的问题。\n\n\n# 接口是什么? 为什么要使用接口而不是直接使用具体类?\n\n接口用于定义 API。它定义了类必须得遵循的规则。同时，它提供了一种抽象，因为客户端只使用接口，这样可以有多重实现，如 List 接口，你可以使用可随机访问的 ArrayList，也可以使用方便插入和删除的 LinkedList。接口中不允许普通方法，以此来保证抽象，但是 Java 8 中你可以在接口声明静态方法和默认普通方法。\n\n\n# Java 中，抽象类与接口之间有什么不同?\n\nJava 中，抽象类和接口有很多不同之处，但是最重要的一个是 Java 中限制一个类只能继承一个类，但是可以实现多个接口。抽象类可以很好的定义一个家族类的默认行为，而接口能更好的定义类型，有助于后面实现多态机制 参见第六条。\n\n\n# Object有哪些公用方法?\n\nclone equals hashcode wait notify notifyall finalize toString getClass 除了clone和finalize其他均为公共方法。\n\n11个方法，wait被重载了两次\n\n\n# equals与==的区别\n\n区别1. ==是一个运算符 equals是Object类的方法\n\n区别2. 比较时的区别\n\n * 用于基本类型的变量比较时: ==用于比较值是否相等，equals不能直接用于基本数据类型的比较，需要转换为其对应的包装类型。\n * 用于引用类型的比较时。==和equals都是比较栈内存中的地址是否相等 。相等为true 否则为false。但是通常会重写equals方法去实现对象内容的比较。\n\n\n# String、StringBuffer与StringBuilder的区别\n\n第一点: 可变和适用范围。String对象是不可变的，而StringBuffer和StringBuilder是可变字符序列。每次对String的操作相当于生成一个新的String对象，而对StringBuffer和StringBuilder的操作是对对象本身的操作，而不会生成新的对象，所以对于频繁改变内容的字符串避免使用String，因为频繁的生成对象将会对系统性能产生影响。\n\n第二点: 线程安全。String由于有final修饰，是immutable的，安全性是简单而纯粹的。StringBuilder和StringBuffer的区别在于StringBuilder不保证同步，也就是说如果需要线程安全需要使用StringBuffer，不需要同步的StringBuilder效率更高。\n\n\n# switch能否用String做参数\n\nJava1.7开始支持，但实际这是一颗Java语法糖。除此之外，byte，short，int，枚举均可用于switch，而boolean和浮点型不可以。\n\n\n# 接口与抽象类\n\n * 一个子类只能继承一个抽象类, 但能实现多个接口\n * 抽象类可以有构造方法, 接口没有构造方法\n * 抽象类可以有普通成员变量, 接口没有普通成员变量\n * 抽象类和接口都可有静态成员变量, 抽象类中静态成员变量访问类型任意，接口只能public static final(默认)\n * 抽象类可以没有抽象方法, 抽象类可以有普通方法；接口在JDK8之前都是抽象方法，在JDK8可以有default方法，在JDK9中允许有私有普通方法\n * 抽象类可以有静态方法；接口在JDK8之前不能有静态方法，在JDK8中可以有静态方法，且只能被接口类直接调用（不能被实现类的对象调用）\n * 抽象类中的方法可以是public、protected; 接口方法在JDK8之前只有public abstract，在JDK8可以有default方法，在JDK9中允许有private方法\n\n\n# 抽象类和最终类\n\n抽象类可以没有抽象方法, 最终类可以没有最终方法\n\n最终类不能被继承, 最终方法不能被重写(可以重载)\n\n\n# 异常\n\n相关的关键字 throw、throws、try...catch、finally\n\n * throws 用在方法签名上, 以便抛出的异常可以被调用者处理\n * throw 方法内部通过throw抛出异常\n * try 用于检测包住的语句块, 若有异常, catch子句捕获并执行catch块\n\n\n# 关于finally\n\n * finally不管有没有异常都要处理\n * 当try和catch中有return时，finally仍然会执行，finally比return先执行\n * 不管有木有异常抛出, finally在return返回前执行\n * finally是在return后面的表达式运算后执行的(此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值)，所以函数返回值是在finally执行前确定的\n\n注意: finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值\n\nfinally不执行的几种情况: 程序提前终止如调用了System.exit, 病毒，断电\n\n\n# 受检查异常和运行时异常\n\n * 受检查的异常(checked exceptions),其必须被try...catch语句块所捕获, 或者在方法签名里通过throws子句声明。受检查的异常必须在编译时被捕捉处理,命名为Checked Exception是因为Java编译器要进行检查, Java虚拟机也要进行检查, 以确保这个规则得到遵守。\n\n常见的checked exception: ClassNotFoundException IOException FileNotFoundException EOFException\n\n * 运行时异常(runtime exceptions), 需要程序员自己分析代码决定是否捕获和处理,比如空指针,被0除...\n\n常见的runtime exception: NullPointerException ArithmeticException ClassCastException IllegalArgumentException IllegalStateException IndexOutOfBoundsException NoSuchElementException\n\n * Error的，则属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，Error不需要捕获。\n\n\n# super出现在父类的子类中。有三种存在方式\n\n * super.xxx(xxx为变量名或对象名)意思是获取父类中xxx的变量或引用\n * super.xxx(); (xxx为方法名)意思是直接访问并调用父类中的方法\n * super() 调用父类构造\n\n注: super只能指代其直接父类\n\n\n# this() & super()在构造方法中的区别\n\n * 调用super()必须写在子类构造方法的第一行, 否则编译不通过\n * super从子类调用父类构造, this在同一类中调用其他构造均需要放在第一行\n * 尽管可以用this调用一个构造器, 却不能调用2个\n * this和super不能出现在同一个构造器中, 否则编译不通过\n * this()、super()都指的对象,不可以在static环境中使用\n * 本质this指向本对象的指针。super是一个关键字\n\n\n# 构造内部类和静态内部类对象\n\npublic class Enclosingone {\n\tpublic class Insideone {}\n\tpublic static class Insideone{}\n}\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t// 构造内部类对象需要外部类的引用\n\tEnclosingone.Insideone obj1 = new Enclosingone().new Insideone();\n\t// 构造静态内部类的对象\n\tEnclosingone.Insideone obj2 = new Enclosingone.Insideone();\n\t}\n}\n\n\n静态内部类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。非静态内部类能够访问外部类的静态和非静态成员。静态内部类不能访问外部类的非静态成员，只能访问外部类的静态成员。\n\n\n# 序列化\n\n声明为static和transient类型的数据不能被序列化， 反序列化需要一个无参构造函数\n\n\n# Java移位运算符\n\njava中有三种移位运算符\n\n * << :左移运算符,x << 1,相当于x乘以2(不溢出的情况下),低位补0\n * >> :带符号右移,x >> 1,相当于x除以2,正数高位补0,负数高位补1\n * >>> :无符号右移,忽略符号位,空位都以0补齐\n\n\n# 形参&实参\n\n形式参数可被视为local variable.形参和局部变量一样都不能离开方法。只有在方法中使用，不会在方法外可见。 形式参数只能用final修饰符，其它任何修饰符都会引起编译器错误。但是用这个修饰符也有一定的限制，就是在方法中不能对参数做任何修改。不过一般情况下，一个方法的形参不用final修饰。只有在特殊情况下，那就是: 方法内部类。一个方法内的内部类如果使用了这个方法的参数或者局部变量的话，这个参数或局部变量应该是final。 形参的值在调用时根据调用者更改，实参则用自身的值更改形参的值(指针、引用皆在此列)，也就是说真正被传递的是实参。\n\n\n# 局部变量为什么要初始化\n\n局部变量是指类方法中的变量，必须初始化。局部变量运行时被分配在栈中，量大，生命周期短，如果虚拟机给每个局部变量都初始化一下，是一笔很大的开销，但变量不初始化为默认值就使用是不安全的。出于速度和安全性两个方面的综合考虑，解决方案就是虚拟机不初始化，但要求编写者一定要在使用前给变量赋值。\n\n\n# Java语言的鲁棒性\n\nJava在编译和运行程序时，都要对可能出现的问题进行检查，以消除错误的产生。它提供自动垃圾收集来进行内存管理，防止程序员在管理内存时容易产生的错误。通过集成的面向对象的例外处理机制，在编译时，Java揭示出可能出现但未被处理的异常，帮助程序员正确地进行选择以防止系统的崩溃。另外，Java在编译时还可捕获类型声明中的许多常见错误，防止动态运行时不匹配问题的出现。",normalizedContent:"# java 基础 - 图谱 & q/a\n\n> 本文主要对java基础知识体系小结，同时结合一些q&a进行理解。\n\n * java 基础 - 图谱 & q/a\n   * 参考文档\n   * 知识体系\n   * q&a\n     * java 中应该使用什么数据类型来代表价格?\n     * 怎么将 byte 转换为 string?\n     * java 中怎样将 bytes 转换为 long 类型?\n     * 我们能将 int 强制转换为 byte 类型的变量吗? 如果该值大于 byte 类型的范围，将会出现什么现象?\n     * 存在两个类，b 继承 a，c 继承 b，我们能将 b 转换为 c 么? 如 c = (c) b；\n     * 哪个类包含 clone 方法? 是 cloneable 还是 object?\n     * java 中 ++ 操作符是线程安全的吗?\n     * a = a + b 与 a += b 的区别\n     * 我能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗?\n     * 3*0.1 == 0.3 将会返回什么? true 还是 false?\n     * int 和 integer 哪个会占用更多的内存?\n     * 为什么 java 中的 string 是不可变的(immutable)?\n     * 我们能在 switch 中使用 string 吗?\n     * java 中的构造器链是什么?\n     * 枚举类\n     * 什么是不可变对象(immutable object)? java 中怎么创建一个不可变对象?\n     * 我们能创建一个包含可变对象的不可变对象吗?\n     * 有没有可能两个不相等的对象有相同的 hashcode?\n     * 两个相同的对象会有不同的 hash code 吗?\n     * 我们可以在 hashcode() 中使用随机数字吗?\n     * java 中，comparator 与 comparable 有什么不同?\n     * 为什么在重写 equals 方法的时候需要重写 hashcode 方法?\n     * “a==b”和”a.equals(b)”有什么区别?\n     * a.hashcode() 有什么用? 与 a.equals(b) 有什么关系?\n     * final、finalize 和 finally 的不同之处?\n     * java 中的编译期常量是什么? 使用它又什么风险?\n     * 静态内部类与顶级类有什么区别?\n     * java 中，serializable 与 externalizable 的区别?\n     * 说出 jdk 1.7 中的三个新特性?\n     * 说出 5 个 jdk 1.8 引入的新特性?\n     * 接口是什么? 为什么要使用接口而不是直接使用具体类?\n     * java 中，抽象类与接口之间有什么不同?\n     * object有哪些公用方法?\n     * equals与==的区别\n     * string、stringbuffer与stringbuilder的区别\n     * switch能否用string做参数\n     * 接口与抽象类\n     * 抽象类和最终类\n     * 异常\n     * 关于finally\n     * 受检查异常和运行时异常\n     * super出现在父类的子类中。有三种存在方式\n     * this() & super()在构造方法中的区别\n     * 构造内部类和静态内部类对象\n     * 序列化\n     * java移位运算符\n     * 形参&实参\n     * 局部变量为什么要初始化\n     * java语言的鲁棒性\n\n\n# 参考文档\n\n * thinking in java (java 编程思想) gitbook中文文档 https://java.quanke.name/\n * thinking in java (java 编程思想) github https://github.com/quanke/think-in-java\n * thinking in java (java 编程思想) gitbook2 https://www.gitbook.com/book/wizardforcel/thinking-in-java/details\n * 转载 https://www.pdai.tech/md/java/basic/java-basic-lan-sum.html\n\n\n# 知识体系\n\n\n\n\n# q&a\n\n\n# java 中应该使用什么数据类型来代表价格?\n\n如果不是特别关心内存和性能的话，使用bigdecimal，否则使用预定义精度的 double 类型。\n\n\n# 怎么将 byte 转换为 string?\n\n可以使用 string 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。\n\n\n# java 中怎样将 bytes 转换为 long 类型?\n\nstring接收bytes的构造器转成string，再long.parselong\n\n\n# 我们能将 int 强制转换为 byte 类型的变量吗? 如果该值大于 byte 类型的范围，将会出现什么现象?\n\n是的，我们可以做强制转换，但是 java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化是，int 类型的高 24 位将会被丢弃，byte 类型的范围是从 -128 到 127。\n\n\n# 存在两个类，b 继承 a，c 继承 b，我们能将 b 转换为 c 么? 如 c = (c) b；\n\n可以，向下转型。但是不建议使用，容易出现类型转型异常.\n\n\n# 哪个类包含 clone 方法? 是 cloneable 还是 object?\n\njava.lang.cloneable 是一个标示性接口，不包含任何方法，clone 方法在 object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由 c 或 c++ 或 其他本地语言实现的。\n\n\n# java 中 ++ 操作符是线程安全的吗?\n\n不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。还会存在竞态条件(读取-修改-写入)。\n\n\n# a = a + b 与 a += b 的区别\n\n+= 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。\n\nbyte a = 127;\nbyte b = 127;\nb = a + b; // error : cannot convert from int to byte\nb += a; // ok\n\n\n(因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错)\n\n\n# 我能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗?\n\n不行，你不能在没有强制类型转换的前提下将一个 double 值赋值给 long 类型的变量，因为 double 类型的范围比 long 类型更广，所以必须要进行强制转换。\n\n\n# 3*0.1 == 0.3 将会返回什么? true 还是 false?\n\nfalse，因为有些浮点数不能完全精确的表示出来。\n\n\n# int 和 integer 哪个会占用更多的内存?\n\ninteger 对象会占用更多的内存。integer 是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间更少。\n\n\n# 为什么 java 中的 string 是不可变的(immutable)?\n\njava 中的 string 不可变是因为 java 的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串。更详细的内容参见答案。\n\n\n# 我们能在 switch 中使用 string 吗?\n\n从 java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。\n\n\n# java 中的构造器链是什么?\n\n当你从一个构造器中调用另一个构造器，就是java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现。\n\n\n# 枚举类\n\njdk1.5出现 每个枚举值都需要调用一次构造函数\n\n\n# 什么是不可变对象(immutable object)? java 中怎么创建一个不可变对象?\n\n不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 string、integer及其它包装类。\n\n如何在java中写出immutable的类?\n\n要写出这样的类，需要遵循以下几个原则:\n\n1)immutable对象的状态在创建之后就不能发生改变，任何对它的改变都应该产生一个新的对象。\n\n2)immutable类的所有的属性都应该是final的。\n\n3)对象必须被正确的创建，比如: 对象引用在对象创建过程中不能泄露(leak)。\n\n4)对象应该是final的，以此来限制子类继承父类，以避免子类改变了父类的immutable特性。\n\n5)如果类中包含mutable类对象，那么返回给客户端的时候，返回该对象的一个拷贝，而不是该对象本身(该条可以归为第一条中的一个特例)\n\n\n# 我们能创建一个包含可变对象的不可变对象吗?\n\n是的，我们是可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用。\n\n\n# 有没有可能两个不相等的对象有相同的 hashcode?\n\n有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。\n\n\n# 两个相同的对象会有不同的 hash code 吗?\n\n不能，根据 hash code 的规定，这是不可能的。\n\n\n# 我们可以在 hashcode() 中使用随机数字吗?\n\n不行，因为对象的 hashcode 值必须是相同的。\n\n\n# java 中，comparator 与 comparable 有什么不同?\n\ncomparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。\n\n\n# 为什么在重写 equals 方法的时候需要重写 hashcode 方法?\n\n因为有强制的规范指定需要同时重写 hashcode 与 equals 是方法，许多容器类，如 hashmap、hashset 都依赖于 hashcode 与 equals 的规定。\n\n\n# “a==b”和”a.equals(b)”有什么区别?\n\n如果 a 和 b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，string 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。\n\n\n# a.hashcode() 有什么用? 与 a.equals(b) 有什么关系?\n\n简介: hashcode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 hashtable、hashmap、linkedhashmap等等。它与 equals() 方法关系特别紧密。根据 java 规范，两个使用 equals() 方法来判断相等的对象，必须具有相同的 hash code。\n\n1、hashcode的作用\n\nlist和set，如何保证set不重复呢? 通过迭代使用equals方法来判断，数据量小还可以接受，数据量大怎么解决? 引入hashcode，实际上hashcode扮演的角色就是寻址，大大减少查询匹配次数。\n\n2、hashcode重要吗\n\n对于数组、list集合就是一个累赘。而对于hashmap, hashset, hashtable就异常重要了。\n\n3、equals方法遵循的原则\n\n * 对称性 若x.equals(y)true，则y.equals(x)true\n * 自反性 x.equals(x)必须true\n * 传递性 若x.equals(y)true,y.equals(z)true,则x.equals(z)必为true\n * 一致性 只要x,y内容不变，无论调用多少次结果不变\n * 其他 x.equals(null) 永远false，x.equals(和x数据类型不同)始终false\n\n\n# final、finalize 和 finally 的不同之处?\n\n * final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。\n * java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的，但是什么时候调用 finalize 没有保证。\n * finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。\n\n\n# java 中的编译期常量是什么? 使用它又什么风险?\n\n变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 jar 文件时，确保重新编译你的程序。\n\n\n# 静态内部类与顶级类有什么区别?\n\n一个公共的顶级类的源文件名称与类名相同，而嵌套静态类没有这个要求。一个嵌套类位于顶级类内部，需要使用顶级类的名称来引用嵌套静态类，如 hashmap.entry 是一个嵌套静态类，hashmap 是一个顶级类，entry是一个嵌套静态类。\n\n\n# java 中，serializable 与 externalizable 的区别?\n\nserializable 接口是一个序列化 java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 jvm 内嵌的默认序列化方式，成本高、脆弱而且不安全。externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。\n\n\n# 说出 jdk 1.7 中的三个新特性?\n\n虽然 jdk 1.7 不像 jdk 5 和 8 一样的大版本，但是，还是有很多新的特性，如 try-with-resource 语句，这样你在使用流或者资源的时候，就不需要手动关闭，java 会自动关闭。fork-join 池某种程度上实现 java 版的 map-reduce。允许 switch 中有 string 变量和文本。菱形操作符(<>)用于泛型推断，不再需要在变量声明的右边申明泛型，因此可以写出可读写更强、更简洁的代码。另一个值得一提的特性是改善异常处理，如允许在同一个 catch 块中捕获多个异常。\n\n\n# 说出 5 个 jdk 1.8 引入的新特性?\n\njava 8 在 java 历史上是一个开创新的版本，下面 jdk 8 中 5 个主要的特性: lambda 表达式，允许像对象一样传递匿名函数 stream api，充分利用现代多核 cpu，可以写出很简洁的代码 date 与 time api，最终，有一个稳定、简单的日期和时间库可供你使用 扩展方法，现在，接口中可以有静态、默认方法。 重复注解，现在你可以将相同的注解在同一类型上使用多次。\n\n下述包含 java 面试过程中关于 solid 的设计原则，oop 基础，如类，对象，接口，继承，多态，封装，抽象以及更高级的一些概念，如组合、聚合及关联。也包含了 gof 设计模式的问题。\n\n\n# 接口是什么? 为什么要使用接口而不是直接使用具体类?\n\n接口用于定义 api。它定义了类必须得遵循的规则。同时，它提供了一种抽象，因为客户端只使用接口，这样可以有多重实现，如 list 接口，你可以使用可随机访问的 arraylist，也可以使用方便插入和删除的 linkedlist。接口中不允许普通方法，以此来保证抽象，但是 java 8 中你可以在接口声明静态方法和默认普通方法。\n\n\n# java 中，抽象类与接口之间有什么不同?\n\njava 中，抽象类和接口有很多不同之处，但是最重要的一个是 java 中限制一个类只能继承一个类，但是可以实现多个接口。抽象类可以很好的定义一个家族类的默认行为，而接口能更好的定义类型，有助于后面实现多态机制 参见第六条。\n\n\n# object有哪些公用方法?\n\nclone equals hashcode wait notify notifyall finalize tostring getclass 除了clone和finalize其他均为公共方法。\n\n11个方法，wait被重载了两次\n\n\n# equals与==的区别\n\n区别1. ==是一个运算符 equals是object类的方法\n\n区别2. 比较时的区别\n\n * 用于基本类型的变量比较时: ==用于比较值是否相等，equals不能直接用于基本数据类型的比较，需要转换为其对应的包装类型。\n * 用于引用类型的比较时。==和equals都是比较栈内存中的地址是否相等 。相等为true 否则为false。但是通常会重写equals方法去实现对象内容的比较。\n\n\n# string、stringbuffer与stringbuilder的区别\n\n第一点: 可变和适用范围。string对象是不可变的，而stringbuffer和stringbuilder是可变字符序列。每次对string的操作相当于生成一个新的string对象，而对stringbuffer和stringbuilder的操作是对对象本身的操作，而不会生成新的对象，所以对于频繁改变内容的字符串避免使用string，因为频繁的生成对象将会对系统性能产生影响。\n\n第二点: 线程安全。string由于有final修饰，是immutable的，安全性是简单而纯粹的。stringbuilder和stringbuffer的区别在于stringbuilder不保证同步，也就是说如果需要线程安全需要使用stringbuffer，不需要同步的stringbuilder效率更高。\n\n\n# switch能否用string做参数\n\njava1.7开始支持，但实际这是一颗java语法糖。除此之外，byte，short，int，枚举均可用于switch，而boolean和浮点型不可以。\n\n\n# 接口与抽象类\n\n * 一个子类只能继承一个抽象类, 但能实现多个接口\n * 抽象类可以有构造方法, 接口没有构造方法\n * 抽象类可以有普通成员变量, 接口没有普通成员变量\n * 抽象类和接口都可有静态成员变量, 抽象类中静态成员变量访问类型任意，接口只能public static final(默认)\n * 抽象类可以没有抽象方法, 抽象类可以有普通方法；接口在jdk8之前都是抽象方法，在jdk8可以有default方法，在jdk9中允许有私有普通方法\n * 抽象类可以有静态方法；接口在jdk8之前不能有静态方法，在jdk8中可以有静态方法，且只能被接口类直接调用（不能被实现类的对象调用）\n * 抽象类中的方法可以是public、protected; 接口方法在jdk8之前只有public abstract，在jdk8可以有default方法，在jdk9中允许有private方法\n\n\n# 抽象类和最终类\n\n抽象类可以没有抽象方法, 最终类可以没有最终方法\n\n最终类不能被继承, 最终方法不能被重写(可以重载)\n\n\n# 异常\n\n相关的关键字 throw、throws、try...catch、finally\n\n * throws 用在方法签名上, 以便抛出的异常可以被调用者处理\n * throw 方法内部通过throw抛出异常\n * try 用于检测包住的语句块, 若有异常, catch子句捕获并执行catch块\n\n\n# 关于finally\n\n * finally不管有没有异常都要处理\n * 当try和catch中有return时，finally仍然会执行，finally比return先执行\n * 不管有木有异常抛出, finally在return返回前执行\n * finally是在return后面的表达式运算后执行的(此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值)，所以函数返回值是在finally执行前确定的\n\n注意: finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值\n\nfinally不执行的几种情况: 程序提前终止如调用了system.exit, 病毒，断电\n\n\n# 受检查异常和运行时异常\n\n * 受检查的异常(checked exceptions),其必须被try...catch语句块所捕获, 或者在方法签名里通过throws子句声明。受检查的异常必须在编译时被捕捉处理,命名为checked exception是因为java编译器要进行检查, java虚拟机也要进行检查, 以确保这个规则得到遵守。\n\n常见的checked exception: classnotfoundexception ioexception filenotfoundexception eofexception\n\n * 运行时异常(runtime exceptions), 需要程序员自己分析代码决定是否捕获和处理,比如空指针,被0除...\n\n常见的runtime exception: nullpointerexception arithmeticexception classcastexception illegalargumentexception illegalstateexception indexoutofboundsexception nosuchelementexception\n\n * error的，则属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，error不需要捕获。\n\n\n# super出现在父类的子类中。有三种存在方式\n\n * super.xxx(xxx为变量名或对象名)意思是获取父类中xxx的变量或引用\n * super.xxx(); (xxx为方法名)意思是直接访问并调用父类中的方法\n * super() 调用父类构造\n\n注: super只能指代其直接父类\n\n\n# this() & super()在构造方法中的区别\n\n * 调用super()必须写在子类构造方法的第一行, 否则编译不通过\n * super从子类调用父类构造, this在同一类中调用其他构造均需要放在第一行\n * 尽管可以用this调用一个构造器, 却不能调用2个\n * this和super不能出现在同一个构造器中, 否则编译不通过\n * this()、super()都指的对象,不可以在static环境中使用\n * 本质this指向本对象的指针。super是一个关键字\n\n\n# 构造内部类和静态内部类对象\n\npublic class enclosingone {\n\tpublic class insideone {}\n\tpublic static class insideone{}\n}\n\npublic class test {\n\tpublic static void main(string[] args) {\n\t// 构造内部类对象需要外部类的引用\n\tenclosingone.insideone obj1 = new enclosingone().new insideone();\n\t// 构造静态内部类的对象\n\tenclosingone.insideone obj2 = new enclosingone.insideone();\n\t}\n}\n\n\n静态内部类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。非静态内部类能够访问外部类的静态和非静态成员。静态内部类不能访问外部类的非静态成员，只能访问外部类的静态成员。\n\n\n# 序列化\n\n声明为static和transient类型的数据不能被序列化， 反序列化需要一个无参构造函数\n\n\n# java移位运算符\n\njava中有三种移位运算符\n\n * << :左移运算符,x << 1,相当于x乘以2(不溢出的情况下),低位补0\n * >> :带符号右移,x >> 1,相当于x除以2,正数高位补0,负数高位补1\n * >>> :无符号右移,忽略符号位,空位都以0补齐\n\n\n# 形参&实参\n\n形式参数可被视为local variable.形参和局部变量一样都不能离开方法。只有在方法中使用，不会在方法外可见。 形式参数只能用final修饰符，其它任何修饰符都会引起编译器错误。但是用这个修饰符也有一定的限制，就是在方法中不能对参数做任何修改。不过一般情况下，一个方法的形参不用final修饰。只有在特殊情况下，那就是: 方法内部类。一个方法内的内部类如果使用了这个方法的参数或者局部变量的话，这个参数或局部变量应该是final。 形参的值在调用时根据调用者更改，实参则用自身的值更改形参的值(指针、引用皆在此列)，也就是说真正被传递的是实参。\n\n\n# 局部变量为什么要初始化\n\n局部变量是指类方法中的变量，必须初始化。局部变量运行时被分配在栈中，量大，生命周期短，如果虚拟机给每个局部变量都初始化一下，是一笔很大的开销，但变量不初始化为默认值就使用是不安全的。出于速度和安全性两个方面的综合考虑，解决方案就是虚拟机不初始化，但要求编写者一定要在使用前给变量赋值。\n\n\n# java语言的鲁棒性\n\njava在编译和运行程序时，都要对可能出现的问题进行检查，以消除错误的产生。它提供自动垃圾收集来进行内存管理，防止程序员在管理内存时容易产生的错误。通过集成的面向对象的例外处理机制，在编译时，java揭示出可能出现但未被处理的异常，帮助程序员正确地进行选择以防止系统的崩溃。另外，java在编译时还可捕获类型声明中的许多常见错误，防止动态运行时不匹配问题的出现。",charsets:{cjk:!0}},{title:"Java 基础 - 面向对象",frontmatter:{},regularPath:"/java/basic/java-basic-oop.html",relativePath:"java/basic/java-basic-oop.md",key:"v-7989f230",path:"/java/basic/java-basic-oop.html",headers:[{level:2,title:"Java 基础 - 面向对象",slug:"java-基础-面向对象",normalizedTitle:"java 基础 - 面向对象",charIndex:2},{level:2,title:"三大特性",slug:"三大特性",normalizedTitle:"三大特性",charIndex:72},{level:3,title:"封装",slug:"封装",normalizedTitle:"封装",charIndex:84},{level:3,title:"继承",slug:"继承",normalizedTitle:"继承",charIndex:94},{level:3,title:"多态",slug:"多态",normalizedTitle:"多态",charIndex:104},{level:2,title:"类图",slug:"类图",normalizedTitle:"类图",charIndex:44},{level:3,title:"泛化关系 (Generalization)",slug:"泛化关系-generalization",normalizedTitle:"泛化关系 (generalization)",charIndex:122},{level:3,title:"实现关系 (Realization)",slug:"实现关系-realization",normalizedTitle:"实现关系 (realization)",charIndex:151},{level:3,title:"聚合关系 (Aggregation)",slug:"聚合关系-aggregation",normalizedTitle:"聚合关系 (aggregation)",charIndex:177},{level:3,title:"组合关系 (Composition)",slug:"组合关系-composition",normalizedTitle:"组合关系 (composition)",charIndex:203},{level:3,title:"关联关系 (Association)",slug:"关联关系-association",normalizedTitle:"关联关系 (association)",charIndex:229},{level:3,title:"依赖关系 (Dependency)",slug:"依赖关系-dependency",normalizedTitle:"依赖关系 (dependency)",charIndex:255},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:278}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java 基础 - 面向对象 三大特性 封装 继承 多态 类图 泛化关系 (Generalization) 实现关系 (Realization) 聚合关系 (Aggregation) 组合关系 (Composition) 关联关系 (Association) 依赖关系 (Dependency) 参考资料",content:'# Java 基础 - 面向对象\n\n> 本文主要介绍Java OOP 面向对象基础和相关类图。\n\n * Java 基础 - 面向对象\n   * 三大特性\n     * 封装\n     * 继承\n     * 多态\n   * 类图\n     * 泛化关系 (Generalization)\n     * 实现关系 (Realization)\n     * 聚合关系 (Aggregation)\n     * 组合关系 (Composition)\n     * 关联关系 (Association)\n     * 依赖关系 (Dependency)\n   * 参考资料\n\n\n# 三大特性\n\n\n# 封装\n\n利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。\n\n优点:\n\n * 减少耦合: 可以独立地开发、测试、优化、使用、理解和修改\n * 减轻维护的负担: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块\n * 有效地调节性能: 可以通过剖析确定哪些模块影响了系统的性能\n * 提高软件的可重用性\n * 降低了构建大型系统的风险: 即使整个系统不可用，但是这些独立的模块却有可能是可用的\n\n以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。\n\n注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。\n\npublic class Person {\n\n    private String name;\n    private int gender;\n    private int age;\n\n    public String getName() {\n        return name;\n    }\n\n    public String getGender() {\n        return gender == 0 ? "man" : "woman";\n    }\n\n    public void work() {\n        if (18 <= age && age <= 50) {\n            System.out.println(name + " is working very hard!");\n        } else {\n            System.out.println(name + " can\'t work any more!");\n        }\n    }\n}\n\n\n\n# 继承\n\n继承实现了 IS-A 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。\n\n继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。\n\nCat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 向上转型 。\n\nAnimal animal = new Cat();\n\n\n\n# 多态\n\n多态分为编译时多态和运行时多态:\n\n * 编译时多态主要指方法的重载\n * 运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定\n\n运行时多态有三个条件:\n\n * 继承\n * 覆盖(重写)\n * 向上转型\n\n下面的代码中，乐器类(Instrument)有两个子类: Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。\n\npublic class Instrument {\n    public void play() {\n        System.out.println("Instrument is playing...");\n    }\n}\n\npublic class Wind extends Instrument {\n    public void play() {\n        System.out.println("Wind is playing...");\n    }\n}\n\npublic class Percussion extends Instrument {\n    public void play() {\n        System.out.println("Percussion is playing...");\n    }\n}\n\npublic class Music {\n    public static void main(String[] args) {\n        List<Instrument> instruments = new ArrayList<>();\n        instruments.add(new Wind());\n        instruments.add(new Percussion());\n        for(Instrument instrument : instruments) {\n            instrument.play();\n        }\n    }\n}\n\n\n\n# 类图\n\n以下类图使用 PlantUML在新窗口打开 绘制，更多语法及使用请参考: http://plantuml.com/ 。\n\n\n# 泛化关系 (Generalization)\n\n用来描述继承关系，在 Java 中使用 extends 关键字。\n\n\n\n@startuml\n\ntitle Generalization\n\nclass Vehical\nclass Car\nclass Truck\n\nVehical <|-- Car\nVehical <|-- Truck\n\n@enduml\n\n\n\n# 实现关系 (Realization)\n\n用来实现一个接口，在 Java 中使用 implements 关键字。\n\n\n\n@startuml\n\ntitle Realization\n\ninterface MoveBehavior\nclass Fly\nclass Run\n\nMoveBehavior <|.. Fly\nMoveBehavior <|.. Run\n\n@enduml\n\n\n\n# 聚合关系 (Aggregation)\n\n表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。\n\n\n\n@startuml\n\ntitle Aggregation\n\nclass Computer\nclass Keyboard\nclass Mouse\nclass Screen\n\nComputer o-- Keyboard\nComputer o-- Mouse\nComputer o-- Screen\n\n@enduml\n\n\n\n# 组合关系 (Composition)\n\n和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。\n\n\n\n@startuml\n\ntitle Composition\n\nclass Company\nclass DepartmentA\nclass DepartmentB\n\nCompany *-- DepartmentA\nCompany *-- DepartmentB\n\n@enduml\n\n\n\n# 关联关系 (Association)\n\n表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。\n\n\n\n@startuml\n\ntitle Association\n\nclass School\nclass Student\n\nSchool "1" - "n" Student\n\n@enduml\n\n\n\n# 依赖关系 (Dependency)\n\n和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式:\n\n * A 类是 B 类中的(某中方法的)局部变量；\n * A 类是 B 类方法当中的一个参数；\n * A 类向 B 类发送消息，从而影响 B 类发生变化；\n\n\n\n@startuml\n\ntitle Dependency\n\nclass Vehicle {\n    move(MoveBehavior)\n}\n\ninterface MoveBehavior {\n    move()\n}\n\nnote "MoveBehavior.move()" as N\n\nVehicle ..> MoveBehavior\n\nVehicle .. N\n\n@enduml\n\n\n\n# 参考资料\n\n * Java 编程思想\n\n * 敏捷软件开发: 原则、模式与实践\n\n * 面向对象设计的 SOLID 原则在新窗口打开\n\n * 看懂 UML 类图和时序图在新窗口打开\n\n * UML 系列——时序图(顺序图)sequence diagram在新窗口打开\n\n * 面向对象编程三大特性 ------ 封装、继承、多态在新窗口打开\n\n * javaoop基础知识总结 https://blog.csdn.net/weixin_38173324/article/details/70037927\n\n * Java实现OOP(面向对象编程) https://www.cnblogs.com/AlanLee/p/6475334.html\n\n * Java 抽象类与oop三大特征 http://www.cnblogs.com/wujing-hubei/p/6012105.html\n\n * 转载 https://www.pdai.tech/md/java/basic/java-basic-oop.html',normalizedContent:'# java 基础 - 面向对象\n\n> 本文主要介绍java oop 面向对象基础和相关类图。\n\n * java 基础 - 面向对象\n   * 三大特性\n     * 封装\n     * 继承\n     * 多态\n   * 类图\n     * 泛化关系 (generalization)\n     * 实现关系 (realization)\n     * 聚合关系 (aggregation)\n     * 组合关系 (composition)\n     * 关联关系 (association)\n     * 依赖关系 (dependency)\n   * 参考资料\n\n\n# 三大特性\n\n\n# 封装\n\n利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。\n\n优点:\n\n * 减少耦合: 可以独立地开发、测试、优化、使用、理解和修改\n * 减轻维护的负担: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块\n * 有效地调节性能: 可以通过剖析确定哪些模块影响了系统的性能\n * 提高软件的可重用性\n * 降低了构建大型系统的风险: 即使整个系统不可用，但是这些独立的模块却有可能是可用的\n\n以下 person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。\n\n注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。\n\npublic class person {\n\n    private string name;\n    private int gender;\n    private int age;\n\n    public string getname() {\n        return name;\n    }\n\n    public string getgender() {\n        return gender == 0 ? "man" : "woman";\n    }\n\n    public void work() {\n        if (18 <= age && age <= 50) {\n            system.out.println(name + " is working very hard!");\n        } else {\n            system.out.println(name + " can\'t work any more!");\n        }\n    }\n}\n\n\n\n# 继承\n\n继承实现了 is-a 关系，例如 cat 和 animal 就是一种 is-a 关系，因此 cat 可以继承自 animal，从而获得 animal 非 private 的属性和方法。\n\n继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。\n\ncat 可以当做 animal 来使用，也就是说可以使用 animal 引用 cat 对象。父类引用指向子类对象称为 向上转型 。\n\nanimal animal = new cat();\n\n\n\n# 多态\n\n多态分为编译时多态和运行时多态:\n\n * 编译时多态主要指方法的重载\n * 运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定\n\n运行时多态有三个条件:\n\n * 继承\n * 覆盖(重写)\n * 向上转型\n\n下面的代码中，乐器类(instrument)有两个子类: wind 和 percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 instrument 来引用 wind 和 percussion 对象。在 instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 instrument 类的方法。\n\npublic class instrument {\n    public void play() {\n        system.out.println("instrument is playing...");\n    }\n}\n\npublic class wind extends instrument {\n    public void play() {\n        system.out.println("wind is playing...");\n    }\n}\n\npublic class percussion extends instrument {\n    public void play() {\n        system.out.println("percussion is playing...");\n    }\n}\n\npublic class music {\n    public static void main(string[] args) {\n        list<instrument> instruments = new arraylist<>();\n        instruments.add(new wind());\n        instruments.add(new percussion());\n        for(instrument instrument : instruments) {\n            instrument.play();\n        }\n    }\n}\n\n\n\n# 类图\n\n以下类图使用 plantuml在新窗口打开 绘制，更多语法及使用请参考: http://plantuml.com/ 。\n\n\n# 泛化关系 (generalization)\n\n用来描述继承关系，在 java 中使用 extends 关键字。\n\n\n\n@startuml\n\ntitle generalization\n\nclass vehical\nclass car\nclass truck\n\nvehical <|-- car\nvehical <|-- truck\n\n@enduml\n\n\n\n# 实现关系 (realization)\n\n用来实现一个接口，在 java 中使用 implements 关键字。\n\n\n\n@startuml\n\ntitle realization\n\ninterface movebehavior\nclass fly\nclass run\n\nmovebehavior <|.. fly\nmovebehavior <|.. run\n\n@enduml\n\n\n\n# 聚合关系 (aggregation)\n\n表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。\n\n\n\n@startuml\n\ntitle aggregation\n\nclass computer\nclass keyboard\nclass mouse\nclass screen\n\ncomputer o-- keyboard\ncomputer o-- mouse\ncomputer o-- screen\n\n@enduml\n\n\n\n# 组合关系 (composition)\n\n和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。\n\n\n\n@startuml\n\ntitle composition\n\nclass company\nclass departmenta\nclass departmentb\n\ncompany *-- departmenta\ncompany *-- departmentb\n\n@enduml\n\n\n\n# 关联关系 (association)\n\n表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。\n\n\n\n@startuml\n\ntitle association\n\nclass school\nclass student\n\nschool "1" - "n" student\n\n@enduml\n\n\n\n# 依赖关系 (dependency)\n\n和关联关系不同的是，依赖关系是在运行过程中起作用的。a 类和 b 类是依赖关系主要有三种形式:\n\n * a 类是 b 类中的(某中方法的)局部变量；\n * a 类是 b 类方法当中的一个参数；\n * a 类向 b 类发送消息，从而影响 b 类发生变化；\n\n\n\n@startuml\n\ntitle dependency\n\nclass vehicle {\n    move(movebehavior)\n}\n\ninterface movebehavior {\n    move()\n}\n\nnote "movebehavior.move()" as n\n\nvehicle ..> movebehavior\n\nvehicle .. n\n\n@enduml\n\n\n\n# 参考资料\n\n * java 编程思想\n\n * 敏捷软件开发: 原则、模式与实践\n\n * 面向对象设计的 solid 原则在新窗口打开\n\n * 看懂 uml 类图和时序图在新窗口打开\n\n * uml 系列——时序图(顺序图)sequence diagram在新窗口打开\n\n * 面向对象编程三大特性 ------ 封装、继承、多态在新窗口打开\n\n * javaoop基础知识总结 https://blog.csdn.net/weixin_38173324/article/details/70037927\n\n * java实现oop(面向对象编程) https://www.cnblogs.com/alanlee/p/6475334.html\n\n * java 抽象类与oop三大特征 http://www.cnblogs.com/wujing-hubei/p/6012105.html\n\n * 转载 https://www.pdai.tech/md/java/basic/java-basic-oop.html',charsets:{cjk:!0}},{title:"Java 基础 - 注解机制详解",frontmatter:{},regularPath:"/java/basic/java-basic-x-annotation.html",relativePath:"java/basic/java-basic-x-annotation.md",key:"v-433786d8",path:"/java/basic/java-basic-x-annotation.html",headers:[{level:2,title:"Java 基础 - 注解机制详解",slug:"java-基础-注解机制详解",normalizedTitle:"java 基础 - 注解机制详解",charIndex:2},{level:2,title:"注解基础",slug:"注解基础",normalizedTitle:"注解基础",charIndex:126},{level:3,title:"Java内置注解",slug:"java内置注解",normalizedTitle:"java内置注解",charIndex:138},{level:3,title:"元注解",slug:"元注解",normalizedTitle:"元注解",charIndex:242},{level:3,title:"注解与反射接口",slug:"注解与反射接口",normalizedTitle:"注解与反射接口",charIndex:440},{level:3,title:"自定义注解",slug:"自定义注解",normalizedTitle:"自定义注解",charIndex:455},{level:2,title:"深入理解注解",slug:"深入理解注解",normalizedTitle:"深入理解注解",charIndex:466},{level:3,title:"Java8提供了哪些新的注解？",slug:"java8提供了哪些新的注解",normalizedTitle:"java8提供了哪些新的注解？",charIndex:480},{level:3,title:"注解支持继承吗？",slug:"注解支持继承吗",normalizedTitle:"注解支持继承吗？",charIndex:503},{level:3,title:"注解实现的原理？",slug:"注解实现的原理",normalizedTitle:"注解实现的原理？",charIndex:519},{level:2,title:"注解的应用场景",slug:"注解的应用场景",normalizedTitle:"注解的应用场景",charIndex:533},{level:3,title:"配置化到注解化 - 框架的演进",slug:"配置化到注解化-框架的演进",normalizedTitle:"配置化到注解化 - 框架的演进",charIndex:548},{level:3,title:"继承实现到注解实现 - Junit3到Junit4",slug:"继承实现到注解实现-junit3到junit4",normalizedTitle:"继承实现到注解实现 - junit3到junit4",charIndex:571},{level:3,title:"自定义注解和AOP - 通过切面实现解耦",slug:"自定义注解和aop-通过切面实现解耦",normalizedTitle:"自定义注解和aop - 通过切面实现解耦",charIndex:604},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:630}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java 基础 - 注解机制详解 注解基础 Java内置注解 元注解 注解与反射接口 自定义注解 深入理解注解 Java8提供了哪些新的注解？ 注解支持继承吗？ 注解实现的原理？ 注解的应用场景 配置化到注解化 - 框架的演进 继承实现到注解实现 - Junit3到Junit4 自定义注解和AOP - 通过切面实现解耦 参考文章",content:'# Java 基础 - 注解机制详解\n\n> 注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它是框架学习和设计者必须掌握的基础。\n\n * Java 基础 - 注解机制详解\n   * 注解基础\n     * Java内置注解\n       * 内置注解 - @Override\n       * 内置注解 - @Deprecated\n       * 内置注解 - @SuppressWarnings\n     * 元注解\n       * 元注解 - @Target\n       * 元注解 - @Retention & @RetentionTarget\n       * 元注解 - @Documented\n       * 元注解 - @Inherited\n       * 元注解 - @Repeatable (Java8)\n       * 元注解 - @Native (Java8)\n     * 注解与反射接口\n     * 自定义注解\n   * 深入理解注解\n     * Java8提供了哪些新的注解？\n     * 注解支持继承吗？\n     * 注解实现的原理？\n   * 注解的应用场景\n     * 配置化到注解化 - 框架的演进\n     * 继承实现到注解实现 - Junit3到Junit4\n     * 自定义注解和AOP - 通过切面实现解耦\n   * 参考文章\n\n\n# 注解基础\n\n注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它主要的作用有以下四方面：\n\n * 生成文档，通过代码里标识的元数据生成javadoc文档。\n * 编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。\n * 编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。\n * 运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。\n\n这么来说是比较抽象的，我们具体看下注解的常见分类：\n\n * Java自带的标准注解，包括@Override、@Deprecated和@SuppressWarnings，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。\n * 元注解，元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented，@Retention用于标明注解被保留的阶段，@Target用于标明注解使用的范围，@Inherited用于标明注解可继承，@Documented用于标明是否生成javadoc文档。\n * 自定义注解，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。\n\n接下来我们通过这个分类角度来理解注解。\n\n\n# Java内置注解\n\n我们从最为常见的Java内置的注解开始说起，先看下下面的代码：\n\nclass A{\n    public void test() {\n        \n    }\n}\n\nclass B extends A{\n\n    /**\n        * 重载父类的test方法\n        */\n    @Override\n    public void test() {\n    }\n\n    /**\n        * 被弃用的方法\n        */\n    @Deprecated\n    public void oldMethod() {\n    }\n\n    /**\n        * 忽略告警\n        * \n        * @return\n        */\n    @SuppressWarnings("rawtypes")\n    public List processList() {\n        List list = new ArrayList();\n        return list;\n    }\n}\n\n\nJava 1.5开始自带的标准注解，包括@Override、@Deprecated和@SuppressWarnings：\n\n * @Override：表示当前的方法定义将覆盖父类中的方法\n * @Deprecated：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告\n * @SuppressWarnings：表示关闭编译器警告信息\n\n我们再具体看下这几个内置注解，同时通过这几个内置注解中的元注解的定义来引出元注解。\n\n# 内置注解 - @Override\n\n我们先来看一下这个注解类型的定义：\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Override {\n}\n\n\n从它的定义我们可以看到，这个注解可以被用来修饰方法，并且它只在编译时有效，在编译后的class文件中便不再存在。这个注解的作用我们大家都不陌生，那就是告诉编译器被修饰的方法是重写的父类的中的相同签名的方法，编译器会对此做出检查，若发现父类中不存在这个方法或是存在的方法签名不同，则会报错。\n\n# 内置注解 - @Deprecated\n\n这个注解的定义如下：\n\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})\npublic @interface Deprecated {\n}\n\n\n从它的定义我们可以知道，它会被文档化，能够保留到运行时，能够修饰构造方法、属性、局部变量、方法、包、参数、类型。这个注解的作用是告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用。\n\n# 内置注解 - @SuppressWarnings\n\n这个注解我们也比较常用到，先来看下它的定义：\n\n@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})\n@Retention(RetentionPolicy.SOURCE)\npublic @interface SuppressWarnings {\n    String[] value();\n}\n\n\n它能够修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量，只能存活在源码时，取值为String[]。它的作用是告诉编译器忽略指定的警告信息，它可以取的值如下所示：\n\n参数                         作用                                        原描述\nall                        抑制所有警告                                    to suppress all warnings\nboxing                     抑制装箱、拆箱操作时候的警告                            to suppress warnings relative to boxing/unboxing operations\ncast                       抑制映射相关的警告                                 to suppress warnings relative to cast operations\ndep-ann                    抑制启用注释的警告                                 to suppress warnings relative to deprecated annotation\ndeprecation                抑制过期方法警告                                  to suppress warnings relative to deprecation\nfallthrough                抑制确在switch中缺失breaks的警告                    to suppress warnings relative to missing breaks in switch\n                                                                     statements\nfinally                    抑制finally模块没有返回的警告                        to suppress warnings relative to finally block that don’t\n                                                                     return\nhiding                     抑制与隐藏变数的区域变数相关的警告                         to suppress warnings relative to locals that hide variable（）\nincomplete-switch          忽略没有完整的switch语句                           to suppress warnings relative to missing entries in a switch\n                                                                     statement (enum case)\nnls                        忽略非nls格式的字符                               to suppress warnings relative to non-nls string literals\nnull                       忽略对null的操作                                to suppress warnings relative to null analysis\nrawtype                    使用generics时忽略没有指定相应的类型                    to suppress warnings relative to un-specific types when\n                                                                     using\nrestriction                抑制与使用不建议或禁止参照相关的警告                        to suppress warnings relative to usage of discouraged or\nserial                     忽略在serializable类中没有声明serialVersionUID变量   to suppress warnings relative to missing serialVersionUID\n                                                                     field for a serializable class\nstatic-access              抑制不正确的静态访问方式警告                            to suppress warnings relative to incorrect static access\nsynthetic-access           抑制子类没有按最优方法访问内部类的警告                       to suppress warnings relative to unoptimized access from\n                                                                     inner classes\nunchecked                  抑制没有进行类型检查操作的警告                           to suppress warnings relative to unchecked operations\nunqualified-field-access   抑制没有权限访问的域的警告                             to suppress warnings relative to field access unqualified\nunused                     抑制没被使用过的代码的警告                             to suppress warnings relative to unused code\n\n\n# 元注解\n\n上述内置注解的定义中使用了一些元注解（注解类型进行注解的注解类），在JDK 1.5中提供了4个标准的元注解：@Target，@Retention，@Documented，@Inherited, 在JDK 1.8中提供了两个元注解 @Repeatable和@Native。\n\n# 元注解 - @Target\n\n> Target注解的作用是：描述注解的使用范围（即：被修饰的注解可以用在什么地方） 。\n\nTarget注解用来说明那些被它所注解的注解类可修饰的对象范围：注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数），在定义注解类时使用了@Target 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在ElementType 枚举中。\n\npublic enum ElementType {\n \n    TYPE, // 类、接口、枚举类\n \n    FIELD, // 成员变量（包括：枚举常量）\n \n    METHOD, // 成员方法\n \n    PARAMETER, // 方法参数\n \n    CONSTRUCTOR, // 构造方法\n \n    LOCAL_VARIABLE, // 局部变量\n \n    ANNOTATION_TYPE, // 注解类\n \n    PACKAGE, // 可用于修饰：包\n \n    TYPE_PARAMETER, // 类型参数，JDK 1.8 新增\n \n    TYPE_USE // 使用类型的任何地方，JDK 1.8 新增\n \n}\n\n\n# 元注解 - @Retention & @RetentionTarget\n\n> Reteniton注解的作用是：描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时） 。\n\nReteniton注解用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在RetentionPolicy枚举中。\n\npublic enum RetentionPolicy {\n \n    SOURCE,    // 源文件保留\n    CLASS,       // 编译期保留，默认值\n    RUNTIME   // 运行期保留，可通过反射去获取注解信息\n}\n\n\n为了验证应用了这三种策略的注解类有何区别，分别使用三种策略各定义一个注解类做测试。\n\n@Retention(RetentionPolicy.SOURCE)\npublic @interface SourcePolicy {\n \n}\n@Retention(RetentionPolicy.CLASS)\npublic @interface ClassPolicy {\n \n}\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface RuntimePolicy {\n \n}\n\n\n用定义好的三个注解类分别去注解一个方法。\n\npublic class RetentionTest {\n \n\t@SourcePolicy\n\tpublic void sourcePolicy() {\n\t}\n \n\t@ClassPolicy\n\tpublic void classPolicy() {\n\t}\n \n\t@RuntimePolicy\n\tpublic void runtimePolicy() {\n\t}\n}\n\n\n通过执行 javap -verbose RetentionTest命令获取到的RetentionTest 的 class 字节码内容如下。\n\n{\n  public retention.RetentionTest();\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object."<init>":()V\n         4: return\n      LineNumberTable:\n        line 3: 0\n\n  public void sourcePolicy();\n    flags: ACC_PUBLIC\n    Code:\n      stack=0, locals=1, args_size=1\n         0: return\n      LineNumberTable:\n        line 7: 0\n\n  public void classPolicy();\n    flags: ACC_PUBLIC\n    Code:\n      stack=0, locals=1, args_size=1\n         0: return\n      LineNumberTable:\n        line 11: 0\n    RuntimeInvisibleAnnotations:\n      0: #11()\n\n  public void runtimePolicy();\n    flags: ACC_PUBLIC\n    Code:\n      stack=0, locals=1, args_size=1\n         0: return\n      LineNumberTable:\n        line 15: 0\n    RuntimeVisibleAnnotations:\n      0: #14()\n}\n\n\n从 RetentionTest 的字节码内容我们可以得出以下两点结论：\n\n * 编译器并没有记录下 sourcePolicy() 方法的注解信息；\n * 编译器分别使用了 RuntimeInvisibleAnnotations 和 RuntimeVisibleAnnotations 属性去记录了classPolicy()方法 和 runtimePolicy()方法 的注解信息；\n\n# 元注解 - @Documented\n\n> Documented注解的作用是：描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。\n\n以下代码在使用Javadoc工具可以生成@TestDocAnnotation注解信息。\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Target;\n \n@Documented\n@Target({ElementType.TYPE,ElementType.METHOD})\npublic @interface TestDocAnnotation {\n \n\tpublic String value() default "default";\n}\n\n\n@TestDocAnnotation("myMethodDoc")\npublic void testDoc() {\n\n}\n\n\n# 元注解 - @Inherited\n\n> Inherited注解的作用：被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。\n\n我们来测试下这个注解：\n\n * 定义@Inherited注解：\n\n@Inherited\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE,ElementType.METHOD})\npublic @interface TestInheritedAnnotation {\n    String [] values();\n    int number();\n}\n\n\n * 使用这个注解\n\n@TestInheritedAnnotation(values = {"value"}, number = 10)\npublic class Person {\n}\n\nclass Student extends Person{\n\t@Test\n    public void test(){\n        Class clazz = Student.class;\n        Annotation[] annotations = clazz.getAnnotations();\n        for (Annotation annotation : annotations) {\n            System.out.println(annotation.toString());\n        }\n    }\n}\n\n\n * 输出\n\nxxxxxxx.TestInheritedAnnotation(values=[value], number=10)\n\n\n即使Student类没有显示地被注解@TestInheritedAnnotation，但是它的父类Person被注解，而且@TestInheritedAnnotation被@Inherited注解，因此Student类自动有了该注解。\n\n# 元注解 - @Repeatable (Java8)\n\n@Repeatable请参考Java 8 - 重复注解\n\n# 元注解 - @Native (Java8)\n\n使用 @Native 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。对于 @Native 注解不常使用，了解即可\n\n\n# 注解与反射接口\n\n> 定义注解后，如何获取注解中的内容呢？反射包java.lang.reflect下的AnnotatedElement接口提供这些方法。这里注意：只有注解被定义为RUNTIME后，该注解才能是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。\n\nAnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的方法来访问Annotation信息。我们看下具体的先关接口\n\n * boolean isAnnotationPresent(Class<?extends Annotation> annotationClass)\n\n判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。注意：此方法会忽略注解对应的注解容器。\n\n * <T extends Annotation> T getAnnotation(Class<T> annotationClass)\n\n返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。\n\n * Annotation[] getAnnotations()\n\n返回该程序元素上存在的所有注解，若没有注解，返回长度为0的数组。\n\n * <T extends Annotation> T[] getAnnotationsByType(Class<T> annotationClass)\n\n返回该程序元素上存在的、指定类型的注解数组。没有注解对应类型的注解时，返回长度为0的数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。getAnnotationsByType方法与 getAnnotation的区别在于，getAnnotationsByType会检测注解对应的重复注解容器。若程序元素为类，当前类上找不到注解，且该注解为可继承的，则会去父类上检测对应的注解。\n\n * <T extends Annotation> T getDeclaredAnnotation(Class<T> annotationClass)\n\n返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释。如果没有注释直接存在于此元素上，则返回null\n\n * <T extends Annotation> T[] getDeclaredAnnotationsByType(Class<T> annotationClass)\n\n返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释\n\n * Annotation[] getDeclaredAnnotations()\n\n返回直接存在于此元素上的所有注解及注解对应的重复注解容器。与此接口中的其他方法不同，该方法将忽略继承的注解。如果没有注释直接存在于此元素上，则返回长度为零的一个数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。\n\n\n# 自定义注解\n\n> 当我们理解了内置注解, 元注解和获取注解的反射接口后，我们便可以开始自定义注解了。这个例子我把上述的知识点全部融入进来, 代码很简单：\n\n * 定义自己的注解\n\npackage com.pdai.java.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MyMethodAnnotation {\n\n    public String title() default "";\n\n    public String description() default "";\n\n}\n\n\n * 使用注解\n\npackage com.pdai.java.annotation;\n\nimport java.io.FileNotFoundException;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class TestMethodAnnotation {\n\n    @Override\n    @MyMethodAnnotation(title = "toStringMethod", description = "override toString method")\n    public String toString() {\n        return "Override toString method";\n    }\n\n    @Deprecated\n    @MyMethodAnnotation(title = "old static method", description = "deprecated old static method")\n    public static void oldMethod() {\n        System.out.println("old method, don\'t use it.");\n    }\n\n    @SuppressWarnings({"unchecked", "deprecation"})\n    @MyMethodAnnotation(title = "test method", description = "suppress warning static method")\n    public static void genericsTest() throws FileNotFoundException {\n        List l = new ArrayList();\n        l.add("abc");\n        oldMethod();\n    }\n}\n\n\n * 用反射接口获取注解信息\n\n在TestMethodAnnotation中添加Main方法进行测试：\n\npublic static void main(String[] args) {\n    try {\n        // 获取所有methods\n        Method[] methods = TestMethodAnnotation.class.getClassLoader()\n                .loadClass(("com.pdai.java.annotation.TestMethodAnnotation"))\n                .getMethods();\n\n        // 遍历\n        for (Method method : methods) {\n            // 方法上是否有MyMethodAnnotation注解\n            if (method.isAnnotationPresent(MyMethodAnnotation.class)) {\n                try {\n                    // 获取并遍历方法上的所有注解\n                    for (Annotation anno : method.getDeclaredAnnotations()) {\n                        System.out.println("Annotation in Method \'"\n                                + method + "\' : " + anno);\n                    }\n\n                    // 获取MyMethodAnnotation对象信息\n                    MyMethodAnnotation methodAnno = method\n                            .getAnnotation(MyMethodAnnotation.class);\n\n                    System.out.println(methodAnno.title());\n\n                } catch (Throwable ex) {\n                    ex.printStackTrace();\n                }\n            }\n        }\n    } catch (SecurityException | ClassNotFoundException e) {\n        e.printStackTrace();\n    }\n}\n\n\n * 测试的输出\n\nAnnotation in Method \'public static void com.pdai.java.annotation.TestMethodAnnotation.oldMethod()\' : @java.lang.Deprecated()\nAnnotation in Method \'public static void com.pdai.java.annotation.TestMethodAnnotation.oldMethod()\' : @com.pdai.java.annotation.MyMethodAnnotation(title=old static method, description=deprecated old static method)\nold static method\nAnnotation in Method \'public static void com.pdai.java.annotation.TestMethodAnnotation.genericsTest() throws java.io.FileNotFoundException\' : @com.pdai.java.annotation.MyMethodAnnotation(title=test method, description=suppress warning static method)\ntest method\nAnnotation in Method \'public java.lang.String com.pdai.java.annotation.TestMethodAnnotation.toString()\' : @com.pdai.java.annotation.MyMethodAnnotation(title=toStringMethod, description=override toString method)\ntoStringMethod\n\n\n\n# 深入理解注解\n\n\n# Java8提供了哪些新的注解？\n\n * @Repeatable\n\n请参考Java 8 - 重复注解\n\n * ElementType.TYPE_USE\n\n请参考Java 8 - 类型注解\n\n * ElementType.TYPE_PARAMETER\n\nElementType.TYPE_USE(此类型包括类型声明和类型参数声明，是为了方便设计者进行类型检查)包含了ElementType.TYPE(类、接口（包括注解类型）和枚举的声明)和ElementType.TYPE_PARAMETER(类型参数声明), 不妨再看个例子\n\n// 自定义ElementType.TYPE_PARAMETER注解\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE_PARAMETER)\npublic @interface MyNotEmpty {\n}\n\n// 自定义ElementType.TYPE_USE注解\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE_USE)\npublic @interface MyNotNull {\n}\n\n// 测试类\npublic class TypeParameterAndTypeUseAnnotation<@MyNotEmpty T>{\n\n  //使用TYPE_PARAMETER类型，会编译不通过\n//\t\tpublic @MyNotEmpty T test(@MyNotEmpty T a){\n//\t\t\tnew ArrayList<@MyNotEmpty String>();\n//\t\t\t\treturn a;\n//\t\t}\n\n  //使用TYPE_USE类型，编译通过\n  public @MyNotNull T test2(@MyNotNull T a){\n    new ArrayList<@MyNotNull String>();\n    return a;\n  }\n}\n\n\n\n# 注解支持继承吗？\n\n> 注解是不支持继承的\n\n不能使用关键字extends来继承某个@interface，但注解在编译后，编译器会自动继承java.lang.annotation.Annotation接口.\n\n虽然反编译后发现注解继承了Annotation接口，请记住，即使Java的接口可以实现多继承，但定义注解时依然无法使用extends关键字继承@interface。\n\n区别于注解的继承，被注解的子类继承父类注解可以用@Inherited： 如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。\n\n\n# 注解实现的原理？\n\n> 网上很多标注解的原理文章根本没有说到点子上。\n\n这里推荐你两篇文章：\n\n * https://blog.csdn.net/qq_20009015/article/details/106038023\n * https://www.race604.com/annotation-processing/\n\n\n# 注解的应用场景\n\n提示\n\n最后我们再看看实际开发中注解的一些应用场景。@pdai\n\n\n# 配置化到注解化 - 框架的演进\n\nSpring 框架 配置化到注解化的转变。\n\n\n# 继承实现到注解实现 - Junit3到Junit4\n\n> 一个模块的封装大多数人都是通过继承和组合等模式来实现的，但是如果结合注解将可以极大程度提高实现的优雅度（降低耦合度）。而Junit3 到Junit4的演化就是最好的一个例子。\n\n * 被测试类\n\npublic class HelloWorld {\n \t\n \tpublic void sayHello(){\n \t\tSystem.out.println("hello....");\n \t\tthrow new NumberFormatException();\n \t}\n \t\n \tpublic void sayWorld(){\n \t\tSystem.out.println("world....");\n \t}\n \t\n \tpublic String say(){\n \t\treturn "hello world!";\n \t}\n \t\n}\n\n\n * Junit 3 实现UT\n\n通过继承 TestCase来实现，初始化是通过Override父类方法来进行，测试方式通过test的前缀方法获取。\n\npublic class HelloWorldTest extends TestCase{\n \tprivate HelloWorld hw;\n \t\n \t@Override\n \tprotected void setUp() throws Exception {\n \t\tsuper.setUp();\n \t\thw=new HelloWorld();\n \t}\n \t\n \t//1.测试没有返回值\n \tpublic void testHello(){\n \t\ttry {\n \t\t\thw.sayHello();\n \t\t} catch (Exception e) {\n \t\t\tSystem.out.println("发生异常.....");\n \t\t}\n \t\t\n \t}\n \tpublic void testWorld(){\n \t\thw.sayWorld();\n \t}\n \t//2.测试有返回值的方法\n \t// 返回字符串\n \tpublic void testSay(){\n \t\tassertEquals("测试失败", hw.say(), "hello world!");\n \t}\n \t//返回对象\n \tpublic void testObj(){\n \t\tassertNull("测试对象不为空", null);\n \t\tassertNotNull("测试对象为空",new String());\n \t}\n \t@Override\n \tprotected void tearDown() throws Exception {\n \t\tsuper.tearDown();\n \t\thw=null;\n \t}\t\n}\n\n\n * Junit 4 实现UT\n\n通过定义@Before，@Test，@After等等注解来实现。\n\npublic class HelloWorldTest {\n \tprivate HelloWorld hw;\n \n \t@Before\n \tpublic void setUp() {\n \t\thw = new HelloWorld();\n \t}\n \n \t@Test(expected=NumberFormatException.class)\n \t// 1.测试没有返回值,有别于junit3的使用，更加方便\n \tpublic void testHello() {\n \t\thw.sayHello();\n \t}\n \t@Test\n \tpublic void testWorld() {\n \t\thw.sayWorld();\n \t}\n \t\n \t@Test\n \t// 2.测试有返回值的方法\n \t// 返回字符串\n \tpublic void testSay() {\n \t\tassertEquals("测试失败", hw.say(), "hello world!");\n \t}\n \t\n \t@Test\n \t// 返回对象\n \tpublic void testObj() {\n \t\tassertNull("测试对象不为空", null);\n \t\tassertNotNull("测试对象为空", new String());\n \t}\n \n \t@After\n \tpublic void tearDown() throws Exception {\n \t\thw = null;\n \t}\n \n}\n\n\n这里我们发现通过注解的方式，我们实现单元测试时将更为优雅。如果你还期望了解Junit4是如何实现运行的呢？可以看这篇文章：JUnit4源码分析运行原理在新窗口打开。\n\n\n# 自定义注解和AOP - 通过切面实现解耦\n\n> 最为常见的就是使用Spring AOP切面实现统一的操作日志管理，我这里找了一个开源项目中的例子（只展示主要代码），给你展示下如何通过注解实现解耦的。\n\n * 自定义Log注解\n\n@Target({ ElementType.PARAMETER, ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Log {\n    /**\n     * 模块 \n     */\n    public String title() default "";\n\n    /**\n     * 功能\n     */\n    public BusinessType businessType() default BusinessType.OTHER;\n\n    /**\n     * 操作人类别\n     */\n    public OperatorType operatorType() default OperatorType.MANAGE;\n\n    /**\n     * 是否保存请求的参数\n     */\n    public boolean isSaveRequestData() default true;\n}\n\n\n * 实现日志的切面, 对自定义注解Log作切点进行拦截\n\n即对注解了@Log的方法进行切点拦截，\n\n@Aspect\n@Component\npublic class LogAspect {\n    private static final Logger log = LoggerFactory.getLogger(LogAspect.class);\n\n    /**\n     * 配置织入点 - 自定义注解的包路径\n     * \n     */\n    @Pointcut("@annotation(com.xxx.aspectj.lang.annotation.Log)")\n    public void logPointCut() {\n    }\n\n    /**\n     * 处理完请求后执行\n     *\n     * @param joinPoint 切点\n     */\n    @AfterReturning(pointcut = "logPointCut()", returning = "jsonResult")\n    public void doAfterReturning(JoinPoint joinPoint, Object jsonResult) {\n        handleLog(joinPoint, null, jsonResult);\n    }\n\n    /**\n     * 拦截异常操作\n     * \n     * @param joinPoint 切点\n     * @param e 异常\n     */\n    @AfterThrowing(value = "logPointCut()", throwing = "e")\n    public void doAfterThrowing(JoinPoint joinPoint, Exception e) {\n        handleLog(joinPoint, e, null);\n    }\n\n    protected void handleLog(final JoinPoint joinPoint, final Exception e, Object jsonResult) {\n        try {\n            // 获得注解\n            Log controllerLog = getAnnotationLog(joinPoint);\n            if (controllerLog == null) {\n                return;\n            }\n\n            // 获取当前的用户\n            User currentUser = ShiroUtils.getSysUser();\n\n            // *========数据库日志=========*//\n            OperLog operLog = new OperLog();\n            operLog.setStatus(BusinessStatus.SUCCESS.ordinal());\n            // 请求的地址\n            String ip = ShiroUtils.getIp();\n            operLog.setOperIp(ip);\n            // 返回参数\n            operLog.setJsonResult(JSONObject.toJSONString(jsonResult));\n\n            operLog.setOperUrl(ServletUtils.getRequest().getRequestURI());\n            if (currentUser != null) {\n                operLog.setOperName(currentUser.getLoginName());\n                if (StringUtils.isNotNull(currentUser.getDept())\n                        && StringUtils.isNotEmpty(currentUser.getDept().getDeptName())) {\n                    operLog.setDeptName(currentUser.getDept().getDeptName());\n                }\n            }\n\n            if (e != null) {\n                operLog.setStatus(BusinessStatus.FAIL.ordinal());\n                operLog.setErrorMsg(StringUtils.substring(e.getMessage(), 0, 2000));\n            }\n            // 设置方法名称\n            String className = joinPoint.getTarget().getClass().getName();\n            String methodName = joinPoint.getSignature().getName();\n            operLog.setMethod(className + "." + methodName + "()");\n            // 设置请求方式\n            operLog.setRequestMethod(ServletUtils.getRequest().getMethod());\n            // 处理设置注解上的参数\n            getControllerMethodDescription(controllerLog, operLog);\n            // 保存数据库\n            AsyncManager.me().execute(AsyncFactory.recordOper(operLog));\n        } catch (Exception exp) {\n            // 记录本地异常日志\n            log.error("==前置通知异常==");\n            log.error("异常信息:{}", exp.getMessage());\n            exp.printStackTrace();\n        }\n    }\n\n    /**\n     * 获取注解中对方法的描述信息 用于Controller层注解\n     * \n     * @param log 日志\n     * @param operLog 操作日志\n     * @throws Exception\n     */\n    public void getControllerMethodDescription(Log log, OperLog operLog) throws Exception {\n        // 设置action动作\n        operLog.setBusinessType(log.businessType().ordinal());\n        // 设置标题\n        operLog.setTitle(log.title());\n        // 设置操作人类别\n        operLog.setOperatorType(log.operatorType().ordinal());\n        // 是否需要保存request，参数和值\n        if (log.isSaveRequestData()) {\n            // 获取参数的信息，传入到数据库中。\n            setRequestValue(operLog);\n        }\n    }\n\n    /**\n     * 获取请求的参数，放到log中\n     * \n     * @param operLog\n     * @param request\n     */\n    private void setRequestValue(OperLog operLog) {\n        Map<String, String[]> map = ServletUtils.getRequest().getParameterMap();\n        String params = JSONObject.toJSONString(map);\n        operLog.setOperParam(StringUtils.substring(params, 0, 2000));\n    }\n\n    /**\n     * 是否存在注解，如果存在就获取\n     */\n    private Log getAnnotationLog(JoinPoint joinPoint) throws Exception {\n        Signature signature = joinPoint.getSignature();\n        MethodSignature methodSignature = (MethodSignature) signature;\n        Method method = methodSignature.getMethod();\n\n        if (method != null)\n        {\n            return method.getAnnotation(Log.class);\n        }\n        return null;\n    }\n}\n\n\n * 使用@Log注解\n\n以一个简单的CRUD操作为例, 这里展示部分代码：每对“部门”进行操作就会产生一条操作日志存入数据库。\n\n@Controller\n@RequestMapping("/system/dept")\npublic class DeptController extends BaseController {\n    private String prefix = "system/dept";\n\n    @Autowired\n    private IDeptService deptService;\n    \n    /**\n     * 新增保存部门\n     */\n    @Log(title = "部门管理", businessType = BusinessType.INSERT)\n    @RequiresPermissions("system:dept:add")\n    @PostMapping("/add")\n    @ResponseBody\n    public AjaxResult addSave(@Validated Dept dept) {\n        if (UserConstants.DEPT_NAME_NOT_UNIQUE.equals(deptService.checkDeptNameUnique(dept))) {\n            return error("新增部门\'" + dept.getDeptName() + "\'失败，部门名称已存在");\n        }\n        return toAjax(deptService.insertDept(dept));\n    }\n\n    /**\n     * 保存\n     */\n    @Log(title = "部门管理", businessType = BusinessType.UPDATE)\n    @RequiresPermissions("system:dept:edit")\n    @PostMapping("/edit")\n    @ResponseBody\n    public AjaxResult editSave(@Validated Dept dept) {\n        if (UserConstants.DEPT_NAME_NOT_UNIQUE.equals(deptService.checkDeptNameUnique(dept))) {\n            return error("修改部门\'" + dept.getDeptName() + "\'失败，部门名称已存在");\n        } else if(dept.getParentId().equals(dept.getDeptId())) {\n            return error("修改部门\'" + dept.getDeptName() + "\'失败，上级部门不能是自己");\n        }\n        return toAjax(deptService.updateDept(dept));\n    }\n\n    /**\n     * 删除\n     */\n    @Log(title = "部门管理", businessType = BusinessType.DELETE)\n    @RequiresPermissions("system:dept:remove")\n    @GetMapping("/remove/{deptId}")\n    @ResponseBody\n    public AjaxResult remove(@PathVariable("deptId") Long deptId) {\n        if (deptService.selectDeptCount(deptId) > 0) {\n            return AjaxResult.warn("存在下级部门,不允许删除");\n        }\n        if (deptService.checkDeptExistUser(deptId)) {\n            return AjaxResult.warn("部门存在用户,不允许删除");\n        }\n        return toAjax(deptService.deleteDeptById(deptId));\n    }\n\n  // ...\n}\n\n\n> 同样的，你也可以看到权限管理也是通过类似的注解（@RequiresPermissions）机制来实现的。所以我们可以看到，通过注解+AOP最终的目标是为了实现模块的解耦。\n\n\n# 参考文章\n\n * https://blog.csdn.net/javazejian/article/details/71860633\n * https://blog.csdn.net/qq_20009015/article/details/106038023\n * https://www.zhihu.com/question/47449512\n * https://www.race604.com/annotation-processing/\n * https://www.runoob.com/w3cnote/java-annotation.html\n * 转载 https://www.pdai.tech/md/java/basic/java-basic-x-annotation.html',normalizedContent:'# java 基础 - 注解机制详解\n\n> 注解是jdk1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它是框架学习和设计者必须掌握的基础。\n\n * java 基础 - 注解机制详解\n   * 注解基础\n     * java内置注解\n       * 内置注解 - @override\n       * 内置注解 - @deprecated\n       * 内置注解 - @suppresswarnings\n     * 元注解\n       * 元注解 - @target\n       * 元注解 - @retention & @retentiontarget\n       * 元注解 - @documented\n       * 元注解 - @inherited\n       * 元注解 - @repeatable (java8)\n       * 元注解 - @native (java8)\n     * 注解与反射接口\n     * 自定义注解\n   * 深入理解注解\n     * java8提供了哪些新的注解？\n     * 注解支持继承吗？\n     * 注解实现的原理？\n   * 注解的应用场景\n     * 配置化到注解化 - 框架的演进\n     * 继承实现到注解实现 - junit3到junit4\n     * 自定义注解和aop - 通过切面实现解耦\n   * 参考文章\n\n\n# 注解基础\n\n注解是jdk1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它主要的作用有以下四方面：\n\n * 生成文档，通过代码里标识的元数据生成javadoc文档。\n * 编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。\n * 编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。\n * 运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。\n\n这么来说是比较抽象的，我们具体看下注解的常见分类：\n\n * java自带的标准注解，包括@override、@deprecated和@suppresswarnings，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。\n * 元注解，元注解是用于定义注解的注解，包括@retention、@target、@inherited、@documented，@retention用于标明注解被保留的阶段，@target用于标明注解使用的范围，@inherited用于标明注解可继承，@documented用于标明是否生成javadoc文档。\n * 自定义注解，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。\n\n接下来我们通过这个分类角度来理解注解。\n\n\n# java内置注解\n\n我们从最为常见的java内置的注解开始说起，先看下下面的代码：\n\nclass a{\n    public void test() {\n        \n    }\n}\n\nclass b extends a{\n\n    /**\n        * 重载父类的test方法\n        */\n    @override\n    public void test() {\n    }\n\n    /**\n        * 被弃用的方法\n        */\n    @deprecated\n    public void oldmethod() {\n    }\n\n    /**\n        * 忽略告警\n        * \n        * @return\n        */\n    @suppresswarnings("rawtypes")\n    public list processlist() {\n        list list = new arraylist();\n        return list;\n    }\n}\n\n\njava 1.5开始自带的标准注解，包括@override、@deprecated和@suppresswarnings：\n\n * @override：表示当前的方法定义将覆盖父类中的方法\n * @deprecated：表示代码被弃用，如果使用了被@deprecated注解的代码则编译器将发出警告\n * @suppresswarnings：表示关闭编译器警告信息\n\n我们再具体看下这几个内置注解，同时通过这几个内置注解中的元注解的定义来引出元注解。\n\n# 内置注解 - @override\n\n我们先来看一下这个注解类型的定义：\n\n@target(elementtype.method)\n@retention(retentionpolicy.source)\npublic @interface override {\n}\n\n\n从它的定义我们可以看到，这个注解可以被用来修饰方法，并且它只在编译时有效，在编译后的class文件中便不再存在。这个注解的作用我们大家都不陌生，那就是告诉编译器被修饰的方法是重写的父类的中的相同签名的方法，编译器会对此做出检查，若发现父类中不存在这个方法或是存在的方法签名不同，则会报错。\n\n# 内置注解 - @deprecated\n\n这个注解的定义如下：\n\n@documented\n@retention(retentionpolicy.runtime)\n@target(value={constructor, field, local_variable, method, package, parameter, type})\npublic @interface deprecated {\n}\n\n\n从它的定义我们可以知道，它会被文档化，能够保留到运行时，能够修饰构造方法、属性、局部变量、方法、包、参数、类型。这个注解的作用是告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用。\n\n# 内置注解 - @suppresswarnings\n\n这个注解我们也比较常用到，先来看下它的定义：\n\n@target({type, field, method, parameter, constructor, local_variable})\n@retention(retentionpolicy.source)\npublic @interface suppresswarnings {\n    string[] value();\n}\n\n\n它能够修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量，只能存活在源码时，取值为string[]。它的作用是告诉编译器忽略指定的警告信息，它可以取的值如下所示：\n\n参数                         作用                                        原描述\nall                        抑制所有警告                                    to suppress all warnings\nboxing                     抑制装箱、拆箱操作时候的警告                            to suppress warnings relative to boxing/unboxing operations\ncast                       抑制映射相关的警告                                 to suppress warnings relative to cast operations\ndep-ann                    抑制启用注释的警告                                 to suppress warnings relative to deprecated annotation\ndeprecation                抑制过期方法警告                                  to suppress warnings relative to deprecation\nfallthrough                抑制确在switch中缺失breaks的警告                    to suppress warnings relative to missing breaks in switch\n                                                                     statements\nfinally                    抑制finally模块没有返回的警告                        to suppress warnings relative to finally block that don’t\n                                                                     return\nhiding                     抑制与隐藏变数的区域变数相关的警告                         to suppress warnings relative to locals that hide variable（）\nincomplete-switch          忽略没有完整的switch语句                           to suppress warnings relative to missing entries in a switch\n                                                                     statement (enum case)\nnls                        忽略非nls格式的字符                               to suppress warnings relative to non-nls string literals\nnull                       忽略对null的操作                                to suppress warnings relative to null analysis\nrawtype                    使用generics时忽略没有指定相应的类型                    to suppress warnings relative to un-specific types when\n                                                                     using\nrestriction                抑制与使用不建议或禁止参照相关的警告                        to suppress warnings relative to usage of discouraged or\nserial                     忽略在serializable类中没有声明serialversionuid变量   to suppress warnings relative to missing serialversionuid\n                                                                     field for a serializable class\nstatic-access              抑制不正确的静态访问方式警告                            to suppress warnings relative to incorrect static access\nsynthetic-access           抑制子类没有按最优方法访问内部类的警告                       to suppress warnings relative to unoptimized access from\n                                                                     inner classes\nunchecked                  抑制没有进行类型检查操作的警告                           to suppress warnings relative to unchecked operations\nunqualified-field-access   抑制没有权限访问的域的警告                             to suppress warnings relative to field access unqualified\nunused                     抑制没被使用过的代码的警告                             to suppress warnings relative to unused code\n\n\n# 元注解\n\n上述内置注解的定义中使用了一些元注解（注解类型进行注解的注解类），在jdk 1.5中提供了4个标准的元注解：@target，@retention，@documented，@inherited, 在jdk 1.8中提供了两个元注解 @repeatable和@native。\n\n# 元注解 - @target\n\n> target注解的作用是：描述注解的使用范围（即：被修饰的注解可以用在什么地方） 。\n\ntarget注解用来说明那些被它所注解的注解类可修饰的对象范围：注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数），在定义注解类时使用了@target 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在elementtype 枚举中。\n\npublic enum elementtype {\n \n    type, // 类、接口、枚举类\n \n    field, // 成员变量（包括：枚举常量）\n \n    method, // 成员方法\n \n    parameter, // 方法参数\n \n    constructor, // 构造方法\n \n    local_variable, // 局部变量\n \n    annotation_type, // 注解类\n \n    package, // 可用于修饰：包\n \n    type_parameter, // 类型参数，jdk 1.8 新增\n \n    type_use // 使用类型的任何地方，jdk 1.8 新增\n \n}\n\n\n# 元注解 - @retention & @retentiontarget\n\n> reteniton注解的作用是：描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时） 。\n\nreteniton注解用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在retentionpolicy枚举中。\n\npublic enum retentionpolicy {\n \n    source,    // 源文件保留\n    class,       // 编译期保留，默认值\n    runtime   // 运行期保留，可通过反射去获取注解信息\n}\n\n\n为了验证应用了这三种策略的注解类有何区别，分别使用三种策略各定义一个注解类做测试。\n\n@retention(retentionpolicy.source)\npublic @interface sourcepolicy {\n \n}\n@retention(retentionpolicy.class)\npublic @interface classpolicy {\n \n}\n@retention(retentionpolicy.runtime)\npublic @interface runtimepolicy {\n \n}\n\n\n用定义好的三个注解类分别去注解一个方法。\n\npublic class retentiontest {\n \n\t@sourcepolicy\n\tpublic void sourcepolicy() {\n\t}\n \n\t@classpolicy\n\tpublic void classpolicy() {\n\t}\n \n\t@runtimepolicy\n\tpublic void runtimepolicy() {\n\t}\n}\n\n\n通过执行 javap -verbose retentiontest命令获取到的retentiontest 的 class 字节码内容如下。\n\n{\n  public retention.retentiontest();\n    flags: acc_public\n    code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // method java/lang/object."<init>":()v\n         4: return\n      linenumbertable:\n        line 3: 0\n\n  public void sourcepolicy();\n    flags: acc_public\n    code:\n      stack=0, locals=1, args_size=1\n         0: return\n      linenumbertable:\n        line 7: 0\n\n  public void classpolicy();\n    flags: acc_public\n    code:\n      stack=0, locals=1, args_size=1\n         0: return\n      linenumbertable:\n        line 11: 0\n    runtimeinvisibleannotations:\n      0: #11()\n\n  public void runtimepolicy();\n    flags: acc_public\n    code:\n      stack=0, locals=1, args_size=1\n         0: return\n      linenumbertable:\n        line 15: 0\n    runtimevisibleannotations:\n      0: #14()\n}\n\n\n从 retentiontest 的字节码内容我们可以得出以下两点结论：\n\n * 编译器并没有记录下 sourcepolicy() 方法的注解信息；\n * 编译器分别使用了 runtimeinvisibleannotations 和 runtimevisibleannotations 属性去记录了classpolicy()方法 和 runtimepolicy()方法 的注解信息；\n\n# 元注解 - @documented\n\n> documented注解的作用是：描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。\n\n以下代码在使用javadoc工具可以生成@testdocannotation注解信息。\n\nimport java.lang.annotation.documented;\nimport java.lang.annotation.elementtype;\nimport java.lang.annotation.target;\n \n@documented\n@target({elementtype.type,elementtype.method})\npublic @interface testdocannotation {\n \n\tpublic string value() default "default";\n}\n\n\n@testdocannotation("mymethoddoc")\npublic void testdoc() {\n\n}\n\n\n# 元注解 - @inherited\n\n> inherited注解的作用：被它修饰的annotation将具有继承性。如果某个类使用了被@inherited修饰的annotation，则其子类将自动具有该注解。\n\n我们来测试下这个注解：\n\n * 定义@inherited注解：\n\n@inherited\n@retention(retentionpolicy.runtime)\n@target({elementtype.type,elementtype.method})\npublic @interface testinheritedannotation {\n    string [] values();\n    int number();\n}\n\n\n * 使用这个注解\n\n@testinheritedannotation(values = {"value"}, number = 10)\npublic class person {\n}\n\nclass student extends person{\n\t@test\n    public void test(){\n        class clazz = student.class;\n        annotation[] annotations = clazz.getannotations();\n        for (annotation annotation : annotations) {\n            system.out.println(annotation.tostring());\n        }\n    }\n}\n\n\n * 输出\n\nxxxxxxx.testinheritedannotation(values=[value], number=10)\n\n\n即使student类没有显示地被注解@testinheritedannotation，但是它的父类person被注解，而且@testinheritedannotation被@inherited注解，因此student类自动有了该注解。\n\n# 元注解 - @repeatable (java8)\n\n@repeatable请参考java 8 - 重复注解\n\n# 元注解 - @native (java8)\n\n使用 @native 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。对于 @native 注解不常使用，了解即可\n\n\n# 注解与反射接口\n\n> 定义注解后，如何获取注解中的内容呢？反射包java.lang.reflect下的annotatedelement接口提供这些方法。这里注意：只有注解被定义为runtime后，该注解才能是运行时可见，当class文件被装载时被保存在class文件中的annotation才会被虚拟机读取。\n\nannotatedelement 接口是所有程序元素（class、method和constructor）的父接口，所以程序通过反射获取了某个类的annotatedelement对象之后，程序就可以调用该对象的方法来访问annotation信息。我们看下具体的先关接口\n\n * boolean isannotationpresent(class<?extends annotation> annotationclass)\n\n判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。注意：此方法会忽略注解对应的注解容器。\n\n * <t extends annotation> t getannotation(class<t> annotationclass)\n\n返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。\n\n * annotation[] getannotations()\n\n返回该程序元素上存在的所有注解，若没有注解，返回长度为0的数组。\n\n * <t extends annotation> t[] getannotationsbytype(class<t> annotationclass)\n\n返回该程序元素上存在的、指定类型的注解数组。没有注解对应类型的注解时，返回长度为0的数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。getannotationsbytype方法与 getannotation的区别在于，getannotationsbytype会检测注解对应的重复注解容器。若程序元素为类，当前类上找不到注解，且该注解为可继承的，则会去父类上检测对应的注解。\n\n * <t extends annotation> t getdeclaredannotation(class<t> annotationclass)\n\n返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释。如果没有注释直接存在于此元素上，则返回null\n\n * <t extends annotation> t[] getdeclaredannotationsbytype(class<t> annotationclass)\n\n返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释\n\n * annotation[] getdeclaredannotations()\n\n返回直接存在于此元素上的所有注解及注解对应的重复注解容器。与此接口中的其他方法不同，该方法将忽略继承的注解。如果没有注释直接存在于此元素上，则返回长度为零的一个数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。\n\n\n# 自定义注解\n\n> 当我们理解了内置注解, 元注解和获取注解的反射接口后，我们便可以开始自定义注解了。这个例子我把上述的知识点全部融入进来, 代码很简单：\n\n * 定义自己的注解\n\npackage com.pdai.java.annotation;\n\nimport java.lang.annotation.elementtype;\nimport java.lang.annotation.retention;\nimport java.lang.annotation.retentionpolicy;\nimport java.lang.annotation.target;\n\n@target(elementtype.method)\n@retention(retentionpolicy.runtime)\npublic @interface mymethodannotation {\n\n    public string title() default "";\n\n    public string description() default "";\n\n}\n\n\n * 使用注解\n\npackage com.pdai.java.annotation;\n\nimport java.io.filenotfoundexception;\nimport java.lang.annotation.annotation;\nimport java.lang.reflect.method;\nimport java.util.arraylist;\nimport java.util.list;\n\npublic class testmethodannotation {\n\n    @override\n    @mymethodannotation(title = "tostringmethod", description = "override tostring method")\n    public string tostring() {\n        return "override tostring method";\n    }\n\n    @deprecated\n    @mymethodannotation(title = "old static method", description = "deprecated old static method")\n    public static void oldmethod() {\n        system.out.println("old method, don\'t use it.");\n    }\n\n    @suppresswarnings({"unchecked", "deprecation"})\n    @mymethodannotation(title = "test method", description = "suppress warning static method")\n    public static void genericstest() throws filenotfoundexception {\n        list l = new arraylist();\n        l.add("abc");\n        oldmethod();\n    }\n}\n\n\n * 用反射接口获取注解信息\n\n在testmethodannotation中添加main方法进行测试：\n\npublic static void main(string[] args) {\n    try {\n        // 获取所有methods\n        method[] methods = testmethodannotation.class.getclassloader()\n                .loadclass(("com.pdai.java.annotation.testmethodannotation"))\n                .getmethods();\n\n        // 遍历\n        for (method method : methods) {\n            // 方法上是否有mymethodannotation注解\n            if (method.isannotationpresent(mymethodannotation.class)) {\n                try {\n                    // 获取并遍历方法上的所有注解\n                    for (annotation anno : method.getdeclaredannotations()) {\n                        system.out.println("annotation in method \'"\n                                + method + "\' : " + anno);\n                    }\n\n                    // 获取mymethodannotation对象信息\n                    mymethodannotation methodanno = method\n                            .getannotation(mymethodannotation.class);\n\n                    system.out.println(methodanno.title());\n\n                } catch (throwable ex) {\n                    ex.printstacktrace();\n                }\n            }\n        }\n    } catch (securityexception | classnotfoundexception e) {\n        e.printstacktrace();\n    }\n}\n\n\n * 测试的输出\n\nannotation in method \'public static void com.pdai.java.annotation.testmethodannotation.oldmethod()\' : @java.lang.deprecated()\nannotation in method \'public static void com.pdai.java.annotation.testmethodannotation.oldmethod()\' : @com.pdai.java.annotation.mymethodannotation(title=old static method, description=deprecated old static method)\nold static method\nannotation in method \'public static void com.pdai.java.annotation.testmethodannotation.genericstest() throws java.io.filenotfoundexception\' : @com.pdai.java.annotation.mymethodannotation(title=test method, description=suppress warning static method)\ntest method\nannotation in method \'public java.lang.string com.pdai.java.annotation.testmethodannotation.tostring()\' : @com.pdai.java.annotation.mymethodannotation(title=tostringmethod, description=override tostring method)\ntostringmethod\n\n\n\n# 深入理解注解\n\n\n# java8提供了哪些新的注解？\n\n * @repeatable\n\n请参考java 8 - 重复注解\n\n * elementtype.type_use\n\n请参考java 8 - 类型注解\n\n * elementtype.type_parameter\n\nelementtype.type_use(此类型包括类型声明和类型参数声明，是为了方便设计者进行类型检查)包含了elementtype.type(类、接口（包括注解类型）和枚举的声明)和elementtype.type_parameter(类型参数声明), 不妨再看个例子\n\n// 自定义elementtype.type_parameter注解\n@retention(retentionpolicy.runtime)\n@target(elementtype.type_parameter)\npublic @interface mynotempty {\n}\n\n// 自定义elementtype.type_use注解\n@retention(retentionpolicy.runtime)\n@target(elementtype.type_use)\npublic @interface mynotnull {\n}\n\n// 测试类\npublic class typeparameterandtypeuseannotation<@mynotempty t>{\n\n  //使用type_parameter类型，会编译不通过\n//\t\tpublic @mynotempty t test(@mynotempty t a){\n//\t\t\tnew arraylist<@mynotempty string>();\n//\t\t\t\treturn a;\n//\t\t}\n\n  //使用type_use类型，编译通过\n  public @mynotnull t test2(@mynotnull t a){\n    new arraylist<@mynotnull string>();\n    return a;\n  }\n}\n\n\n\n# 注解支持继承吗？\n\n> 注解是不支持继承的\n\n不能使用关键字extends来继承某个@interface，但注解在编译后，编译器会自动继承java.lang.annotation.annotation接口.\n\n虽然反编译后发现注解继承了annotation接口，请记住，即使java的接口可以实现多继承，但定义注解时依然无法使用extends关键字继承@interface。\n\n区别于注解的继承，被注解的子类继承父类注解可以用@inherited： 如果某个类使用了被@inherited修饰的annotation，则其子类将自动具有该注解。\n\n\n# 注解实现的原理？\n\n> 网上很多标注解的原理文章根本没有说到点子上。\n\n这里推荐你两篇文章：\n\n * https://blog.csdn.net/qq_20009015/article/details/106038023\n * https://www.race604.com/annotation-processing/\n\n\n# 注解的应用场景\n\n提示\n\n最后我们再看看实际开发中注解的一些应用场景。@pdai\n\n\n# 配置化到注解化 - 框架的演进\n\nspring 框架 配置化到注解化的转变。\n\n\n# 继承实现到注解实现 - junit3到junit4\n\n> 一个模块的封装大多数人都是通过继承和组合等模式来实现的，但是如果结合注解将可以极大程度提高实现的优雅度（降低耦合度）。而junit3 到junit4的演化就是最好的一个例子。\n\n * 被测试类\n\npublic class helloworld {\n \t\n \tpublic void sayhello(){\n \t\tsystem.out.println("hello....");\n \t\tthrow new numberformatexception();\n \t}\n \t\n \tpublic void sayworld(){\n \t\tsystem.out.println("world....");\n \t}\n \t\n \tpublic string say(){\n \t\treturn "hello world!";\n \t}\n \t\n}\n\n\n * junit 3 实现ut\n\n通过继承 testcase来实现，初始化是通过override父类方法来进行，测试方式通过test的前缀方法获取。\n\npublic class helloworldtest extends testcase{\n \tprivate helloworld hw;\n \t\n \t@override\n \tprotected void setup() throws exception {\n \t\tsuper.setup();\n \t\thw=new helloworld();\n \t}\n \t\n \t//1.测试没有返回值\n \tpublic void testhello(){\n \t\ttry {\n \t\t\thw.sayhello();\n \t\t} catch (exception e) {\n \t\t\tsystem.out.println("发生异常.....");\n \t\t}\n \t\t\n \t}\n \tpublic void testworld(){\n \t\thw.sayworld();\n \t}\n \t//2.测试有返回值的方法\n \t// 返回字符串\n \tpublic void testsay(){\n \t\tassertequals("测试失败", hw.say(), "hello world!");\n \t}\n \t//返回对象\n \tpublic void testobj(){\n \t\tassertnull("测试对象不为空", null);\n \t\tassertnotnull("测试对象为空",new string());\n \t}\n \t@override\n \tprotected void teardown() throws exception {\n \t\tsuper.teardown();\n \t\thw=null;\n \t}\t\n}\n\n\n * junit 4 实现ut\n\n通过定义@before，@test，@after等等注解来实现。\n\npublic class helloworldtest {\n \tprivate helloworld hw;\n \n \t@before\n \tpublic void setup() {\n \t\thw = new helloworld();\n \t}\n \n \t@test(expected=numberformatexception.class)\n \t// 1.测试没有返回值,有别于junit3的使用，更加方便\n \tpublic void testhello() {\n \t\thw.sayhello();\n \t}\n \t@test\n \tpublic void testworld() {\n \t\thw.sayworld();\n \t}\n \t\n \t@test\n \t// 2.测试有返回值的方法\n \t// 返回字符串\n \tpublic void testsay() {\n \t\tassertequals("测试失败", hw.say(), "hello world!");\n \t}\n \t\n \t@test\n \t// 返回对象\n \tpublic void testobj() {\n \t\tassertnull("测试对象不为空", null);\n \t\tassertnotnull("测试对象为空", new string());\n \t}\n \n \t@after\n \tpublic void teardown() throws exception {\n \t\thw = null;\n \t}\n \n}\n\n\n这里我们发现通过注解的方式，我们实现单元测试时将更为优雅。如果你还期望了解junit4是如何实现运行的呢？可以看这篇文章：junit4源码分析运行原理在新窗口打开。\n\n\n# 自定义注解和aop - 通过切面实现解耦\n\n> 最为常见的就是使用spring aop切面实现统一的操作日志管理，我这里找了一个开源项目中的例子（只展示主要代码），给你展示下如何通过注解实现解耦的。\n\n * 自定义log注解\n\n@target({ elementtype.parameter, elementtype.method })\n@retention(retentionpolicy.runtime)\n@documented\npublic @interface log {\n    /**\n     * 模块 \n     */\n    public string title() default "";\n\n    /**\n     * 功能\n     */\n    public businesstype businesstype() default businesstype.other;\n\n    /**\n     * 操作人类别\n     */\n    public operatortype operatortype() default operatortype.manage;\n\n    /**\n     * 是否保存请求的参数\n     */\n    public boolean issaverequestdata() default true;\n}\n\n\n * 实现日志的切面, 对自定义注解log作切点进行拦截\n\n即对注解了@log的方法进行切点拦截，\n\n@aspect\n@component\npublic class logaspect {\n    private static final logger log = loggerfactory.getlogger(logaspect.class);\n\n    /**\n     * 配置织入点 - 自定义注解的包路径\n     * \n     */\n    @pointcut("@annotation(com.xxx.aspectj.lang.annotation.log)")\n    public void logpointcut() {\n    }\n\n    /**\n     * 处理完请求后执行\n     *\n     * @param joinpoint 切点\n     */\n    @afterreturning(pointcut = "logpointcut()", returning = "jsonresult")\n    public void doafterreturning(joinpoint joinpoint, object jsonresult) {\n        handlelog(joinpoint, null, jsonresult);\n    }\n\n    /**\n     * 拦截异常操作\n     * \n     * @param joinpoint 切点\n     * @param e 异常\n     */\n    @afterthrowing(value = "logpointcut()", throwing = "e")\n    public void doafterthrowing(joinpoint joinpoint, exception e) {\n        handlelog(joinpoint, e, null);\n    }\n\n    protected void handlelog(final joinpoint joinpoint, final exception e, object jsonresult) {\n        try {\n            // 获得注解\n            log controllerlog = getannotationlog(joinpoint);\n            if (controllerlog == null) {\n                return;\n            }\n\n            // 获取当前的用户\n            user currentuser = shiroutils.getsysuser();\n\n            // *========数据库日志=========*//\n            operlog operlog = new operlog();\n            operlog.setstatus(businessstatus.success.ordinal());\n            // 请求的地址\n            string ip = shiroutils.getip();\n            operlog.setoperip(ip);\n            // 返回参数\n            operlog.setjsonresult(jsonobject.tojsonstring(jsonresult));\n\n            operlog.setoperurl(servletutils.getrequest().getrequesturi());\n            if (currentuser != null) {\n                operlog.setopername(currentuser.getloginname());\n                if (stringutils.isnotnull(currentuser.getdept())\n                        && stringutils.isnotempty(currentuser.getdept().getdeptname())) {\n                    operlog.setdeptname(currentuser.getdept().getdeptname());\n                }\n            }\n\n            if (e != null) {\n                operlog.setstatus(businessstatus.fail.ordinal());\n                operlog.seterrormsg(stringutils.substring(e.getmessage(), 0, 2000));\n            }\n            // 设置方法名称\n            string classname = joinpoint.gettarget().getclass().getname();\n            string methodname = joinpoint.getsignature().getname();\n            operlog.setmethod(classname + "." + methodname + "()");\n            // 设置请求方式\n            operlog.setrequestmethod(servletutils.getrequest().getmethod());\n            // 处理设置注解上的参数\n            getcontrollermethoddescription(controllerlog, operlog);\n            // 保存数据库\n            asyncmanager.me().execute(asyncfactory.recordoper(operlog));\n        } catch (exception exp) {\n            // 记录本地异常日志\n            log.error("==前置通知异常==");\n            log.error("异常信息:{}", exp.getmessage());\n            exp.printstacktrace();\n        }\n    }\n\n    /**\n     * 获取注解中对方法的描述信息 用于controller层注解\n     * \n     * @param log 日志\n     * @param operlog 操作日志\n     * @throws exception\n     */\n    public void getcontrollermethoddescription(log log, operlog operlog) throws exception {\n        // 设置action动作\n        operlog.setbusinesstype(log.businesstype().ordinal());\n        // 设置标题\n        operlog.settitle(log.title());\n        // 设置操作人类别\n        operlog.setoperatortype(log.operatortype().ordinal());\n        // 是否需要保存request，参数和值\n        if (log.issaverequestdata()) {\n            // 获取参数的信息，传入到数据库中。\n            setrequestvalue(operlog);\n        }\n    }\n\n    /**\n     * 获取请求的参数，放到log中\n     * \n     * @param operlog\n     * @param request\n     */\n    private void setrequestvalue(operlog operlog) {\n        map<string, string[]> map = servletutils.getrequest().getparametermap();\n        string params = jsonobject.tojsonstring(map);\n        operlog.setoperparam(stringutils.substring(params, 0, 2000));\n    }\n\n    /**\n     * 是否存在注解，如果存在就获取\n     */\n    private log getannotationlog(joinpoint joinpoint) throws exception {\n        signature signature = joinpoint.getsignature();\n        methodsignature methodsignature = (methodsignature) signature;\n        method method = methodsignature.getmethod();\n\n        if (method != null)\n        {\n            return method.getannotation(log.class);\n        }\n        return null;\n    }\n}\n\n\n * 使用@log注解\n\n以一个简单的crud操作为例, 这里展示部分代码：每对“部门”进行操作就会产生一条操作日志存入数据库。\n\n@controller\n@requestmapping("/system/dept")\npublic class deptcontroller extends basecontroller {\n    private string prefix = "system/dept";\n\n    @autowired\n    private ideptservice deptservice;\n    \n    /**\n     * 新增保存部门\n     */\n    @log(title = "部门管理", businesstype = businesstype.insert)\n    @requirespermissions("system:dept:add")\n    @postmapping("/add")\n    @responsebody\n    public ajaxresult addsave(@validated dept dept) {\n        if (userconstants.dept_name_not_unique.equals(deptservice.checkdeptnameunique(dept))) {\n            return error("新增部门\'" + dept.getdeptname() + "\'失败，部门名称已存在");\n        }\n        return toajax(deptservice.insertdept(dept));\n    }\n\n    /**\n     * 保存\n     */\n    @log(title = "部门管理", businesstype = businesstype.update)\n    @requirespermissions("system:dept:edit")\n    @postmapping("/edit")\n    @responsebody\n    public ajaxresult editsave(@validated dept dept) {\n        if (userconstants.dept_name_not_unique.equals(deptservice.checkdeptnameunique(dept))) {\n            return error("修改部门\'" + dept.getdeptname() + "\'失败，部门名称已存在");\n        } else if(dept.getparentid().equals(dept.getdeptid())) {\n            return error("修改部门\'" + dept.getdeptname() + "\'失败，上级部门不能是自己");\n        }\n        return toajax(deptservice.updatedept(dept));\n    }\n\n    /**\n     * 删除\n     */\n    @log(title = "部门管理", businesstype = businesstype.delete)\n    @requirespermissions("system:dept:remove")\n    @getmapping("/remove/{deptid}")\n    @responsebody\n    public ajaxresult remove(@pathvariable("deptid") long deptid) {\n        if (deptservice.selectdeptcount(deptid) > 0) {\n            return ajaxresult.warn("存在下级部门,不允许删除");\n        }\n        if (deptservice.checkdeptexistuser(deptid)) {\n            return ajaxresult.warn("部门存在用户,不允许删除");\n        }\n        return toajax(deptservice.deletedeptbyid(deptid));\n    }\n\n  // ...\n}\n\n\n> 同样的，你也可以看到权限管理也是通过类似的注解（@requirespermissions）机制来实现的。所以我们可以看到，通过注解+aop最终的目标是为了实现模块的解耦。\n\n\n# 参考文章\n\n * https://blog.csdn.net/javazejian/article/details/71860633\n * https://blog.csdn.net/qq_20009015/article/details/106038023\n * https://www.zhihu.com/question/47449512\n * https://www.race604.com/annotation-processing/\n * https://www.runoob.com/w3cnote/java-annotation.html\n * 转载 https://www.pdai.tech/md/java/basic/java-basic-x-annotation.html',charsets:{cjk:!0}},{title:"Java 基础 - 知识点",frontmatter:{},regularPath:"/java/basic/java-basic-lan-basic.html",relativePath:"java/basic/java-basic-lan-basic.md",key:"v-85306db0",path:"/java/basic/java-basic-lan-basic.html",headers:[{level:2,title:"Java 基础 - 知识点",slug:"java-基础-知识点",normalizedTitle:"java 基础 - 知识点",charIndex:2},{level:2,title:"数据类型",slug:"数据类型",normalizedTitle:"数据类型",charIndex:62},{level:3,title:"包装类型",slug:"包装类型",normalizedTitle:"包装类型",charIndex:74},{level:3,title:"缓存池",slug:"缓存池",normalizedTitle:"缓存池",charIndex:86},{level:2,title:"String",slug:"string",normalizedTitle:"string",charIndex:95},{level:3,title:"概览",slug:"概览",normalizedTitle:"概览",charIndex:109},{level:3,title:"不可变的好处",slug:"不可变的好处",normalizedTitle:"不可变的好处",charIndex:119},{level:3,title:"String, StringBuffer and StringBuilder",slug:"string-stringbuffer-and-stringbuilder",normalizedTitle:"string, stringbuffer and stringbuilder",charIndex:133},{level:3,title:"String.intern()",slug:"string-intern",normalizedTitle:"string.intern()",charIndex:179},{level:2,title:"运算",slug:"运算",normalizedTitle:"运算",charIndex:200},{level:3,title:"参数传递",slug:"参数传递",normalizedTitle:"参数传递",charIndex:210},{level:3,title:"float 与 double",slug:"float-与-double",normalizedTitle:"float 与 double",charIndex:222},{level:3,title:"隐式类型转换",slug:"隐式类型转换",normalizedTitle:"隐式类型转换",charIndex:244},{level:3,title:"switch",slug:"switch",normalizedTitle:"switch",charIndex:258},{level:2,title:"继承",slug:"继承",normalizedTitle:"继承",charIndex:270},{level:3,title:"访问权限",slug:"访问权限",normalizedTitle:"访问权限",charIndex:280},{level:3,title:"抽象类与接口",slug:"抽象类与接口",normalizedTitle:"抽象类与接口",charIndex:292},{level:3,title:"super",slug:"super",normalizedTitle:"super",charIndex:306},{level:3,title:"重写与重载",slug:"重写与重载",normalizedTitle:"重写与重载",charIndex:319},{level:2,title:"Object 通用方法",slug:"object-通用方法",normalizedTitle:"object 通用方法",charIndex:330},{level:3,title:"概览",slug:"概览-2",normalizedTitle:"概览",charIndex:109},{level:3,title:"equals()",slug:"equals",normalizedTitle:"equals()",charIndex:359},{level:3,title:"hashCode()",slug:"hashcode",normalizedTitle:"hashcode()",charIndex:375},{level:3,title:"toString()",slug:"tostring",normalizedTitle:"tostring()",charIndex:393},{level:3,title:"clone()",slug:"clone",normalizedTitle:"clone()",charIndex:411},{level:2,title:"关键字",slug:"关键字",normalizedTitle:"关键字",charIndex:424},{level:3,title:"final",slug:"final",normalizedTitle:"final",charIndex:435},{level:3,title:"static",slug:"static",normalizedTitle:"static",charIndex:448},{level:2,title:"反射",slug:"反射",normalizedTitle:"反射",charIndex:460},{level:2,title:"异常",slug:"异常",normalizedTitle:"异常",charIndex:468},{level:2,title:"泛型",slug:"泛型",normalizedTitle:"泛型",charIndex:476},{level:2,title:"注解",slug:"注解",normalizedTitle:"注解",charIndex:484},{level:2,title:"特性",slug:"特性",normalizedTitle:"特性",charIndex:492},{level:3,title:"Java 各版本的新特性",slug:"java-各版本的新特性",normalizedTitle:"java 各版本的新特性",charIndex:502},{level:3,title:"Java 与 C++ 的区别",slug:"java-与-c-的区别",normalizedTitle:"java 与 c++ 的区别",charIndex:522},{level:3,title:"JRE or JDK",slug:"jre-or-jdk",normalizedTitle:"jre or jdk",charIndex:544},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:560}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java 基础 - 知识点 数据类型 包装类型 缓存池 String 概览 不可变的好处 String, StringBuffer and StringBuilder String.intern() 运算 参数传递 float 与 double 隐式类型转换 switch 继承 访问权限 抽象类与接口 super 重写与重载 Object 通用方法 概览 equals() hashCode() toString() clone() 关键字 final static 反射 异常 泛型 注解 特性 Java 各版本的新特性 Java 与 C++ 的区别 JRE or JDK 参考资料",content:'# Java 基础 - 知识点\n\n> 本文主要对Java基础知识点进行总结。\n\n * Java 基础 - 知识点\n   * 数据类型\n     * 包装类型\n     * 缓存池\n   * String\n     * 概览\n     * 不可变的好处\n     * String, StringBuffer and StringBuilder\n     * String.intern()\n   * 运算\n     * 参数传递\n     * float 与 double\n     * 隐式类型转换\n     * switch\n   * 继承\n     * 访问权限\n     * 抽象类与接口\n     * super\n     * 重写与重载\n   * Object 通用方法\n     * 概览\n     * equals()\n     * hashCode()\n     * toString()\n     * clone()\n   * 关键字\n     * final\n     * static\n   * 反射\n   * 异常\n   * 泛型\n   * 注解\n   * 特性\n     * Java 各版本的新特性\n     * Java 与 C++ 的区别\n     * JRE or JDK\n   * 参考资料\n\n\n# 数据类型\n\n\n# 包装类型\n\n八个基本类型:\n\n * boolean/1\n * byte/8\n * char/16\n * short/16\n * int/32\n * float/32\n * long/64\n * double/64\n\n基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。\n\nInteger x = 2;     // 装箱\nint y = x;         // 拆箱\n\n\n\n# 缓存池\n\nnew Integer(123) 与 Integer.valueOf(123) 的区别在于:\n\n * new Integer(123) 每次都会新建一个对象\n * Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。\n\nInteger x = new Integer(123);\nInteger y = new Integer(123);\nSystem.out.println(x == y);    // false\nInteger z = Integer.valueOf(123);\nInteger k = Integer.valueOf(123);\nSystem.out.println(z == k);   // true\n\n\nvalueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。\n\npublic static Integer valueOf(int i) {\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\n\n\n在 Java 8 中，Integer 缓存池的大小默认为 -128~127。\n\nstatic final int low = -128;\nstatic final int high;\nstatic final Integer cache[];\n\nstatic {\n    // high value may be configured by property\n    int h = 127;\n    String integerCacheHighPropValue =\n        sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");\n    if (integerCacheHighPropValue != null) {\n        try {\n            int i = parseInt(integerCacheHighPropValue);\n            i = Math.max(i, 127);\n            // Maximum array size is Integer.MAX_VALUE\n            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n        } catch( NumberFormatException nfe) {\n            // If the property cannot be parsed into an int, ignore it.\n        }\n    }\n    high = h;\n\n    cache = new Integer[(high - low) + 1];\n    int j = low;\n    for(int k = 0; k < cache.length; k++)\n        cache[k] = new Integer(j++);\n\n    // range [-128, 127] must be interned (JLS7 5.1.7)\n    assert IntegerCache.high >= 127;\n}\n\n\n编译器会在缓冲池范围内的基本类型自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。\n\nInteger m = 123;\nInteger n = 123;\nSystem.out.println(m == n); // true\n\n\n基本类型对应的缓冲池如下:\n\n * boolean values true and false\n * all byte values\n * short values between -128 and 127\n * int values between -128 and 127\n * char in the range \\u0000 to \\u007F\n\n在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。\n\n如果在缓冲池之外：\n\nInteger m = 323;\nInteger n = 323;\nSystem.out.println(m == n); // false\n\n\n\n# String\n\n\n# 概览\n\nString 被声明为 final，因此它不可被继承。\n\n内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。\n\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    /** The value is used for character storage. */\n    private final char value[];\n\n\n\n# 不可变的好处\n\n1. 可以缓存 hash 值\n\n因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。\n\n2. String Pool 的需要\n\n如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。\n\n\n\n3. 安全性\n\nString 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。\n\n4. 线程安全\n\nString 不可变性天生具备线程安全，可以在多个线程中安全地使用。\n\nProgram Creek : Why String is immutable in Java?在新窗口打开\n\n\n# String, StringBuffer and StringBuilder\n\n1. 可变性\n\n * String 不可变\n * StringBuffer 和 StringBuilder 可变\n\n2. 线程安全\n\n * String 不可变，因此是线程安全的\n * StringBuilder 不是线程安全的\n * StringBuffer 是线程安全的，内部使用 synchronized 进行同步\n\nStackOverflow : String, StringBuffer, and StringBuilder在新窗口打开\n\n\n# String.intern()\n\n使用 String.intern() 可以保证相同内容的字符串变量引用同一的内存对象。\n\n下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同对象，而 s3 是通过 s1.intern() 方法取得一个对象引用。intern() 首先把 s1 引用的对象放到 String Pool(字符串常量池)中，然后返回这个对象引用。因此 s3 和 s1 引用的是同一个字符串常量池的对象。\n\nString s1 = new String("aaa");\nString s2 = new String("aaa");\nSystem.out.println(s1 == s2);           // false\nString s3 = s1.intern();\nSystem.out.println(s1.intern() == s3);  // true\n\n\n如果是采用 "bbb" 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 String Pool 中。\n\nString s4 = "bbb";\nString s5 = "bbb";\nSystem.out.println(s4 == s5);  // true\n\n\n * HotSpot中字符串常量池保存哪里？永久代？方法区还是堆区？\n\n 1. 运行时常量池（Runtime Constant Pool）是虚拟机规范中是方法区的一部分，在加载类和结构到虚拟机后，就会创建对应的运行时常量池；而字符串常量池是这个过程中常量字符串的存放位置。所以从这个角度，字符串常量池属于虚拟机规范中的方法区，它是一个逻辑上的概念；而堆区，永久代以及元空间是实际的存放位置。\n 2. 不同的虚拟机对虚拟机的规范（比如方法区）是不一样的，只有 HotSpot 才有永久代的概念。\n 3. HotSpot也是发展的，由于一些问题在新窗口打开的存在，HotSpot考虑逐渐去永久代，对于不同版本的JDK，实际的存储位置是有差异的，具体看如下表格：\n\nJDK版本       是否有永久代，字符串常量池放在哪里？                                方法区逻辑上规范，由哪些实际的部分实现的？\njdk1.6及之前   有永久代，运行时常量池（包括字符串常量池），静态变量存放在永久代上                 这个时期方法区在HotSpot中是由永久代来实现的，以至于这个时期说方法区就是指永久代\njdk1.7      有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中；             这个时期方法区在HotSpot中由永久代（类型信息、字段、方法、常量）和堆（字符串常量池、静态变量）共同实现\njdk1.8及之后   取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中   这个时期方法区在HotSpot中由本地内存的元空间（类型信息、字段、方法、常量）和堆（字符串常量池、静态变量）共同实现\n\n\n# 运算\n\n\n# 参数传递\n\nJava 的参数是以值传递的形式传入方法中，而不是引用传递。\n\n以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中改变指针引用的对象，那么这两个指针此时指向的是完全不同的对象，一方改变其所指向对象的内容对另一方没有影响。\n\npublic class Dog {\n    String name;\n\n    Dog(String name) {\n        this.name = name;\n    }\n\n    String getName() {\n        return this.name;\n    }\n\n    void setName(String name) {\n        this.name = name;\n    }\n\n    String getObjectAddress() {\n        return super.toString();\n    }\n}\n\n\npublic class PassByValueExample {\n    public static void main(String[] args) {\n        Dog dog = new Dog("A");\n        System.out.println(dog.getObjectAddress()); // Dog@4554617c\n        func(dog);\n        System.out.println(dog.getObjectAddress()); // Dog@4554617c\n        System.out.println(dog.getName());          // A\n    }\n\n    private static void func(Dog dog) {\n        System.out.println(dog.getObjectAddress()); // Dog@4554617c\n        dog = new Dog("B");\n        System.out.println(dog.getObjectAddress()); // Dog@74a14482\n        System.out.println(dog.getName());          // B\n    }\n}\n\n\n但是如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。\n\nclass PassByValueExample {\n    public static void main(String[] args) {\n        Dog dog = new Dog("A");\n        func(dog);\n        System.out.println(dog.getName());          // B\n    }\n\n    private static void func(Dog dog) {\n        dog.setName("B");\n    }\n}\n\n\nStackOverflow: Is Java “pass-by-reference” or “pass-by-value”?在新窗口打开\n\n\n# float 与 double\n\n1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。Java 不能隐式执行向下转型，因为这会使得精度降低。\n\n1.1f 字面量才是 float 类型。\n\n\n# 隐式类型转换\n\n因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。\n\nshort s1 = 1;\n// s1 = s1 + 1;\n\n\n但是使用 += 运算符可以执行隐式类型转换。\n\n上面的语句相当于将 s1 + 1 的计算结果进行了向下转型:\n\nStackOverflow : Why don\'t Java\'s +=, -=, *=, /= compound assignment operators require casting?在新窗口打开\n\n\n# switch\n\n从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。\n\nString s = "a";\nswitch (s) {\n    case "a":\n        System.out.println("aaa");\n        break;\n    case "b":\n        System.out.println("bbb");\n        break;\n}\n\n\nswitch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。\n\n// long x = 111;\n// switch (x) { // Incompatible types. Found: \'long\', required: \'char, byte, short, int, Character, Byte, Short, Integer, String, or an enum\'\n//     case 111:\n//         System.out.println(111);\n//         break;\n//     case 222:\n//         System.out.println(222);\n//         break;\n// }\n\n\nStackOverflow : Why can\'t your switch statement data type be long, Java?在新窗口打开\n\n\n# 继承\n\n\n# 访问权限\n\nJava 中有三个访问权限修饰符: private、protected 以及 public，如果不加访问修饰符，表示包级可见。\n\n可以对类或类中的成员(字段以及方法)加上访问修饰符。\n\n * 类可见表示其它类可以用这个类创建实例对象。\n * 成员可见表示其它类可以用这个类的实例对象访问到该成员；\n\nprotected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。\n\n设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。\n\n如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。\n\n字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 共有字段，如果在某个时刻，我们想要使用 int 去存储 id 字段，那么就需要去修改所有的客户端代码。\n\npublic class AccessExample {\n    public String id;\n}\n\n\n可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。\n\npublic class AccessExample {\n\n    private int id;\n\n    public String getId() {\n        return id + "";\n    }\n\n    public void setId(String id) {\n        this.id = Integer.valueOf(id);\n    }\n}\n\n\n但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。\n\npublic class AccessWithInnerClassExample {\n    private class InnerClass {\n        int x;\n    }\n\n    private InnerClass innerClass;\n\n    public AccessWithInnerClassExample() {\n        innerClass = new InnerClass();\n    }\n\n    public int getValue() {\n        return innerClass.x;  // 直接访问\n    }\n}\n\n\n\n# 抽象类与接口\n\n1. 抽象类\n\n抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。\n\n抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。\n\npublic abstract class AbstractClassExample {\n\n    protected int x;\n    private int y;\n\n    public abstract void func1();\n\n    public void func2() {\n        System.out.println("func2");\n    }\n}\n\n\npublic class AbstractExtendClassExample extends AbstractClassExample {\n    @Override\n    public void func1() {\n        System.out.println("func1");\n    }\n}\n\n\n// AbstractClassExample ac1 = new AbstractClassExample(); // \'AbstractClassExample\' is abstract; cannot be instantiated\nAbstractClassExample ac2 = new AbstractExtendClassExample();\nac2.func1();\n\n\n2. 接口\n\n接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。\n\n从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。\n\n接口的成员(字段 + 方法)默认都是 public 的，并且不允许定义为 private 或者 protected。\n\n接口的字段默认都是 static 和 final 的。\n\npublic interface InterfaceExample {\n    void func1();\n\n    default void func2(){\n        System.out.println("func2");\n    }\n\n    int x = 123;\n    // int y;               // Variable \'y\' might not have been initialized\n    public int z = 0;       // Modifier \'public\' is redundant for interface fields\n    // private int k = 0;   // Modifier \'private\' not allowed here\n    // protected int l = 0; // Modifier \'protected\' not allowed here\n    // private void fun3(); // Modifier \'private\' not allowed here\n}\n\n\npublic class InterfaceImplementExample implements InterfaceExample {\n    @Override\n    public void func1() {\n        System.out.println("func1");\n    }\n}\n\n\n// InterfaceExample ie1 = new InterfaceExample(); // \'InterfaceExample\' is abstract; cannot be instantiated\nInterfaceExample ie2 = new InterfaceImplementExample();\nie2.func1();\nSystem.out.println(InterfaceExample.x);\n\n\n3. 比较\n\n * 从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。\n * 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。\n * 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。\n * 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。\n\n4. 使用选择\n\n使用接口:\n\n * 需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；\n * 需要使用多重继承。\n\n使用抽象类:\n\n * 需要在几个相关的类中共享代码。\n * 需要能控制继承来的成员的访问权限，而不是都为 public。\n * 需要继承非静态和非常量字段。\n\n在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。\n\n * 深入理解 abstract class 和 interface在新窗口打开\n * When to Use Abstract Class and Interface在新窗口打开\n\n\n# super\n\n * 访问父类的构造函数: 可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。\n * 访问父类的成员: 如果子类重写了父类的中某个方法的实现，可以通过使用 super 关键字来引用父类的方法实现。\n\npublic class SuperExample {\n    protected int x;\n    protected int y;\n\n    public SuperExample(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void func() {\n        System.out.println("SuperExample.func()");\n    }\n}\n\n\npublic class SuperExtendExample extends SuperExample {\n    private int z;\n\n    public SuperExtendExample(int x, int y, int z) {\n        super(x, y);\n        this.z = z;\n    }\n\n    @Override\n    public void func() {\n        super.func();\n        System.out.println("SuperExtendExample.func()");\n    }\n}\n\n\nSuperExample e = new SuperExtendExample(1, 2, 3);\ne.func();\n\n\nSuperExample.func()\nSuperExtendExample.func()\n\n\nUsing the Keyword super在新窗口打开\n\n\n# 重写与重载\n\n1. 重写(Override)\n\n存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。\n\n为了满足里式替换原则，重写有以下两个限制:\n\n * 子类方法的访问权限必须大于等于父类方法；\n * 子类方法的返回类型必须是父类方法返回类型或为其子类型。\n\n使用 @Override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。\n\n2. 重载(Overload)\n\n存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。\n\n应该注意的是，返回值不同，其它都相同不算是重载。\n\n\n# Object 通用方法\n\n\n# 概览\n\npublic final native Class<?> getClass()\n\npublic native int hashCode()\n\npublic boolean equals(Object obj)\n\nprotected native Object clone() throws CloneNotSupportedException\n\npublic String toString()\n\npublic final native void notify()\n\npublic final native void notifyAll()\n\npublic final native void wait(long timeout) throws InterruptedException\n\npublic final void wait(long timeout, int nanos) throws InterruptedException\n\npublic final void wait() throws InterruptedException\n\nprotected void finalize() throws Throwable {}\n\n\n\n# equals()\n\n1. 等价关系\n\n(一)自反性\n\n(二)对称性\n\nx.equals(y) == y.equals(x); // true\n\n\n(三)传递性\n\nif (x.equals(y) && y.equals(z))\n    x.equals(z); // true;\n\n\n(四)一致性\n\n多次调用 equals() 方法结果不变\n\nx.equals(y) == x.equals(y); // true\n\n\n(五)与 null 的比较\n\n对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false\n\nx.equals(null); // false;\n\n\n2. equals() 与 ==\n\n * 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。\n * 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。\n\nInteger x = new Integer(1);\nInteger y = new Integer(1);\nSystem.out.println(x.equals(y)); // true\nSystem.out.println(x == y);      // false\n\n\n3. 实现\n\n * 检查是否为同一个对象的引用，如果是直接返回 true；\n * 检查是否是同一个类型，如果不是，直接返回 false；\n * 将 Object 对象进行转型；\n * 判断每个关键域是否相等。\n\npublic class EqualExample {\n    private int x;\n    private int y;\n    private int z;\n\n    public EqualExample(int x, int y, int z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        EqualExample that = (EqualExample) o;\n\n        if (x != that.x) return false;\n        if (y != that.y) return false;\n        return z == that.z;\n    }\n}\n\n\n\n# hashCode()\n\nhashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。\n\n在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。\n\n下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。\n\nEqualExample e1 = new EqualExample(1, 1, 1);\nEqualExample e2 = new EqualExample(1, 1, 1);\nSystem.out.println(e1.equals(e2)); // true\nHashSet<EqualExample> set = new HashSet<>();\nset.add(e1);\nset.add(e2);\nSystem.out.println(set.size());   // 2\n\n\n理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来，可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。\n\n一个数与 31 相乘可以转换成移位和减法: 31*x == (x<<5)-x，编译器会自动进行这个优化。\n\n@Override\npublic int hashCode() {\n    int result = 17;\n    result = 31 * result + x;\n    result = 31 * result + y;\n    result = 31 * result + z;\n    return result;\n}\n\n\n\n# toString()\n\n默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。\n\npublic class ToStringExample {\n    private int number;\n\n    public ToStringExample(int number) {\n        this.number = number;\n    }\n}\n\n\nToStringExample example = new ToStringExample(123);\nSystem.out.println(example.toString());\n\n\n\n# clone()\n\n1. cloneable\n\nclone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。\n\npublic class CloneExample {\n    private int a;\n    private int b;\n}\n\n\nCloneExample e1 = new CloneExample();\n// CloneExample e2 = e1.clone(); // \'clone()\' has protected access in \'java.lang.Object\'\n\n\n重写 clone() 得到以下实现:\n\npublic class CloneExample {\n    private int a;\n    private int b;\n\n    @Override\n    protected CloneExample clone() throws CloneNotSupportedException {\n        return (CloneExample)super.clone();\n    }\n}\n\n\nCloneExample e1 = new CloneExample();\ntry {\n    CloneExample e2 = e1.clone();\n} catch (CloneNotSupportedException e) {\n    e.printStackTrace();\n}\n\n\njava.lang.CloneNotSupportedException: CloneExample\n\n\n以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。\n\n应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。\n\npublic class CloneExample implements Cloneable {\n    private int a;\n    private int b;\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n}\n\n\n2. 浅拷贝\n\n拷贝对象和原始对象的引用类型引用同一个对象。\n\npublic class ShallowCloneExample implements Cloneable {\n    private int[] arr;\n\n    public ShallowCloneExample() {\n        arr = new int[10];\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = i;\n        }\n    }\n\n    public void set(int index, int value) {\n        arr[index] = value;\n    }\n\n    public int get(int index) {\n        return arr[index];\n    }\n\n    @Override\n    protected ShallowCloneExample clone() throws CloneNotSupportedException {\n        return (ShallowCloneExample) super.clone();\n    }\n}\n\n\nShallowCloneExample e1 = new ShallowCloneExample();\nShallowCloneExample e2 = null;\ntry {\n    e2 = e1.clone();\n} catch (CloneNotSupportedException e) {\n    e.printStackTrace();\n}\ne1.set(2, 222);\nSystem.out.println(e2.get(2)); // 222\n\n\n3. 深拷贝\n\n拷贝对象和原始对象的引用类型引用不同对象。\n\npublic class DeepCloneExample implements Cloneable {\n    private int[] arr;\n\n    public DeepCloneExample() {\n        arr = new int[10];\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = i;\n        }\n    }\n\n    public void set(int index, int value) {\n        arr[index] = value;\n    }\n\n    public int get(int index) {\n        return arr[index];\n    }\n\n    @Override\n    protected DeepCloneExample clone() throws CloneNotSupportedException {\n        DeepCloneExample result = (DeepCloneExample) super.clone();\n        result.arr = new int[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            result.arr[i] = arr[i];\n        }\n        return result;\n    }\n}\n\n\nDeepCloneExample e1 = new DeepCloneExample();\nDeepCloneExample e2 = null;\ntry {\n    e2 = e1.clone();\n} catch (CloneNotSupportedException e) {\n    e.printStackTrace();\n}\ne1.set(2, 222);\nSystem.out.println(e2.get(2)); // 2\n\n\n4. clone() 的替代方案\n\n使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。\n\npublic class CloneConstructorExample {\n    private int[] arr;\n\n    public CloneConstructorExample() {\n        arr = new int[10];\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = i;\n        }\n    }\n\n    public CloneConstructorExample(CloneConstructorExample original) {\n        arr = new int[original.arr.length];\n        for (int i = 0; i < original.arr.length; i++) {\n            arr[i] = original.arr[i];\n        }\n    }\n\n    public void set(int index, int value) {\n        arr[index] = value;\n    }\n\n    public int get(int index) {\n        return arr[index];\n    }\n}\n\n\nCloneConstructorExample e1 = new CloneConstructorExample();\nCloneConstructorExample e2 = new CloneConstructorExample(e1);\ne1.set(2, 222);\nSystem.out.println(e2.get(2)); // 2\n\n\n\n# 关键字\n\n\n# final\n\n1. 数据\n\n声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。\n\n * 对于基本类型，final 使数值不变；\n * 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。\n\nfinal int x = 1;\n// x = 2;  // cannot assign value to final variable \'x\'\nfinal A y = new A();\ny.a = 1;\n\n\n2. 方法\n\n声明方法不能被子类重写。\n\nprivate 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。\n\n3. 类\n\n声明类不允许被继承。\n\n\n# static\n\n1. 静态变量\n\n * 静态变量: 又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它；静态变量在内存中只存在一份。\n * 实例变量: 每创建一个实例就会产生一个实例变量，它与该实例同生共死。\n\npublic class A {\n    private int x;         // 实例变量\n    private static int y;  // 静态变量\n\n    public static void main(String[] args) {\n        // int x = A.x;  // Non-static field \'x\' cannot be referenced from a static context\n        A a = new A();\n        int x = a.x;\n        int y = A.y;\n    }\n}\n\n\n2. 静态方法\n\n静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法(abstract)。\n\npublic abstract class A {\n    public static void func1(){\n    }\n    // public abstract static void func2();  // Illegal combination of modifiers: \'abstract\' and \'static\'\n}\n\n\n只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。\n\npublic class A {\n    private static int x;\n    private int y;\n\n    public static void func1(){\n        int a = x;\n        // int b = y;  // Non-static field \'y\' cannot be referenced from a static context\n        // int b = this.y;     // \'A.this\' cannot be referenced from a static context\n    }\n}\n\n\n3. 静态语句块\n\n静态语句块在类初始化时运行一次。\n\npublic class A {\n    static {\n        System.out.println("123");\n    }\n\n    public static void main(String[] args) {\n        A a1 = new A();\n        A a2 = new A();\n    }\n}\n\n\n4. 静态内部类\n\n非静态内部类依赖于外部类的实例，而静态内部类不需要。\n\npublic class OuterClass {\n    class InnerClass {\n    }\n\n    static class StaticInnerClass {\n    }\n\n    public static void main(String[] args) {\n        // InnerClass innerClass = new InnerClass(); // \'OuterClass.this\' cannot be referenced from a static context\n        OuterClass outerClass = new OuterClass();\n        InnerClass innerClass = outerClass.new InnerClass();\n        StaticInnerClass staticInnerClass = new StaticInnerClass();\n    }\n}\n\n\n静态内部类不能访问外部类的非静态的变量和方法。\n\n5. 静态导包\n\n在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。\n\nimport static com.xxx.ClassName.*\n\n\n6. 初始化顺序\n\n静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。\n\npublic static String staticField = "静态变量";\n\n\nstatic {\n    System.out.println("静态语句块");\n}\n\n\npublic String field = "实例变量";\n\n\n{\n    System.out.println("普通语句块");\n}\n\n\n最后才是构造函数的初始化。\n\npublic InitialOrderTest() {\n    System.out.println("构造函数");\n}\n\n\n存在继承的情况下，初始化顺序为:\n\n * 父类(静态变量、静态语句块)\n * 子类(静态变量、静态语句块)\n * 父类(实例变量、普通语句块)\n * 父类(构造函数)\n * 子类(实例变量、普通语句块)\n * 子类(构造函数)\n\n\n# 反射\n\n每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。\n\n类加载相当于 Class 对象的加载。类在第一次使用时才动态加载到 JVM 中，可以使用 Class.forName("com.mysql.jdbc.Driver") 这种方式来控制类的加载，该方法会返回一个 Class 对象。\n\n反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。\n\nClass 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类:\n\n * Field : 可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；\n * Method : 可以使用 invoke() 方法调用与 Method 对象关联的方法；\n * Constructor : 可以用 Constructor 创建新的对象。\n\nAdvantages of Using Reflection:\n\n * Extensibility Features : An application may make use of external, user-defined classes by creating instances of extensibility objects using their fully-qualified names.\n * Class Browsers and Visual Development Environments : A class browser needs to be able to enumerate the members of classes. Visual development environments can benefit from making use of type information available in reflection to aid the developer in writing correct code.\n * Debuggers and Test Tools : Debuggers need to be able to examine private members on classes. Test harnesses can make use of reflection to systematically call a discoverable set APIs defined on a class, to insure a high level of code coverage in a test suite.\n\nDrawbacks of Reflection:\n\nReflection is powerful, but should not be used indiscriminately. If it is possible to perform an operation without using reflection, then it is preferable to avoid using it. The following concerns should be kept in mind when accessing code via reflection.\n\n * Performance Overhead : Because reflection involves types that are dynamically resolved, certain Java virtual machine optimizations can not be performed. Consequently, reflective operations have slower performance than their non-reflective counterparts, and should be avoided in sections of code which are called frequently in performance-sensitive applications.\n * Security Restrictions : Reflection requires a runtime permission which may not be present when running under a security manager. This is in an important consideration for code which has to run in a restricted security context, such as in an Applet.\n * Exposure of Internals :Since reflection allows code to perform operations that would be illegal in non-reflective code, such as accessing private fields and methods, the use of reflection can result in unexpected side-effects, which may render code dysfunctional and may destroy portability. Reflective code breaks abstractions and therefore may change behavior with upgrades of the platform.\n\n相关文章：Java 基础 - 反射机制详解\n\n\n# 异常\n\nThrowable 可以用来表示任何可以作为异常抛出的类，分为两种: Error 和 Exception。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种:\n\n * 受检异常 : 需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复；\n * 非受检异常 : 是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。\n\n\n\n相关文章：Java 基础 - 异常机制详解\n\n\n# 泛型\n\npublic class Box<T> {\n    // T stands for "Type"\n    private T t;\n    public void set(T t) { this.t = t; }\n    public T get() { return t; }\n}\n\n\n相关文章：Java 基础 - 泛型机制详解\n\n\n# 注解\n\nJava 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。\n\n相关文章：Java 基础 - 注解机制详解\n\n\n# 特性\n\n\n# Java 各版本的新特性\n\nNew highlights in Java SE 8\n\n 1. Lambda Expressions\n 2. Pipelines and Streams\n 3. Date and Time API\n 4. Default Methods\n 5. Type Annotations\n 6. Nashhorn JavaScript Engine\n 7. Concurrent Accumulators\n 8. Parallel operations\n 9. PermGen Error Removed\n\nNew highlights in Java SE 7\n\n 1. Strings in Switch Statement\n 2. Type Inference for Generic Instance Creation\n 3. Multiple Exception Handling\n 4. Support for Dynamic Languages\n 5. Try with Resources\n 6. Java nio Package\n 7. Binary Literals, Underscore in literals\n 8. Diamond Syntax\n\n * Difference between Java 1.8 and Java 1.7?在新窗口打开\n * Java 8 特性在新窗口打开\n\n\n# Java 与 C++ 的区别\n\n * Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。\n * Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。\n * Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。\n * Java 支持自动垃圾回收，而 C++ 需要手动回收。\n * Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。\n * Java 不支持操作符重载，虽然可以对两个 String 对象支持加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。\n * Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。\n * Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。\n\nWhat are the main differences between Java and C++?在新窗口打开\n\n\n# JRE or JDK\n\n * JRE is the JVM program, Java application need to run on JRE.\n * JDK is a superset of JRE, JRE + tools for developing java programs. e.g, it provides the compiler "javac"\n\n\n# 参考资料\n\n * Eckel B. Java 编程思想[M]. 机械工业出版社, 2002.\n * Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.\n * 转载 https://www.pdai.tech/md/java/basic/java-basic-lan-basic.html',normalizedContent:'# java 基础 - 知识点\n\n> 本文主要对java基础知识点进行总结。\n\n * java 基础 - 知识点\n   * 数据类型\n     * 包装类型\n     * 缓存池\n   * string\n     * 概览\n     * 不可变的好处\n     * string, stringbuffer and stringbuilder\n     * string.intern()\n   * 运算\n     * 参数传递\n     * float 与 double\n     * 隐式类型转换\n     * switch\n   * 继承\n     * 访问权限\n     * 抽象类与接口\n     * super\n     * 重写与重载\n   * object 通用方法\n     * 概览\n     * equals()\n     * hashcode()\n     * tostring()\n     * clone()\n   * 关键字\n     * final\n     * static\n   * 反射\n   * 异常\n   * 泛型\n   * 注解\n   * 特性\n     * java 各版本的新特性\n     * java 与 c++ 的区别\n     * jre or jdk\n   * 参考资料\n\n\n# 数据类型\n\n\n# 包装类型\n\n八个基本类型:\n\n * boolean/1\n * byte/8\n * char/16\n * short/16\n * int/32\n * float/32\n * long/64\n * double/64\n\n基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。\n\ninteger x = 2;     // 装箱\nint y = x;         // 拆箱\n\n\n\n# 缓存池\n\nnew integer(123) 与 integer.valueof(123) 的区别在于:\n\n * new integer(123) 每次都会新建一个对象\n * integer.valueof(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。\n\ninteger x = new integer(123);\ninteger y = new integer(123);\nsystem.out.println(x == y);    // false\ninteger z = integer.valueof(123);\ninteger k = integer.valueof(123);\nsystem.out.println(z == k);   // true\n\n\nvalueof() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。\n\npublic static integer valueof(int i) {\n    if (i >= integercache.low && i <= integercache.high)\n        return integercache.cache[i + (-integercache.low)];\n    return new integer(i);\n}\n\n\n在 java 8 中，integer 缓存池的大小默认为 -128~127。\n\nstatic final int low = -128;\nstatic final int high;\nstatic final integer cache[];\n\nstatic {\n    // high value may be configured by property\n    int h = 127;\n    string integercachehighpropvalue =\n        sun.misc.vm.getsavedproperty("java.lang.integer.integercache.high");\n    if (integercachehighpropvalue != null) {\n        try {\n            int i = parseint(integercachehighpropvalue);\n            i = math.max(i, 127);\n            // maximum array size is integer.max_value\n            h = math.min(i, integer.max_value - (-low) -1);\n        } catch( numberformatexception nfe) {\n            // if the property cannot be parsed into an int, ignore it.\n        }\n    }\n    high = h;\n\n    cache = new integer[(high - low) + 1];\n    int j = low;\n    for(int k = 0; k < cache.length; k++)\n        cache[k] = new integer(j++);\n\n    // range [-128, 127] must be interned (jls7 5.1.7)\n    assert integercache.high >= 127;\n}\n\n\n编译器会在缓冲池范围内的基本类型自动装箱过程调用 valueof() 方法，因此多个 integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。\n\ninteger m = 123;\ninteger n = 123;\nsystem.out.println(m == n); // true\n\n\n基本类型对应的缓冲池如下:\n\n * boolean values true and false\n * all byte values\n * short values between -128 and 127\n * int values between -128 and 127\n * char in the range \\u0000 to \\u007f\n\n在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。\n\n如果在缓冲池之外：\n\ninteger m = 323;\ninteger n = 323;\nsystem.out.println(m == n); // false\n\n\n\n# string\n\n\n# 概览\n\nstring 被声明为 final，因此它不可被继承。\n\n内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 string 内部没有改变 value 数组的方法，因此可以保证 string 不可变。\n\npublic final class string\n    implements java.io.serializable, comparable<string>, charsequence {\n    /** the value is used for character storage. */\n    private final char value[];\n\n\n\n# 不可变的好处\n\n1. 可以缓存 hash 值\n\n因为 string 的 hash 值经常被使用，例如 string 用做 hashmap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。\n\n2. string pool 的需要\n\n如果一个 string 对象已经被创建过了，那么就会从 string pool 中取得引用。只有 string 是不可变的，才可能使用 string pool。\n\n\n\n3. 安全性\n\nstring 经常作为参数，string 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 string 是可变的，那么在网络连接过程中，string 被改变，改变 string 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。\n\n4. 线程安全\n\nstring 不可变性天生具备线程安全，可以在多个线程中安全地使用。\n\nprogram creek : why string is immutable in java?在新窗口打开\n\n\n# string, stringbuffer and stringbuilder\n\n1. 可变性\n\n * string 不可变\n * stringbuffer 和 stringbuilder 可变\n\n2. 线程安全\n\n * string 不可变，因此是线程安全的\n * stringbuilder 不是线程安全的\n * stringbuffer 是线程安全的，内部使用 synchronized 进行同步\n\nstackoverflow : string, stringbuffer, and stringbuilder在新窗口打开\n\n\n# string.intern()\n\n使用 string.intern() 可以保证相同内容的字符串变量引用同一的内存对象。\n\n下面示例中，s1 和 s2 采用 new string() 的方式新建了两个不同对象，而 s3 是通过 s1.intern() 方法取得一个对象引用。intern() 首先把 s1 引用的对象放到 string pool(字符串常量池)中，然后返回这个对象引用。因此 s3 和 s1 引用的是同一个字符串常量池的对象。\n\nstring s1 = new string("aaa");\nstring s2 = new string("aaa");\nsystem.out.println(s1 == s2);           // false\nstring s3 = s1.intern();\nsystem.out.println(s1.intern() == s3);  // true\n\n\n如果是采用 "bbb" 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 string pool 中。\n\nstring s4 = "bbb";\nstring s5 = "bbb";\nsystem.out.println(s4 == s5);  // true\n\n\n * hotspot中字符串常量池保存哪里？永久代？方法区还是堆区？\n\n 1. 运行时常量池（runtime constant pool）是虚拟机规范中是方法区的一部分，在加载类和结构到虚拟机后，就会创建对应的运行时常量池；而字符串常量池是这个过程中常量字符串的存放位置。所以从这个角度，字符串常量池属于虚拟机规范中的方法区，它是一个逻辑上的概念；而堆区，永久代以及元空间是实际的存放位置。\n 2. 不同的虚拟机对虚拟机的规范（比如方法区）是不一样的，只有 hotspot 才有永久代的概念。\n 3. hotspot也是发展的，由于一些问题在新窗口打开的存在，hotspot考虑逐渐去永久代，对于不同版本的jdk，实际的存储位置是有差异的，具体看如下表格：\n\njdk版本       是否有永久代，字符串常量池放在哪里？                                方法区逻辑上规范，由哪些实际的部分实现的？\njdk1.6及之前   有永久代，运行时常量池（包括字符串常量池），静态变量存放在永久代上                 这个时期方法区在hotspot中是由永久代来实现的，以至于这个时期说方法区就是指永久代\njdk1.7      有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中；             这个时期方法区在hotspot中由永久代（类型信息、字段、方法、常量）和堆（字符串常量池、静态变量）共同实现\njdk1.8及之后   取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中   这个时期方法区在hotspot中由本地内存的元空间（类型信息、字段、方法、常量）和堆（字符串常量池、静态变量）共同实现\n\n\n# 运算\n\n\n# 参数传递\n\njava 的参数是以值传递的形式传入方法中，而不是引用传递。\n\n以下代码中 dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中改变指针引用的对象，那么这两个指针此时指向的是完全不同的对象，一方改变其所指向对象的内容对另一方没有影响。\n\npublic class dog {\n    string name;\n\n    dog(string name) {\n        this.name = name;\n    }\n\n    string getname() {\n        return this.name;\n    }\n\n    void setname(string name) {\n        this.name = name;\n    }\n\n    string getobjectaddress() {\n        return super.tostring();\n    }\n}\n\n\npublic class passbyvalueexample {\n    public static void main(string[] args) {\n        dog dog = new dog("a");\n        system.out.println(dog.getobjectaddress()); // dog@4554617c\n        func(dog);\n        system.out.println(dog.getobjectaddress()); // dog@4554617c\n        system.out.println(dog.getname());          // a\n    }\n\n    private static void func(dog dog) {\n        system.out.println(dog.getobjectaddress()); // dog@4554617c\n        dog = new dog("b");\n        system.out.println(dog.getobjectaddress()); // dog@74a14482\n        system.out.println(dog.getname());          // b\n    }\n}\n\n\n但是如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。\n\nclass passbyvalueexample {\n    public static void main(string[] args) {\n        dog dog = new dog("a");\n        func(dog);\n        system.out.println(dog.getname());          // b\n    }\n\n    private static void func(dog dog) {\n        dog.setname("b");\n    }\n}\n\n\nstackoverflow: is java “pass-by-reference” or “pass-by-value”?在新窗口打开\n\n\n# float 与 double\n\n1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。java 不能隐式执行向下转型，因为这会使得精度降低。\n\n1.1f 字面量才是 float 类型。\n\n\n# 隐式类型转换\n\n因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。\n\nshort s1 = 1;\n// s1 = s1 + 1;\n\n\n但是使用 += 运算符可以执行隐式类型转换。\n\n上面的语句相当于将 s1 + 1 的计算结果进行了向下转型:\n\nstackoverflow : why don\'t java\'s +=, -=, *=, /= compound assignment operators require casting?在新窗口打开\n\n\n# switch\n\n从 java 7 开始，可以在 switch 条件判断语句中使用 string 对象。\n\nstring s = "a";\nswitch (s) {\n    case "a":\n        system.out.println("aaa");\n        break;\n    case "b":\n        system.out.println("bbb");\n        break;\n}\n\n\nswitch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。\n\n// long x = 111;\n// switch (x) { // incompatible types. found: \'long\', required: \'char, byte, short, int, character, byte, short, integer, string, or an enum\'\n//     case 111:\n//         system.out.println(111);\n//         break;\n//     case 222:\n//         system.out.println(222);\n//         break;\n// }\n\n\nstackoverflow : why can\'t your switch statement data type be long, java?在新窗口打开\n\n\n# 继承\n\n\n# 访问权限\n\njava 中有三个访问权限修饰符: private、protected 以及 public，如果不加访问修饰符，表示包级可见。\n\n可以对类或类中的成员(字段以及方法)加上访问修饰符。\n\n * 类可见表示其它类可以用这个类创建实例对象。\n * 成员可见表示其它类可以用这个类的实例对象访问到该成员；\n\nprotected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。\n\n设计良好的模块会隐藏所有的实现细节，把它的 api 与它的实现清晰地隔离开来。模块之间只通过它们的 api 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。\n\n如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。\n\n字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，accessexample 拥有 id 共有字段，如果在某个时刻，我们想要使用 int 去存储 id 字段，那么就需要去修改所有的客户端代码。\n\npublic class accessexample {\n    public string id;\n}\n\n\n可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。\n\npublic class accessexample {\n\n    private int id;\n\n    public string getid() {\n        return id + "";\n    }\n\n    public void setid(string id) {\n        this.id = integer.valueof(id);\n    }\n}\n\n\n但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。\n\npublic class accesswithinnerclassexample {\n    private class innerclass {\n        int x;\n    }\n\n    private innerclass innerclass;\n\n    public accesswithinnerclassexample() {\n        innerclass = new innerclass();\n    }\n\n    public int getvalue() {\n        return innerclass.x;  // 直接访问\n    }\n}\n\n\n\n# 抽象类与接口\n\n1. 抽象类\n\n抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。\n\n抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。\n\npublic abstract class abstractclassexample {\n\n    protected int x;\n    private int y;\n\n    public abstract void func1();\n\n    public void func2() {\n        system.out.println("func2");\n    }\n}\n\n\npublic class abstractextendclassexample extends abstractclassexample {\n    @override\n    public void func1() {\n        system.out.println("func1");\n    }\n}\n\n\n// abstractclassexample ac1 = new abstractclassexample(); // \'abstractclassexample\' is abstract; cannot be instantiated\nabstractclassexample ac2 = new abstractextendclassexample();\nac2.func1();\n\n\n2. 接口\n\n接口是抽象类的延伸，在 java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。\n\n从 java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。\n\n接口的成员(字段 + 方法)默认都是 public 的，并且不允许定义为 private 或者 protected。\n\n接口的字段默认都是 static 和 final 的。\n\npublic interface interfaceexample {\n    void func1();\n\n    default void func2(){\n        system.out.println("func2");\n    }\n\n    int x = 123;\n    // int y;               // variable \'y\' might not have been initialized\n    public int z = 0;       // modifier \'public\' is redundant for interface fields\n    // private int k = 0;   // modifier \'private\' not allowed here\n    // protected int l = 0; // modifier \'protected\' not allowed here\n    // private void fun3(); // modifier \'private\' not allowed here\n}\n\n\npublic class interfaceimplementexample implements interfaceexample {\n    @override\n    public void func1() {\n        system.out.println("func1");\n    }\n}\n\n\n// interfaceexample ie1 = new interfaceexample(); // \'interfaceexample\' is abstract; cannot be instantiated\ninterfaceexample ie2 = new interfaceimplementexample();\nie2.func1();\nsystem.out.println(interfaceexample.x);\n\n\n3. 比较\n\n * 从设计层面上看，抽象类提供了一种 is-a 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 like-a 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 is-a 关系。\n * 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。\n * 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。\n * 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。\n\n4. 使用选择\n\n使用接口:\n\n * 需要让不相关的类都实现一个方法，例如不相关的类都可以实现 compareable 接口中的 compareto() 方法；\n * 需要使用多重继承。\n\n使用抽象类:\n\n * 需要在几个相关的类中共享代码。\n * 需要能控制继承来的成员的访问权限，而不是都为 public。\n * 需要继承非静态和非常量字段。\n\n在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。\n\n * 深入理解 abstract class 和 interface在新窗口打开\n * when to use abstract class and interface在新窗口打开\n\n\n# super\n\n * 访问父类的构造函数: 可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。\n * 访问父类的成员: 如果子类重写了父类的中某个方法的实现，可以通过使用 super 关键字来引用父类的方法实现。\n\npublic class superexample {\n    protected int x;\n    protected int y;\n\n    public superexample(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public void func() {\n        system.out.println("superexample.func()");\n    }\n}\n\n\npublic class superextendexample extends superexample {\n    private int z;\n\n    public superextendexample(int x, int y, int z) {\n        super(x, y);\n        this.z = z;\n    }\n\n    @override\n    public void func() {\n        super.func();\n        system.out.println("superextendexample.func()");\n    }\n}\n\n\nsuperexample e = new superextendexample(1, 2, 3);\ne.func();\n\n\nsuperexample.func()\nsuperextendexample.func()\n\n\nusing the keyword super在新窗口打开\n\n\n# 重写与重载\n\n1. 重写(override)\n\n存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。\n\n为了满足里式替换原则，重写有以下两个限制:\n\n * 子类方法的访问权限必须大于等于父类方法；\n * 子类方法的返回类型必须是父类方法返回类型或为其子类型。\n\n使用 @override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。\n\n2. 重载(overload)\n\n存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。\n\n应该注意的是，返回值不同，其它都相同不算是重载。\n\n\n# object 通用方法\n\n\n# 概览\n\npublic final native class<?> getclass()\n\npublic native int hashcode()\n\npublic boolean equals(object obj)\n\nprotected native object clone() throws clonenotsupportedexception\n\npublic string tostring()\n\npublic final native void notify()\n\npublic final native void notifyall()\n\npublic final native void wait(long timeout) throws interruptedexception\n\npublic final void wait(long timeout, int nanos) throws interruptedexception\n\npublic final void wait() throws interruptedexception\n\nprotected void finalize() throws throwable {}\n\n\n\n# equals()\n\n1. 等价关系\n\n(一)自反性\n\n(二)对称性\n\nx.equals(y) == y.equals(x); // true\n\n\n(三)传递性\n\nif (x.equals(y) && y.equals(z))\n    x.equals(z); // true;\n\n\n(四)一致性\n\n多次调用 equals() 方法结果不变\n\nx.equals(y) == x.equals(y); // true\n\n\n(五)与 null 的比较\n\n对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false\n\nx.equals(null); // false;\n\n\n2. equals() 与 ==\n\n * 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。\n * 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。\n\ninteger x = new integer(1);\ninteger y = new integer(1);\nsystem.out.println(x.equals(y)); // true\nsystem.out.println(x == y);      // false\n\n\n3. 实现\n\n * 检查是否为同一个对象的引用，如果是直接返回 true；\n * 检查是否是同一个类型，如果不是，直接返回 false；\n * 将 object 对象进行转型；\n * 判断每个关键域是否相等。\n\npublic class equalexample {\n    private int x;\n    private int y;\n    private int z;\n\n    public equalexample(int x, int y, int z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    @override\n    public boolean equals(object o) {\n        if (this == o) return true;\n        if (o == null || getclass() != o.getclass()) return false;\n\n        equalexample that = (equalexample) o;\n\n        if (x != that.x) return false;\n        if (y != that.y) return false;\n        return z == that.z;\n    }\n}\n\n\n\n# hashcode()\n\nhashcode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。\n\n在覆盖 equals() 方法时应当总是覆盖 hashcode() 方法，保证等价的两个对象散列值也相等。\n\n下面的代码中，新建了两个等价的对象，并将它们添加到 hashset 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 equalexample 没有实现 hascode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。\n\nequalexample e1 = new equalexample(1, 1, 1);\nequalexample e2 = new equalexample(1, 1, 1);\nsystem.out.println(e1.equals(e2)); // true\nhashset<equalexample> set = new hashset<>();\nset.add(e1);\nset.add(e2);\nsystem.out.println(set.size());   // 2\n\n\n理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来，可以将每个域都当成 r 进制的某一位，然后组成一个 r 进制的整数。r 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。\n\n一个数与 31 相乘可以转换成移位和减法: 31*x == (x<<5)-x，编译器会自动进行这个优化。\n\n@override\npublic int hashcode() {\n    int result = 17;\n    result = 31 * result + x;\n    result = 31 * result + y;\n    result = 31 * result + z;\n    return result;\n}\n\n\n\n# tostring()\n\n默认返回 tostringexample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。\n\npublic class tostringexample {\n    private int number;\n\n    public tostringexample(int number) {\n        this.number = number;\n    }\n}\n\n\ntostringexample example = new tostringexample(123);\nsystem.out.println(example.tostring());\n\n\n\n# clone()\n\n1. cloneable\n\nclone() 是 object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。\n\npublic class cloneexample {\n    private int a;\n    private int b;\n}\n\n\ncloneexample e1 = new cloneexample();\n// cloneexample e2 = e1.clone(); // \'clone()\' has protected access in \'java.lang.object\'\n\n\n重写 clone() 得到以下实现:\n\npublic class cloneexample {\n    private int a;\n    private int b;\n\n    @override\n    protected cloneexample clone() throws clonenotsupportedexception {\n        return (cloneexample)super.clone();\n    }\n}\n\n\ncloneexample e1 = new cloneexample();\ntry {\n    cloneexample e2 = e1.clone();\n} catch (clonenotsupportedexception e) {\n    e.printstacktrace();\n}\n\n\njava.lang.clonenotsupportedexception: cloneexample\n\n\n以上抛出了 clonenotsupportedexception，这是因为 cloneexample 没有实现 cloneable 接口。\n\n应该注意的是，clone() 方法并不是 cloneable 接口的方法，而是 object 的一个 protected 方法。cloneable 接口只是规定，如果一个类没有实现 cloneable 接口又调用了 clone() 方法，就会抛出 clonenotsupportedexception。\n\npublic class cloneexample implements cloneable {\n    private int a;\n    private int b;\n\n    @override\n    protected object clone() throws clonenotsupportedexception {\n        return super.clone();\n    }\n}\n\n\n2. 浅拷贝\n\n拷贝对象和原始对象的引用类型引用同一个对象。\n\npublic class shallowcloneexample implements cloneable {\n    private int[] arr;\n\n    public shallowcloneexample() {\n        arr = new int[10];\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = i;\n        }\n    }\n\n    public void set(int index, int value) {\n        arr[index] = value;\n    }\n\n    public int get(int index) {\n        return arr[index];\n    }\n\n    @override\n    protected shallowcloneexample clone() throws clonenotsupportedexception {\n        return (shallowcloneexample) super.clone();\n    }\n}\n\n\nshallowcloneexample e1 = new shallowcloneexample();\nshallowcloneexample e2 = null;\ntry {\n    e2 = e1.clone();\n} catch (clonenotsupportedexception e) {\n    e.printstacktrace();\n}\ne1.set(2, 222);\nsystem.out.println(e2.get(2)); // 222\n\n\n3. 深拷贝\n\n拷贝对象和原始对象的引用类型引用不同对象。\n\npublic class deepcloneexample implements cloneable {\n    private int[] arr;\n\n    public deepcloneexample() {\n        arr = new int[10];\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = i;\n        }\n    }\n\n    public void set(int index, int value) {\n        arr[index] = value;\n    }\n\n    public int get(int index) {\n        return arr[index];\n    }\n\n    @override\n    protected deepcloneexample clone() throws clonenotsupportedexception {\n        deepcloneexample result = (deepcloneexample) super.clone();\n        result.arr = new int[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            result.arr[i] = arr[i];\n        }\n        return result;\n    }\n}\n\n\ndeepcloneexample e1 = new deepcloneexample();\ndeepcloneexample e2 = null;\ntry {\n    e2 = e1.clone();\n} catch (clonenotsupportedexception e) {\n    e.printstacktrace();\n}\ne1.set(2, 222);\nsystem.out.println(e2.get(2)); // 2\n\n\n4. clone() 的替代方案\n\n使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。effective java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。\n\npublic class cloneconstructorexample {\n    private int[] arr;\n\n    public cloneconstructorexample() {\n        arr = new int[10];\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = i;\n        }\n    }\n\n    public cloneconstructorexample(cloneconstructorexample original) {\n        arr = new int[original.arr.length];\n        for (int i = 0; i < original.arr.length; i++) {\n            arr[i] = original.arr[i];\n        }\n    }\n\n    public void set(int index, int value) {\n        arr[index] = value;\n    }\n\n    public int get(int index) {\n        return arr[index];\n    }\n}\n\n\ncloneconstructorexample e1 = new cloneconstructorexample();\ncloneconstructorexample e2 = new cloneconstructorexample(e1);\ne1.set(2, 222);\nsystem.out.println(e2.get(2)); // 2\n\n\n\n# 关键字\n\n\n# final\n\n1. 数据\n\n声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。\n\n * 对于基本类型，final 使数值不变；\n * 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。\n\nfinal int x = 1;\n// x = 2;  // cannot assign value to final variable \'x\'\nfinal a y = new a();\ny.a = 1;\n\n\n2. 方法\n\n声明方法不能被子类重写。\n\nprivate 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。\n\n3. 类\n\n声明类不允许被继承。\n\n\n# static\n\n1. 静态变量\n\n * 静态变量: 又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它；静态变量在内存中只存在一份。\n * 实例变量: 每创建一个实例就会产生一个实例变量，它与该实例同生共死。\n\npublic class a {\n    private int x;         // 实例变量\n    private static int y;  // 静态变量\n\n    public static void main(string[] args) {\n        // int x = a.x;  // non-static field \'x\' cannot be referenced from a static context\n        a a = new a();\n        int x = a.x;\n        int y = a.y;\n    }\n}\n\n\n2. 静态方法\n\n静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法(abstract)。\n\npublic abstract class a {\n    public static void func1(){\n    }\n    // public abstract static void func2();  // illegal combination of modifiers: \'abstract\' and \'static\'\n}\n\n\n只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。\n\npublic class a {\n    private static int x;\n    private int y;\n\n    public static void func1(){\n        int a = x;\n        // int b = y;  // non-static field \'y\' cannot be referenced from a static context\n        // int b = this.y;     // \'a.this\' cannot be referenced from a static context\n    }\n}\n\n\n3. 静态语句块\n\n静态语句块在类初始化时运行一次。\n\npublic class a {\n    static {\n        system.out.println("123");\n    }\n\n    public static void main(string[] args) {\n        a a1 = new a();\n        a a2 = new a();\n    }\n}\n\n\n4. 静态内部类\n\n非静态内部类依赖于外部类的实例，而静态内部类不需要。\n\npublic class outerclass {\n    class innerclass {\n    }\n\n    static class staticinnerclass {\n    }\n\n    public static void main(string[] args) {\n        // innerclass innerclass = new innerclass(); // \'outerclass.this\' cannot be referenced from a static context\n        outerclass outerclass = new outerclass();\n        innerclass innerclass = outerclass.new innerclass();\n        staticinnerclass staticinnerclass = new staticinnerclass();\n    }\n}\n\n\n静态内部类不能访问外部类的非静态的变量和方法。\n\n5. 静态导包\n\n在使用静态变量和方法时不用再指明 classname，从而简化代码，但可读性大大降低。\n\nimport static com.xxx.classname.*\n\n\n6. 初始化顺序\n\n静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。\n\npublic static string staticfield = "静态变量";\n\n\nstatic {\n    system.out.println("静态语句块");\n}\n\n\npublic string field = "实例变量";\n\n\n{\n    system.out.println("普通语句块");\n}\n\n\n最后才是构造函数的初始化。\n\npublic initialordertest() {\n    system.out.println("构造函数");\n}\n\n\n存在继承的情况下，初始化顺序为:\n\n * 父类(静态变量、静态语句块)\n * 子类(静态变量、静态语句块)\n * 父类(实例变量、普通语句块)\n * 父类(构造函数)\n * 子类(实例变量、普通语句块)\n * 子类(构造函数)\n\n\n# 反射\n\n每个类都有一个 class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 class 对象。\n\n类加载相当于 class 对象的加载。类在第一次使用时才动态加载到 jvm 中，可以使用 class.forname("com.mysql.jdbc.driver") 这种方式来控制类的加载，该方法会返回一个 class 对象。\n\n反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。\n\nclass 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类:\n\n * field : 可以使用 get() 和 set() 方法读取和修改 field 对象关联的字段；\n * method : 可以使用 invoke() 方法调用与 method 对象关联的方法；\n * constructor : 可以用 constructor 创建新的对象。\n\nadvantages of using reflection:\n\n * extensibility features : an application may make use of external, user-defined classes by creating instances of extensibility objects using their fully-qualified names.\n * class browsers and visual development environments : a class browser needs to be able to enumerate the members of classes. visual development environments can benefit from making use of type information available in reflection to aid the developer in writing correct code.\n * debuggers and test tools : debuggers need to be able to examine private members on classes. test harnesses can make use of reflection to systematically call a discoverable set apis defined on a class, to insure a high level of code coverage in a test suite.\n\ndrawbacks of reflection:\n\nreflection is powerful, but should not be used indiscriminately. if it is possible to perform an operation without using reflection, then it is preferable to avoid using it. the following concerns should be kept in mind when accessing code via reflection.\n\n * performance overhead : because reflection involves types that are dynamically resolved, certain java virtual machine optimizations can not be performed. consequently, reflective operations have slower performance than their non-reflective counterparts, and should be avoided in sections of code which are called frequently in performance-sensitive applications.\n * security restrictions : reflection requires a runtime permission which may not be present when running under a security manager. this is in an important consideration for code which has to run in a restricted security context, such as in an applet.\n * exposure of internals :since reflection allows code to perform operations that would be illegal in non-reflective code, such as accessing private fields and methods, the use of reflection can result in unexpected side-effects, which may render code dysfunctional and may destroy portability. reflective code breaks abstractions and therefore may change behavior with upgrades of the platform.\n\n相关文章：java 基础 - 反射机制详解\n\n\n# 异常\n\nthrowable 可以用来表示任何可以作为异常抛出的类，分为两种: error 和 exception。其中 error 用来表示 jvm 无法处理的错误，exception 分为两种:\n\n * 受检异常 : 需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复；\n * 非受检异常 : 是程序运行时错误，例如除 0 会引发 arithmetic exception，此时程序崩溃并且无法恢复。\n\n\n\n相关文章：java 基础 - 异常机制详解\n\n\n# 泛型\n\npublic class box<t> {\n    // t stands for "type"\n    private t t;\n    public void set(t t) { this.t = t; }\n    public t get() { return t; }\n}\n\n\n相关文章：java 基础 - 泛型机制详解\n\n\n# 注解\n\njava 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。\n\n相关文章：java 基础 - 注解机制详解\n\n\n# 特性\n\n\n# java 各版本的新特性\n\nnew highlights in java se 8\n\n 1. lambda expressions\n 2. pipelines and streams\n 3. date and time api\n 4. default methods\n 5. type annotations\n 6. nashhorn javascript engine\n 7. concurrent accumulators\n 8. parallel operations\n 9. permgen error removed\n\nnew highlights in java se 7\n\n 1. strings in switch statement\n 2. type inference for generic instance creation\n 3. multiple exception handling\n 4. support for dynamic languages\n 5. try with resources\n 6. java nio package\n 7. binary literals, underscore in literals\n 8. diamond syntax\n\n * difference between java 1.8 and java 1.7?在新窗口打开\n * java 8 特性在新窗口打开\n\n\n# java 与 c++ 的区别\n\n * java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.object，c++ 为了兼容 c 即支持面向对象也支持面向过程。\n * java 通过虚拟机从而实现跨平台特性，但是 c++ 依赖于特定的平台。\n * java 没有指针，它的引用可以理解为安全指针，而 c++ 具有和 c 一样的指针。\n * java 支持自动垃圾回收，而 c++ 需要手动回收。\n * java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 c++ 支持多重继承。\n * java 不支持操作符重载，虽然可以对两个 string 对象支持加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 c++ 可以。\n * java 的 goto 是保留字，但是不可用，c++ 可以使用 goto。\n * java 不支持条件编译，c++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。\n\nwhat are the main differences between java and c++?在新窗口打开\n\n\n# jre or jdk\n\n * jre is the jvm program, java application need to run on jre.\n * jdk is a superset of jre, jre + tools for developing java programs. e.g, it provides the compiler "javac"\n\n\n# 参考资料\n\n * eckel b. java 编程思想[m]. 机械工业出版社, 2002.\n * bloch j. effective java[m]. addison-wesley professional, 2017.\n * 转载 https://www.pdai.tech/md/java/basic/java-basic-lan-basic.html',charsets:{cjk:!0}},{title:"Java 基础 - 异常机制详解",frontmatter:{},regularPath:"/java/basic/java-basic-x-exception.html",relativePath:"java/basic/java-basic-x-exception.md",key:"v-be2976b0",path:"/java/basic/java-basic-x-exception.html",headers:[{level:2,title:"Java 基础 - 异常机制详解",slug:"java-基础-异常机制详解",normalizedTitle:"java 基础 - 异常机制详解",charIndex:2},{level:2,title:"异常的层次结构",slug:"异常的层次结构",normalizedTitle:"异常的层次结构",charIndex:176},{level:3,title:"Throwable",slug:"throwable",normalizedTitle:"throwable",charIndex:191},{level:3,title:"Error（错误）",slug:"error-错误",normalizedTitle:"error（错误）",charIndex:208},{level:3,title:"Exception（异常）",slug:"exception-异常",normalizedTitle:"exception（异常）",charIndex:225},{level:3,title:"可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）",slug:"可查的异常-checked-exceptions-和不可查的异常-unchecked-exceptions",normalizedTitle:"可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）",charIndex:246},{level:2,title:"异常基础",slug:"异常基础",normalizedTitle:"异常基础",charIndex:306},{level:3,title:"异常关键字",slug:"异常关键字",normalizedTitle:"异常关键字",charIndex:318},{level:3,title:"异常的申明(throws)",slug:"异常的申明-throws",normalizedTitle:"异常的申明(throws)",charIndex:331},{level:3,title:"异常的抛出(throw)",slug:"异常的抛出-throw",normalizedTitle:"异常的抛出(throw)",charIndex:352},{level:3,title:"异常的自定义",slug:"异常的自定义",normalizedTitle:"异常的自定义",charIndex:372},{level:3,title:"异常的捕获",slug:"异常的捕获",normalizedTitle:"异常的捕获",charIndex:386},{level:3,title:"异常基础总结",slug:"异常基础总结",normalizedTitle:"异常基础总结",charIndex:493},{level:3,title:"常用的异常",slug:"常用的异常",normalizedTitle:"常用的异常",charIndex:507},{level:2,title:"异常实践",slug:"异常实践",normalizedTitle:"异常实践",charIndex:518},{level:3,title:"只针对不正常的情况才使用异常",slug:"只针对不正常的情况才使用异常",normalizedTitle:"只针对不正常的情况才使用异常",charIndex:530},{level:3,title:"在 finally 块中清理资源或者使用 try-with-resource 语句",slug:"在-finally-块中清理资源或者使用-try-with-resource-语句",normalizedTitle:"在 finally 块中清理资源或者使用 try-with-resource 语句",charIndex:552},{level:3,title:"尽量使用标准的异常",slug:"尽量使用标准的异常",normalizedTitle:"尽量使用标准的异常",charIndex:601},{level:3,title:"对异常进行文档说明",slug:"对异常进行文档说明",normalizedTitle:"对异常进行文档说明",charIndex:618},{level:3,title:"优先捕获最具体的异常",slug:"优先捕获最具体的异常",normalizedTitle:"优先捕获最具体的异常",charIndex:635},{level:3,title:"不要捕获 Throwable 类",slug:"不要捕获-throwable-类",normalizedTitle:"不要捕获 throwable 类",charIndex:653},{level:3,title:"不要忽略异常",slug:"不要忽略异常",normalizedTitle:"不要忽略异常",charIndex:677},{level:3,title:"不要记录并抛出异常",slug:"不要记录并抛出异常",normalizedTitle:"不要记录并抛出异常",charIndex:691},{level:3,title:"包装异常时不要抛弃原始的异常",slug:"包装异常时不要抛弃原始的异常",normalizedTitle:"包装异常时不要抛弃原始的异常",charIndex:708},{level:3,title:"不要使用异常控制程序的流程",slug:"不要使用异常控制程序的流程",normalizedTitle:"不要使用异常控制程序的流程",charIndex:730},{level:3,title:"不要在finally块中使用return。",slug:"不要在finally块中使用return。",normalizedTitle:"不要在finally块中使用return。",charIndex:751},{level:2,title:"深入理解异常",slug:"深入理解异常",normalizedTitle:"深入理解异常",charIndex:778},{level:3,title:"JVM处理异常的机制？",slug:"jvm处理异常的机制",normalizedTitle:"jvm处理异常的机制？",charIndex:792},{level:3,title:"异常是否耗时？为什么会耗时？",slug:"异常是否耗时-为什么会耗时",normalizedTitle:"异常是否耗时？为什么会耗时？",charIndex:811},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:831}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java 基础 - 异常机制详解 异常的层次结构 Throwable Error（错误） Exception（异常） 可查的异常（checked exceptions）和不可查的异常（unchecked exceptions） 异常基础 异常关键字 异常的申明(throws) 异常的抛出(throw) 异常的自定义 异常的捕获 异常基础总结 常用的异常 异常实践 只针对不正常的情况才使用异常 在 finally 块中清理资源或者使用 try-with-resource 语句 尽量使用标准的异常 对异常进行文档说明 优先捕获最具体的异常 不要捕获 Throwable 类 不要忽略异常 不要记录并抛出异常 包装异常时不要抛弃原始的异常 不要使用异常控制程序的流程 不要在finally块中使用return。 深入理解异常 JVM处理异常的机制？ 异常是否耗时？为什么会耗时？ 参考文章",content:'# Java 基础 - 异常机制详解\n\n> Java异常是Java提供的一种识别及响应错误的一致性机制，java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。本文综合多篇文章后，总结了Java 异常的相关知识，希望可以提升你对Java中异常的认知效率。\n\n * Java 基础 - 异常机制详解\n   * 异常的层次结构\n     * Throwable\n     * Error（错误）\n     * Exception（异常）\n     * 可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）\n   * 异常基础\n     * 异常关键字\n     * 异常的申明(throws)\n     * 异常的抛出(throw)\n     * 异常的自定义\n     * 异常的捕获\n       * try-catch\n       * try-catch-finally\n       * try-finally\n       * try-with-resource\n     * 异常基础总结\n     * 常用的异常\n   * 异常实践\n     * 只针对不正常的情况才使用异常\n     * 在 finally 块中清理资源或者使用 try-with-resource 语句\n     * 尽量使用标准的异常\n     * 对异常进行文档说明\n     * 优先捕获最具体的异常\n     * 不要捕获 Throwable 类\n     * 不要忽略异常\n     * 不要记录并抛出异常\n     * 包装异常时不要抛弃原始的异常\n     * 不要使用异常控制程序的流程\n     * 不要在finally块中使用return。\n   * 深入理解异常\n     * JVM处理异常的机制？\n     * 异常是否耗时？为什么会耗时？\n   * 参考文章\n\n\n# 异常的层次结构\n\n异常指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。Java通 过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的 错误条件。当条件生成时，错误将引发异常。\n\nJava异常类层次结构图：\n\n\n\n\n# Throwable\n\nThrowable 是 Java 语言中所有错误与异常的超类。\n\nThrowable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。\n\nThrowable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。\n\n\n# Error（错误）\n\nError 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。\n\n此类错误一般表示代码运行时 JVM 出现问题。通常有 Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。\n\n这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！\n\n\n# Exception（异常）\n\n程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。\n\n * 运行时异常\n\n都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。\n\n运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。\n\n * 非运行时异常 （编译异常）\n\n是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。\n\n\n# 可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）\n\n * 可查异常（编译器要求必须处置的异常）：\n\n正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。\n\n除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。\n\n * 不可查异常(编译器不要求强制处置的异常)\n\n包括运行时异常（RuntimeException与其子类）和错误（Error）。\n\n\n# 异常基础\n\n\n# 异常关键字\n\n * try – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。\n * catch – 用于捕获异常。catch用来捕获try语句块中发生的异常。\n * finally – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。\n * throw – 用于抛出异常。\n * throws – 用在方法签名中，用于声明该方法可能抛出的异常。\n\n\n# 异常的申明(throws)\n\n在Java中，当前执行的语句必属于某个方法，Java解释器调用main方法执行开始执行程序。若方法中存在检查异常，如果不对其捕获，那必须在方法头中显式声明该异常，以便于告知方法调用者此方法有异常，需要进行处理。 在方法中声明一个异常，方法头中使用关键字throws，后面接上要声明的异常。若声明多个异常，则使用逗号分割。如下所示：\n\npublic static void method() throws IOException, FileNotFoundException{\n    //something statements\n}\n\n\n注意：若是父类的方法没有声明异常，则子类继承方法后，也不能声明异常。\n\n通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。\n\nprivate static void readFile(String filePath) throws IOException {\n    File file = new File(filePath);\n    String result;\n    BufferedReader reader = new BufferedReader(new FileReader(file));\n    while((result = reader.readLine())!=null) {\n        System.out.println(result);\n    }\n    reader.close();\n}\n\n\nThrows抛出异常的规则：\n\n * 如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。\n * 必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误\n * 仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。\n * 调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。\n\n\n# 异常的抛出(throw)\n\n如果代码可能会引发某种错误，可以创建一个合适的异常类实例并抛出它，这就是抛出异常。如下所示：\n\npublic static double method(int value) {\n    if(value == 0) {\n        throw new ArithmeticException("参数不能为0"); //抛出一个运行时异常\n    }\n    return 5.0 / value;\n}\n\n\n大部分情况下都不需要手动抛出异常，因为Java的大部分方法要么已经处理异常，要么已声明异常。所以一般都是捕获异常或者再往上抛。\n\n有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。\n\nprivate static void readFile(String filePath) throws MyException {    \n    try {\n        // code\n    } catch (IOException e) {\n        MyException ex = new MyException("read file failed.");\n        ex.initCause(e);\n        throw ex;\n    }\n}\n\n\n\n# 异常的自定义\n\n习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）, 比如上面用到的自定义MyException：\n\npublic class MyException extends Exception {\n    public MyException(){ }\n    public MyException(String msg){\n        super(msg);\n    }\n    // ...\n}\n\n\n\n# 异常的捕获\n\n异常捕获处理的方法通常有：\n\n * try-catch\n * try-catch-finally\n * try-finally\n * try-with-resource\n\n# try-catch\n\n在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理\n\nprivate static void readFile(String filePath) {\n    try {\n        // code\n    } catch (FileNotFoundException e) {\n        // handle FileNotFoundException\n    } catch (IOException e){\n        // handle IOException\n    }\n}\n\n\n同一个 catch 也可以捕获多种类型异常，用 | 隔开\n\nprivate static void readFile(String filePath) {\n    try {\n        // code\n    } catch (FileNotFoundException | UnknownHostException e) {\n        // handle FileNotFoundException or UnknownHostException\n    } catch (IOException e){\n        // handle IOException\n    }\n}\n\n\n# try-catch-finally\n\n * 常规语法\n\ntry {                        \n    //执行程序代码，可能会出现异常                 \n} catch(Exception e) {   \n    //捕获异常并处理   \n} finally {\n    //必执行的代码\n}\n\n\n * 执行的顺序\n   * 当try没有捕获到异常时：try语句块中的语句逐一被执行，程序将跳过catch语句块，执行finally语句块和其后的语句；\n   * 当try捕获到异常，catch语句块里没有处理此异常的情况：当try语句块里的某条语句出现异常时，而没有处理此异常的catch语句块时，此异常将会抛给JVM处理，finally语句块里的语句还是会被执行，但finally语句块后的语句不会被执行；\n   * 当try捕获到异常，catch语句块里有处理此异常的情况：在try语句块中是按照顺序来执行的，当执行到某一条语句出现异常时，程序将跳到catch语句块，并与catch语句块逐一匹配，找到与之对应的处理程序，其他的catch语句块将不会被执行，而try语句块中，出现异常之后的语句也不会被执行，catch语句块执行完后，执行finally语句块里的语句，最后执行finally语句块后的语句；\n\n\n\n * 一个完整的例子\n\nprivate static void readFile(String filePath) throws MyException {\n    File file = new File(filePath);\n    String result;\n    BufferedReader reader = null;\n    try {\n        reader = new BufferedReader(new FileReader(file));\n        while((result = reader.readLine())!=null) {\n            System.out.println(result);\n        }\n    } catch (IOException e) {\n        System.out.println("readFile method catch block.");\n        MyException ex = new MyException("read file failed.");\n        ex.initCause(e);\n        throw ex;\n    } finally {\n        System.out.println("readFile method finally block.");\n        if (null != reader) {\n            try {\n                reader.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n\n# try-finally\n\n> 可以直接用try-finally吗？ 可以。\n\ntry块中引起异常，异常代码之后的语句不再执行，直接执行finally语句。 try块没有引发异常，则执行完try块就执行finally语句。\n\ntry-finally可用在不需要捕获异常的代码，可以保证资源在使用后被关闭。例如IO流中执行完相应操作后，关闭相应资源；使用Lock对象保证线程同步，通过finally可以保证锁会被释放；数据库连接代码时，关闭连接操作等等。\n\n//以Lock加锁为例，演示try-finally\nReentrantLock lock = new ReentrantLock();\ntry {\n    //需要加锁的代码\n} finally {\n    lock.unlock(); //保证锁一定被释放\n}\n\n\nfinally遇见如下情况不会执行\n\n * 在前面的代码中用了System.exit()退出程序。\n * finally语句块中发生了异常。\n * 程序所在的线程死亡。\n * 关闭CPU。\n\n# try-with-resource\n\n> try-with-resource是Java 7中引入的，很容易被忽略。\n\n上面例子中，finally 中的 close 方法也可能抛出 IOException, 从而覆盖了原始异常。JAVA 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 AutoCloseable 接口的类。\n\n * 代码实现\n\nprivate  static void tryWithResourceTest(){\n    try (Scanner scanner = new Scanner(new FileInputStream("c:/abc"),"UTF-8")){\n        // code\n    } catch (IOException e){\n        // handle exception\n    }\n}\n\n\n * 看下Scanner\n\npublic final class Scanner implements Iterator<String>, Closeable {\n  // ...\n}\npublic interface Closeable extends AutoCloseable {\n    public void close() throws IOException;\n}\n\n\ntry 代码块退出时，会自动调用 scanner.close 方法，和把 scanner.close 方法放在 finally 代码块中不同的是，若 scanner.close 抛出异常，则会被抑制，抛出的仍然为原始异常。被抑制的异常会由 addSusppressed 方法添加到原来的异常，如果想要获取被抑制的异常列表，可以调用 getSuppressed 方法来获取。\n\n\n# 异常基础总结\n\n * try、catch和finally都不能单独使用，只能是try-catch、try-finally或者try-catch-finally。\n * try语句块监控代码，出现异常就停止执行下面的代码，然后将异常移交给catch语句块来处理。\n * finally语句块中的代码一定会被执行，常用于回收资源 。\n * throws：声明一个异常，告知方法调用者。\n * throw ：抛出一个异常，至于该异常被捕获还是继续抛出都与它无关。\n\nJava编程思想一书中，对异常的总结。\n\n * 在恰当的级别处理问题。（在知道该如何处理的情况下了捕获异常。）\n * 解决问题并且重新调用产生异常的方法。\n * 进行少许修补，然后绕过异常发生的地方继续执行。\n * 用别的数据进行计算，以代替方法预计会返回的值。\n * 把当前运行环境下能做的事尽量做完，然后把相同的异常重抛到更高层。\n * 把当前运行环境下能做的事尽量做完，然后把不同的异常抛到更高层。\n * 终止程序。\n * 进行简化（如果你的异常模式使问题变得太复杂，那么用起来会非常痛苦）。\n * 让类库和程序更安全。\n\n\n# 常用的异常\n\n在Java中提供了一些异常用来描述经常发生的错误，对于这些异常，有的需要程序员进行捕获处理或声明抛出，有的是由Java虚拟机自动进行捕获处理。Java中常见的异常类:\n\n * RuntimeException\n   \n   * java.lang.ArrayIndexOutOfBoundsException 数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。\n   * java.lang.ArithmeticException 算术条件异常。譬如：整数除零等。\n   * java.lang.NullPointerException 空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等\n   * java.lang.ClassNotFoundException 找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。\n   * java.lang.NegativeArraySizeException 数组长度为负异常\n   * java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常\n   * java.lang.SecurityException 安全性异常\n   * java.lang.IllegalArgumentException 非法参数异常\n\n * IOException\n   \n   * IOException：操作输入流和输出流时可能出现的异常。\n   * EOFException 文件已结束异常\n   * FileNotFoundException 文件未找到异常\n\n * 其他\n   \n   * ClassCastException 类型转换异常类\n   * ArrayStoreException 数组中包含不兼容的值抛出的异常\n   * SQLException 操作数据库异常类\n   * NoSuchFieldException 字段未找到异常\n   * NoSuchMethodException 方法未找到抛出的异常\n   * NumberFormatException 字符串转换为数字抛出的异常\n   * StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常\n   * IllegalAccessException 不允许访问某类异常\n   * InstantiationException 当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常\n\n\n# 异常实践\n\n提示\n\n在 Java 中处理异常并不是一个简单的事情。不仅仅初学者很难理解，即使一些有经验的开发者也需要花费很多时间来思考如何处理异常，包括需要处理哪些异常，怎样处理等等。这也是绝大多数开发团队都会制定一些规则来规范进行异常处理的原因。\n\n当你抛出或捕获异常的时候，有很多不同的情况需要考虑，而且大部分事情都是为了改善代码的可读性或者 API 的可用性。\n\n异常不仅仅是一个错误控制机制，也是一个通信媒介。因此，为了和同事更好的合作，一个团队必须要制定出一个最佳实践和规则，只有这样，团队成员才能理解这些通用概念，同时在工作中使用它。\n\n这里给出几个被很多团队使用的异常处理最佳实践。\n\n\n# 只针对不正常的情况才使用异常\n\n> 异常只应该被用于不正常的条件，它们永远不应该被用于正常的控制流。《阿里手册》中：【强制】Java 类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException等等。\n\n比如，在解析字符串形式的数字时，可能存在数字格式错误，不得通过catch Exception来实现\n\n * 代码1\n\nif (obj != null) {\n  //...\n}\n\n\n * 代码2\n\ntry { \n  obj.method(); \n} catch (NullPointerException e) {\n  //...\n}\n\n\n主要原因有三点：\n\n * 异常机制的设计初衷是用于不正常的情况，所以很少会会JVM实现试图对它们的性能进行优化。所以，创建、抛出和捕获异常的开销是很昂贵的。\n * 把代码放在try-catch中返回阻止了JVM实现本来可能要执行的某些特定的优化。\n * 对数组进行遍历的标准模式并不会导致冗余的检查，有些现代的JVM实现会将它们优化掉。\n\n\n# 在 finally 块中清理资源或者使用 try-with-resource 语句\n\n当使用类似InputStream这种需要使用后关闭的资源时，一个常见的错误就是在try块的最后关闭资源。\n\n * 错误示例\n\npublic void doNotCloseResourceInTry() {\n    FileInputStream inputStream = null;\n    try {\n        File file = new File("./tmp.txt");\n        inputStream = new FileInputStream(file);\n        // use the inputStream to read a file\n        // do NOT do this\n        inputStream.close();\n    } catch (FileNotFoundException e) {\n        log.error(e);\n    } catch (IOException e) {\n        log.error(e);\n    }\n}\n\n\n问题就是，只有没有异常抛出的时候，这段代码才可以正常工作。try 代码块内代码会正常执行，并且资源可以正常关闭。但是，使用 try 代码块是有原因的，一般调用一个或多个可能抛出异常的方法，而且，你自己也可能会抛出一个异常，这意味着代码可能不会执行到 try 代码块的最后部分。结果就是，你并没有关闭资源。\n\n所以，你应该把清理工作的代码放到 finally 里去，或者使用 try-with-resource 特性。\n\n * 方法一：使用 finally 代码块\n\n与前面几行 try 代码块不同，finally 代码块总是会被执行。不管 try 代码块成功执行之后还是你在 catch 代码块中处理完异常后都会执行。因此，你可以确保你清理了所有打开的资源。\n\npublic void closeResourceInFinally() {\n    FileInputStream inputStream = null;\n    try {\n        File file = new File("./tmp.txt");\n        inputStream = new FileInputStream(file);\n        // use the inputStream to read a file\n    } catch (FileNotFoundException e) {\n        log.error(e);\n    } finally {\n        if (inputStream != null) {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n                log.error(e);\n            }\n        }\n    }\n}\n\n\n * 方法二：Java 7 的 try-with-resource 语法\n\n如果你的资源实现了 AutoCloseable 接口，你可以使用这个语法。大多数的 Java 标准资源都继承了这个接口。当你在 try 子句中打开资源，资源会在 try 代码块执行后或异常处理后自动关闭。\n\npublic void automaticallyCloseResource() {\n    File file = new File("./tmp.txt");\n    try (FileInputStream inputStream = new FileInputStream(file);) {\n        // use the inputStream to read a file\n    } catch (FileNotFoundException e) {\n        log.error(e);\n    } catch (IOException e) {\n        log.error(e);\n    }\n}\n\n\n\n# 尽量使用标准的异常\n\n> 代码重用是值得提倡的，这是一条通用规则，异常也不例外。\n\n重用现有的异常有几个好处：\n\n * 它使得你的API更加易于学习和使用，因为它与程序员原来已经熟悉的习惯用法是一致的。\n * 对于用到这些API的程序而言，它们的可读性更好，因为它们不会充斥着程序员不熟悉的异常。\n * 异常类越少，意味着内存占用越小，并且转载这些类的时间开销也越小。\n\nJava标准异常中有几个是经常被使用的异常。如下表格：\n\n异常                                使用场合\nIllegalArgumentException          参数的值不合适\nIllegalStateException             参数的状态不合适\nNullPointerException              在null被禁止的情况下参数值为null\nIndexOutOfBoundsException         下标越界\nConcurrentModificationException   在禁止并发修改的情况下，对象检测到并发修改\nUnsupportedOperationException     对象不支持客户请求的方法\n\n虽然它们是Java平台库迄今为止最常被重用的异常，但是，在许可的条件下，其它的异常也可以被重用。例如，如果你要实现诸如复数或者矩阵之类的算术对象，那么重用ArithmeticException和NumberFormatException将是非常合适的。如果一个异常满足你的需要，则不要犹豫，使用就可以，不过你一定要确保抛出异常的条件与该异常的文档中描述的条件一致。这种重用必须建立在语义的基础上，而不是名字的基础上。\n\n最后，一定要清楚，选择重用哪一种异常并没有必须遵循的规则。例如，考虑纸牌对象的情形，假设有一个用于发牌操作的方法，它的参数(handSize)是发一手牌的纸牌张数。假设调用者在这个参数中传递的值大于整副牌的剩余张数。那么这种情形既可以被解释为IllegalArgumentException(handSize的值太大)，也可以被解释为IllegalStateException(相对客户的请求而言，纸牌对象的纸牌太少)。\n\n\n# 对异常进行文档说明\n\n> 当在方法上声明抛出异常时，也需要进行文档说明。目的是为了给调用者提供尽可能多的信息，从而可以更好地避免或处理异常。\n\n在 Javadoc 添加 @throws 声明，并且描述抛出异常的场景。\n\n/**\n* Method description\n* \n* @throws MyBusinessException - businuess exception description\n*/\npublic void doSomething(String input) throws MyBusinessException {\n   // ...\n}\n\n\n同时，在抛出MyBusinessException 异常时，需要尽可能精确地描述问题和相关信息，这样无论是打印到日志中还是在监控工具中，都能够更容易被人阅读，从而可以更好地定位具体错误信息、错误的严重程度等。\n\n\n# 优先捕获最具体的异常\n\n> 大多数 IDE 都可以帮助你实现这个最佳实践。当你尝试首先捕获较不具体的异常时，它们会报告无法访问的代码块。\n\n但问题在于，只有匹配异常的第一个 catch 块会被执行。 因此，如果首先捕获 IllegalArgumentException ，则永远不会到达应该处理更具体的 NumberFormatException 的 catch 块，因为它是 IllegalArgumentException 的子类。\n\n总是优先捕获最具体的异常类，并将不太具体的 catch 块添加到列表的末尾。\n\n你可以在下面的代码片断中看到这样一个 try-catch 语句的例子。 第一个 catch 块处理所有 NumberFormatException 异常，第二个处理所有非 NumberFormatException 异常的IllegalArgumentException 异常。\n\npublic void catchMostSpecificExceptionFirst() {\n    try {\n        doSomething("A message");\n    } catch (NumberFormatException e) {\n        log.error(e);\n    } catch (IllegalArgumentException e) {\n        log.error(e)\n    }\n}\n\n\n\n# 不要捕获 Throwable 类\n\n> Throwable 是所有异常和错误的超类。你可以在 catch 子句中使用它，但是你永远不应该这样做！\n\n如果在 catch 子句中使用 Throwable ，它不仅会捕获所有异常，也将捕获所有的错误。JVM 抛出错误，指出不应该由应用程序处理的严重问题。 典型的例子是 OutOfMemoryError 或者 StackOverflowError 。两者都是由应用程序控制之外的情况引起的，无法处理。\n\n所以，最好不要捕获 Throwable ，除非你确定自己处于一种特殊的情况下能够处理错误。\n\npublic void doNotCatchThrowable() {\n    try {\n        // do something\n    } catch (Throwable t) {\n        // don\'t do this!\n    }\n}\n\n\n\n# 不要忽略异常\n\n> 很多时候，开发者很有自信不会抛出异常，因此写了一个catch块，但是没有做任何处理或者记录日志。\n\npublic void doNotIgnoreExceptions() {\n    try {\n        // do something\n    } catch (NumberFormatException e) {\n        // this will never happen\n    }\n}\n\n\n但现实是经常会出现无法预料的异常，或者无法确定这里的代码未来是不是会改动(删除了阻止异常抛出的代码)，而此时由于异常被捕获，使得无法拿到足够的错误信息来定位问题。\n\n合理的做法是至少要记录异常的信息。\n\npublic void logAnException() {\n    try {\n        // do something\n    } catch (NumberFormatException e) {\n        log.error("This should never happen: " + e); // see this line\n    }\n}\n\n\n\n# 不要记录并抛出异常\n\n> 这可能是本文中最常被忽略的最佳实践。\n\n可以发现很多代码甚至类库中都会有捕获异常、记录日志并再次抛出的逻辑。如下：\n\ntry {\n    new Long("xyz");\n} catch (NumberFormatException e) {\n    log.error(e);\n    throw e;\n}\n\n\n这个处理逻辑看着是合理的。但这经常会给同一个异常输出多条日志。如下：\n\n17:44:28,945 ERROR TestExceptionHandling:65 - java.lang.NumberFormatException: For input string: "xyz"\nException in thread "main" java.lang.NumberFormatException: For input string: "xyz"\nat java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)\nat java.lang.Long.parseLong(Long.java:589)\nat java.lang.Long.(Long.java:965)\nat com.stackify.example.TestExceptionHandling.logAndThrowException(TestExceptionHandling.java:63)\nat com.stackify.example.TestExceptionHandling.main(TestExceptionHandling.java:58)\n\n\n如上所示，后面的日志也没有附加更有用的信息。如果想要提供更加有用的信息，那么可以将异常包装为自定义异常。\n\npublic void wrapException(String input) throws MyBusinessException {\n    try {\n        // do something\n    } catch (NumberFormatException e) {\n        throw new MyBusinessException("A message that describes the error.", e);\n    }\n}\n\n\n因此，仅仅当想要处理异常时才去捕获，否则只需要在方法签名中声明让调用者去处理。\n\n\n# 包装异常时不要抛弃原始的异常\n\n捕获标准异常并包装为自定义异常是一个很常见的做法。这样可以添加更为具体的异常信息并能够做针对的异常处理。 在你这样做时，请确保将原始异常设置为原因（注：参考下方代码 NumberFormatException e 中的原始异常 e ）。Exception 类提供了特殊的构造函数方法，它接受一个 Throwable 作为参数。否则，你将会丢失堆栈跟踪和原始异常的消息，这将会使分析导致异常的异常事件变得困难。\n\npublic void wrapException(String input) throws MyBusinessException {\n    try {\n        // do something\n    } catch (NumberFormatException e) {\n        throw new MyBusinessException("A message that describes the error.", e);\n    }\n}\n\n\n\n# 不要使用异常控制程序的流程\n\n不应该使用异常控制应用的执行流程，例如，本应该使用if语句进行条件判断的情况下，你却使用异常处理，这是非常不好的习惯，会严重影响应用的性能。\n\n\n# 不要在finally块中使用return。\n\ntry块中的return语句执行成功后，并不马上返回，而是继续执行finally块中的语句，如果此处存在return语句，则在此直接返回，无情丢弃掉try块中的返回点。\n\n如下是一个反例：\n\nprivate int x = 0;\npublic int checkReturn() {\n    try {\n        // x等于1，此处不返回\n        return ++x;\n    } finally {\n        // 返回的结果是2\n        return ++x;\n    }\n}\n\n\n\n# 深入理解异常\n\n\n# JVM处理异常的机制？\n\n提到JVM处理异常的机制，就需要提及Exception Table，以下称为异常表。我们暂且不急于介绍异常表，先看一个简单的 Java 处理异常的小例子。\n\npublic static void simpleTryCatch() {\n   try {\n       testNPE();\n   } catch (Exception e) {\n       e.printStackTrace();\n   }\n}\n\n\n上面的代码是一个很简单的例子，用来捕获处理一个潜在的空指针异常。\n\n当然如果只是看简简单单的代码，我们很难看出什么高深之处，更没有了今天文章要谈论的内容。\n\n所以这里我们需要借助一把神兵利器，它就是javap,一个用来拆解class文件的工具，和javac一样由JDK提供。\n\n然后我们使用javap来分析这段代码（需要先使用javac编译）\n\n//javap -c Main\n public static void simpleTryCatch();\n    Code:\n       0: invokestatic  #3                  // Method testNPE:()V\n       3: goto          11\n       6: astore_0\n       7: aload_0\n       8: invokevirtual #5                  // Method java/lang/Exception.printStackTrace:()V\n      11: return\n    Exception table:\n       from    to  target type\n           0     3     6   Class java/lang/Exception\n\n\n看到上面的代码，应该会有会心一笑，因为终于看到了Exception table，也就是我们要研究的异常表。\n\n异常表中包含了一个或多个异常处理者(Exception Handler)的信息，这些信息包含如下\n\n * from 可能发生异常的起始点\n * to 可能发生异常的结束点\n * target 上述from和to之前发生异常后的异常处理者的位置\n * type 异常处理者处理的异常的类信息\n\n那么异常表用在什么时候呢\n\n答案是异常发生的时候，当一个异常发生时\n\n * 1.JVM会在当前出现异常的方法中，查找异常表，是否有合适的处理者来处理\n * 2.如果当前方法异常表不为空，并且异常符合处理者的from和to节点，并且type也匹配，则JVM调用位于target的调用者来处理。\n * 3.如果上一条未找到合理的处理者，则继续查找异常表中的剩余条目\n * 4.如果当前方法的异常表无法处理，则向上查找（弹栈处理）刚刚调用该方法的调用处，并重复上面的操作。\n * 5.如果所有的栈帧被弹出，仍然没有处理，则抛给当前的Thread，Thread则会终止。\n * 6.如果当前Thread为最后一个非守护线程，且未处理异常，则会导致JVM终止运行。\n\n以上就是JVM处理异常的一些机制。\n\ntry catch -finally\n\n除了简单的try-catch外，我们还常常和finally做结合使用。比如这样的代码\n\npublic static void simpleTryCatchFinally() {\n   try {\n       testNPE();\n   } catch (Exception e) {\n       e.printStackTrace();\n   } finally {\n       System.out.println("Finally");\n   }\n}\n\n\n同样我们使用javap分析一下代码\n\npublic static void simpleTryCatchFinally();\n    Code:\n       0: invokestatic  #3                  // Method testNPE:()V\n       3: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;\n       6: ldc           #7                  // String Finally\n       8: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n      11: goto          41\n      14: astore_0\n      15: aload_0\n      16: invokevirtual #5                  // Method java/lang/Exception.printStackTrace:()V\n      19: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;\n      22: ldc           #7                  // String Finally\n      24: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n      27: goto          41\n      30: astore_1\n      31: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;\n      34: ldc           #7                  // String Finally\n      36: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n      39: aload_1\n      40: athrow\n      41: return\n    Exception table:\n       from    to  target type\n           0     3    14   Class java/lang/Exception\n           0     3    30   any\n          14    19    30   any\n\n\n和之前有所不同，这次异常表中，有三条数据，而我们仅仅捕获了一个Exception, 异常表的后两个item的type为any; 上面的三条异常表item的意思为:\n\n * 如果0到3之间，发生了Exception类型的异常，调用14位置的异常处理者。\n * 如果0到3之间，无论发生什么异常，都调用30位置的处理者\n * 如果14到19之间（即catch部分），不论发生什么异常，都调用30位置的处理者。\n\n再次分析上面的Java代码，finally里面的部分已经被提取到了try部分和catch部分。我们再次调一下代码来看一下\n\npublic static void simpleTryCatchFinally();\n    Code:\n      //try 部分提取finally代码，如果没有异常发生，则执行输出finally操作，直至goto到41位置，执行返回操作。  \n\n       0: invokestatic  #3                  // Method testNPE:()V\n       3: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;\n       6: ldc           #7                  // String Finally\n       8: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n      11: goto          41\n\n      //catch部分提取finally代码，如果没有异常发生，则执行输出finally操作，直至执行got到41位置，执行返回操作。\n      14: astore_0\n      15: aload_0\n      16: invokevirtual #5                  // Method java/lang/Exception.printStackTrace:()V\n      19: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;\n      22: ldc           #7                  // String Finally\n      24: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n      27: goto          41\n      //finally部分的代码如果被调用，有可能是try部分，也有可能是catch部分发生异常。\n      30: astore_1\n      31: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;\n      34: ldc           #7                  // String Finally\n      36: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n      39: aload_1\n      40: athrow     //如果异常没有被catch捕获，而是到了这里，执行完finally的语句后，仍然要把这个异常抛出去，传递给调用处。\n      41: return\n\n\nCatch先后顺序的问题\n\n我们在代码中的catch的顺序决定了异常处理者在异常表的位置，所以，越是具体的异常要先处理，否则就会出现下面的问题\n\nprivate static void misuseCatchException() {\n   try {\n       testNPE();\n   } catch (Throwable t) {\n       t.printStackTrace();\n   } catch (Exception e) { //error occurs during compilings with tips Exception Java.lang.Exception has already benn caught.\n       e.printStackTrace();\n   }\n}\n\n\n这段代码会导致编译失败，因为先捕获Throwable后捕获Exception，会导致后面的catch永远无法被执行。\n\nReturn 和finally的问题\n\n这算是我们扩展的一个相对比较极端的问题，就是类似这样的代码，既有return，又有finally，那么finally导致会不会执行\n\npublic static String tryCatchReturn() {\n   try {\n       testNPE();\n       return  "OK";\n   } catch (Exception e) {\n       return "ERROR";\n   } finally {\n       System.out.println("tryCatchReturn");\n   }\n}\n\n\n答案是finally会执行，那么还是使用上面的方法，我们来看一下为什么finally会执行。\n\npublic static java.lang.String tryCatchReturn();\n    Code:\n       0: invokestatic  #3                  // Method testNPE:()V\n       3: ldc           #6                  // String OK\n       5: astore_0\n       6: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;\n       9: ldc           #8                  // String tryCatchReturn\n      11: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n      14: aload_0\n      15: areturn       返回OK字符串，areturn意思为return a reference from a method\n      16: astore_0\n      17: ldc           #10                 // String ERROR\n      19: astore_1\n      20: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;\n      23: ldc           #8                  // String tryCatchReturn\n      25: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n      28: aload_1\n      29: areturn  //返回ERROR字符串\n      30: astore_2\n      31: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;\n      34: ldc           #8                  // String tryCatchReturn\n      36: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n      39: aload_2\n      40: athrow  如果catch有未处理的异常，抛出去。\n\n\n\n# 异常是否耗时？为什么会耗时？\n\n说用异常慢，首先来看看异常慢在哪里？有多慢？下面的测试用例简单的测试了建立对象、建立异常对象、抛出并接住异常对象三者的耗时对比：\n\npublic class ExceptionTest {  \n  \n    private int testTimes;  \n  \n    public ExceptionTest(int testTimes) {  \n        this.testTimes = testTimes;  \n    }  \n  \n    public void newObject() {  \n        long l = System.nanoTime();  \n        for (int i = 0; i < testTimes; i++) {  \n            new Object();  \n        }  \n        System.out.println("建立对象：" + (System.nanoTime() - l));  \n    }  \n  \n    public void newException() {  \n        long l = System.nanoTime();  \n        for (int i = 0; i < testTimes; i++) {  \n            new Exception();  \n        }  \n        System.out.println("建立异常对象：" + (System.nanoTime() - l));  \n    }  \n  \n    public void catchException() {  \n        long l = System.nanoTime();  \n        for (int i = 0; i < testTimes; i++) {  \n            try {  \n                throw new Exception();  \n            } catch (Exception e) {  \n            }  \n        }  \n        System.out.println("建立、抛出并接住异常对象：" + (System.nanoTime() - l));  \n    }  \n  \n    public static void main(String[] args) {  \n        ExceptionTest test = new ExceptionTest(10000);  \n        test.newObject();  \n        test.newException();  \n        test.catchException();  \n    }  \n}  \n\n\n运行结果：\n\n建立对象：575817  \n建立异常对象：9589080  \n建立、抛出并接住异常对象：47394475  \n\n\n建立一个异常对象，是建立一个普通Object耗时的约20倍（实际上差距会比这个数字更大一些，因为循环也占用了时间，追求精确的读者可以再测一下空循环的耗时然后在对比前减掉这部分），而抛出、接住一个异常对象，所花费时间大约是建立异常对象的4倍。\n\n那占用时间的“大头”：抛出、接住异常，系统到底做了什么事情？请参考这篇文章：\n\n * https://www.iteye.com/blog/icyfenix-857722\n\n\n# 参考文章\n\n * https://blog.csdn.net/MacWx/article/details/90204111\n * https://blog.csdn.net/hguisu/article/details/6155636\n * https://blog.csdn.net/ThinkWon/article/details/101681073\n * https://www.cnblogs.com/skywang12345/p/3544287.html\n * https://www.codercto.com/a/33350.html\n * 转载 https://www.pdai.tech/md/java/basic/java-basic-x-exception.html',normalizedContent:'# java 基础 - 异常机制详解\n\n> java异常是java提供的一种识别及响应错误的一致性机制，java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。本文综合多篇文章后，总结了java 异常的相关知识，希望可以提升你对java中异常的认知效率。\n\n * java 基础 - 异常机制详解\n   * 异常的层次结构\n     * throwable\n     * error（错误）\n     * exception（异常）\n     * 可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）\n   * 异常基础\n     * 异常关键字\n     * 异常的申明(throws)\n     * 异常的抛出(throw)\n     * 异常的自定义\n     * 异常的捕获\n       * try-catch\n       * try-catch-finally\n       * try-finally\n       * try-with-resource\n     * 异常基础总结\n     * 常用的异常\n   * 异常实践\n     * 只针对不正常的情况才使用异常\n     * 在 finally 块中清理资源或者使用 try-with-resource 语句\n     * 尽量使用标准的异常\n     * 对异常进行文档说明\n     * 优先捕获最具体的异常\n     * 不要捕获 throwable 类\n     * 不要忽略异常\n     * 不要记录并抛出异常\n     * 包装异常时不要抛弃原始的异常\n     * 不要使用异常控制程序的流程\n     * 不要在finally块中使用return。\n   * 深入理解异常\n     * jvm处理异常的机制？\n     * 异常是否耗时？为什么会耗时？\n   * 参考文章\n\n\n# 异常的层次结构\n\n异常指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。java通 过api中throwable类的众多子类描述各种不同的异常。因而，java异常都是对象，是throwable子类的实例，描述了出现在一段编码中的 错误条件。当条件生成时，错误将引发异常。\n\njava异常类层次结构图：\n\n\n\n\n# throwable\n\nthrowable 是 java 语言中所有错误与异常的超类。\n\nthrowable 包含两个子类：error（错误）和 exception（异常），它们通常用于指示发生了异常情况。\n\nthrowable 包含了其线程创建时线程执行堆栈的快照，它提供了 printstacktrace() 等接口用于获取堆栈跟踪数据等信息。\n\n\n# error（错误）\n\nerror 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。\n\n此类错误一般表示代码运行时 jvm 出现问题。通常有 virtual machineerror（虚拟机运行错误）、noclassdeffounderror（类定义错误）等。比如 outofmemoryerror：内存不足错误；stackoverflowerror：栈溢出错误。此类错误发生时，jvm 将终止线程。\n\n这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照java惯例，我们是不应该实现任何新的error子类的！\n\n\n# exception（异常）\n\n程序本身可以捕获并且可以处理的异常。exception 这种异常又分为两类：运行时异常和编译时异常。\n\n * 运行时异常\n\n都是runtimeexception类及其子类异常，如nullpointerexception(空指针异常)、indexoutofboundsexception(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。\n\n运行时异常的特点是java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。\n\n * 非运行时异常 （编译异常）\n\n是runtimeexception以外的异常，类型上都属于exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如ioexception、sqlexception等以及用户自定义的exception异常，一般情况下不自定义检查异常。\n\n\n# 可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）\n\n * 可查异常（编译器要求必须处置的异常）：\n\n正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。\n\n除了runtimeexception及其子类以外，其他的exception类及其子类都属于可查异常。这种异常的特点是java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。\n\n * 不可查异常(编译器不要求强制处置的异常)\n\n包括运行时异常（runtimeexception与其子类）和错误（error）。\n\n\n# 异常基础\n\n\n# 异常关键字\n\n * try – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。\n * catch – 用于捕获异常。catch用来捕获try语句块中发生的异常。\n * finally – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。\n * throw – 用于抛出异常。\n * throws – 用在方法签名中，用于声明该方法可能抛出的异常。\n\n\n# 异常的申明(throws)\n\n在java中，当前执行的语句必属于某个方法，java解释器调用main方法执行开始执行程序。若方法中存在检查异常，如果不对其捕获，那必须在方法头中显式声明该异常，以便于告知方法调用者此方法有异常，需要进行处理。 在方法中声明一个异常，方法头中使用关键字throws，后面接上要声明的异常。若声明多个异常，则使用逗号分割。如下所示：\n\npublic static void method() throws ioexception, filenotfoundexception{\n    //something statements\n}\n\n\n注意：若是父类的方法没有声明异常，则子类继承方法后，也不能声明异常。\n\n通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。\n\nprivate static void readfile(string filepath) throws ioexception {\n    file file = new file(filepath);\n    string result;\n    bufferedreader reader = new bufferedreader(new filereader(file));\n    while((result = reader.readline())!=null) {\n        system.out.println(result);\n    }\n    reader.close();\n}\n\n\nthrows抛出异常的规则：\n\n * 如果是不可查异常（unchecked exception），即error、runtimeexception或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。\n * 必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误\n * 仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。\n * 调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。\n\n\n# 异常的抛出(throw)\n\n如果代码可能会引发某种错误，可以创建一个合适的异常类实例并抛出它，这就是抛出异常。如下所示：\n\npublic static double method(int value) {\n    if(value == 0) {\n        throw new arithmeticexception("参数不能为0"); //抛出一个运行时异常\n    }\n    return 5.0 / value;\n}\n\n\n大部分情况下都不需要手动抛出异常，因为java的大部分方法要么已经处理异常，要么已声明异常。所以一般都是捕获异常或者再往上抛。\n\n有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。\n\nprivate static void readfile(string filepath) throws myexception {    \n    try {\n        // code\n    } catch (ioexception e) {\n        myexception ex = new myexception("read file failed.");\n        ex.initcause(e);\n        throw ex;\n    }\n}\n\n\n\n# 异常的自定义\n\n习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（throwable 的 tostring 方法会打印这些详细信息，调试时很有用）, 比如上面用到的自定义myexception：\n\npublic class myexception extends exception {\n    public myexception(){ }\n    public myexception(string msg){\n        super(msg);\n    }\n    // ...\n}\n\n\n\n# 异常的捕获\n\n异常捕获处理的方法通常有：\n\n * try-catch\n * try-catch-finally\n * try-finally\n * try-with-resource\n\n# try-catch\n\n在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理\n\nprivate static void readfile(string filepath) {\n    try {\n        // code\n    } catch (filenotfoundexception e) {\n        // handle filenotfoundexception\n    } catch (ioexception e){\n        // handle ioexception\n    }\n}\n\n\n同一个 catch 也可以捕获多种类型异常，用 | 隔开\n\nprivate static void readfile(string filepath) {\n    try {\n        // code\n    } catch (filenotfoundexception | unknownhostexception e) {\n        // handle filenotfoundexception or unknownhostexception\n    } catch (ioexception e){\n        // handle ioexception\n    }\n}\n\n\n# try-catch-finally\n\n * 常规语法\n\ntry {                        \n    //执行程序代码，可能会出现异常                 \n} catch(exception e) {   \n    //捕获异常并处理   \n} finally {\n    //必执行的代码\n}\n\n\n * 执行的顺序\n   * 当try没有捕获到异常时：try语句块中的语句逐一被执行，程序将跳过catch语句块，执行finally语句块和其后的语句；\n   * 当try捕获到异常，catch语句块里没有处理此异常的情况：当try语句块里的某条语句出现异常时，而没有处理此异常的catch语句块时，此异常将会抛给jvm处理，finally语句块里的语句还是会被执行，但finally语句块后的语句不会被执行；\n   * 当try捕获到异常，catch语句块里有处理此异常的情况：在try语句块中是按照顺序来执行的，当执行到某一条语句出现异常时，程序将跳到catch语句块，并与catch语句块逐一匹配，找到与之对应的处理程序，其他的catch语句块将不会被执行，而try语句块中，出现异常之后的语句也不会被执行，catch语句块执行完后，执行finally语句块里的语句，最后执行finally语句块后的语句；\n\n\n\n * 一个完整的例子\n\nprivate static void readfile(string filepath) throws myexception {\n    file file = new file(filepath);\n    string result;\n    bufferedreader reader = null;\n    try {\n        reader = new bufferedreader(new filereader(file));\n        while((result = reader.readline())!=null) {\n            system.out.println(result);\n        }\n    } catch (ioexception e) {\n        system.out.println("readfile method catch block.");\n        myexception ex = new myexception("read file failed.");\n        ex.initcause(e);\n        throw ex;\n    } finally {\n        system.out.println("readfile method finally block.");\n        if (null != reader) {\n            try {\n                reader.close();\n            } catch (ioexception e) {\n                e.printstacktrace();\n            }\n        }\n    }\n}\n\n\n# try-finally\n\n> 可以直接用try-finally吗？ 可以。\n\ntry块中引起异常，异常代码之后的语句不再执行，直接执行finally语句。 try块没有引发异常，则执行完try块就执行finally语句。\n\ntry-finally可用在不需要捕获异常的代码，可以保证资源在使用后被关闭。例如io流中执行完相应操作后，关闭相应资源；使用lock对象保证线程同步，通过finally可以保证锁会被释放；数据库连接代码时，关闭连接操作等等。\n\n//以lock加锁为例，演示try-finally\nreentrantlock lock = new reentrantlock();\ntry {\n    //需要加锁的代码\n} finally {\n    lock.unlock(); //保证锁一定被释放\n}\n\n\nfinally遇见如下情况不会执行\n\n * 在前面的代码中用了system.exit()退出程序。\n * finally语句块中发生了异常。\n * 程序所在的线程死亡。\n * 关闭cpu。\n\n# try-with-resource\n\n> try-with-resource是java 7中引入的，很容易被忽略。\n\n上面例子中，finally 中的 close 方法也可能抛出 ioexception, 从而覆盖了原始异常。java 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 autocloseable 接口的类。\n\n * 代码实现\n\nprivate  static void trywithresourcetest(){\n    try (scanner scanner = new scanner(new fileinputstream("c:/abc"),"utf-8")){\n        // code\n    } catch (ioexception e){\n        // handle exception\n    }\n}\n\n\n * 看下scanner\n\npublic final class scanner implements iterator<string>, closeable {\n  // ...\n}\npublic interface closeable extends autocloseable {\n    public void close() throws ioexception;\n}\n\n\ntry 代码块退出时，会自动调用 scanner.close 方法，和把 scanner.close 方法放在 finally 代码块中不同的是，若 scanner.close 抛出异常，则会被抑制，抛出的仍然为原始异常。被抑制的异常会由 addsusppressed 方法添加到原来的异常，如果想要获取被抑制的异常列表，可以调用 getsuppressed 方法来获取。\n\n\n# 异常基础总结\n\n * try、catch和finally都不能单独使用，只能是try-catch、try-finally或者try-catch-finally。\n * try语句块监控代码，出现异常就停止执行下面的代码，然后将异常移交给catch语句块来处理。\n * finally语句块中的代码一定会被执行，常用于回收资源 。\n * throws：声明一个异常，告知方法调用者。\n * throw ：抛出一个异常，至于该异常被捕获还是继续抛出都与它无关。\n\njava编程思想一书中，对异常的总结。\n\n * 在恰当的级别处理问题。（在知道该如何处理的情况下了捕获异常。）\n * 解决问题并且重新调用产生异常的方法。\n * 进行少许修补，然后绕过异常发生的地方继续执行。\n * 用别的数据进行计算，以代替方法预计会返回的值。\n * 把当前运行环境下能做的事尽量做完，然后把相同的异常重抛到更高层。\n * 把当前运行环境下能做的事尽量做完，然后把不同的异常抛到更高层。\n * 终止程序。\n * 进行简化（如果你的异常模式使问题变得太复杂，那么用起来会非常痛苦）。\n * 让类库和程序更安全。\n\n\n# 常用的异常\n\n在java中提供了一些异常用来描述经常发生的错误，对于这些异常，有的需要程序员进行捕获处理或声明抛出，有的是由java虚拟机自动进行捕获处理。java中常见的异常类:\n\n * runtimeexception\n   \n   * java.lang.arrayindexoutofboundsexception 数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。\n   * java.lang.arithmeticexception 算术条件异常。譬如：整数除零等。\n   * java.lang.nullpointerexception 空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等\n   * java.lang.classnotfoundexception 找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历classpah之后找不到对应名称的class文件时，抛出该异常。\n   * java.lang.negativearraysizeexception 数组长度为负异常\n   * java.lang.arraystoreexception 数组中包含不兼容的值抛出的异常\n   * java.lang.securityexception 安全性异常\n   * java.lang.illegalargumentexception 非法参数异常\n\n * ioexception\n   \n   * ioexception：操作输入流和输出流时可能出现的异常。\n   * eofexception 文件已结束异常\n   * filenotfoundexception 文件未找到异常\n\n * 其他\n   \n   * classcastexception 类型转换异常类\n   * arraystoreexception 数组中包含不兼容的值抛出的异常\n   * sqlexception 操作数据库异常类\n   * nosuchfieldexception 字段未找到异常\n   * nosuchmethodexception 方法未找到抛出的异常\n   * numberformatexception 字符串转换为数字抛出的异常\n   * stringindexoutofboundsexception 字符串索引超出范围抛出的异常\n   * illegalaccessexception 不允许访问某类异常\n   * instantiationexception 当应用程序试图使用class类中的newinstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常\n\n\n# 异常实践\n\n提示\n\n在 java 中处理异常并不是一个简单的事情。不仅仅初学者很难理解，即使一些有经验的开发者也需要花费很多时间来思考如何处理异常，包括需要处理哪些异常，怎样处理等等。这也是绝大多数开发团队都会制定一些规则来规范进行异常处理的原因。\n\n当你抛出或捕获异常的时候，有很多不同的情况需要考虑，而且大部分事情都是为了改善代码的可读性或者 api 的可用性。\n\n异常不仅仅是一个错误控制机制，也是一个通信媒介。因此，为了和同事更好的合作，一个团队必须要制定出一个最佳实践和规则，只有这样，团队成员才能理解这些通用概念，同时在工作中使用它。\n\n这里给出几个被很多团队使用的异常处理最佳实践。\n\n\n# 只针对不正常的情况才使用异常\n\n> 异常只应该被用于不正常的条件，它们永远不应该被用于正常的控制流。《阿里手册》中：【强制】java 类库中定义的可以通过预检查方式规避的runtimeexception异常不应该通过catch 的方式来处理，比如：nullpointerexception，indexoutofboundsexception等等。\n\n比如，在解析字符串形式的数字时，可能存在数字格式错误，不得通过catch exception来实现\n\n * 代码1\n\nif (obj != null) {\n  //...\n}\n\n\n * 代码2\n\ntry { \n  obj.method(); \n} catch (nullpointerexception e) {\n  //...\n}\n\n\n主要原因有三点：\n\n * 异常机制的设计初衷是用于不正常的情况，所以很少会会jvm实现试图对它们的性能进行优化。所以，创建、抛出和捕获异常的开销是很昂贵的。\n * 把代码放在try-catch中返回阻止了jvm实现本来可能要执行的某些特定的优化。\n * 对数组进行遍历的标准模式并不会导致冗余的检查，有些现代的jvm实现会将它们优化掉。\n\n\n# 在 finally 块中清理资源或者使用 try-with-resource 语句\n\n当使用类似inputstream这种需要使用后关闭的资源时，一个常见的错误就是在try块的最后关闭资源。\n\n * 错误示例\n\npublic void donotcloseresourceintry() {\n    fileinputstream inputstream = null;\n    try {\n        file file = new file("./tmp.txt");\n        inputstream = new fileinputstream(file);\n        // use the inputstream to read a file\n        // do not do this\n        inputstream.close();\n    } catch (filenotfoundexception e) {\n        log.error(e);\n    } catch (ioexception e) {\n        log.error(e);\n    }\n}\n\n\n问题就是，只有没有异常抛出的时候，这段代码才可以正常工作。try 代码块内代码会正常执行，并且资源可以正常关闭。但是，使用 try 代码块是有原因的，一般调用一个或多个可能抛出异常的方法，而且，你自己也可能会抛出一个异常，这意味着代码可能不会执行到 try 代码块的最后部分。结果就是，你并没有关闭资源。\n\n所以，你应该把清理工作的代码放到 finally 里去，或者使用 try-with-resource 特性。\n\n * 方法一：使用 finally 代码块\n\n与前面几行 try 代码块不同，finally 代码块总是会被执行。不管 try 代码块成功执行之后还是你在 catch 代码块中处理完异常后都会执行。因此，你可以确保你清理了所有打开的资源。\n\npublic void closeresourceinfinally() {\n    fileinputstream inputstream = null;\n    try {\n        file file = new file("./tmp.txt");\n        inputstream = new fileinputstream(file);\n        // use the inputstream to read a file\n    } catch (filenotfoundexception e) {\n        log.error(e);\n    } finally {\n        if (inputstream != null) {\n            try {\n                inputstream.close();\n            } catch (ioexception e) {\n                log.error(e);\n            }\n        }\n    }\n}\n\n\n * 方法二：java 7 的 try-with-resource 语法\n\n如果你的资源实现了 autocloseable 接口，你可以使用这个语法。大多数的 java 标准资源都继承了这个接口。当你在 try 子句中打开资源，资源会在 try 代码块执行后或异常处理后自动关闭。\n\npublic void automaticallycloseresource() {\n    file file = new file("./tmp.txt");\n    try (fileinputstream inputstream = new fileinputstream(file);) {\n        // use the inputstream to read a file\n    } catch (filenotfoundexception e) {\n        log.error(e);\n    } catch (ioexception e) {\n        log.error(e);\n    }\n}\n\n\n\n# 尽量使用标准的异常\n\n> 代码重用是值得提倡的，这是一条通用规则，异常也不例外。\n\n重用现有的异常有几个好处：\n\n * 它使得你的api更加易于学习和使用，因为它与程序员原来已经熟悉的习惯用法是一致的。\n * 对于用到这些api的程序而言，它们的可读性更好，因为它们不会充斥着程序员不熟悉的异常。\n * 异常类越少，意味着内存占用越小，并且转载这些类的时间开销也越小。\n\njava标准异常中有几个是经常被使用的异常。如下表格：\n\n异常                                使用场合\nillegalargumentexception          参数的值不合适\nillegalstateexception             参数的状态不合适\nnullpointerexception              在null被禁止的情况下参数值为null\nindexoutofboundsexception         下标越界\nconcurrentmodificationexception   在禁止并发修改的情况下，对象检测到并发修改\nunsupportedoperationexception     对象不支持客户请求的方法\n\n虽然它们是java平台库迄今为止最常被重用的异常，但是，在许可的条件下，其它的异常也可以被重用。例如，如果你要实现诸如复数或者矩阵之类的算术对象，那么重用arithmeticexception和numberformatexception将是非常合适的。如果一个异常满足你的需要，则不要犹豫，使用就可以，不过你一定要确保抛出异常的条件与该异常的文档中描述的条件一致。这种重用必须建立在语义的基础上，而不是名字的基础上。\n\n最后，一定要清楚，选择重用哪一种异常并没有必须遵循的规则。例如，考虑纸牌对象的情形，假设有一个用于发牌操作的方法，它的参数(handsize)是发一手牌的纸牌张数。假设调用者在这个参数中传递的值大于整副牌的剩余张数。那么这种情形既可以被解释为illegalargumentexception(handsize的值太大)，也可以被解释为illegalstateexception(相对客户的请求而言，纸牌对象的纸牌太少)。\n\n\n# 对异常进行文档说明\n\n> 当在方法上声明抛出异常时，也需要进行文档说明。目的是为了给调用者提供尽可能多的信息，从而可以更好地避免或处理异常。\n\n在 javadoc 添加 @throws 声明，并且描述抛出异常的场景。\n\n/**\n* method description\n* \n* @throws mybusinessexception - businuess exception description\n*/\npublic void dosomething(string input) throws mybusinessexception {\n   // ...\n}\n\n\n同时，在抛出mybusinessexception 异常时，需要尽可能精确地描述问题和相关信息，这样无论是打印到日志中还是在监控工具中，都能够更容易被人阅读，从而可以更好地定位具体错误信息、错误的严重程度等。\n\n\n# 优先捕获最具体的异常\n\n> 大多数 ide 都可以帮助你实现这个最佳实践。当你尝试首先捕获较不具体的异常时，它们会报告无法访问的代码块。\n\n但问题在于，只有匹配异常的第一个 catch 块会被执行。 因此，如果首先捕获 illegalargumentexception ，则永远不会到达应该处理更具体的 numberformatexception 的 catch 块，因为它是 illegalargumentexception 的子类。\n\n总是优先捕获最具体的异常类，并将不太具体的 catch 块添加到列表的末尾。\n\n你可以在下面的代码片断中看到这样一个 try-catch 语句的例子。 第一个 catch 块处理所有 numberformatexception 异常，第二个处理所有非 numberformatexception 异常的illegalargumentexception 异常。\n\npublic void catchmostspecificexceptionfirst() {\n    try {\n        dosomething("a message");\n    } catch (numberformatexception e) {\n        log.error(e);\n    } catch (illegalargumentexception e) {\n        log.error(e)\n    }\n}\n\n\n\n# 不要捕获 throwable 类\n\n> throwable 是所有异常和错误的超类。你可以在 catch 子句中使用它，但是你永远不应该这样做！\n\n如果在 catch 子句中使用 throwable ，它不仅会捕获所有异常，也将捕获所有的错误。jvm 抛出错误，指出不应该由应用程序处理的严重问题。 典型的例子是 outofmemoryerror 或者 stackoverflowerror 。两者都是由应用程序控制之外的情况引起的，无法处理。\n\n所以，最好不要捕获 throwable ，除非你确定自己处于一种特殊的情况下能够处理错误。\n\npublic void donotcatchthrowable() {\n    try {\n        // do something\n    } catch (throwable t) {\n        // don\'t do this!\n    }\n}\n\n\n\n# 不要忽略异常\n\n> 很多时候，开发者很有自信不会抛出异常，因此写了一个catch块，但是没有做任何处理或者记录日志。\n\npublic void donotignoreexceptions() {\n    try {\n        // do something\n    } catch (numberformatexception e) {\n        // this will never happen\n    }\n}\n\n\n但现实是经常会出现无法预料的异常，或者无法确定这里的代码未来是不是会改动(删除了阻止异常抛出的代码)，而此时由于异常被捕获，使得无法拿到足够的错误信息来定位问题。\n\n合理的做法是至少要记录异常的信息。\n\npublic void loganexception() {\n    try {\n        // do something\n    } catch (numberformatexception e) {\n        log.error("this should never happen: " + e); // see this line\n    }\n}\n\n\n\n# 不要记录并抛出异常\n\n> 这可能是本文中最常被忽略的最佳实践。\n\n可以发现很多代码甚至类库中都会有捕获异常、记录日志并再次抛出的逻辑。如下：\n\ntry {\n    new long("xyz");\n} catch (numberformatexception e) {\n    log.error(e);\n    throw e;\n}\n\n\n这个处理逻辑看着是合理的。但这经常会给同一个异常输出多条日志。如下：\n\n17:44:28,945 error testexceptionhandling:65 - java.lang.numberformatexception: for input string: "xyz"\nexception in thread "main" java.lang.numberformatexception: for input string: "xyz"\nat java.lang.numberformatexception.forinputstring(numberformatexception.java:65)\nat java.lang.long.parselong(long.java:589)\nat java.lang.long.(long.java:965)\nat com.stackify.example.testexceptionhandling.logandthrowexception(testexceptionhandling.java:63)\nat com.stackify.example.testexceptionhandling.main(testexceptionhandling.java:58)\n\n\n如上所示，后面的日志也没有附加更有用的信息。如果想要提供更加有用的信息，那么可以将异常包装为自定义异常。\n\npublic void wrapexception(string input) throws mybusinessexception {\n    try {\n        // do something\n    } catch (numberformatexception e) {\n        throw new mybusinessexception("a message that describes the error.", e);\n    }\n}\n\n\n因此，仅仅当想要处理异常时才去捕获，否则只需要在方法签名中声明让调用者去处理。\n\n\n# 包装异常时不要抛弃原始的异常\n\n捕获标准异常并包装为自定义异常是一个很常见的做法。这样可以添加更为具体的异常信息并能够做针对的异常处理。 在你这样做时，请确保将原始异常设置为原因（注：参考下方代码 numberformatexception e 中的原始异常 e ）。exception 类提供了特殊的构造函数方法，它接受一个 throwable 作为参数。否则，你将会丢失堆栈跟踪和原始异常的消息，这将会使分析导致异常的异常事件变得困难。\n\npublic void wrapexception(string input) throws mybusinessexception {\n    try {\n        // do something\n    } catch (numberformatexception e) {\n        throw new mybusinessexception("a message that describes the error.", e);\n    }\n}\n\n\n\n# 不要使用异常控制程序的流程\n\n不应该使用异常控制应用的执行流程，例如，本应该使用if语句进行条件判断的情况下，你却使用异常处理，这是非常不好的习惯，会严重影响应用的性能。\n\n\n# 不要在finally块中使用return。\n\ntry块中的return语句执行成功后，并不马上返回，而是继续执行finally块中的语句，如果此处存在return语句，则在此直接返回，无情丢弃掉try块中的返回点。\n\n如下是一个反例：\n\nprivate int x = 0;\npublic int checkreturn() {\n    try {\n        // x等于1，此处不返回\n        return ++x;\n    } finally {\n        // 返回的结果是2\n        return ++x;\n    }\n}\n\n\n\n# 深入理解异常\n\n\n# jvm处理异常的机制？\n\n提到jvm处理异常的机制，就需要提及exception table，以下称为异常表。我们暂且不急于介绍异常表，先看一个简单的 java 处理异常的小例子。\n\npublic static void simpletrycatch() {\n   try {\n       testnpe();\n   } catch (exception e) {\n       e.printstacktrace();\n   }\n}\n\n\n上面的代码是一个很简单的例子，用来捕获处理一个潜在的空指针异常。\n\n当然如果只是看简简单单的代码，我们很难看出什么高深之处，更没有了今天文章要谈论的内容。\n\n所以这里我们需要借助一把神兵利器，它就是javap,一个用来拆解class文件的工具，和javac一样由jdk提供。\n\n然后我们使用javap来分析这段代码（需要先使用javac编译）\n\n//javap -c main\n public static void simpletrycatch();\n    code:\n       0: invokestatic  #3                  // method testnpe:()v\n       3: goto          11\n       6: astore_0\n       7: aload_0\n       8: invokevirtual #5                  // method java/lang/exception.printstacktrace:()v\n      11: return\n    exception table:\n       from    to  target type\n           0     3     6   class java/lang/exception\n\n\n看到上面的代码，应该会有会心一笑，因为终于看到了exception table，也就是我们要研究的异常表。\n\n异常表中包含了一个或多个异常处理者(exception handler)的信息，这些信息包含如下\n\n * from 可能发生异常的起始点\n * to 可能发生异常的结束点\n * target 上述from和to之前发生异常后的异常处理者的位置\n * type 异常处理者处理的异常的类信息\n\n那么异常表用在什么时候呢\n\n答案是异常发生的时候，当一个异常发生时\n\n * 1.jvm会在当前出现异常的方法中，查找异常表，是否有合适的处理者来处理\n * 2.如果当前方法异常表不为空，并且异常符合处理者的from和to节点，并且type也匹配，则jvm调用位于target的调用者来处理。\n * 3.如果上一条未找到合理的处理者，则继续查找异常表中的剩余条目\n * 4.如果当前方法的异常表无法处理，则向上查找（弹栈处理）刚刚调用该方法的调用处，并重复上面的操作。\n * 5.如果所有的栈帧被弹出，仍然没有处理，则抛给当前的thread，thread则会终止。\n * 6.如果当前thread为最后一个非守护线程，且未处理异常，则会导致jvm终止运行。\n\n以上就是jvm处理异常的一些机制。\n\ntry catch -finally\n\n除了简单的try-catch外，我们还常常和finally做结合使用。比如这样的代码\n\npublic static void simpletrycatchfinally() {\n   try {\n       testnpe();\n   } catch (exception e) {\n       e.printstacktrace();\n   } finally {\n       system.out.println("finally");\n   }\n}\n\n\n同样我们使用javap分析一下代码\n\npublic static void simpletrycatchfinally();\n    code:\n       0: invokestatic  #3                  // method testnpe:()v\n       3: getstatic     #6                  // field java/lang/system.out:ljava/io/printstream;\n       6: ldc           #7                  // string finally\n       8: invokevirtual #8                  // method java/io/printstream.println:(ljava/lang/string;)v\n      11: goto          41\n      14: astore_0\n      15: aload_0\n      16: invokevirtual #5                  // method java/lang/exception.printstacktrace:()v\n      19: getstatic     #6                  // field java/lang/system.out:ljava/io/printstream;\n      22: ldc           #7                  // string finally\n      24: invokevirtual #8                  // method java/io/printstream.println:(ljava/lang/string;)v\n      27: goto          41\n      30: astore_1\n      31: getstatic     #6                  // field java/lang/system.out:ljava/io/printstream;\n      34: ldc           #7                  // string finally\n      36: invokevirtual #8                  // method java/io/printstream.println:(ljava/lang/string;)v\n      39: aload_1\n      40: athrow\n      41: return\n    exception table:\n       from    to  target type\n           0     3    14   class java/lang/exception\n           0     3    30   any\n          14    19    30   any\n\n\n和之前有所不同，这次异常表中，有三条数据，而我们仅仅捕获了一个exception, 异常表的后两个item的type为any; 上面的三条异常表item的意思为:\n\n * 如果0到3之间，发生了exception类型的异常，调用14位置的异常处理者。\n * 如果0到3之间，无论发生什么异常，都调用30位置的处理者\n * 如果14到19之间（即catch部分），不论发生什么异常，都调用30位置的处理者。\n\n再次分析上面的java代码，finally里面的部分已经被提取到了try部分和catch部分。我们再次调一下代码来看一下\n\npublic static void simpletrycatchfinally();\n    code:\n      //try 部分提取finally代码，如果没有异常发生，则执行输出finally操作，直至goto到41位置，执行返回操作。  \n\n       0: invokestatic  #3                  // method testnpe:()v\n       3: getstatic     #6                  // field java/lang/system.out:ljava/io/printstream;\n       6: ldc           #7                  // string finally\n       8: invokevirtual #8                  // method java/io/printstream.println:(ljava/lang/string;)v\n      11: goto          41\n\n      //catch部分提取finally代码，如果没有异常发生，则执行输出finally操作，直至执行got到41位置，执行返回操作。\n      14: astore_0\n      15: aload_0\n      16: invokevirtual #5                  // method java/lang/exception.printstacktrace:()v\n      19: getstatic     #6                  // field java/lang/system.out:ljava/io/printstream;\n      22: ldc           #7                  // string finally\n      24: invokevirtual #8                  // method java/io/printstream.println:(ljava/lang/string;)v\n      27: goto          41\n      //finally部分的代码如果被调用，有可能是try部分，也有可能是catch部分发生异常。\n      30: astore_1\n      31: getstatic     #6                  // field java/lang/system.out:ljava/io/printstream;\n      34: ldc           #7                  // string finally\n      36: invokevirtual #8                  // method java/io/printstream.println:(ljava/lang/string;)v\n      39: aload_1\n      40: athrow     //如果异常没有被catch捕获，而是到了这里，执行完finally的语句后，仍然要把这个异常抛出去，传递给调用处。\n      41: return\n\n\ncatch先后顺序的问题\n\n我们在代码中的catch的顺序决定了异常处理者在异常表的位置，所以，越是具体的异常要先处理，否则就会出现下面的问题\n\nprivate static void misusecatchexception() {\n   try {\n       testnpe();\n   } catch (throwable t) {\n       t.printstacktrace();\n   } catch (exception e) { //error occurs during compilings with tips exception java.lang.exception has already benn caught.\n       e.printstacktrace();\n   }\n}\n\n\n这段代码会导致编译失败，因为先捕获throwable后捕获exception，会导致后面的catch永远无法被执行。\n\nreturn 和finally的问题\n\n这算是我们扩展的一个相对比较极端的问题，就是类似这样的代码，既有return，又有finally，那么finally导致会不会执行\n\npublic static string trycatchreturn() {\n   try {\n       testnpe();\n       return  "ok";\n   } catch (exception e) {\n       return "error";\n   } finally {\n       system.out.println("trycatchreturn");\n   }\n}\n\n\n答案是finally会执行，那么还是使用上面的方法，我们来看一下为什么finally会执行。\n\npublic static java.lang.string trycatchreturn();\n    code:\n       0: invokestatic  #3                  // method testnpe:()v\n       3: ldc           #6                  // string ok\n       5: astore_0\n       6: getstatic     #7                  // field java/lang/system.out:ljava/io/printstream;\n       9: ldc           #8                  // string trycatchreturn\n      11: invokevirtual #9                  // method java/io/printstream.println:(ljava/lang/string;)v\n      14: aload_0\n      15: areturn       返回ok字符串，areturn意思为return a reference from a method\n      16: astore_0\n      17: ldc           #10                 // string error\n      19: astore_1\n      20: getstatic     #7                  // field java/lang/system.out:ljava/io/printstream;\n      23: ldc           #8                  // string trycatchreturn\n      25: invokevirtual #9                  // method java/io/printstream.println:(ljava/lang/string;)v\n      28: aload_1\n      29: areturn  //返回error字符串\n      30: astore_2\n      31: getstatic     #7                  // field java/lang/system.out:ljava/io/printstream;\n      34: ldc           #8                  // string trycatchreturn\n      36: invokevirtual #9                  // method java/io/printstream.println:(ljava/lang/string;)v\n      39: aload_2\n      40: athrow  如果catch有未处理的异常，抛出去。\n\n\n\n# 异常是否耗时？为什么会耗时？\n\n说用异常慢，首先来看看异常慢在哪里？有多慢？下面的测试用例简单的测试了建立对象、建立异常对象、抛出并接住异常对象三者的耗时对比：\n\npublic class exceptiontest {  \n  \n    private int testtimes;  \n  \n    public exceptiontest(int testtimes) {  \n        this.testtimes = testtimes;  \n    }  \n  \n    public void newobject() {  \n        long l = system.nanotime();  \n        for (int i = 0; i < testtimes; i++) {  \n            new object();  \n        }  \n        system.out.println("建立对象：" + (system.nanotime() - l));  \n    }  \n  \n    public void newexception() {  \n        long l = system.nanotime();  \n        for (int i = 0; i < testtimes; i++) {  \n            new exception();  \n        }  \n        system.out.println("建立异常对象：" + (system.nanotime() - l));  \n    }  \n  \n    public void catchexception() {  \n        long l = system.nanotime();  \n        for (int i = 0; i < testtimes; i++) {  \n            try {  \n                throw new exception();  \n            } catch (exception e) {  \n            }  \n        }  \n        system.out.println("建立、抛出并接住异常对象：" + (system.nanotime() - l));  \n    }  \n  \n    public static void main(string[] args) {  \n        exceptiontest test = new exceptiontest(10000);  \n        test.newobject();  \n        test.newexception();  \n        test.catchexception();  \n    }  \n}  \n\n\n运行结果：\n\n建立对象：575817  \n建立异常对象：9589080  \n建立、抛出并接住异常对象：47394475  \n\n\n建立一个异常对象，是建立一个普通object耗时的约20倍（实际上差距会比这个数字更大一些，因为循环也占用了时间，追求精确的读者可以再测一下空循环的耗时然后在对比前减掉这部分），而抛出、接住一个异常对象，所花费时间大约是建立异常对象的4倍。\n\n那占用时间的“大头”：抛出、接住异常，系统到底做了什么事情？请参考这篇文章：\n\n * https://www.iteye.com/blog/icyfenix-857722\n\n\n# 参考文章\n\n * https://blog.csdn.net/macwx/article/details/90204111\n * https://blog.csdn.net/hguisu/article/details/6155636\n * https://blog.csdn.net/thinkwon/article/details/101681073\n * https://www.cnblogs.com/skywang12345/p/3544287.html\n * https://www.codercto.com/a/33350.html\n * 转载 https://www.pdai.tech/md/java/basic/java-basic-x-exception.html',charsets:{cjk:!0}},{title:"Java 基础 - 泛型机制详解",frontmatter:{},regularPath:"/java/basic/java-basic-x-generic.html",relativePath:"java/basic/java-basic-x-generic.md",key:"v-cdde13b0",path:"/java/basic/java-basic-x-generic.html",headers:[{level:2,title:"Java 基础 - 泛型机制详解",slug:"java-基础-泛型机制详解",normalizedTitle:"java 基础 - 泛型机制详解",charIndex:2},{level:2,title:"为什么会引入泛型",slug:"为什么会引入泛型",normalizedTitle:"为什么会引入泛型",charIndex:252},{level:2,title:"泛型的基本使用",slug:"泛型的基本使用",normalizedTitle:"泛型的基本使用",charIndex:266},{level:3,title:"泛型类",slug:"泛型类",normalizedTitle:"泛型类",charIndex:281},{level:3,title:"泛型接口",slug:"泛型接口",normalizedTitle:"泛型接口",charIndex:292},{level:3,title:"泛型方法",slug:"泛型方法",normalizedTitle:"泛型方法",charIndex:304},{level:3,title:"泛型的上下限",slug:"泛型的上下限",normalizedTitle:"泛型的上下限",charIndex:316},{level:3,title:"泛型数组",slug:"泛型数组",normalizedTitle:"泛型数组",charIndex:330},{level:2,title:"深入理解泛型",slug:"深入理解泛型",normalizedTitle:"深入理解泛型",charIndex:340},{level:3,title:"如何理解Java中的泛型是伪泛型？泛型中类型擦除",slug:"如何理解java中的泛型是伪泛型-泛型中类型擦除",normalizedTitle:"如何理解java中的泛型是伪泛型？泛型中类型擦除",charIndex:354},{level:3,title:"如何证明类型的擦除呢？",slug:"如何证明类型的擦除呢",normalizedTitle:"如何证明类型的擦除呢？",charIndex:386},{level:3,title:"如何理解类型擦除后保留的原始类型?",slug:"如何理解类型擦除后保留的原始类型",normalizedTitle:"如何理解类型擦除后保留的原始类型?",charIndex:405},{level:3,title:"如何理解泛型的编译期检查？",slug:"如何理解泛型的编译期检查",normalizedTitle:"如何理解泛型的编译期检查？",charIndex:430},{level:3,title:"如何理解泛型的多态？泛型的桥接方法",slug:"如何理解泛型的多态-泛型的桥接方法",normalizedTitle:"如何理解泛型的多态？泛型的桥接方法",charIndex:451},{level:3,title:"如何理解基本类型不能作为泛型类型？",slug:"如何理解基本类型不能作为泛型类型",normalizedTitle:"如何理解基本类型不能作为泛型类型？",charIndex:476},{level:3,title:"如何理解泛型类型不能实例化？",slug:"如何理解泛型类型不能实例化",normalizedTitle:"如何理解泛型类型不能实例化？",charIndex:501},{level:3,title:"泛型数组：能不能采用具体的泛型类型进行初始化？",slug:"泛型数组-能不能采用具体的泛型类型进行初始化",normalizedTitle:"泛型数组：能不能采用具体的泛型类型进行初始化？",charIndex:523},{level:3,title:"泛型数组：如何正确的初始化泛型数组实例？",slug:"泛型数组-如何正确的初始化泛型数组实例",normalizedTitle:"泛型数组：如何正确的初始化泛型数组实例？",charIndex:554},{level:3,title:"如何理解泛型类中的静态方法和静态变量？",slug:"如何理解泛型类中的静态方法和静态变量",normalizedTitle:"如何理解泛型类中的静态方法和静态变量？",charIndex:582},{level:3,title:"如何理解异常中使用泛型？",slug:"如何理解异常中使用泛型",normalizedTitle:"如何理解异常中使用泛型？",charIndex:609},{level:3,title:"如何获取泛型的参数类型？",slug:"如何获取泛型的参数类型",normalizedTitle:"如何获取泛型的参数类型？",charIndex:629},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:647}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java 基础 - 泛型机制详解 为什么会引入泛型 泛型的基本使用 泛型类 泛型接口 泛型方法 泛型的上下限 泛型数组 深入理解泛型 如何理解Java中的泛型是伪泛型？泛型中类型擦除 如何证明类型的擦除呢？ 如何理解类型擦除后保留的原始类型? 如何理解泛型的编译期检查？ 如何理解泛型的多态？泛型的桥接方法 如何理解基本类型不能作为泛型类型？ 如何理解泛型类型不能实例化？ 泛型数组：能不能采用具体的泛型类型进行初始化？ 泛型数组：如何正确的初始化泛型数组实例？ 如何理解泛型类中的静态方法和静态变量？ 如何理解异常中使用泛型？ 如何获取泛型的参数类型？ 参考文章",content:'# Java 基础 - 泛型机制详解\n\n> Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。本文综合多篇文章后，总结了Java 泛型的相关知识，希望可以提升你对Java中泛型的认知效率。\n\n * Java 基础 - 泛型机制详解\n   * 为什么会引入泛型\n   * 泛型的基本使用\n     * 泛型类\n     * 泛型接口\n     * 泛型方法\n     * 泛型的上下限\n     * 泛型数组\n   * 深入理解泛型\n     * 如何理解Java中的泛型是伪泛型？泛型中类型擦除\n     * 如何证明类型的擦除呢？\n     * 如何理解类型擦除后保留的原始类型?\n     * 如何理解泛型的编译期检查？\n     * 如何理解泛型的多态？泛型的桥接方法\n     * 如何理解基本类型不能作为泛型类型？\n     * 如何理解泛型类型不能实例化？\n     * 泛型数组：能不能采用具体的泛型类型进行初始化？\n     * 泛型数组：如何正确的初始化泛型数组实例？\n     * 如何理解泛型类中的静态方法和静态变量？\n     * 如何理解异常中使用泛型？\n     * 如何获取泛型的参数类型？\n   * 参考文章\n\n\n# 为什么会引入泛型\n\n> 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。\n\n引入泛型的意义在于：\n\n * 适用于多种数据类型执行相同的代码（代码复用）\n\n我们通过一个例子来阐述，先看下下面的代码：\n\nprivate static int add(int a, int b) {\n    System.out.println(a + "+" + b + "=" + (a + b));\n    return a + b;\n}\n\nprivate static float add(float a, float b) {\n    System.out.println(a + "+" + b + "=" + (a + b));\n    return a + b;\n}\n\nprivate static double add(double a, double b) {\n    System.out.println(a + "+" + b + "=" + (a + b));\n    return a + b;\n}\n\n\n如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法；通过泛型，我们可以复用为一个方法：\n\nprivate static <T extends Number> double add(T a, T b) {\n    System.out.println(a + "+" + b + "=" + (a.doubleValue() + b.doubleValue()));\n    return a.doubleValue() + b.doubleValue();\n}\n\n\n * 泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）\n\n看下这个例子：\n\nList list = new ArrayList();\nlist.add("xxString");\nlist.add(100d);\nlist.add(new Person());\n\n\n我们在使用上述list中，list中的元素都是Object类型（无法约束其中的类型），所以在取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现java.lang.ClassCastException异常。\n\n引入泛型，它将提供类型的约束，提供编译前的检查：\n\nList<String> list = new ArrayList<String>();\n\n// list中只能放String, 不能放其它类型的元素\n\n\n\n# 泛型的基本使用\n\n提示\n\n我们通过一些例子来学习泛型的使用；泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法。一些例子可以参考《李兴华 - Java实战经典》。\n\n\n# 泛型类\n\n * 从一个简单的泛型类看起：\n\nclass Point<T>{         // 此处可以随便写标识符号，T是type的简称  \n    private T var ;     // var的类型由T指定，即：由外部指定  \n    public T getVar(){  // 返回值的类型由外部决定  \n        return var ;  \n    }  \n    public void setVar(T var){  // 设置的类型也由外部决定  \n        this.var = var ;  \n    }  \n}  \npublic class GenericsDemo06{  \n    public static void main(String args[]){  \n        Point<String> p = new Point<String>() ;     // 里面的var类型为String类型  \n        p.setVar("it") ;                            // 设置字符串  \n        System.out.println(p.getVar().length()) ;   // 取得字符串的长度  \n    }  \n}\n\n\n * 多元泛型\n\nclass Notepad<K,V>{       // 此处指定了两个泛型类型  \n    private K key ;     // 此变量的类型由外部决定  \n    private V value ;   // 此变量的类型由外部决定  \n    public K getKey(){  \n        return this.key ;  \n    }  \n    public V getValue(){  \n        return this.value ;  \n    }  \n    public void setKey(K key){  \n        this.key = key ;  \n    }  \n    public void setValue(V value){  \n        this.value = value ;  \n    }  \n} \npublic class GenericsDemo09{  \n    public static void main(String args[]){  \n        Notepad<String,Integer> t = null ;        // 定义两个泛型类型的对象  \n        t = new Notepad<String,Integer>() ;       // 里面的key为String，value为Integer  \n        t.setKey("汤姆") ;        // 设置第一个内容  \n        t.setValue(20) ;            // 设置第二个内容  \n        System.out.print("姓名；" + t.getKey()) ;      // 取得信息  \n        System.out.print("，年龄；" + t.getValue()) ;       // 取得信息  \n  \n    }  \n}\n\n\n\n# 泛型接口\n\n * 简单的泛型接口\n\ninterface Info<T>{        // 在接口上定义泛型  \n    public T getVar() ; // 定义抽象方法，抽象方法的返回值就是泛型类型  \n}  \nclass InfoImpl<T> implements Info<T>{   // 定义泛型接口的子类  \n    private T var ;             // 定义属性  \n    public InfoImpl(T var){     // 通过构造方法设置属性内容  \n        this.setVar(var) ;    \n    }  \n    public void setVar(T var){  \n        this.var = var ;  \n    }  \n    public T getVar(){  \n        return this.var ;  \n    }  \n} \npublic class GenericsDemo24{  \n    public static void main(String arsg[]){  \n        Info<String> i = null;        // 声明接口对象  \n        i = new InfoImpl<String>("汤姆") ;  // 通过子类实例化对象  \n        System.out.println("内容：" + i.getVar()) ;  \n    }  \n}  \n\n\n\n# 泛型方法\n\n泛型方法，是在调用方法的时候指明泛型的具体类型。重点看下泛型的方法（图参考自：https://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html）\n\n * 定义泛型方法语法格式\n\n\n\n * 调用泛型方法语法格式\n\n\n\n说明一下，定义泛型方法时，必须在返回值前边加一个<T>，来声明这是一个泛型方法，持有一个泛型T，然后才可以用泛型T作为方法的返回值。\n\nClass<T>的作用就是指明泛型的具体类型，而Class<T>类型的变量c，可以用来创建泛型类的对象。\n\n为什么要用变量c来创建对象呢？既然是泛型方法，就代表着我们不知道具体的类型是什么，也不知道构造方法如何，因此没有办法去new一个对象，但可以利用变量c的newInstance方法去创建对象，也就是利用反射创建对象。\n\n泛型方法要求的参数是Class<T>类型，而Class.forName()方法的返回值也是Class<T>，因此可以用Class.forName()作为参数。其中，forName()方法中的参数是何种类型，返回的Class<T>就是何种类型。在本例中，forName()方法中传入的是User类的完整路径，因此返回的是Class<User>类型的对象，因此调用泛型方法时，变量c的类型就是Class<User>，因此泛型方法中的泛型T就被指明为User，因此变量obj的类型为User。\n\n当然，泛型方法不是仅仅可以有一个参数Class<T>，可以根据需要添加其他参数。\n\n为什么要使用泛型方法呢？因为泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活。\n\n\n# 泛型的上下限\n\n * 先看下如下的代码，很明显是会报错的 （具体错误原因请参考后文）。\n\nclass A{}\nclass B extends A {}\n\n// 如下两个方法不会报错\npublic static void funA(A a) {\n    // ...          \n}\npublic static void funB(B b) {\n    funA(b);\n    // ...             \n}\n\n// 如下funD方法会报错\npublic static void funC(List<A> listA) {\n    // ...          \n}\npublic static void funD(List<B> listB) {\n    funC(listB); // Unresolved compilation problem: The method doPrint(List<A>) in the type test is not applicable for the arguments (List<B>)\n    // ...             \n}\n\n\n那么如何解决呢？\n\n为了解决泛型中隐含的转换问题，Java泛型加入了类型参数的上下边界机制。<? extends A>表示该类型参数可以是A(上边界)或者A的子类类型。编译时擦除到类型A，即用A类型代替类型参数。这种方法可以解决开始遇到的问题，编译器知道类型参数的范围，如果传入的实例类型B是在这个范围内的话允许转换，这时只要一次类型转换就可以了，运行时会把对象当做A的实例看待。\n\npublic static void funC(List<? extends A> listA) {\n    // ...          \n}\npublic static void funD(List<B> listB) {\n    funC(listB); // OK\n    // ...             \n}\n\n\n * 泛型上下限的引入\n\n在使用泛型的时候，我们可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。\n\n上限\n\nclass Info<T extends Number>{    // 此处泛型只能是数字类型\n    private T var ;        // 定义泛型变量\n    public void setVar(T var){\n        this.var = var ;\n    }\n    public T getVar(){\n        return this.var ;\n    }\n    public String toString(){    // 直接打印\n        return this.var.toString() ;\n    }\n}\npublic class demo1{\n    public static void main(String args[]){\n        Info<Integer> i1 = new Info<Integer>() ;        // 声明Integer的泛型对象\n    }\n}\n\n\n下限\n\nclass Info<T>{\n    private T var ;        // 定义泛型变量\n    public void setVar(T var){\n        this.var = var ;\n    }\n    public T getVar(){\n        return this.var ;\n    }\n    public String toString(){    // 直接打印\n        return this.var.toString() ;\n    }\n}\npublic class GenericsDemo21{\n    public static void main(String args[]){\n        Info<String> i1 = new Info<String>() ;        // 声明String的泛型对象\n        Info<Object> i2 = new Info<Object>() ;        // 声明Object的泛型对象\n        i1.setVar("hello") ;\n        i2.setVar(new Object()) ;\n        fun(i1) ;\n        fun(i2) ;\n    }\n    public static void fun(Info<? super String> temp){    // 只能接收String或Object类型的泛型，String类的父类只有Object类\n        System.out.print(temp + ", ") ;\n    }\n}\n\n\n小结\n\n<?> 无限制通配符\n<? extends E> extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类\n<? super E> super 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类\n\n// 使用原则《Effictive Java》\n// 为了获得最大限度的灵活性，要在表示 生产者或者消费者 的输入参数上使用通配符，使用的规则就是：生产者有上限、消费者有下限\n1. 如果参数化类型表示一个 T 的生产者，使用 < ? extends T>;\n2. 如果它表示一个 T 的消费者，就使用 < ? super T>；\n3. 如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。\n\n\n * 再看一个实际例子，加深印象\n\nprivate  <E extends Comparable<? super E>> E max(List<? extends E> e1) {\n    if (e1 == null){\n        return null;\n    }\n    //迭代器返回的元素属于 E 的某个子类型\n    Iterator<? extends E> iterator = e1.iterator();\n    E result = iterator.next();\n    while (iterator.hasNext()){\n        E next = iterator.next();\n        if (next.compareTo(result) > 0){\n            result = next;\n        }\n    }\n    return result;\n}\n\n\n上述代码中的类型参数 E 的范围是<E extends Comparable<? super E>>，我们可以分步查看：\n\n * 要进行比较，所以 E 需要是可比较的类，因此需要 extends Comparable<…>（注意这里不要和继承的 extends 搞混了，不一样）\n\n * Comparable< ? super E> 要对 E 进行比较，即 E 的消费者，所以需要用 super\n\n * 而参数 List< ? extends E> 表示要操作的数据是 E 的子类的列表，指定上限，这样容器才够大\n\n * 多个限制\n\n使用&符号\n\npublic class Client {\n    //工资低于2500元的上斑族并且站立的乘客车票打8折\n    public static <T extends Staff & Passenger> void discount(T t){\n        if(t.getSalary()<2500 && t.isStanding()){\n            System.out.println("恭喜你！您的车票打八折！");\n        }\n    }\n    public static void main(String[] args) {\n        discount(new Me());\n    }\n}\n\n\n\n# 泛型数组\n\n> 具体可以参考下文中关于泛型数组的理解。\n\n首先，我们泛型数组相关的申明：\n\nList<String>[] list11 = new ArrayList<String>[10]; //编译错误，非法创建 \nList<String>[] list12 = new ArrayList<?>[10]; //编译错误，需要强转类型 \nList<String>[] list13 = (List<String>[]) new ArrayList<?>[10]; //OK，但是会有警告 \nList<?>[] list14 = new ArrayList<String>[10]; //编译错误，非法创建 \nList<?>[] list15 = new ArrayList<?>[10]; //OK \nList<String>[] list6 = new ArrayList[10]; //OK，但是会有警告\n\n\n那么通常我们如何用呢？\n\n * 讨巧的使用场景\n\npublic class GenericsDemo30{  \n    public static void main(String args[]){  \n        Integer i[] = fun1(1,2,3,4,5,6) ;   // 返回泛型数组  \n        fun2(i) ;  \n    }  \n    public static <T> T[] fun1(T...arg){  // 接收可变参数  \n        return arg ;            // 返回泛型数组  \n    }  \n    public static <T> void fun2(T param[]){   // 输出  \n        System.out.print("接收泛型数组：") ;  \n        for(T t:param){  \n            System.out.print(t + "、") ;  \n        }  \n    }  \n}\n\n\n * 合理使用\n\npublic ArrayWithTypeToken(Class<T> type, int size) {\n    array = (T[]) Array.newInstance(type, size);\n}\n\n\n具体可以查看后文解释。\n\n\n# 深入理解泛型\n\n提示\n\n我们通过泛型背后的类型擦除以及相关的问题来进一步理解泛型。\n\n\n# 如何理解Java中的泛型是伪泛型？泛型中类型擦除\n\n> Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。理解类型擦除对于用好泛型是很有帮助的，尤其是一些看起来“疑难杂症”的问题，弄明白了类型擦除也就迎刃而解了。\n\n泛型的类型擦除原则是：\n\n * 消除类型参数声明，即删除<>及其包围的部分。\n * 根据类型参数的上下界推断并替换所有的类型参数为原生态类型：如果类型参数是无限制通配符或没有上下界限定则替换为Object，如果存在上下界限定则根据子类替换原则取类型参数的最左边限定类型（即父类）。\n * 为了保证类型安全，必要时插入强制类型转换代码。\n * 自动产生“桥接方法”以保证擦除类型后的代码仍然具有泛型的“多态性”。\n\n那么如何进行擦除的呢？\n\n参考自：http://softlab.sdut.edu.cn/blog/subaochen/2017/01/generics-type-erasure/\n\n * 擦除类定义中的类型参数 - 无限制类型擦除\n\n当类定义中的类型参数没有任何限制时，在类型擦除中直接被替换为Object，即形如<T>和<?>的类型参数都被替换为Object。\n\n\n\n * 擦除类定义中的类型参数 - 有限制类型擦除\n\n当类定义中的类型参数存在限制（上下界）时，在类型擦除中替换为类型参数的上界或者下界，比如形如<T extends Number>和<? extends Number>的类型参数被替换为Number，<? super Number>被替换为Object。\n\n\n\n * 擦除方法定义中的类型参数\n\n擦除方法定义中的类型参数原则和擦除类定义中的类型参数是一样的，这里仅以擦除方法定义中的有限制类型参数为例。\n\n\n\n\n# 如何证明类型的擦除呢？\n\n> 我们通过两个例子证明Java类型的类型擦除\n\n * 原始类型相等\n\npublic class Test {\n\n    public static void main(String[] args) {\n\n        ArrayList<String> list1 = new ArrayList<String>();\n        list1.add("abc");\n\n        ArrayList<Integer> list2 = new ArrayList<Integer>();\n        list2.add(123);\n\n        System.out.println(list1.getClass() == list2.getClass()); // true\n    }\n}\n\n\n在这个例子中，我们定义了两个ArrayList数组，不过一个是ArrayList<String>泛型类型的，只能存储字符串；一个是ArrayList<Integer>泛型类型的，只能存储整数，最后，我们通过list1对象和list2对象的getClass()方法获取他们的类的信息，最后发现结果为true。说明泛型类型String和Integer都被擦除掉了，只剩下原始类型。\n\n * 通过反射添加其它类型元素\n\npublic class Test {\n\n    public static void main(String[] args) throws Exception {\n\n        ArrayList<Integer> list = new ArrayList<Integer>();\n\n        list.add(1);  //这样调用 add 方法只能存储整形，因为泛型类型的实例为 Integer\n\n        list.getClass().getMethod("add", Object.class).invoke(list, "asd");\n\n        for (int i = 0; i < list.size(); i++) {\n            System.out.println(list.get(i));\n        }\n    }\n\n}\n\n\n在程序中定义了一个ArrayList泛型类型实例化为Integer对象，如果直接调用add()方法，那么只能存储整数数据，不过当我们利用反射调用add()方法的时候，却可以存储字符串，这说明了Integer泛型实例在编译之后被擦除掉了，只保留了原始类型。\n\n\n# 如何理解类型擦除后保留的原始类型?\n\n> 在上面，两次提到了原始类型，什么是原始类型？\n\n原始类型 就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换。\n\n * 原始类型Object\n\nclass Pair<T> {  \n    private T value;  \n    public T getValue() {  \n        return value;  \n    }  \n    public void setValue(T  value) {  \n        this.value = value;  \n    }  \n} \n\n\nPair的原始类型为:\n\nclass Pair {  \n    private Object value;  \n    public Object getValue() {  \n        return value;  \n    }  \n    public void setValue(Object  value) {  \n        this.value = value;  \n    }  \n}\n\n\n因为在Pair<T>中，T 是一个无限定的类型变量，所以用Object替换，其结果就是一个普通的类，如同泛型加入Java语言之前的已经实现的样子。在程序中可以包含不同类型的Pair，如Pair<String>或Pair<Integer>，但是擦除类型后他们的就成为原始的Pair类型了，原始类型都是Object。\n\n从上面章节，我们也可以明白ArrayList被擦除类型后，原始类型也变为Object，所以通过反射我们就可以存储字符串了。\n\n如果类型变量有限定，那么原始类型就用第一个边界的类型变量类替换。\n\n比如: Pair这样声明的话\n\npublic class Pair<T extends Comparable> {}\n\n\n那么原始类型就是Comparable。\n\n要区分原始类型和泛型变量的类型。\n\n在调用泛型方法时，可以指定泛型，也可以不指定泛型:\n\n * 在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object\n * 在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类\n\npublic class Test {  \n    public static void main(String[] args) {  \n\n        /**不指定泛型的时候*/  \n        int i = Test.add(1, 2); //这两个参数都是Integer，所以T为Integer类型  \n        Number f = Test.add(1, 1.2); //这两个参数一个是Integer，一个是Float，所以取同一父类的最小级，为Number  \n        Object o = Test.add(1, "asd"); //这两个参数一个是Integer，一个是String，所以取同一父类的最小级，为Object  \n\n        /**指定泛型的时候*/  \n        int a = Test.<Integer>add(1, 2); //指定了Integer，所以只能为Integer类型或者其子类  \n        int b = Test.<Integer>add(1, 2.2); //编译错误，指定了Integer，不能为Float  \n        Number c = Test.<Number>add(1, 2.2); //指定为Number，所以可以为Integer和Float  \n    }  \n\n    //这是一个简单的泛型方法  \n    public static <T> T add(T x,T y){  \n        return y;  \n    }  \n}\n\n\n其实在泛型类中，不指定泛型的时候，也差不多，只不过这个时候的泛型为Object，就比如ArrayList中，如果不指定泛型，那么这个ArrayList可以存储任意的对象。\n\n * Object泛型\n\npublic static void main(String[] args) {  \n    ArrayList list = new ArrayList();  \n    list.add(1);  \n    list.add("121");  \n    list.add(new Date());  \n}  \n\n\n\n# 如何理解泛型的编译期检查？\n\n> 既然说类型变量会在编译的时候擦除掉，那为什么我们往 ArrayList 创建的对象中添加整数会报错呢？不是说泛型变量String会在编译的时候变为Object类型吗？为什么不能存别的类型呢？既然类型擦除了，如何保证我们只能使用泛型变量限定的类型呢？\n\nJava编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译。\n\n例如：\n\npublic static  void main(String[] args) {  \n\n    ArrayList<String> list = new ArrayList<String>();  \n    list.add("123");  \n    list.add(123);//编译错误  \n}\n\n\n在上面的程序中，使用add方法添加一个整型，在IDE中，直接会报错，说明这就是在编译之前的检查，因为如果是在编译之后检查，类型擦除后，原始类型为Object，是应该允许任意引用类型添加的。可实际上却不是这样的，这恰恰说明了关于泛型变量的使用，是会在编译之前检查的。\n\n那么，这个类型检查是针对谁的呢？我们先看看参数化类型和原始类型的兼容。\n\n以 ArrayList举例子，以前的写法:\n\nArrayList list = new ArrayList();  \n\n\n现在的写法:\n\nArrayList<String> list = new ArrayList<String>();\n\n\n如果是与以前的代码兼容，各种引用传值之间，必然会出现如下的情况：\n\nArrayList<String> list1 = new ArrayList(); //第一种 情况\nArrayList list2 = new ArrayList<String>(); //第二种 情况\n\n\n这样是没有错误的，不过会有个编译时警告。\n\n不过在第一种情况，可以实现与完全使用泛型参数一样的效果，第二种则没有效果。\n\n因为类型检查就是编译时完成的，new ArrayList()只是在内存中开辟了一个存储空间，可以存储任何类型对象，而真正涉及类型检查的是它的引用，因为我们是使用它引用list1来调用它的方法，比如说调用add方法，所以list1引用能完成泛型类型的检查。而引用list2没有使用泛型，所以不行。\n\n举例子：\n\npublic class Test {  \n\n    public static void main(String[] args) {  \n\n        ArrayList<String> list1 = new ArrayList();  \n        list1.add("1"); //编译通过  \n        list1.add(1); //编译错误  \n        String str1 = list1.get(0); //返回类型就是String  \n\n        ArrayList list2 = new ArrayList<String>();  \n        list2.add("1"); //编译通过  \n        list2.add(1); //编译通过  \n        Object object = list2.get(0); //返回类型就是Object  \n\n        new ArrayList<String>().add("11"); //编译通过  \n        new ArrayList<String>().add(22); //编译错误  \n\n        String str2 = new ArrayList<String>().get(0); //返回类型就是String  \n    }  \n} \n\n\n通过上面的例子，我们可以明白，类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象。\n\n泛型中参数话类型为什么不考虑继承关系？\n\n在Java中，像下面形式的引用传递是不允许的:\n\nArrayList<String> list1 = new ArrayList<Object>(); //编译错误  \nArrayList<Object> list2 = new ArrayList<String>(); //编译错误\n\n\n * 我们先看第一种情况，将第一种情况拓展成下面的形式：\n\nArrayList<Object> list1 = new ArrayList<Object>();  \nlist1.add(new Object());  \nlist1.add(new Object());  \nArrayList<String> list2 = list1; //编译错误\n\n\n实际上，在第4行代码的时候，就会有编译错误。那么，我们先假设它编译没错。那么当我们使用list2引用用get()方法取值的时候，返回的都是String类型的对象（上面提到了，类型检测是根据引用来决定的），可是它里面实际上已经被我们存放了Object类型的对象，这样就会有ClassCastException了。所以为了避免这种极易出现的错误，Java不允许进行这样的引用传递。（这也是泛型出现的原因，就是为了解决类型转换的问题，我们不能违背它的初衷）。\n\n * 再看第二种情况，将第二种情况拓展成下面的形式：\n\nArrayList<String> list1 = new ArrayList<String>();  \nlist1.add(new String());  \nlist1.add(new String());\n\nArrayList<Object> list2 = list1; //编译错误\n\n\n没错，这样的情况比第一种情况好的多，最起码，在我们用list2取值的时候不会出现ClassCastException，因为是从String转换为Object。可是，这样做有什么意义呢，泛型出现的原因，就是为了解决类型转换的问题。\n\n我们使用了泛型，到头来，还是要自己强转，违背了泛型设计的初衷。所以java不允许这么干。再说，你如果又用list2往里面add()新的对象，那么到时候取得时候，我怎么知道我取出来的到底是String类型的，还是Object类型的呢？\n\n所以，要格外注意，泛型中的引用传递的问题。\n\n\n# 如何理解泛型的多态？泛型的桥接方法\n\n> 类型擦除会造成多态的冲突，而JVM解决方法就是桥接方法。\n\n现在有这样一个泛型类：\n\nclass Pair<T> {  \n\n    private T value;  \n\n    public T getValue() {  \n        return value;  \n    }  \n\n    public void setValue(T value) {  \n        this.value = value;  \n    }  \n}\n\n\n然后我们想要一个子类继承它。\n\nclass DateInter extends Pair<Date> {  \n\n    @Override  \n    public void setValue(Date value) {  \n        super.setValue(value);  \n    }  \n\n    @Override  \n    public Date getValue() {  \n        return super.getValue();  \n    }  \n}\n\n\n在这个子类中，我们设定父类的泛型类型为Pair<Date>，在子类中，我们覆盖了父类的两个方法，我们的原意是这样的：将父类的泛型类型限定为Date，那么父类里面的两个方法的参数都为Date类型。\n\npublic Date getValue() {  \n    return value;  \n}  \n\npublic void setValue(Date value) {  \n    this.value = value;  \n}\n\n\n所以，我们在子类中重写这两个方法一点问题也没有，实际上，从他们的@Override标签中也可以看到，一点问题也没有，实际上是这样的吗？\n\n分析：实际上，类型擦除后，父类的的泛型类型全部变为了原始类型Object，所以父类编译之后会变成下面的样子：\n\nclass Pair {  \n    private Object value;  \n\n    public Object getValue() {  \n        return value;  \n    }  \n\n    public void setValue(Object  value) {  \n        this.value = value;  \n    }  \n} \n\n\n再看子类的两个重写的方法的类型：\n\n@Override  \npublic void setValue(Date value) {  \n    super.setValue(value);  \n}  \n@Override  \npublic Date getValue() {  \n    return super.getValue();  \n}\n\n\n先来分析setValue方法，父类的类型是Object，而子类的类型是Date，参数类型不一样，这如果实在普通的继承关系中，根本就不会是重写，而是重载。 我们在一个main方法测试一下：\n\npublic static void main(String[] args) throws ClassNotFoundException {  \n        DateInter dateInter = new DateInter();  \n        dateInter.setValue(new Date());                  \n        dateInter.setValue(new Object()); //编译错误  \n}\n\n\n如果是重载，那么子类中两个setValue方法，一个是参数Object类型，一个是Date类型，可是我们发现，根本就没有这样的一个子类继承自父类的Object类型参数的方法。所以说，却是是重写了，而不是重载了。\n\n为什么会这样呢？\n\n原因是这样的，我们传入父类的泛型类型是Date，Pair<Date>，我们的本意是将泛型类变为如下：\n\nclass Pair {  \n    private Date value;  \n    public Date getValue() {  \n        return value;  \n    }  \n    public void setValue(Date value) {  \n        this.value = value;  \n    }  \n}\n\n\n然后再子类中重写参数类型为Date的那两个方法，实现继承中的多态。\n\n可是由于种种原因，虚拟机并不能将泛型类型变为Date，只能将类型擦除掉，变为原始类型Object。这样，我们的本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。JVM知道你的本意吗？知道！！！可是它能直接实现吗，不能！！！如果真的不能的话，那我们怎么去重写我们想要的Date类型参数的方法啊。\n\n> 于是JVM采用了一个特殊的方法，来完成这项功能，那就是桥方法。\n\n首先，我们用javap -c className的方式反编译下DateInter子类的字节码，结果如下：\n\nclass com.tao.test.DateInter extends com.tao.test.Pair<java.util.Date> {  \n  com.tao.test.DateInter();  \n    Code:  \n       0: aload_0  \n       1: invokespecial #8                  // Method com/tao/test/Pair."<init>":()V  \n       4: return  \n\n  public void setValue(java.util.Date);  //我们重写的setValue方法  \n    Code:  \n       0: aload_0  \n       1: aload_1  \n       2: invokespecial #16                 // Method com/tao/test/Pair.setValue:(Ljava/lang/Object;)V  \n       5: return  \n\n  public java.util.Date getValue();    //我们重写的getValue方法  \n    Code:  \n       0: aload_0  \n       1: invokespecial #23                 // Method com/tao/test/Pair.getValue:()Ljava/lang/Object;  \n       4: checkcast     #26                 // class java/util/Date  \n       7: areturn  \n\n  public java.lang.Object getValue();     //编译时由编译器生成的桥方法  \n    Code:  \n       0: aload_0  \n       1: invokevirtual #28                 // Method getValue:()Ljava/util/Date 去调用我们重写的getValue方法;  \n       4: areturn  \n\n  public void setValue(java.lang.Object);   //编译时由编译器生成的桥方法  \n    Code:  \n       0: aload_0  \n       1: aload_1  \n       2: checkcast     #26                 // class java/util/Date  \n       5: invokevirtual #30                 // Method setValue:(Ljava/util/Date; 去调用我们重写的setValue方法)V  \n       8: return  \n}\n\n\n从编译的结果来看，我们本意重写setValue和getValue方法的子类，竟然有4个方法，其实不用惊奇，最后的两个方法，就是编译器自己生成的桥方法。可以看到桥方法的参数类型都是Object，也就是说，子类中真正覆盖父类两个方法的就是这两个我们看不到的桥方法。而打在我们自己定义的setvalue和getValue方法上面的@Oveerride只不过是假象。而桥方法的内部实现，就只是去调用我们自己重写的那两个方法。\n\n所以，虚拟机巧妙的使用了桥方法，来解决了类型擦除和多态的冲突。\n\n不过，要提到一点，这里面的setValue和getValue这两个桥方法的意义又有不同。\n\nsetValue方法是为了解决类型擦除与多态之间的冲突。\n\n而getValue却有普遍的意义，怎么说呢，如果这是一个普通的继承关系：\n\n那么父类的getValue方法如下：\n\npublic Object getValue() {  \n    return super.getValue();  \n}\n\n\n而子类重写的方法是：\n\npublic Date getValue() {  \n    return super.getValue();  \n}\n\n\n其实这在普通的类继承中也是普遍存在的重写，这就是协变。\n\n并且，还有一点也许会有疑问，子类中的桥方法Object getValue()和Date getValue()是同时存在的，可是如果是常规的两个方法，他们的方法签名是一样的，也就是说虚拟机根本不能分别这两个方法。如果是我们自己编写Java代码，这样的代码是无法通过编译器的检查的，但是虚拟机却是允许这样做的，因为虚拟机通过参数类型和返回类型来确定一个方法，所以编译器为了实现泛型的多态允许自己做这个看起来“不合法”的事情，然后交给虚拟器去区别。\n\n\n# 如何理解基本类型不能作为泛型类型？\n\n> 比如，我们没有ArrayList<int>，只有ArrayList<Integer>, 为何？\n\n因为当类型擦除后，ArrayList的原始类型变为Object，但是Object类型不能存储int值，只能引用Integer的值。\n\n另外需要注意，我们能够使用list.add(1)是因为Java基础类型的自动装箱拆箱操作。\n\n\n# 如何理解泛型类型不能实例化？\n\n> 不能实例化泛型类型, 这本质上是由于类型擦除决定的：\n\n我们可以看到如下代码会在编译器中报错：\n\nT test = new T(); // ERROR\n\n\n因为在 Java 编译期没法确定泛型参数化类型，也就找不到对应的类字节码文件，所以自然就不行了，此外由于T 被擦除为 Object，如果可以 new T() 则就变成了 new Object()，失去了本意。     如果我们确实需要实例化一个泛型，应该如何做呢？可以通过反射实现：\n\nstatic <T> T newTclass (Class < T > clazz) throws InstantiationException, IllegalAccessException {\n    T obj = clazz.newInstance();\n    return obj;\n}\n\n\n\n# 泛型数组：能不能采用具体的泛型类型进行初始化？\n\n我们先来看下Oracle官网提供的一个例子：\n\nList<String>[] lsa = new List<String>[10]; // Not really allowed.\nObject o = lsa;\nObject[] oa = (Object[]) o;\nList<Integer> li = new ArrayList<Integer>();\nli.add(new Integer(3));\noa[1] = li; // Unsound, but passes run time store check\nString s = lsa[1].get(0); // Run-time error ClassCastException.\n\n\n由于 JVM 泛型的擦除机制，所以上面代码可以给 oa[1] 赋值为 ArrayList 也不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现 ClassCastException，如果可以进行泛型数组的声明则上面说的这种情况在编译期不会出现任何警告和错误，只有在运行时才会出错，但是泛型的出现就是为了消灭 ClassCastException，所以如果 Java 支持泛型数组初始化操作就是搬起石头砸自己的脚。\n\n而对于下面的代码来说是成立的：\n\nList<?>[] lsa = new List<?>[10]; // OK, array of unbounded wildcard type.\nObject o = lsa;\nObject[] oa = (Object[]) o;\nList<Integer> li = new ArrayList<Integer>();\nli.add(new Integer(3));\noa[1] = li; // Correct.\nInteger i = (Integer) lsa[1].get(0); // OK\n\n\n所以说采用通配符的方式初始化泛型数组是允许的，因为对于通配符的方式最后取出数据是要做显式类型转换的，符合预期逻辑。综述就是说Java 的泛型数组初始化时数组类型不能是具体的泛型类型，只能是通配符的形式，因为具体类型会导致可存入任意类型对象，在取出时会发生类型转换异常，会与泛型的设计思想冲突，而通配符形式本来就需要自己强转，符合预期。\n\nOracle 官方文档：https://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html在新窗口打开\n\n更进一步的，我们看看如下的代码：\n\nList<String>[] list11 = new ArrayList<String>[10]; //编译错误，非法创建 \nList<String>[] list12 = new ArrayList<?>[10]; //编译错误，需要强转类型 \nList<String>[] list13 = (List<String>[]) new ArrayList<?>[10]; //OK，但是会有警告 \nList<?>[] list14 = new ArrayList<String>[10]; //编译错误，非法创建 \nList<?>[] list15 = new ArrayList<?>[10]; //OK \nList<String>[] list6 = new ArrayList[10]; //OK，但是会有警告\n\n\n因为在 Java 中是不能创建一个确切的泛型类型的数组的，除非是采用通配符的方式且要做显式类型转换才可以。\n\n\n# 泛型数组：如何正确的初始化泛型数组实例？\n\n> 这个无论我们通过new ArrayList[10] 的形式还是通过泛型通配符的形式初始化泛型数组实例都是存在警告的，也就是说仅仅语法合格，运行时潜在的风险需要我们自己来承担，因此那些方式初始化泛型数组都不是最优雅的方式。\n\n我们在使用到泛型数组的场景下应该尽量使用列表集合替换，此外也可以通过使用 java.lang.reflect.Array.newInstance(Class<T> componentType, int length) 方法来创建一个具有指定类型和维度的数组，如下：\n\npublic class ArrayWithTypeToken<T> {\n    private T[] array;\n\n    public ArrayWithTypeToken(Class<T> type, int size) {\n        array = (T[]) Array.newInstance(type, size);\n    }\n\n    public void put(int index, T item) {\n        array[index] = item;\n    }\n\n    public T get(int index) {\n        return array[index];\n    }\n\n    public T[] create() {\n        return array;\n    }\n}\n//...\n\nArrayWithTypeToken<Integer> arrayToken = new ArrayWithTypeToken<Integer>(Integer.class, 100);\nInteger[] array = arrayToken.create();\n\n\n所以使用反射来初始化泛型数组算是优雅实现，因为泛型类型 T在运行时才能被确定下来，我们能创建泛型数组也必然是在 Java 运行时想办法，而运行时能起作用的技术最好的就是反射了。\n\n\n# 如何理解泛型类中的静态方法和静态变量？\n\n> 泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数\n\n举例说明：\n\npublic class Test2<T> {    \n    public static T one;   //编译错误    \n    public static  T show(T one){ //编译错误    \n        return null;    \n    }    \n}\n\n\n因为泛型类中的泛型参数的实例化是在定义对象的时候指定的，而静态变量和静态方法不需要使用对象来调用。对象都没有创建，如何确定这个泛型参数是何种类型，所以当然是错误的。\n\n但是要注意区分下面的一种情况：\n\npublic class Test2<T> {    \n\n    public static <T >T show(T one){ //这是正确的    \n        return null;    \n    }    \n}\n\n\n因为这是一个泛型方法，在泛型方法中使用的T是自己在方法中定义的 T，而不是泛型类中的T。\n\n\n# 如何理解异常中使用泛型？\n\n * 不能抛出也不能捕获泛型类的对象。事实上，泛型类扩展Throwable都不合法。例如：下面的定义将不会通过编译：\n\npublic class Problem<T> extends Exception {\n\n}\n\n\n为什么不能扩展Throwable，因为异常都是在运行时捕获和抛出的，而在编译的时候，泛型信息全都会被擦除掉，那么，假设上面的编译可行，那么，在看下面的定义：\n\ntry{\n\n} catch(Problem<Integer> e1) {\n\n} catch(Problem<Number> e2) {\n\n} \n\n\n类型信息被擦除后，那么两个地方的catch都变为原始类型Object，那么也就是说，这两个地方的catch变的一模一样,就相当于下面的这样\n\ntry{\n\n} catch(Problem<Object> e1) {\n\n} catch(Problem<Object> e2) {\n\n}\n\n\n这个当然就是不行的。\n\n * 不能再catch子句中使用泛型变量\n\npublic static <T extends Throwable> void doWork(Class<T> t) {\n    try {\n        ...\n    } catch(T e) { //编译错误\n        ...\n    }\n}\n\n\n因为泛型信息在编译的时候已经变为原始类型，也就是说上面的T会变为原始类型Throwable，那么如果可以再catch子句中使用泛型变量，那么，下面的定义呢：\n\npublic static <T extends Throwable> void doWork(Class<T> t){\n    try {\n\n    } catch(T e) { //编译错误\n\n    } catch(IndexOutOfBounds e) {\n\n    }                         \n}\n\n\n根据异常捕获的原则，一定是子类在前面，父类在后面，那么上面就违背了这个原则。即使你在使用该静态方法的使用T是ArrayIndexOutofBounds，在编译之后还是会变成Throwable，ArrayIndexOutofBounds是IndexOutofBounds的子类，违背了异常捕获的原则。所以java为了避免这样的情况，禁止在catch子句中使用泛型变量。\n\n * 但是在异常声明中可以使用类型变量。下面方法是合法的。\n\npublic static<T extends Throwable> void doWork(T t) throws T {\n    try{\n        ...\n    } catch(Throwable realCause) {\n        t.initCause(realCause);\n        throw t; \n    }\n}\n\n\n上面的这样使用是没问题的。\n\n\n# 如何获取泛型的参数类型？\n\n> 既然类型被擦除了，那么如何获取泛型的参数类型呢？可以通过反射（java.lang.reflect.Type）获取泛型\n\njava.lang.reflect.Type是Java中所有类型的公共高级接口, 代表了Java中的所有类型. Type体系中类型的包括：数组类型(GenericArrayType)、参数化类型(ParameterizedType)、类型变量(TypeVariable)、通配符类型(WildcardType)、原始类型(Class)、基本类型(Class), 以上这些类型都实现Type接口。\n\npublic class GenericType<T> {\n    private T data;\n\n    public T getData() {\n        return data;\n    }\n\n    public void setData(T data) {\n        this.data = data;\n    }\n\n    public static void main(String[] args) {\n        GenericType<String> genericType = new GenericType<String>() {};\n        Type superclass = genericType.getClass().getGenericSuperclass();\n        //getActualTypeArguments 返回确切的泛型参数, 如Map<String, Integer>返回[String, Integer]\n        Type type = ((ParameterizedType) superclass).getActualTypeArguments()[0]; \n        System.out.println(type);//class java.lang.String\n    }\n}\n\n\n其中 ParameterizedType:\n\npublic interface ParameterizedType extends Type {\n    // 返回确切的泛型参数, 如Map<String, Integer>返回[String, Integer]\n    Type[] getActualTypeArguments();\n    \n    //返回当前class或interface声明的类型, 如List<?>返回List\n    Type getRawType();\n    \n    //返回所属类型. 如,当前类型为O<T>.I<S>, 则返回O<T>. 顶级类型将返回null \n    Type getOwnerType();\n}\n\n\n\n# 参考文章\n\n> 泛型作为Java基础知识点之一，网上知识点比较多也比较散，本文主要综合了网络上比较好的文章，方便你快速学习。（以下是一部分我参考的链接）\n\n * https://blog.csdn.net/sunxianghuang/article/details/51982979\n * https://blog.csdn.net/LonelyRoamer/article/details/7868820\n * https://docs.oracle.com/javase/tutorial/extra/generics/index.html\n * https://blog.csdn.net/s10461/article/details/53941091\n * https://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html\n * https://www.cnblogs.com/rudy-laura/articles/3391013.html\n * https://www.jianshu.com/p/986f732ed2f1\n * https://blog.csdn.net/u011240877/article/details/53545041\n * 转载 https://www.pdai.tech/md/java/basic/java-basic-x-generic.html',normalizedContent:'# java 基础 - 泛型机制详解\n\n> java泛型这个特性是从jdk 1.5才开始加入的，因此为了兼容之前的版本，java泛型的实现采取了“伪泛型”的策略，即java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（type erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。本文综合多篇文章后，总结了java 泛型的相关知识，希望可以提升你对java中泛型的认知效率。\n\n * java 基础 - 泛型机制详解\n   * 为什么会引入泛型\n   * 泛型的基本使用\n     * 泛型类\n     * 泛型接口\n     * 泛型方法\n     * 泛型的上下限\n     * 泛型数组\n   * 深入理解泛型\n     * 如何理解java中的泛型是伪泛型？泛型中类型擦除\n     * 如何证明类型的擦除呢？\n     * 如何理解类型擦除后保留的原始类型?\n     * 如何理解泛型的编译期检查？\n     * 如何理解泛型的多态？泛型的桥接方法\n     * 如何理解基本类型不能作为泛型类型？\n     * 如何理解泛型类型不能实例化？\n     * 泛型数组：能不能采用具体的泛型类型进行初始化？\n     * 泛型数组：如何正确的初始化泛型数组实例？\n     * 如何理解泛型类中的静态方法和静态变量？\n     * 如何理解异常中使用泛型？\n     * 如何获取泛型的参数类型？\n   * 参考文章\n\n\n# 为什么会引入泛型\n\n> 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。\n\n引入泛型的意义在于：\n\n * 适用于多种数据类型执行相同的代码（代码复用）\n\n我们通过一个例子来阐述，先看下下面的代码：\n\nprivate static int add(int a, int b) {\n    system.out.println(a + "+" + b + "=" + (a + b));\n    return a + b;\n}\n\nprivate static float add(float a, float b) {\n    system.out.println(a + "+" + b + "=" + (a + b));\n    return a + b;\n}\n\nprivate static double add(double a, double b) {\n    system.out.println(a + "+" + b + "=" + (a + b));\n    return a + b;\n}\n\n\n如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法；通过泛型，我们可以复用为一个方法：\n\nprivate static <t extends number> double add(t a, t b) {\n    system.out.println(a + "+" + b + "=" + (a.doublevalue() + b.doublevalue()));\n    return a.doublevalue() + b.doublevalue();\n}\n\n\n * 泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）\n\n看下这个例子：\n\nlist list = new arraylist();\nlist.add("xxstring");\nlist.add(100d);\nlist.add(new person());\n\n\n我们在使用上述list中，list中的元素都是object类型（无法约束其中的类型），所以在取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现java.lang.classcastexception异常。\n\n引入泛型，它将提供类型的约束，提供编译前的检查：\n\nlist<string> list = new arraylist<string>();\n\n// list中只能放string, 不能放其它类型的元素\n\n\n\n# 泛型的基本使用\n\n提示\n\n我们通过一些例子来学习泛型的使用；泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法。一些例子可以参考《李兴华 - java实战经典》。\n\n\n# 泛型类\n\n * 从一个简单的泛型类看起：\n\nclass point<t>{         // 此处可以随便写标识符号，t是type的简称  \n    private t var ;     // var的类型由t指定，即：由外部指定  \n    public t getvar(){  // 返回值的类型由外部决定  \n        return var ;  \n    }  \n    public void setvar(t var){  // 设置的类型也由外部决定  \n        this.var = var ;  \n    }  \n}  \npublic class genericsdemo06{  \n    public static void main(string args[]){  \n        point<string> p = new point<string>() ;     // 里面的var类型为string类型  \n        p.setvar("it") ;                            // 设置字符串  \n        system.out.println(p.getvar().length()) ;   // 取得字符串的长度  \n    }  \n}\n\n\n * 多元泛型\n\nclass notepad<k,v>{       // 此处指定了两个泛型类型  \n    private k key ;     // 此变量的类型由外部决定  \n    private v value ;   // 此变量的类型由外部决定  \n    public k getkey(){  \n        return this.key ;  \n    }  \n    public v getvalue(){  \n        return this.value ;  \n    }  \n    public void setkey(k key){  \n        this.key = key ;  \n    }  \n    public void setvalue(v value){  \n        this.value = value ;  \n    }  \n} \npublic class genericsdemo09{  \n    public static void main(string args[]){  \n        notepad<string,integer> t = null ;        // 定义两个泛型类型的对象  \n        t = new notepad<string,integer>() ;       // 里面的key为string，value为integer  \n        t.setkey("汤姆") ;        // 设置第一个内容  \n        t.setvalue(20) ;            // 设置第二个内容  \n        system.out.print("姓名；" + t.getkey()) ;      // 取得信息  \n        system.out.print("，年龄；" + t.getvalue()) ;       // 取得信息  \n  \n    }  \n}\n\n\n\n# 泛型接口\n\n * 简单的泛型接口\n\ninterface info<t>{        // 在接口上定义泛型  \n    public t getvar() ; // 定义抽象方法，抽象方法的返回值就是泛型类型  \n}  \nclass infoimpl<t> implements info<t>{   // 定义泛型接口的子类  \n    private t var ;             // 定义属性  \n    public infoimpl(t var){     // 通过构造方法设置属性内容  \n        this.setvar(var) ;    \n    }  \n    public void setvar(t var){  \n        this.var = var ;  \n    }  \n    public t getvar(){  \n        return this.var ;  \n    }  \n} \npublic class genericsdemo24{  \n    public static void main(string arsg[]){  \n        info<string> i = null;        // 声明接口对象  \n        i = new infoimpl<string>("汤姆") ;  // 通过子类实例化对象  \n        system.out.println("内容：" + i.getvar()) ;  \n    }  \n}  \n\n\n\n# 泛型方法\n\n泛型方法，是在调用方法的时候指明泛型的具体类型。重点看下泛型的方法（图参考自：https://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html）\n\n * 定义泛型方法语法格式\n\n\n\n * 调用泛型方法语法格式\n\n\n\n说明一下，定义泛型方法时，必须在返回值前边加一个<t>，来声明这是一个泛型方法，持有一个泛型t，然后才可以用泛型t作为方法的返回值。\n\nclass<t>的作用就是指明泛型的具体类型，而class<t>类型的变量c，可以用来创建泛型类的对象。\n\n为什么要用变量c来创建对象呢？既然是泛型方法，就代表着我们不知道具体的类型是什么，也不知道构造方法如何，因此没有办法去new一个对象，但可以利用变量c的newinstance方法去创建对象，也就是利用反射创建对象。\n\n泛型方法要求的参数是class<t>类型，而class.forname()方法的返回值也是class<t>，因此可以用class.forname()作为参数。其中，forname()方法中的参数是何种类型，返回的class<t>就是何种类型。在本例中，forname()方法中传入的是user类的完整路径，因此返回的是class<user>类型的对象，因此调用泛型方法时，变量c的类型就是class<user>，因此泛型方法中的泛型t就被指明为user，因此变量obj的类型为user。\n\n当然，泛型方法不是仅仅可以有一个参数class<t>，可以根据需要添加其他参数。\n\n为什么要使用泛型方法呢？因为泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活。\n\n\n# 泛型的上下限\n\n * 先看下如下的代码，很明显是会报错的 （具体错误原因请参考后文）。\n\nclass a{}\nclass b extends a {}\n\n// 如下两个方法不会报错\npublic static void funa(a a) {\n    // ...          \n}\npublic static void funb(b b) {\n    funa(b);\n    // ...             \n}\n\n// 如下fund方法会报错\npublic static void func(list<a> lista) {\n    // ...          \n}\npublic static void fund(list<b> listb) {\n    func(listb); // unresolved compilation problem: the method doprint(list<a>) in the type test is not applicable for the arguments (list<b>)\n    // ...             \n}\n\n\n那么如何解决呢？\n\n为了解决泛型中隐含的转换问题，java泛型加入了类型参数的上下边界机制。<? extends a>表示该类型参数可以是a(上边界)或者a的子类类型。编译时擦除到类型a，即用a类型代替类型参数。这种方法可以解决开始遇到的问题，编译器知道类型参数的范围，如果传入的实例类型b是在这个范围内的话允许转换，这时只要一次类型转换就可以了，运行时会把对象当做a的实例看待。\n\npublic static void func(list<? extends a> lista) {\n    // ...          \n}\npublic static void fund(list<b> listb) {\n    func(listb); // ok\n    // ...             \n}\n\n\n * 泛型上下限的引入\n\n在使用泛型的时候，我们可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。\n\n上限\n\nclass info<t extends number>{    // 此处泛型只能是数字类型\n    private t var ;        // 定义泛型变量\n    public void setvar(t var){\n        this.var = var ;\n    }\n    public t getvar(){\n        return this.var ;\n    }\n    public string tostring(){    // 直接打印\n        return this.var.tostring() ;\n    }\n}\npublic class demo1{\n    public static void main(string args[]){\n        info<integer> i1 = new info<integer>() ;        // 声明integer的泛型对象\n    }\n}\n\n\n下限\n\nclass info<t>{\n    private t var ;        // 定义泛型变量\n    public void setvar(t var){\n        this.var = var ;\n    }\n    public t getvar(){\n        return this.var ;\n    }\n    public string tostring(){    // 直接打印\n        return this.var.tostring() ;\n    }\n}\npublic class genericsdemo21{\n    public static void main(string args[]){\n        info<string> i1 = new info<string>() ;        // 声明string的泛型对象\n        info<object> i2 = new info<object>() ;        // 声明object的泛型对象\n        i1.setvar("hello") ;\n        i2.setvar(new object()) ;\n        fun(i1) ;\n        fun(i2) ;\n    }\n    public static void fun(info<? super string> temp){    // 只能接收string或object类型的泛型，string类的父类只有object类\n        system.out.print(temp + ", ") ;\n    }\n}\n\n\n小结\n\n<?> 无限制通配符\n<? extends e> extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类\n<? super e> super 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类\n\n// 使用原则《effictive java》\n// 为了获得最大限度的灵活性，要在表示 生产者或者消费者 的输入参数上使用通配符，使用的规则就是：生产者有上限、消费者有下限\n1. 如果参数化类型表示一个 t 的生产者，使用 < ? extends t>;\n2. 如果它表示一个 t 的消费者，就使用 < ? super t>；\n3. 如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。\n\n\n * 再看一个实际例子，加深印象\n\nprivate  <e extends comparable<? super e>> e max(list<? extends e> e1) {\n    if (e1 == null){\n        return null;\n    }\n    //迭代器返回的元素属于 e 的某个子类型\n    iterator<? extends e> iterator = e1.iterator();\n    e result = iterator.next();\n    while (iterator.hasnext()){\n        e next = iterator.next();\n        if (next.compareto(result) > 0){\n            result = next;\n        }\n    }\n    return result;\n}\n\n\n上述代码中的类型参数 e 的范围是<e extends comparable<? super e>>，我们可以分步查看：\n\n * 要进行比较，所以 e 需要是可比较的类，因此需要 extends comparable<…>（注意这里不要和继承的 extends 搞混了，不一样）\n\n * comparable< ? super e> 要对 e 进行比较，即 e 的消费者，所以需要用 super\n\n * 而参数 list< ? extends e> 表示要操作的数据是 e 的子类的列表，指定上限，这样容器才够大\n\n * 多个限制\n\n使用&符号\n\npublic class client {\n    //工资低于2500元的上斑族并且站立的乘客车票打8折\n    public static <t extends staff & passenger> void discount(t t){\n        if(t.getsalary()<2500 && t.isstanding()){\n            system.out.println("恭喜你！您的车票打八折！");\n        }\n    }\n    public static void main(string[] args) {\n        discount(new me());\n    }\n}\n\n\n\n# 泛型数组\n\n> 具体可以参考下文中关于泛型数组的理解。\n\n首先，我们泛型数组相关的申明：\n\nlist<string>[] list11 = new arraylist<string>[10]; //编译错误，非法创建 \nlist<string>[] list12 = new arraylist<?>[10]; //编译错误，需要强转类型 \nlist<string>[] list13 = (list<string>[]) new arraylist<?>[10]; //ok，但是会有警告 \nlist<?>[] list14 = new arraylist<string>[10]; //编译错误，非法创建 \nlist<?>[] list15 = new arraylist<?>[10]; //ok \nlist<string>[] list6 = new arraylist[10]; //ok，但是会有警告\n\n\n那么通常我们如何用呢？\n\n * 讨巧的使用场景\n\npublic class genericsdemo30{  \n    public static void main(string args[]){  \n        integer i[] = fun1(1,2,3,4,5,6) ;   // 返回泛型数组  \n        fun2(i) ;  \n    }  \n    public static <t> t[] fun1(t...arg){  // 接收可变参数  \n        return arg ;            // 返回泛型数组  \n    }  \n    public static <t> void fun2(t param[]){   // 输出  \n        system.out.print("接收泛型数组：") ;  \n        for(t t:param){  \n            system.out.print(t + "、") ;  \n        }  \n    }  \n}\n\n\n * 合理使用\n\npublic arraywithtypetoken(class<t> type, int size) {\n    array = (t[]) array.newinstance(type, size);\n}\n\n\n具体可以查看后文解释。\n\n\n# 深入理解泛型\n\n提示\n\n我们通过泛型背后的类型擦除以及相关的问题来进一步理解泛型。\n\n\n# 如何理解java中的泛型是伪泛型？泛型中类型擦除\n\n> java泛型这个特性是从jdk 1.5才开始加入的，因此为了兼容之前的版本，java泛型的实现采取了“伪泛型”的策略，即java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（type erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。理解类型擦除对于用好泛型是很有帮助的，尤其是一些看起来“疑难杂症”的问题，弄明白了类型擦除也就迎刃而解了。\n\n泛型的类型擦除原则是：\n\n * 消除类型参数声明，即删除<>及其包围的部分。\n * 根据类型参数的上下界推断并替换所有的类型参数为原生态类型：如果类型参数是无限制通配符或没有上下界限定则替换为object，如果存在上下界限定则根据子类替换原则取类型参数的最左边限定类型（即父类）。\n * 为了保证类型安全，必要时插入强制类型转换代码。\n * 自动产生“桥接方法”以保证擦除类型后的代码仍然具有泛型的“多态性”。\n\n那么如何进行擦除的呢？\n\n参考自：http://softlab.sdut.edu.cn/blog/subaochen/2017/01/generics-type-erasure/\n\n * 擦除类定义中的类型参数 - 无限制类型擦除\n\n当类定义中的类型参数没有任何限制时，在类型擦除中直接被替换为object，即形如<t>和<?>的类型参数都被替换为object。\n\n\n\n * 擦除类定义中的类型参数 - 有限制类型擦除\n\n当类定义中的类型参数存在限制（上下界）时，在类型擦除中替换为类型参数的上界或者下界，比如形如<t extends number>和<? extends number>的类型参数被替换为number，<? super number>被替换为object。\n\n\n\n * 擦除方法定义中的类型参数\n\n擦除方法定义中的类型参数原则和擦除类定义中的类型参数是一样的，这里仅以擦除方法定义中的有限制类型参数为例。\n\n\n\n\n# 如何证明类型的擦除呢？\n\n> 我们通过两个例子证明java类型的类型擦除\n\n * 原始类型相等\n\npublic class test {\n\n    public static void main(string[] args) {\n\n        arraylist<string> list1 = new arraylist<string>();\n        list1.add("abc");\n\n        arraylist<integer> list2 = new arraylist<integer>();\n        list2.add(123);\n\n        system.out.println(list1.getclass() == list2.getclass()); // true\n    }\n}\n\n\n在这个例子中，我们定义了两个arraylist数组，不过一个是arraylist<string>泛型类型的，只能存储字符串；一个是arraylist<integer>泛型类型的，只能存储整数，最后，我们通过list1对象和list2对象的getclass()方法获取他们的类的信息，最后发现结果为true。说明泛型类型string和integer都被擦除掉了，只剩下原始类型。\n\n * 通过反射添加其它类型元素\n\npublic class test {\n\n    public static void main(string[] args) throws exception {\n\n        arraylist<integer> list = new arraylist<integer>();\n\n        list.add(1);  //这样调用 add 方法只能存储整形，因为泛型类型的实例为 integer\n\n        list.getclass().getmethod("add", object.class).invoke(list, "asd");\n\n        for (int i = 0; i < list.size(); i++) {\n            system.out.println(list.get(i));\n        }\n    }\n\n}\n\n\n在程序中定义了一个arraylist泛型类型实例化为integer对象，如果直接调用add()方法，那么只能存储整数数据，不过当我们利用反射调用add()方法的时候，却可以存储字符串，这说明了integer泛型实例在编译之后被擦除掉了，只保留了原始类型。\n\n\n# 如何理解类型擦除后保留的原始类型?\n\n> 在上面，两次提到了原始类型，什么是原始类型？\n\n原始类型 就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用object）替换。\n\n * 原始类型object\n\nclass pair<t> {  \n    private t value;  \n    public t getvalue() {  \n        return value;  \n    }  \n    public void setvalue(t  value) {  \n        this.value = value;  \n    }  \n} \n\n\npair的原始类型为:\n\nclass pair {  \n    private object value;  \n    public object getvalue() {  \n        return value;  \n    }  \n    public void setvalue(object  value) {  \n        this.value = value;  \n    }  \n}\n\n\n因为在pair<t>中，t 是一个无限定的类型变量，所以用object替换，其结果就是一个普通的类，如同泛型加入java语言之前的已经实现的样子。在程序中可以包含不同类型的pair，如pair<string>或pair<integer>，但是擦除类型后他们的就成为原始的pair类型了，原始类型都是object。\n\n从上面章节，我们也可以明白arraylist被擦除类型后，原始类型也变为object，所以通过反射我们就可以存储字符串了。\n\n如果类型变量有限定，那么原始类型就用第一个边界的类型变量类替换。\n\n比如: pair这样声明的话\n\npublic class pair<t extends comparable> {}\n\n\n那么原始类型就是comparable。\n\n要区分原始类型和泛型变量的类型。\n\n在调用泛型方法时，可以指定泛型，也可以不指定泛型:\n\n * 在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到object\n * 在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类\n\npublic class test {  \n    public static void main(string[] args) {  \n\n        /**不指定泛型的时候*/  \n        int i = test.add(1, 2); //这两个参数都是integer，所以t为integer类型  \n        number f = test.add(1, 1.2); //这两个参数一个是integer，一个是float，所以取同一父类的最小级，为number  \n        object o = test.add(1, "asd"); //这两个参数一个是integer，一个是string，所以取同一父类的最小级，为object  \n\n        /**指定泛型的时候*/  \n        int a = test.<integer>add(1, 2); //指定了integer，所以只能为integer类型或者其子类  \n        int b = test.<integer>add(1, 2.2); //编译错误，指定了integer，不能为float  \n        number c = test.<number>add(1, 2.2); //指定为number，所以可以为integer和float  \n    }  \n\n    //这是一个简单的泛型方法  \n    public static <t> t add(t x,t y){  \n        return y;  \n    }  \n}\n\n\n其实在泛型类中，不指定泛型的时候，也差不多，只不过这个时候的泛型为object，就比如arraylist中，如果不指定泛型，那么这个arraylist可以存储任意的对象。\n\n * object泛型\n\npublic static void main(string[] args) {  \n    arraylist list = new arraylist();  \n    list.add(1);  \n    list.add("121");  \n    list.add(new date());  \n}  \n\n\n\n# 如何理解泛型的编译期检查？\n\n> 既然说类型变量会在编译的时候擦除掉，那为什么我们往 arraylist 创建的对象中添加整数会报错呢？不是说泛型变量string会在编译的时候变为object类型吗？为什么不能存别的类型呢？既然类型擦除了，如何保证我们只能使用泛型变量限定的类型呢？\n\njava编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译。\n\n例如：\n\npublic static  void main(string[] args) {  \n\n    arraylist<string> list = new arraylist<string>();  \n    list.add("123");  \n    list.add(123);//编译错误  \n}\n\n\n在上面的程序中，使用add方法添加一个整型，在ide中，直接会报错，说明这就是在编译之前的检查，因为如果是在编译之后检查，类型擦除后，原始类型为object，是应该允许任意引用类型添加的。可实际上却不是这样的，这恰恰说明了关于泛型变量的使用，是会在编译之前检查的。\n\n那么，这个类型检查是针对谁的呢？我们先看看参数化类型和原始类型的兼容。\n\n以 arraylist举例子，以前的写法:\n\narraylist list = new arraylist();  \n\n\n现在的写法:\n\narraylist<string> list = new arraylist<string>();\n\n\n如果是与以前的代码兼容，各种引用传值之间，必然会出现如下的情况：\n\narraylist<string> list1 = new arraylist(); //第一种 情况\narraylist list2 = new arraylist<string>(); //第二种 情况\n\n\n这样是没有错误的，不过会有个编译时警告。\n\n不过在第一种情况，可以实现与完全使用泛型参数一样的效果，第二种则没有效果。\n\n因为类型检查就是编译时完成的，new arraylist()只是在内存中开辟了一个存储空间，可以存储任何类型对象，而真正涉及类型检查的是它的引用，因为我们是使用它引用list1来调用它的方法，比如说调用add方法，所以list1引用能完成泛型类型的检查。而引用list2没有使用泛型，所以不行。\n\n举例子：\n\npublic class test {  \n\n    public static void main(string[] args) {  \n\n        arraylist<string> list1 = new arraylist();  \n        list1.add("1"); //编译通过  \n        list1.add(1); //编译错误  \n        string str1 = list1.get(0); //返回类型就是string  \n\n        arraylist list2 = new arraylist<string>();  \n        list2.add("1"); //编译通过  \n        list2.add(1); //编译通过  \n        object object = list2.get(0); //返回类型就是object  \n\n        new arraylist<string>().add("11"); //编译通过  \n        new arraylist<string>().add(22); //编译错误  \n\n        string str2 = new arraylist<string>().get(0); //返回类型就是string  \n    }  \n} \n\n\n通过上面的例子，我们可以明白，类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象。\n\n泛型中参数话类型为什么不考虑继承关系？\n\n在java中，像下面形式的引用传递是不允许的:\n\narraylist<string> list1 = new arraylist<object>(); //编译错误  \narraylist<object> list2 = new arraylist<string>(); //编译错误\n\n\n * 我们先看第一种情况，将第一种情况拓展成下面的形式：\n\narraylist<object> list1 = new arraylist<object>();  \nlist1.add(new object());  \nlist1.add(new object());  \narraylist<string> list2 = list1; //编译错误\n\n\n实际上，在第4行代码的时候，就会有编译错误。那么，我们先假设它编译没错。那么当我们使用list2引用用get()方法取值的时候，返回的都是string类型的对象（上面提到了，类型检测是根据引用来决定的），可是它里面实际上已经被我们存放了object类型的对象，这样就会有classcastexception了。所以为了避免这种极易出现的错误，java不允许进行这样的引用传递。（这也是泛型出现的原因，就是为了解决类型转换的问题，我们不能违背它的初衷）。\n\n * 再看第二种情况，将第二种情况拓展成下面的形式：\n\narraylist<string> list1 = new arraylist<string>();  \nlist1.add(new string());  \nlist1.add(new string());\n\narraylist<object> list2 = list1; //编译错误\n\n\n没错，这样的情况比第一种情况好的多，最起码，在我们用list2取值的时候不会出现classcastexception，因为是从string转换为object。可是，这样做有什么意义呢，泛型出现的原因，就是为了解决类型转换的问题。\n\n我们使用了泛型，到头来，还是要自己强转，违背了泛型设计的初衷。所以java不允许这么干。再说，你如果又用list2往里面add()新的对象，那么到时候取得时候，我怎么知道我取出来的到底是string类型的，还是object类型的呢？\n\n所以，要格外注意，泛型中的引用传递的问题。\n\n\n# 如何理解泛型的多态？泛型的桥接方法\n\n> 类型擦除会造成多态的冲突，而jvm解决方法就是桥接方法。\n\n现在有这样一个泛型类：\n\nclass pair<t> {  \n\n    private t value;  \n\n    public t getvalue() {  \n        return value;  \n    }  \n\n    public void setvalue(t value) {  \n        this.value = value;  \n    }  \n}\n\n\n然后我们想要一个子类继承它。\n\nclass dateinter extends pair<date> {  \n\n    @override  \n    public void setvalue(date value) {  \n        super.setvalue(value);  \n    }  \n\n    @override  \n    public date getvalue() {  \n        return super.getvalue();  \n    }  \n}\n\n\n在这个子类中，我们设定父类的泛型类型为pair<date>，在子类中，我们覆盖了父类的两个方法，我们的原意是这样的：将父类的泛型类型限定为date，那么父类里面的两个方法的参数都为date类型。\n\npublic date getvalue() {  \n    return value;  \n}  \n\npublic void setvalue(date value) {  \n    this.value = value;  \n}\n\n\n所以，我们在子类中重写这两个方法一点问题也没有，实际上，从他们的@override标签中也可以看到，一点问题也没有，实际上是这样的吗？\n\n分析：实际上，类型擦除后，父类的的泛型类型全部变为了原始类型object，所以父类编译之后会变成下面的样子：\n\nclass pair {  \n    private object value;  \n\n    public object getvalue() {  \n        return value;  \n    }  \n\n    public void setvalue(object  value) {  \n        this.value = value;  \n    }  \n} \n\n\n再看子类的两个重写的方法的类型：\n\n@override  \npublic void setvalue(date value) {  \n    super.setvalue(value);  \n}  \n@override  \npublic date getvalue() {  \n    return super.getvalue();  \n}\n\n\n先来分析setvalue方法，父类的类型是object，而子类的类型是date，参数类型不一样，这如果实在普通的继承关系中，根本就不会是重写，而是重载。 我们在一个main方法测试一下：\n\npublic static void main(string[] args) throws classnotfoundexception {  \n        dateinter dateinter = new dateinter();  \n        dateinter.setvalue(new date());                  \n        dateinter.setvalue(new object()); //编译错误  \n}\n\n\n如果是重载，那么子类中两个setvalue方法，一个是参数object类型，一个是date类型，可是我们发现，根本就没有这样的一个子类继承自父类的object类型参数的方法。所以说，却是是重写了，而不是重载了。\n\n为什么会这样呢？\n\n原因是这样的，我们传入父类的泛型类型是date，pair<date>，我们的本意是将泛型类变为如下：\n\nclass pair {  \n    private date value;  \n    public date getvalue() {  \n        return value;  \n    }  \n    public void setvalue(date value) {  \n        this.value = value;  \n    }  \n}\n\n\n然后再子类中重写参数类型为date的那两个方法，实现继承中的多态。\n\n可是由于种种原因，虚拟机并不能将泛型类型变为date，只能将类型擦除掉，变为原始类型object。这样，我们的本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。jvm知道你的本意吗？知道！！！可是它能直接实现吗，不能！！！如果真的不能的话，那我们怎么去重写我们想要的date类型参数的方法啊。\n\n> 于是jvm采用了一个特殊的方法，来完成这项功能，那就是桥方法。\n\n首先，我们用javap -c classname的方式反编译下dateinter子类的字节码，结果如下：\n\nclass com.tao.test.dateinter extends com.tao.test.pair<java.util.date> {  \n  com.tao.test.dateinter();  \n    code:  \n       0: aload_0  \n       1: invokespecial #8                  // method com/tao/test/pair."<init>":()v  \n       4: return  \n\n  public void setvalue(java.util.date);  //我们重写的setvalue方法  \n    code:  \n       0: aload_0  \n       1: aload_1  \n       2: invokespecial #16                 // method com/tao/test/pair.setvalue:(ljava/lang/object;)v  \n       5: return  \n\n  public java.util.date getvalue();    //我们重写的getvalue方法  \n    code:  \n       0: aload_0  \n       1: invokespecial #23                 // method com/tao/test/pair.getvalue:()ljava/lang/object;  \n       4: checkcast     #26                 // class java/util/date  \n       7: areturn  \n\n  public java.lang.object getvalue();     //编译时由编译器生成的桥方法  \n    code:  \n       0: aload_0  \n       1: invokevirtual #28                 // method getvalue:()ljava/util/date 去调用我们重写的getvalue方法;  \n       4: areturn  \n\n  public void setvalue(java.lang.object);   //编译时由编译器生成的桥方法  \n    code:  \n       0: aload_0  \n       1: aload_1  \n       2: checkcast     #26                 // class java/util/date  \n       5: invokevirtual #30                 // method setvalue:(ljava/util/date; 去调用我们重写的setvalue方法)v  \n       8: return  \n}\n\n\n从编译的结果来看，我们本意重写setvalue和getvalue方法的子类，竟然有4个方法，其实不用惊奇，最后的两个方法，就是编译器自己生成的桥方法。可以看到桥方法的参数类型都是object，也就是说，子类中真正覆盖父类两个方法的就是这两个我们看不到的桥方法。而打在我们自己定义的setvalue和getvalue方法上面的@oveerride只不过是假象。而桥方法的内部实现，就只是去调用我们自己重写的那两个方法。\n\n所以，虚拟机巧妙的使用了桥方法，来解决了类型擦除和多态的冲突。\n\n不过，要提到一点，这里面的setvalue和getvalue这两个桥方法的意义又有不同。\n\nsetvalue方法是为了解决类型擦除与多态之间的冲突。\n\n而getvalue却有普遍的意义，怎么说呢，如果这是一个普通的继承关系：\n\n那么父类的getvalue方法如下：\n\npublic object getvalue() {  \n    return super.getvalue();  \n}\n\n\n而子类重写的方法是：\n\npublic date getvalue() {  \n    return super.getvalue();  \n}\n\n\n其实这在普通的类继承中也是普遍存在的重写，这就是协变。\n\n并且，还有一点也许会有疑问，子类中的桥方法object getvalue()和date getvalue()是同时存在的，可是如果是常规的两个方法，他们的方法签名是一样的，也就是说虚拟机根本不能分别这两个方法。如果是我们自己编写java代码，这样的代码是无法通过编译器的检查的，但是虚拟机却是允许这样做的，因为虚拟机通过参数类型和返回类型来确定一个方法，所以编译器为了实现泛型的多态允许自己做这个看起来“不合法”的事情，然后交给虚拟器去区别。\n\n\n# 如何理解基本类型不能作为泛型类型？\n\n> 比如，我们没有arraylist<int>，只有arraylist<integer>, 为何？\n\n因为当类型擦除后，arraylist的原始类型变为object，但是object类型不能存储int值，只能引用integer的值。\n\n另外需要注意，我们能够使用list.add(1)是因为java基础类型的自动装箱拆箱操作。\n\n\n# 如何理解泛型类型不能实例化？\n\n> 不能实例化泛型类型, 这本质上是由于类型擦除决定的：\n\n我们可以看到如下代码会在编译器中报错：\n\nt test = new t(); // error\n\n\n因为在 java 编译期没法确定泛型参数化类型，也就找不到对应的类字节码文件，所以自然就不行了，此外由于t 被擦除为 object，如果可以 new t() 则就变成了 new object()，失去了本意。     如果我们确实需要实例化一个泛型，应该如何做呢？可以通过反射实现：\n\nstatic <t> t newtclass (class < t > clazz) throws instantiationexception, illegalaccessexception {\n    t obj = clazz.newinstance();\n    return obj;\n}\n\n\n\n# 泛型数组：能不能采用具体的泛型类型进行初始化？\n\n我们先来看下oracle官网提供的一个例子：\n\nlist<string>[] lsa = new list<string>[10]; // not really allowed.\nobject o = lsa;\nobject[] oa = (object[]) o;\nlist<integer> li = new arraylist<integer>();\nli.add(new integer(3));\noa[1] = li; // unsound, but passes run time store check\nstring s = lsa[1].get(0); // run-time error classcastexception.\n\n\n由于 jvm 泛型的擦除机制，所以上面代码可以给 oa[1] 赋值为 arraylist 也不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现 classcastexception，如果可以进行泛型数组的声明则上面说的这种情况在编译期不会出现任何警告和错误，只有在运行时才会出错，但是泛型的出现就是为了消灭 classcastexception，所以如果 java 支持泛型数组初始化操作就是搬起石头砸自己的脚。\n\n而对于下面的代码来说是成立的：\n\nlist<?>[] lsa = new list<?>[10]; // ok, array of unbounded wildcard type.\nobject o = lsa;\nobject[] oa = (object[]) o;\nlist<integer> li = new arraylist<integer>();\nli.add(new integer(3));\noa[1] = li; // correct.\ninteger i = (integer) lsa[1].get(0); // ok\n\n\n所以说采用通配符的方式初始化泛型数组是允许的，因为对于通配符的方式最后取出数据是要做显式类型转换的，符合预期逻辑。综述就是说java 的泛型数组初始化时数组类型不能是具体的泛型类型，只能是通配符的形式，因为具体类型会导致可存入任意类型对象，在取出时会发生类型转换异常，会与泛型的设计思想冲突，而通配符形式本来就需要自己强转，符合预期。\n\noracle 官方文档：https://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html在新窗口打开\n\n更进一步的，我们看看如下的代码：\n\nlist<string>[] list11 = new arraylist<string>[10]; //编译错误，非法创建 \nlist<string>[] list12 = new arraylist<?>[10]; //编译错误，需要强转类型 \nlist<string>[] list13 = (list<string>[]) new arraylist<?>[10]; //ok，但是会有警告 \nlist<?>[] list14 = new arraylist<string>[10]; //编译错误，非法创建 \nlist<?>[] list15 = new arraylist<?>[10]; //ok \nlist<string>[] list6 = new arraylist[10]; //ok，但是会有警告\n\n\n因为在 java 中是不能创建一个确切的泛型类型的数组的，除非是采用通配符的方式且要做显式类型转换才可以。\n\n\n# 泛型数组：如何正确的初始化泛型数组实例？\n\n> 这个无论我们通过new arraylist[10] 的形式还是通过泛型通配符的形式初始化泛型数组实例都是存在警告的，也就是说仅仅语法合格，运行时潜在的风险需要我们自己来承担，因此那些方式初始化泛型数组都不是最优雅的方式。\n\n我们在使用到泛型数组的场景下应该尽量使用列表集合替换，此外也可以通过使用 java.lang.reflect.array.newinstance(class<t> componenttype, int length) 方法来创建一个具有指定类型和维度的数组，如下：\n\npublic class arraywithtypetoken<t> {\n    private t[] array;\n\n    public arraywithtypetoken(class<t> type, int size) {\n        array = (t[]) array.newinstance(type, size);\n    }\n\n    public void put(int index, t item) {\n        array[index] = item;\n    }\n\n    public t get(int index) {\n        return array[index];\n    }\n\n    public t[] create() {\n        return array;\n    }\n}\n//...\n\narraywithtypetoken<integer> arraytoken = new arraywithtypetoken<integer>(integer.class, 100);\ninteger[] array = arraytoken.create();\n\n\n所以使用反射来初始化泛型数组算是优雅实现，因为泛型类型 t在运行时才能被确定下来，我们能创建泛型数组也必然是在 java 运行时想办法，而运行时能起作用的技术最好的就是反射了。\n\n\n# 如何理解泛型类中的静态方法和静态变量？\n\n> 泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数\n\n举例说明：\n\npublic class test2<t> {    \n    public static t one;   //编译错误    \n    public static  t show(t one){ //编译错误    \n        return null;    \n    }    \n}\n\n\n因为泛型类中的泛型参数的实例化是在定义对象的时候指定的，而静态变量和静态方法不需要使用对象来调用。对象都没有创建，如何确定这个泛型参数是何种类型，所以当然是错误的。\n\n但是要注意区分下面的一种情况：\n\npublic class test2<t> {    \n\n    public static <t >t show(t one){ //这是正确的    \n        return null;    \n    }    \n}\n\n\n因为这是一个泛型方法，在泛型方法中使用的t是自己在方法中定义的 t，而不是泛型类中的t。\n\n\n# 如何理解异常中使用泛型？\n\n * 不能抛出也不能捕获泛型类的对象。事实上，泛型类扩展throwable都不合法。例如：下面的定义将不会通过编译：\n\npublic class problem<t> extends exception {\n\n}\n\n\n为什么不能扩展throwable，因为异常都是在运行时捕获和抛出的，而在编译的时候，泛型信息全都会被擦除掉，那么，假设上面的编译可行，那么，在看下面的定义：\n\ntry{\n\n} catch(problem<integer> e1) {\n\n} catch(problem<number> e2) {\n\n} \n\n\n类型信息被擦除后，那么两个地方的catch都变为原始类型object，那么也就是说，这两个地方的catch变的一模一样,就相当于下面的这样\n\ntry{\n\n} catch(problem<object> e1) {\n\n} catch(problem<object> e2) {\n\n}\n\n\n这个当然就是不行的。\n\n * 不能再catch子句中使用泛型变量\n\npublic static <t extends throwable> void dowork(class<t> t) {\n    try {\n        ...\n    } catch(t e) { //编译错误\n        ...\n    }\n}\n\n\n因为泛型信息在编译的时候已经变为原始类型，也就是说上面的t会变为原始类型throwable，那么如果可以再catch子句中使用泛型变量，那么，下面的定义呢：\n\npublic static <t extends throwable> void dowork(class<t> t){\n    try {\n\n    } catch(t e) { //编译错误\n\n    } catch(indexoutofbounds e) {\n\n    }                         \n}\n\n\n根据异常捕获的原则，一定是子类在前面，父类在后面，那么上面就违背了这个原则。即使你在使用该静态方法的使用t是arrayindexoutofbounds，在编译之后还是会变成throwable，arrayindexoutofbounds是indexoutofbounds的子类，违背了异常捕获的原则。所以java为了避免这样的情况，禁止在catch子句中使用泛型变量。\n\n * 但是在异常声明中可以使用类型变量。下面方法是合法的。\n\npublic static<t extends throwable> void dowork(t t) throws t {\n    try{\n        ...\n    } catch(throwable realcause) {\n        t.initcause(realcause);\n        throw t; \n    }\n}\n\n\n上面的这样使用是没问题的。\n\n\n# 如何获取泛型的参数类型？\n\n> 既然类型被擦除了，那么如何获取泛型的参数类型呢？可以通过反射（java.lang.reflect.type）获取泛型\n\njava.lang.reflect.type是java中所有类型的公共高级接口, 代表了java中的所有类型. type体系中类型的包括：数组类型(genericarraytype)、参数化类型(parameterizedtype)、类型变量(typevariable)、通配符类型(wildcardtype)、原始类型(class)、基本类型(class), 以上这些类型都实现type接口。\n\npublic class generictype<t> {\n    private t data;\n\n    public t getdata() {\n        return data;\n    }\n\n    public void setdata(t data) {\n        this.data = data;\n    }\n\n    public static void main(string[] args) {\n        generictype<string> generictype = new generictype<string>() {};\n        type superclass = generictype.getclass().getgenericsuperclass();\n        //getactualtypearguments 返回确切的泛型参数, 如map<string, integer>返回[string, integer]\n        type type = ((parameterizedtype) superclass).getactualtypearguments()[0]; \n        system.out.println(type);//class java.lang.string\n    }\n}\n\n\n其中 parameterizedtype:\n\npublic interface parameterizedtype extends type {\n    // 返回确切的泛型参数, 如map<string, integer>返回[string, integer]\n    type[] getactualtypearguments();\n    \n    //返回当前class或interface声明的类型, 如list<?>返回list\n    type getrawtype();\n    \n    //返回所属类型. 如,当前类型为o<t>.i<s>, 则返回o<t>. 顶级类型将返回null \n    type getownertype();\n}\n\n\n\n# 参考文章\n\n> 泛型作为java基础知识点之一，网上知识点比较多也比较散，本文主要综合了网络上比较好的文章，方便你快速学习。（以下是一部分我参考的链接）\n\n * https://blog.csdn.net/sunxianghuang/article/details/51982979\n * https://blog.csdn.net/lonelyroamer/article/details/7868820\n * https://docs.oracle.com/javase/tutorial/extra/generics/index.html\n * https://blog.csdn.net/s10461/article/details/53941091\n * https://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html\n * https://www.cnblogs.com/rudy-laura/articles/3391013.html\n * https://www.jianshu.com/p/986f732ed2f1\n * https://blog.csdn.net/u011240877/article/details/53545041\n * 转载 https://www.pdai.tech/md/java/basic/java-basic-x-generic.html',charsets:{cjk:!0}},{title:"Collection - LinkedList源码解析",frontmatter:{},regularPath:"/java/collection/java-collection-LinkedList.html",relativePath:"java/collection/java-collection-LinkedList.md",key:"v-a5a02d48",path:"/java/collection/java-collection-LinkedList.html",headers:[{level:2,title:"Collection - LinkedList源码解析",slug:"collection-linkedlist源码解析",normalizedTitle:"collection - linkedlist源码解析",charIndex:2},{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:106},{level:2,title:"LinkedList实现",slug:"linkedlist实现",normalizedTitle:"linkedlist实现",charIndex:114},{level:3,title:"底层数据结构",slug:"底层数据结构",normalizedTitle:"底层数据结构",charIndex:134},{level:3,title:"构造函数",slug:"构造函数",normalizedTitle:"构造函数",charIndex:148},{level:3,title:"getFirst(), getLast()",slug:"getfirst-getlast",normalizedTitle:"getfirst(), getlast()",charIndex:160},{level:3,title:"removeFirst(), removeLast(), remove(e), remove(index)",slug:"removefirst-removelast-remove-e-remove-index",normalizedTitle:"removefirst(), removelast(), remove(e), remove(index)",charIndex:189},{level:3,title:"add()",slug:"add",normalizedTitle:"add()",charIndex:250},{level:3,title:"addAll()",slug:"addall",normalizedTitle:"addall()",charIndex:263},{level:3,title:"clear()",slug:"clear",normalizedTitle:"clear()",charIndex:279},{level:3,title:"Positional Access 方法",slug:"positional-access-方法",normalizedTitle:"positional access 方法",charIndex:294},{level:3,title:"查找操作",slug:"查找操作",normalizedTitle:"查找操作",charIndex:322},{level:3,title:"Queue 方法",slug:"queue-方法",normalizedTitle:"queue 方法",charIndex:334},{level:3,title:"Deque 方法",slug:"deque-方法",normalizedTitle:"deque 方法",charIndex:350},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:364}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Collection - LinkedList源码解析 概述 LinkedList实现 底层数据结构 构造函数 getFirst(), getLast() removeFirst(), removeLast(), remove(e), remove(index) add() addAll() clear() Positional Access 方法 查找操作 Queue 方法 Deque 方法 参考",content:'# Collection - LinkedList源码解析\n\n> 本文主要对Collection - LinkedList进行源码解析。\n\n * Collection - LinkedList源码解析\n   * 概述\n   * LinkedList实现\n     * 底层数据结构\n     * 构造函数\n     * getFirst(), getLast()\n     * removeFirst(), removeLast(), remove(e), remove(index)\n     * add()\n     * addAll()\n     * clear()\n     * Positional Access 方法\n     * 查找操作\n     * Queue 方法\n     * Deque 方法\n   * 参考\n\n\n# 概述\n\nLinkedList_同时实现了_List_接口和_Deque_接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列(Queue)，同时又可以看作一个栈(Stack)。这样看来，LinkedList_简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用_LinkedList，一方面是因为Java官方已经声明不建议使用_Stack_类，更遗憾的是，Java里根本没有一个叫做_Queue_的类(它是个接口名字)。关于栈或队列，现在的首选是_ArrayDeque，它有着比_LinkedList_(当作栈或队列使用时)有着更好的性能。\n\n\n\n_LinkedList_的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率_LinkedList_没有实现同步(synchronized)，如果需要多个线程并发访问，可以先采用Collections.synchronizedList()方法对其进行包装。\n\n\n# LinkedList实现\n\n\n# 底层数据结构\n\n_LinkedList_底层通过双向链表实现，本节将着重讲解插入和删除元素时双向链表的维护过程，也即是之间解跟_List_接口相关的函数，而将_Queue_和_Stack_以及_Deque_相关的知识放在下一节讲。双向链表的每个节点用内部类_Node_表示。_LinkedList_通过first和last引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候first和last都指向null。\n\n    transient int size = 0;\n\n    /**\n     * Pointer to first node.\n     * Invariant: (first == null && last == null) ||\n     *            (first.prev == null && first.item != null)\n     */\n    transient Node<E> first;\n\n    /**\n     * Pointer to last node.\n     * Invariant: (first == null && last == null) ||\n     *            (last.next == null && last.item != null)\n     */\n    transient Node<E> last;\n\n\n其中Node是私有的内部类:\n\n    private static class Node<E> {\n        E item;\n        Node<E> next;\n        Node<E> prev;\n\n        Node(Node<E> prev, E element, Node<E> next) {\n            this.item = element;\n            this.next = next;\n            this.prev = prev;\n        }\n    }\n\n\n\n# 构造函数\n\n    /**\n     * Constructs an empty list.\n     */\n    public LinkedList() {\n    }\n\n    /**\n     * Constructs a list containing the elements of the specified\n     * collection, in the order they are returned by the collection\'s\n     * iterator.\n     *\n     * @param  c the collection whose elements are to be placed into this list\n     * @throws NullPointerException if the specified collection is null\n     */\n    public LinkedList(Collection<? extends E> c) {\n        this();\n        addAll(c);\n    }\n\n\n\n# getFirst(), getLast()\n\n获取第一个元素， 和获取最后一个元素:\n\n    /**\n     * Returns the first element in this list.\n     *\n     * @return the first element in this list\n     * @throws NoSuchElementException if this list is empty\n     */\n    public E getFirst() {\n        final Node<E> f = first;\n        if (f == null)\n            throw new NoSuchElementException();\n        return f.item;\n    }\n\n    /**\n     * Returns the last element in this list.\n     *\n     * @return the last element in this list\n     * @throws NoSuchElementException if this list is empty\n     */\n    public E getLast() {\n        final Node<E> l = last;\n        if (l == null)\n            throw new NoSuchElementException();\n        return l.item;\n    }\n\n\n\n# removeFirst(), removeLast(), remove(e), remove(index)\n\nremove()方法也有两个版本，一个是删除跟指定元素相等的第一个元素remove(Object o)，另一个是删除指定下标处的元素remove(int index)。\n\n\n\n删除元素 - 指的是删除第一次出现的这个元素, 如果没有这个元素，则返回false；判断的依据是equals方法， 如果equals，则直接unlink这个node；由于LinkedList可存放null元素，故也可以删除第一次出现null的元素；\n\n    /**\n     * Removes the first occurrence of the specified element from this list,\n     * if it is present.  If this list does not contain the element, it is\n     * unchanged.  More formally, removes the element with the lowest index\n     * {@code i} such that\n     * <tt>(o==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;o.equals(get(i)))</tt>\n     * (if such an element exists).  Returns {@code true} if this list\n     * contained the specified element (or equivalently, if this list\n     * changed as a result of the call).\n     *\n     * @param o element to be removed from this list, if present\n     * @return {@code true} if this list contained the specified element\n     */\n    public boolean remove(Object o) {\n        if (o == null) {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (x.item == null) {\n                    unlink(x);\n                    return true;\n                }\n            }\n        } else {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (o.equals(x.item)) {\n                    unlink(x);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    \n    /**\n     * Unlinks non-null node x.\n     */\n    E unlink(Node<E> x) {\n        // assert x != null;\n        final E element = x.item;\n        final Node<E> next = x.next;\n        final Node<E> prev = x.prev;\n\n        if (prev == null) {// 第一个元素\n            first = next;\n        } else {\n            prev.next = next;\n            x.prev = null;\n        }\n\n        if (next == null) {// 最后一个元素\n            last = prev;\n        } else {\n            next.prev = prev;\n            x.next = null;\n        }\n\n        x.item = null; // GC\n        size--;\n        modCount++;\n        return element;\n    }\n\n\nremove(int index)使用的是下标计数， 只需要判断该index是否有元素即可，如果有则直接unlink这个node。\n\n    /**\n     * Removes the element at the specified position in this list.  Shifts any\n     * subsequent elements to the left (subtracts one from their indices).\n     * Returns the element that was removed from the list.\n     *\n     * @param index the index of the element to be removed\n     * @return the element previously at the specified position\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public E remove(int index) {\n        checkElementIndex(index);\n        return unlink(node(index));\n    }\n\n\n删除head元素:\n\n    /**\n     * Removes and returns the first element from this list.\n     *\n     * @return the first element from this list\n     * @throws NoSuchElementException if this list is empty\n     */\n    public E removeFirst() {\n        final Node<E> f = first;\n        if (f == null)\n            throw new NoSuchElementException();\n        return unlinkFirst(f);\n    }\n\n\n    /**\n     * Unlinks non-null first node f.\n     */\n    private E unlinkFirst(Node<E> f) {\n        // assert f == first && f != null;\n        final E element = f.item;\n        final Node<E> next = f.next;\n        f.item = null;\n        f.next = null; // help GC\n        first = next;\n        if (next == null)\n            last = null;\n        else\n            next.prev = null;\n        size--;\n        modCount++;\n        return element;\n    }\n\n\n删除last元素:\n\n/**\n     * Removes and returns the last element from this list.\n     *\n     * @return the last element from this list\n     * @throws NoSuchElementException if this list is empty\n     */\n    public E removeLast() {\n        final Node<E> l = last;\n        if (l == null)\n            throw new NoSuchElementException();\n        return unlinkLast(l);\n    }\n    \n    /**\n     * Unlinks non-null last node l.\n     */\n    private E unlinkLast(Node<E> l) {\n        // assert l == last && l != null;\n        final E element = l.item;\n        final Node<E> prev = l.prev;\n        l.item = null;\n        l.prev = null; // help GC\n        last = prev;\n        if (prev == null)\n            first = null;\n        else\n            prev.next = null;\n        size--;\n        modCount++;\n        return element;\n    }\n\n\n\n\n\n# add()\n\n_add()_方法有两个版本，一个是add(E e)，该方法在_LinkedList_的末尾插入元素，因为有last指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是add(int index, E element)，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。\n\n    /**\n     * Appends the specified element to the end of this list.\n     *\n     * <p>This method is equivalent to {@link #addLast}.\n     *\n     * @param e element to be appended to this list\n     * @return {@code true} (as specified by {@link Collection#add})\n     */\n    public boolean add(E e) {\n        linkLast(e);\n        return true;\n    }\n    \n    /**\n     * Links e as last element.\n     */\n    void linkLast(E e) {\n        final Node<E> l = last;\n        final Node<E> newNode = new Node<>(l, e, null);\n        last = newNode;\n        if (l == null)\n            first = newNode;\n        else\n            l.next = newNode;\n        size++;\n        modCount++;\n    }\n\n\n\n\nadd(int index, E element), 当index==size时，等同于add(E e); 如果不是，则分两步: 1.先根据index找到要插入的位置,即node(index)方法；2.修改引用，完成插入操作。\n\n    /**\n     * Inserts the specified element at the specified position in this list.\n     * Shifts the element currently at that position (if any) and any\n     * subsequent elements to the right (adds one to their indices).\n     *\n     * @param index index at which the specified element is to be inserted\n     * @param element element to be inserted\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public void add(int index, E element) {\n        checkPositionIndex(index);\n\n        if (index == size)\n            linkLast(element);\n        else\n            linkBefore(element, node(index));\n    }\n\n\n上面代码中的node(int index)函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件index < (size >> 1)，也即是index是靠近前端还是后端。从这里也可以看出，linkedList通过index检索元素的效率没有arrayList高。\n\n    /**\n     * Returns the (non-null) Node at the specified element index.\n     */\n    Node<E> node(int index) {\n        // assert isElementIndex(index);\n\n        if (index < (size >> 1)) {\n            Node<E> x = first;\n            for (int i = 0; i < index; i++)\n                x = x.next;\n            return x;\n        } else {\n            Node<E> x = last;\n            for (int i = size - 1; i > index; i--)\n                x = x.prev;\n            return x;\n        }\n    }\n\n\n\n# addAll()\n\naddAll(index, c) 实现方式并不是直接调用add(index,e)来实现，主要是因为效率的问题，另一个是fail-fast中modCount只会增加1次；\n\n    /**\n     * Appends all of the elements in the specified collection to the end of\n     * this list, in the order that they are returned by the specified\n     * collection\'s iterator.  The behavior of this operation is undefined if\n     * the specified collection is modified while the operation is in\n     * progress.  (Note that this will occur if the specified collection is\n     * this list, and it\'s nonempty.)\n     *\n     * @param c collection containing elements to be added to this list\n     * @return {@code true} if this list changed as a result of the call\n     * @throws NullPointerException if the specified collection is null\n     */\n    public boolean addAll(Collection<? extends E> c) {\n        return addAll(size, c);\n    }\n\n    /**\n     * Inserts all of the elements in the specified collection into this\n     * list, starting at the specified position.  Shifts the element\n     * currently at that position (if any) and any subsequent elements to\n     * the right (increases their indices).  The new elements will appear\n     * in the list in the order that they are returned by the\n     * specified collection\'s iterator.\n     *\n     * @param index index at which to insert the first element\n     *              from the specified collection\n     * @param c collection containing elements to be added to this list\n     * @return {@code true} if this list changed as a result of the call\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     * @throws NullPointerException if the specified collection is null\n     */\n    public boolean addAll(int index, Collection<? extends E> c) {\n        checkPositionIndex(index);\n\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        if (numNew == 0)\n            return false;\n\n        Node<E> pred, succ;\n        if (index == size) {\n            succ = null;\n            pred = last;\n        } else {\n            succ = node(index);\n            pred = succ.prev;\n        }\n\n        for (Object o : a) {\n            @SuppressWarnings("unchecked") E e = (E) o;\n            Node<E> newNode = new Node<>(pred, e, null);\n            if (pred == null)\n                first = newNode;\n            else\n                pred.next = newNode;\n            pred = newNode;\n        }\n\n        if (succ == null) {\n            last = pred;\n        } else {\n            pred.next = succ;\n            succ.prev = pred;\n        }\n\n        size += numNew;\n        modCount++;\n        return true;\n    }\n\n\n\n# clear()\n\n为了让GC更快可以回收放置的元素，需要将node之间的引用关系赋空。\n\n    /**\n     * Removes all of the elements from this list.\n     * The list will be empty after this call returns.\n     */\n    public void clear() {\n        // Clearing all of the links between nodes is "unnecessary", but:\n        // - helps a generational GC if the discarded nodes inhabit\n        //   more than one generation\n        // - is sure to free memory even if there is a reachable Iterator\n        for (Node<E> x = first; x != null; ) {\n            Node<E> next = x.next;\n            x.item = null;\n            x.next = null;\n            x.prev = null;\n            x = next;\n        }\n        first = last = null;\n        size = 0;\n        modCount++;\n    }\n\n\n\n# Positional Access 方法\n\n通过index获取元素\n\n    /**\n     * Returns the element at the specified position in this list.\n     *\n     * @param index index of the element to return\n     * @return the element at the specified position in this list\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public E get(int index) {\n        checkElementIndex(index);\n        return node(index).item;\n    }\n\n\n将某个位置的元素重新赋值:\n\n    /**\n     * Replaces the element at the specified position in this list with the\n     * specified element.\n     *\n     * @param index index of the element to replace\n     * @param element element to be stored at the specified position\n     * @return the element previously at the specified position\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public E set(int index, E element) {\n        checkElementIndex(index);\n        Node<E> x = node(index);\n        E oldVal = x.item;\n        x.item = element;\n        return oldVal;\n    }\n\n\n将元素插入到指定index位置:\n\n    /**\n     * Inserts the specified element at the specified position in this list.\n     * Shifts the element currently at that position (if any) and any\n     * subsequent elements to the right (adds one to their indices).\n     *\n     * @param index index at which the specified element is to be inserted\n     * @param element element to be inserted\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public void add(int index, E element) {\n        checkPositionIndex(index);\n\n        if (index == size)\n            linkLast(element);\n        else\n            linkBefore(element, node(index));\n    }\n\n\n删除指定位置的元素:\n\n    /**\n     * Removes the element at the specified position in this list.  Shifts any\n     * subsequent elements to the left (subtracts one from their indices).\n     * Returns the element that was removed from the list.\n     *\n     * @param index the index of the element to be removed\n     * @return the element previously at the specified position\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public E remove(int index) {\n        checkElementIndex(index);\n        return unlink(node(index));\n    }\n\n\n其它位置的方法:\n\n\n\n    /**\n     * Tells if the argument is the index of an existing element.\n     */\n    private boolean isElementIndex(int index) {\n        return index >= 0 && index < size;\n    }\n\n    /**\n     * Tells if the argument is the index of a valid position for an\n     * iterator or an add operation.\n     */\n    private boolean isPositionIndex(int index) {\n        return index >= 0 && index <= size;\n    }\n\n    /**\n     * Constructs an IndexOutOfBoundsException detail message.\n     * Of the many possible refactorings of the error handling code,\n     * this "outlining" performs best with both server and client VMs.\n     */\n    private String outOfBoundsMsg(int index) {\n        return "Index: "+index+", Size: "+size;\n    }\n\n    private void checkElementIndex(int index) {\n        if (!isElementIndex(index))\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n    }\n\n    private void checkPositionIndex(int index) {\n        if (!isPositionIndex(index))\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n    }\n\n\n\n# 查找操作\n\n查找操作的本质是查找元素的下标:\n\n查找第一次出现的index, 如果找不到返回-1；\n\n    /**\n     * Returns the index of the first occurrence of the specified element\n     * in this list, or -1 if this list does not contain the element.\n     * More formally, returns the lowest index {@code i} such that\n     * <tt>(o==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;o.equals(get(i)))</tt>,\n     * or -1 if there is no such index.\n     *\n     * @param o element to search for\n     * @return the index of the first occurrence of the specified element in\n     *         this list, or -1 if this list does not contain the element\n     */\n    public int indexOf(Object o) {\n        int index = 0;\n        if (o == null) {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (x.item == null)\n                    return index;\n                index++;\n            }\n        } else {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (o.equals(x.item))\n                    return index;\n                index++;\n            }\n        }\n        return -1;\n    }\n\n\n查找最后一次出现的index, 如果找不到返回-1；\n\n    /**\n     * Returns the index of the last occurrence of the specified element\n     * in this list, or -1 if this list does not contain the element.\n     * More formally, returns the highest index {@code i} such that\n     * <tt>(o==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;o.equals(get(i)))</tt>,\n     * or -1 if there is no such index.\n     *\n     * @param o element to search for\n     * @return the index of the last occurrence of the specified element in\n     *         this list, or -1 if this list does not contain the element\n     */\n    public int lastIndexOf(Object o) {\n        int index = size;\n        if (o == null) {\n            for (Node<E> x = last; x != null; x = x.prev) {\n                index--;\n                if (x.item == null)\n                    return index;\n            }\n        } else {\n            for (Node<E> x = last; x != null; x = x.prev) {\n                index--;\n                if (o.equals(x.item))\n                    return index;\n            }\n        }\n        return -1;\n    }\n\n\n\n# Queue 方法\n\n   \n    /**\n     * Retrieves, but does not remove, the head (first element) of this list.\n     *\n     * @return the head of this list, or {@code null} if this list is empty\n     * @since 1.5\n     */\n    public E peek() {\n        final Node<E> f = first;\n        return (f == null) ? null : f.item;\n    }\n\n    /**\n     * Retrieves, but does not remove, the head (first element) of this list.\n     *\n     * @return the head of this list\n     * @throws NoSuchElementException if this list is empty\n     * @since 1.5\n     */\n    public E element() {\n        return getFirst();\n    }\n\n    /**\n     * Retrieves and removes the head (first element) of this list.\n     *\n     * @return the head of this list, or {@code null} if this list is empty\n     * @since 1.5\n     */\n    public E poll() {\n        final Node<E> f = first;\n        return (f == null) ? null : unlinkFirst(f);\n    }\n\n    /**\n     * Retrieves and removes the head (first element) of this list.\n     *\n     * @return the head of this list\n     * @throws NoSuchElementException if this list is empty\n     * @since 1.5\n     */\n    public E remove() {\n        return removeFirst();\n    }\n\n    /**\n     * Adds the specified element as the tail (last element) of this list.\n     *\n     * @param e the element to add\n     * @return {@code true} (as specified by {@link Queue#offer})\n     * @since 1.5\n     */\n    public boolean offer(E e) {\n        return add(e);\n    }\n\n\n\n# Deque 方法\n\n    /**\n     * Inserts the specified element at the front of this list.\n     *\n     * @param e the element to insert\n     * @return {@code true} (as specified by {@link Deque#offerFirst})\n     * @since 1.6\n     */\n    public boolean offerFirst(E e) {\n        addFirst(e);\n        return true;\n    }\n\n    /**\n     * Inserts the specified element at the end of this list.\n     *\n     * @param e the element to insert\n     * @return {@code true} (as specified by {@link Deque#offerLast})\n     * @since 1.6\n     */\n    public boolean offerLast(E e) {\n        addLast(e);\n        return true;\n    }\n\n    /**\n     * Retrieves, but does not remove, the first element of this list,\n     * or returns {@code null} if this list is empty.\n     *\n     * @return the first element of this list, or {@code null}\n     *         if this list is empty\n     * @since 1.6\n     */\n    public E peekFirst() {\n        final Node<E> f = first;\n        return (f == null) ? null : f.item;\n     }\n\n    /**\n     * Retrieves, but does not remove, the last element of this list,\n     * or returns {@code null} if this list is empty.\n     *\n     * @return the last element of this list, or {@code null}\n     *         if this list is empty\n     * @since 1.6\n     */\n    public E peekLast() {\n        final Node<E> l = last;\n        return (l == null) ? null : l.item;\n    }\n\n    /**\n     * Retrieves and removes the first element of this list,\n     * or returns {@code null} if this list is empty.\n     *\n     * @return the first element of this list, or {@code null} if\n     *     this list is empty\n     * @since 1.6\n     */\n    public E pollFirst() {\n        final Node<E> f = first;\n        return (f == null) ? null : unlinkFirst(f);\n    }\n\n    /**\n     * Retrieves and removes the last element of this list,\n     * or returns {@code null} if this list is empty.\n     *\n     * @return the last element of this list, or {@code null} if\n     *     this list is empty\n     * @since 1.6\n     */\n    public E pollLast() {\n        final Node<E> l = last;\n        return (l == null) ? null : unlinkLast(l);\n    }\n\n    /**\n     * Pushes an element onto the stack represented by this list.  In other\n     * words, inserts the element at the front of this list.\n     *\n     * <p>This method is equivalent to {@link #addFirst}.\n     *\n     * @param e the element to push\n     * @since 1.6\n     */\n    public void push(E e) {\n        addFirst(e);\n    }\n\n    /**\n     * Pops an element from the stack represented by this list.  In other\n     * words, removes and returns the first element of this list.\n     *\n     * <p>This method is equivalent to {@link #removeFirst()}.\n     *\n     * @return the element at the front of this list (which is the top\n     *         of the stack represented by this list)\n     * @throws NoSuchElementException if this list is empty\n     * @since 1.6\n     */\n    public E pop() {\n        return removeFirst();\n    }\n\n    /**\n     * Removes the first occurrence of the specified element in this\n     * list (when traversing the list from head to tail).  If the list\n     * does not contain the element, it is unchanged.\n     *\n     * @param o element to be removed from this list, if present\n     * @return {@code true} if the list contained the specified element\n     * @since 1.6\n     */\n    public boolean removeFirstOccurrence(Object o) {\n        return remove(o);\n    }\n\n    /**\n     * Removes the last occurrence of the specified element in this\n     * list (when traversing the list from head to tail).  If the list\n     * does not contain the element, it is unchanged.\n     *\n     * @param o element to be removed from this list, if present\n     * @return {@code true} if the list contained the specified element\n     * @since 1.6\n     */\n    public boolean removeLastOccurrence(Object o) {\n        if (o == null) {\n            for (Node<E> x = last; x != null; x = x.prev) {\n                if (x.item == null) {\n                    unlink(x);\n                    return true;\n                }\n            }\n        } else {\n            for (Node<E> x = last; x != null; x = x.prev) {\n                if (o.equals(x.item)) {\n                    unlink(x);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n\n\n# 参考\n\n * Java LinkedList源码剖析 结合源码对LinkedList进行讲解 http://www.cnblogs.com/CarpenterLee/p/5457150.html\n * 转载 https://www.pdai.tech/md/java/collection/java-collection-LinkedList.html',normalizedContent:'# collection - linkedlist源码解析\n\n> 本文主要对collection - linkedlist进行源码解析。\n\n * collection - linkedlist源码解析\n   * 概述\n   * linkedlist实现\n     * 底层数据结构\n     * 构造函数\n     * getfirst(), getlast()\n     * removefirst(), removelast(), remove(e), remove(index)\n     * add()\n     * addall()\n     * clear()\n     * positional access 方法\n     * 查找操作\n     * queue 方法\n     * deque 方法\n   * 参考\n\n\n# 概述\n\nlinkedlist_同时实现了_list_接口和_deque_接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列(queue)，同时又可以看作一个栈(stack)。这样看来，linkedlist_简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用_linkedlist，一方面是因为java官方已经声明不建议使用_stack_类，更遗憾的是，java里根本没有一个叫做_queue_的类(它是个接口名字)。关于栈或队列，现在的首选是_arraydeque，它有着比_linkedlist_(当作栈或队列使用时)有着更好的性能。\n\n\n\n_linkedlist_的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率_linkedlist_没有实现同步(synchronized)，如果需要多个线程并发访问，可以先采用collections.synchronizedlist()方法对其进行包装。\n\n\n# linkedlist实现\n\n\n# 底层数据结构\n\n_linkedlist_底层通过双向链表实现，本节将着重讲解插入和删除元素时双向链表的维护过程，也即是之间解跟_list_接口相关的函数，而将_queue_和_stack_以及_deque_相关的知识放在下一节讲。双向链表的每个节点用内部类_node_表示。_linkedlist_通过first和last引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候first和last都指向null。\n\n    transient int size = 0;\n\n    /**\n     * pointer to first node.\n     * invariant: (first == null && last == null) ||\n     *            (first.prev == null && first.item != null)\n     */\n    transient node<e> first;\n\n    /**\n     * pointer to last node.\n     * invariant: (first == null && last == null) ||\n     *            (last.next == null && last.item != null)\n     */\n    transient node<e> last;\n\n\n其中node是私有的内部类:\n\n    private static class node<e> {\n        e item;\n        node<e> next;\n        node<e> prev;\n\n        node(node<e> prev, e element, node<e> next) {\n            this.item = element;\n            this.next = next;\n            this.prev = prev;\n        }\n    }\n\n\n\n# 构造函数\n\n    /**\n     * constructs an empty list.\n     */\n    public linkedlist() {\n    }\n\n    /**\n     * constructs a list containing the elements of the specified\n     * collection, in the order they are returned by the collection\'s\n     * iterator.\n     *\n     * @param  c the collection whose elements are to be placed into this list\n     * @throws nullpointerexception if the specified collection is null\n     */\n    public linkedlist(collection<? extends e> c) {\n        this();\n        addall(c);\n    }\n\n\n\n# getfirst(), getlast()\n\n获取第一个元素， 和获取最后一个元素:\n\n    /**\n     * returns the first element in this list.\n     *\n     * @return the first element in this list\n     * @throws nosuchelementexception if this list is empty\n     */\n    public e getfirst() {\n        final node<e> f = first;\n        if (f == null)\n            throw new nosuchelementexception();\n        return f.item;\n    }\n\n    /**\n     * returns the last element in this list.\n     *\n     * @return the last element in this list\n     * @throws nosuchelementexception if this list is empty\n     */\n    public e getlast() {\n        final node<e> l = last;\n        if (l == null)\n            throw new nosuchelementexception();\n        return l.item;\n    }\n\n\n\n# removefirst(), removelast(), remove(e), remove(index)\n\nremove()方法也有两个版本，一个是删除跟指定元素相等的第一个元素remove(object o)，另一个是删除指定下标处的元素remove(int index)。\n\n\n\n删除元素 - 指的是删除第一次出现的这个元素, 如果没有这个元素，则返回false；判断的依据是equals方法， 如果equals，则直接unlink这个node；由于linkedlist可存放null元素，故也可以删除第一次出现null的元素；\n\n    /**\n     * removes the first occurrence of the specified element from this list,\n     * if it is present.  if this list does not contain the element, it is\n     * unchanged.  more formally, removes the element with the lowest index\n     * {@code i} such that\n     * <tt>(o==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;o.equals(get(i)))</tt>\n     * (if such an element exists).  returns {@code true} if this list\n     * contained the specified element (or equivalently, if this list\n     * changed as a result of the call).\n     *\n     * @param o element to be removed from this list, if present\n     * @return {@code true} if this list contained the specified element\n     */\n    public boolean remove(object o) {\n        if (o == null) {\n            for (node<e> x = first; x != null; x = x.next) {\n                if (x.item == null) {\n                    unlink(x);\n                    return true;\n                }\n            }\n        } else {\n            for (node<e> x = first; x != null; x = x.next) {\n                if (o.equals(x.item)) {\n                    unlink(x);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    \n    /**\n     * unlinks non-null node x.\n     */\n    e unlink(node<e> x) {\n        // assert x != null;\n        final e element = x.item;\n        final node<e> next = x.next;\n        final node<e> prev = x.prev;\n\n        if (prev == null) {// 第一个元素\n            first = next;\n        } else {\n            prev.next = next;\n            x.prev = null;\n        }\n\n        if (next == null) {// 最后一个元素\n            last = prev;\n        } else {\n            next.prev = prev;\n            x.next = null;\n        }\n\n        x.item = null; // gc\n        size--;\n        modcount++;\n        return element;\n    }\n\n\nremove(int index)使用的是下标计数， 只需要判断该index是否有元素即可，如果有则直接unlink这个node。\n\n    /**\n     * removes the element at the specified position in this list.  shifts any\n     * subsequent elements to the left (subtracts one from their indices).\n     * returns the element that was removed from the list.\n     *\n     * @param index the index of the element to be removed\n     * @return the element previously at the specified position\n     * @throws indexoutofboundsexception {@inheritdoc}\n     */\n    public e remove(int index) {\n        checkelementindex(index);\n        return unlink(node(index));\n    }\n\n\n删除head元素:\n\n    /**\n     * removes and returns the first element from this list.\n     *\n     * @return the first element from this list\n     * @throws nosuchelementexception if this list is empty\n     */\n    public e removefirst() {\n        final node<e> f = first;\n        if (f == null)\n            throw new nosuchelementexception();\n        return unlinkfirst(f);\n    }\n\n\n    /**\n     * unlinks non-null first node f.\n     */\n    private e unlinkfirst(node<e> f) {\n        // assert f == first && f != null;\n        final e element = f.item;\n        final node<e> next = f.next;\n        f.item = null;\n        f.next = null; // help gc\n        first = next;\n        if (next == null)\n            last = null;\n        else\n            next.prev = null;\n        size--;\n        modcount++;\n        return element;\n    }\n\n\n删除last元素:\n\n/**\n     * removes and returns the last element from this list.\n     *\n     * @return the last element from this list\n     * @throws nosuchelementexception if this list is empty\n     */\n    public e removelast() {\n        final node<e> l = last;\n        if (l == null)\n            throw new nosuchelementexception();\n        return unlinklast(l);\n    }\n    \n    /**\n     * unlinks non-null last node l.\n     */\n    private e unlinklast(node<e> l) {\n        // assert l == last && l != null;\n        final e element = l.item;\n        final node<e> prev = l.prev;\n        l.item = null;\n        l.prev = null; // help gc\n        last = prev;\n        if (prev == null)\n            first = null;\n        else\n            prev.next = null;\n        size--;\n        modcount++;\n        return element;\n    }\n\n\n\n\n\n# add()\n\n_add()_方法有两个版本，一个是add(e e)，该方法在_linkedlist_的末尾插入元素，因为有last指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是add(int index, e element)，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。\n\n    /**\n     * appends the specified element to the end of this list.\n     *\n     * <p>this method is equivalent to {@link #addlast}.\n     *\n     * @param e element to be appended to this list\n     * @return {@code true} (as specified by {@link collection#add})\n     */\n    public boolean add(e e) {\n        linklast(e);\n        return true;\n    }\n    \n    /**\n     * links e as last element.\n     */\n    void linklast(e e) {\n        final node<e> l = last;\n        final node<e> newnode = new node<>(l, e, null);\n        last = newnode;\n        if (l == null)\n            first = newnode;\n        else\n            l.next = newnode;\n        size++;\n        modcount++;\n    }\n\n\n\n\nadd(int index, e element), 当index==size时，等同于add(e e); 如果不是，则分两步: 1.先根据index找到要插入的位置,即node(index)方法；2.修改引用，完成插入操作。\n\n    /**\n     * inserts the specified element at the specified position in this list.\n     * shifts the element currently at that position (if any) and any\n     * subsequent elements to the right (adds one to their indices).\n     *\n     * @param index index at which the specified element is to be inserted\n     * @param element element to be inserted\n     * @throws indexoutofboundsexception {@inheritdoc}\n     */\n    public void add(int index, e element) {\n        checkpositionindex(index);\n\n        if (index == size)\n            linklast(element);\n        else\n            linkbefore(element, node(index));\n    }\n\n\n上面代码中的node(int index)函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件index < (size >> 1)，也即是index是靠近前端还是后端。从这里也可以看出，linkedlist通过index检索元素的效率没有arraylist高。\n\n    /**\n     * returns the (non-null) node at the specified element index.\n     */\n    node<e> node(int index) {\n        // assert iselementindex(index);\n\n        if (index < (size >> 1)) {\n            node<e> x = first;\n            for (int i = 0; i < index; i++)\n                x = x.next;\n            return x;\n        } else {\n            node<e> x = last;\n            for (int i = size - 1; i > index; i--)\n                x = x.prev;\n            return x;\n        }\n    }\n\n\n\n# addall()\n\naddall(index, c) 实现方式并不是直接调用add(index,e)来实现，主要是因为效率的问题，另一个是fail-fast中modcount只会增加1次；\n\n    /**\n     * appends all of the elements in the specified collection to the end of\n     * this list, in the order that they are returned by the specified\n     * collection\'s iterator.  the behavior of this operation is undefined if\n     * the specified collection is modified while the operation is in\n     * progress.  (note that this will occur if the specified collection is\n     * this list, and it\'s nonempty.)\n     *\n     * @param c collection containing elements to be added to this list\n     * @return {@code true} if this list changed as a result of the call\n     * @throws nullpointerexception if the specified collection is null\n     */\n    public boolean addall(collection<? extends e> c) {\n        return addall(size, c);\n    }\n\n    /**\n     * inserts all of the elements in the specified collection into this\n     * list, starting at the specified position.  shifts the element\n     * currently at that position (if any) and any subsequent elements to\n     * the right (increases their indices).  the new elements will appear\n     * in the list in the order that they are returned by the\n     * specified collection\'s iterator.\n     *\n     * @param index index at which to insert the first element\n     *              from the specified collection\n     * @param c collection containing elements to be added to this list\n     * @return {@code true} if this list changed as a result of the call\n     * @throws indexoutofboundsexception {@inheritdoc}\n     * @throws nullpointerexception if the specified collection is null\n     */\n    public boolean addall(int index, collection<? extends e> c) {\n        checkpositionindex(index);\n\n        object[] a = c.toarray();\n        int numnew = a.length;\n        if (numnew == 0)\n            return false;\n\n        node<e> pred, succ;\n        if (index == size) {\n            succ = null;\n            pred = last;\n        } else {\n            succ = node(index);\n            pred = succ.prev;\n        }\n\n        for (object o : a) {\n            @suppresswarnings("unchecked") e e = (e) o;\n            node<e> newnode = new node<>(pred, e, null);\n            if (pred == null)\n                first = newnode;\n            else\n                pred.next = newnode;\n            pred = newnode;\n        }\n\n        if (succ == null) {\n            last = pred;\n        } else {\n            pred.next = succ;\n            succ.prev = pred;\n        }\n\n        size += numnew;\n        modcount++;\n        return true;\n    }\n\n\n\n# clear()\n\n为了让gc更快可以回收放置的元素，需要将node之间的引用关系赋空。\n\n    /**\n     * removes all of the elements from this list.\n     * the list will be empty after this call returns.\n     */\n    public void clear() {\n        // clearing all of the links between nodes is "unnecessary", but:\n        // - helps a generational gc if the discarded nodes inhabit\n        //   more than one generation\n        // - is sure to free memory even if there is a reachable iterator\n        for (node<e> x = first; x != null; ) {\n            node<e> next = x.next;\n            x.item = null;\n            x.next = null;\n            x.prev = null;\n            x = next;\n        }\n        first = last = null;\n        size = 0;\n        modcount++;\n    }\n\n\n\n# positional access 方法\n\n通过index获取元素\n\n    /**\n     * returns the element at the specified position in this list.\n     *\n     * @param index index of the element to return\n     * @return the element at the specified position in this list\n     * @throws indexoutofboundsexception {@inheritdoc}\n     */\n    public e get(int index) {\n        checkelementindex(index);\n        return node(index).item;\n    }\n\n\n将某个位置的元素重新赋值:\n\n    /**\n     * replaces the element at the specified position in this list with the\n     * specified element.\n     *\n     * @param index index of the element to replace\n     * @param element element to be stored at the specified position\n     * @return the element previously at the specified position\n     * @throws indexoutofboundsexception {@inheritdoc}\n     */\n    public e set(int index, e element) {\n        checkelementindex(index);\n        node<e> x = node(index);\n        e oldval = x.item;\n        x.item = element;\n        return oldval;\n    }\n\n\n将元素插入到指定index位置:\n\n    /**\n     * inserts the specified element at the specified position in this list.\n     * shifts the element currently at that position (if any) and any\n     * subsequent elements to the right (adds one to their indices).\n     *\n     * @param index index at which the specified element is to be inserted\n     * @param element element to be inserted\n     * @throws indexoutofboundsexception {@inheritdoc}\n     */\n    public void add(int index, e element) {\n        checkpositionindex(index);\n\n        if (index == size)\n            linklast(element);\n        else\n            linkbefore(element, node(index));\n    }\n\n\n删除指定位置的元素:\n\n    /**\n     * removes the element at the specified position in this list.  shifts any\n     * subsequent elements to the left (subtracts one from their indices).\n     * returns the element that was removed from the list.\n     *\n     * @param index the index of the element to be removed\n     * @return the element previously at the specified position\n     * @throws indexoutofboundsexception {@inheritdoc}\n     */\n    public e remove(int index) {\n        checkelementindex(index);\n        return unlink(node(index));\n    }\n\n\n其它位置的方法:\n\n\n\n    /**\n     * tells if the argument is the index of an existing element.\n     */\n    private boolean iselementindex(int index) {\n        return index >= 0 && index < size;\n    }\n\n    /**\n     * tells if the argument is the index of a valid position for an\n     * iterator or an add operation.\n     */\n    private boolean ispositionindex(int index) {\n        return index >= 0 && index <= size;\n    }\n\n    /**\n     * constructs an indexoutofboundsexception detail message.\n     * of the many possible refactorings of the error handling code,\n     * this "outlining" performs best with both server and client vms.\n     */\n    private string outofboundsmsg(int index) {\n        return "index: "+index+", size: "+size;\n    }\n\n    private void checkelementindex(int index) {\n        if (!iselementindex(index))\n            throw new indexoutofboundsexception(outofboundsmsg(index));\n    }\n\n    private void checkpositionindex(int index) {\n        if (!ispositionindex(index))\n            throw new indexoutofboundsexception(outofboundsmsg(index));\n    }\n\n\n\n# 查找操作\n\n查找操作的本质是查找元素的下标:\n\n查找第一次出现的index, 如果找不到返回-1；\n\n    /**\n     * returns the index of the first occurrence of the specified element\n     * in this list, or -1 if this list does not contain the element.\n     * more formally, returns the lowest index {@code i} such that\n     * <tt>(o==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;o.equals(get(i)))</tt>,\n     * or -1 if there is no such index.\n     *\n     * @param o element to search for\n     * @return the index of the first occurrence of the specified element in\n     *         this list, or -1 if this list does not contain the element\n     */\n    public int indexof(object o) {\n        int index = 0;\n        if (o == null) {\n            for (node<e> x = first; x != null; x = x.next) {\n                if (x.item == null)\n                    return index;\n                index++;\n            }\n        } else {\n            for (node<e> x = first; x != null; x = x.next) {\n                if (o.equals(x.item))\n                    return index;\n                index++;\n            }\n        }\n        return -1;\n    }\n\n\n查找最后一次出现的index, 如果找不到返回-1；\n\n    /**\n     * returns the index of the last occurrence of the specified element\n     * in this list, or -1 if this list does not contain the element.\n     * more formally, returns the highest index {@code i} such that\n     * <tt>(o==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;o.equals(get(i)))</tt>,\n     * or -1 if there is no such index.\n     *\n     * @param o element to search for\n     * @return the index of the last occurrence of the specified element in\n     *         this list, or -1 if this list does not contain the element\n     */\n    public int lastindexof(object o) {\n        int index = size;\n        if (o == null) {\n            for (node<e> x = last; x != null; x = x.prev) {\n                index--;\n                if (x.item == null)\n                    return index;\n            }\n        } else {\n            for (node<e> x = last; x != null; x = x.prev) {\n                index--;\n                if (o.equals(x.item))\n                    return index;\n            }\n        }\n        return -1;\n    }\n\n\n\n# queue 方法\n\n   \n    /**\n     * retrieves, but does not remove, the head (first element) of this list.\n     *\n     * @return the head of this list, or {@code null} if this list is empty\n     * @since 1.5\n     */\n    public e peek() {\n        final node<e> f = first;\n        return (f == null) ? null : f.item;\n    }\n\n    /**\n     * retrieves, but does not remove, the head (first element) of this list.\n     *\n     * @return the head of this list\n     * @throws nosuchelementexception if this list is empty\n     * @since 1.5\n     */\n    public e element() {\n        return getfirst();\n    }\n\n    /**\n     * retrieves and removes the head (first element) of this list.\n     *\n     * @return the head of this list, or {@code null} if this list is empty\n     * @since 1.5\n     */\n    public e poll() {\n        final node<e> f = first;\n        return (f == null) ? null : unlinkfirst(f);\n    }\n\n    /**\n     * retrieves and removes the head (first element) of this list.\n     *\n     * @return the head of this list\n     * @throws nosuchelementexception if this list is empty\n     * @since 1.5\n     */\n    public e remove() {\n        return removefirst();\n    }\n\n    /**\n     * adds the specified element as the tail (last element) of this list.\n     *\n     * @param e the element to add\n     * @return {@code true} (as specified by {@link queue#offer})\n     * @since 1.5\n     */\n    public boolean offer(e e) {\n        return add(e);\n    }\n\n\n\n# deque 方法\n\n    /**\n     * inserts the specified element at the front of this list.\n     *\n     * @param e the element to insert\n     * @return {@code true} (as specified by {@link deque#offerfirst})\n     * @since 1.6\n     */\n    public boolean offerfirst(e e) {\n        addfirst(e);\n        return true;\n    }\n\n    /**\n     * inserts the specified element at the end of this list.\n     *\n     * @param e the element to insert\n     * @return {@code true} (as specified by {@link deque#offerlast})\n     * @since 1.6\n     */\n    public boolean offerlast(e e) {\n        addlast(e);\n        return true;\n    }\n\n    /**\n     * retrieves, but does not remove, the first element of this list,\n     * or returns {@code null} if this list is empty.\n     *\n     * @return the first element of this list, or {@code null}\n     *         if this list is empty\n     * @since 1.6\n     */\n    public e peekfirst() {\n        final node<e> f = first;\n        return (f == null) ? null : f.item;\n     }\n\n    /**\n     * retrieves, but does not remove, the last element of this list,\n     * or returns {@code null} if this list is empty.\n     *\n     * @return the last element of this list, or {@code null}\n     *         if this list is empty\n     * @since 1.6\n     */\n    public e peeklast() {\n        final node<e> l = last;\n        return (l == null) ? null : l.item;\n    }\n\n    /**\n     * retrieves and removes the first element of this list,\n     * or returns {@code null} if this list is empty.\n     *\n     * @return the first element of this list, or {@code null} if\n     *     this list is empty\n     * @since 1.6\n     */\n    public e pollfirst() {\n        final node<e> f = first;\n        return (f == null) ? null : unlinkfirst(f);\n    }\n\n    /**\n     * retrieves and removes the last element of this list,\n     * or returns {@code null} if this list is empty.\n     *\n     * @return the last element of this list, or {@code null} if\n     *     this list is empty\n     * @since 1.6\n     */\n    public e polllast() {\n        final node<e> l = last;\n        return (l == null) ? null : unlinklast(l);\n    }\n\n    /**\n     * pushes an element onto the stack represented by this list.  in other\n     * words, inserts the element at the front of this list.\n     *\n     * <p>this method is equivalent to {@link #addfirst}.\n     *\n     * @param e the element to push\n     * @since 1.6\n     */\n    public void push(e e) {\n        addfirst(e);\n    }\n\n    /**\n     * pops an element from the stack represented by this list.  in other\n     * words, removes and returns the first element of this list.\n     *\n     * <p>this method is equivalent to {@link #removefirst()}.\n     *\n     * @return the element at the front of this list (which is the top\n     *         of the stack represented by this list)\n     * @throws nosuchelementexception if this list is empty\n     * @since 1.6\n     */\n    public e pop() {\n        return removefirst();\n    }\n\n    /**\n     * removes the first occurrence of the specified element in this\n     * list (when traversing the list from head to tail).  if the list\n     * does not contain the element, it is unchanged.\n     *\n     * @param o element to be removed from this list, if present\n     * @return {@code true} if the list contained the specified element\n     * @since 1.6\n     */\n    public boolean removefirstoccurrence(object o) {\n        return remove(o);\n    }\n\n    /**\n     * removes the last occurrence of the specified element in this\n     * list (when traversing the list from head to tail).  if the list\n     * does not contain the element, it is unchanged.\n     *\n     * @param o element to be removed from this list, if present\n     * @return {@code true} if the list contained the specified element\n     * @since 1.6\n     */\n    public boolean removelastoccurrence(object o) {\n        if (o == null) {\n            for (node<e> x = last; x != null; x = x.prev) {\n                if (x.item == null) {\n                    unlink(x);\n                    return true;\n                }\n            }\n        } else {\n            for (node<e> x = last; x != null; x = x.prev) {\n                if (o.equals(x.item)) {\n                    unlink(x);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n\n\n# 参考\n\n * java linkedlist源码剖析 结合源码对linkedlist进行讲解 http://www.cnblogs.com/carpenterlee/p/5457150.html\n * 转载 https://www.pdai.tech/md/java/collection/java-collection-linkedlist.html',charsets:{cjk:!0}},{title:"Java 基础 - 反射机制详解",frontmatter:{},regularPath:"/java/basic/java-basic-x-reflection.html",relativePath:"java/basic/java-basic-x-reflection.md",key:"v-52bd9ac8",path:"/java/basic/java-basic-x-reflection.html",headers:[{level:2,title:"Java 基础 - 反射机制详解",slug:"java-基础-反射机制详解",normalizedTitle:"java 基础 - 反射机制详解",charIndex:2},{level:2,title:"反射基础",slug:"反射基础",normalizedTitle:"反射基础",charIndex:226},{level:3,title:"Class类",slug:"class类",normalizedTitle:"class类",charIndex:238},{level:3,title:"类加载",slug:"类加载",normalizedTitle:"类加载",charIndex:252},{level:2,title:"反射的使用",slug:"反射的使用",normalizedTitle:"反射的使用",charIndex:261},{level:3,title:"Class类对象的获取",slug:"class类对象的获取",normalizedTitle:"class类对象的获取",charIndex:274},{level:3,title:"Constructor类及其用法",slug:"constructor类及其用法",normalizedTitle:"constructor类及其用法",charIndex:293},{level:3,title:"Field类及其用法",slug:"field类及其用法",normalizedTitle:"field类及其用法",charIndex:317},{level:3,title:"Method类及其用法",slug:"method类及其用法",normalizedTitle:"method类及其用法",charIndex:335},{level:2,title:"反射机制执行的流程",slug:"反射机制执行的流程",normalizedTitle:"反射机制执行的流程",charIndex:352},{level:3,title:"反射获取类实例",slug:"反射获取类实例",normalizedTitle:"反射获取类实例",charIndex:369},{level:3,title:"反射获取方法",slug:"反射获取方法",normalizedTitle:"反射获取方法",charIndex:384},{level:3,title:"调用 method.invoke() 方法",slug:"调用-method-invoke-方法",normalizedTitle:"调用 method.invoke() 方法",charIndex:398},{level:3,title:"反射调用流程小结",slug:"反射调用流程小结",normalizedTitle:"反射调用流程小结",charIndex:427},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:441}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java 基础 - 反射机制详解 反射基础 Class类 类加载 反射的使用 Class类对象的获取 Constructor类及其用法 Field类及其用法 Method类及其用法 反射机制执行的流程 反射获取类实例 反射获取方法 调用 method.invoke() 方法 反射调用流程小结 参考文章",content:'# Java 基础 - 反射机制详解\n\n> JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。Java反射机制在框架设计中极为广泛，需要深入理解。本文综合多篇文章后，总结了Java 反射的相关知识，希望可以提升你对Java中反射的认知效率。\n\n * Java 基础 - 反射机制详解\n   * 反射基础\n     * Class类\n     * 类加载\n   * 反射的使用\n     * Class类对象的获取\n     * Constructor类及其用法\n     * Field类及其用法\n     * Method类及其用法\n   * 反射机制执行的流程\n     * 反射获取类实例\n     * 反射获取方法\n     * 调用 method.invoke() 方法\n     * 反射调用流程小结\n   * 参考文章\n\n\n# 反射基础\n\nRTTI（Run-Time Type Identification）运行时类型识别。在《Thinking in Java》一书第十四章中有提到，其作用是在运行时识别一个对象的类型和类的信息。主要有两种方式：一种是“传统的”RTTI，它假定我们在编译时已经知道了所有的类型；另一种是“反射”机制，它允许我们在运行时发现和使用类的信息。\n\n反射就是把java类中的各种成分映射成一个个的Java对象\n\n例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。\n\n> 这里我们首先需要理解 Class类，以及类的加载机制； 然后基于此我们如何通过反射获取Class类以及类中的成员变量、方法、构造方法等。\n\n\n# Class类\n\nClass类，Class类也是一个实实在在的类，存在于JDK的java.lang包中。Class类的实例表示java应用运行时的类(class ans enum)或接口(interface and annotation)（每个java类运行时都在JVM里表现为一个class对象，可通过类名.class、类型.getClass()、Class.forName("类名")等方法获取class对象）。数组同样也被映射为class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。基本类型boolean，byte，char，short，int，long，float，double和关键字void同样表现为 class 对象。\n\npublic final class Class<T> implements java.io.Serializable,\n                              GenericDeclaration,\n                              Type,\n                              AnnotatedElement {\n    private static final int ANNOTATION= 0x00002000;\n    private static final int ENUM      = 0x00004000;\n    private static final int SYNTHETIC = 0x00001000;\n\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }\n\n    /*\n     * Private constructor. Only the Java Virtual Machine creates Class objects.   //私有构造器，只有JVM才能调用创建Class对象\n     * This constructor is not used and prevents the default constructor being\n     * generated.\n     */\n    private Class(ClassLoader loader) {\n        // Initialize final field for classLoader.  The initialization value of non-null\n        // prevents future JIT optimizations from assuming this final field is null.\n        classLoader = loader;\n    }\n\n\n到这我们也就可以得出以下几点信息：\n\n * Class类也是类的一种，与class关键字是不一样的。\n\n * 手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，而且这个Class对象保存在同名.class的文件中(字节码文件)\n\n * 每个通过关键字class标识的类，在内存中有且只有一个与之对应的Class对象来描述其类型信息，无论创建多少个实例对象，其依据的都是用一个Class对象。\n\n * Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载\n\n * Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要(关于反射稍后分析)。\n\n\n# 类加载\n\n类加载机制和类字节码技术可以参考如下两篇文章：\n\n * JVM基础 - 类字节码详解\n   * 源代码通过编译器编译为字节码，再通过类加载子系统进行加载到JVM中运行\n * JVM基础 - Java 类加载机制\n   * 这篇文章将带你深入理解Java 类加载机制\n\n其中，这里我们需要回顾的是：\n\n 1. 类加载机制流程\n\n\n\n 2. 类的加载\n\n\n\n\n# 反射的使用\n\n提示\n\n基于此我们如何通过反射获取Class类对象以及类中的成员变量、方法、构造方法等\n\n在Java中，Class类与java.lang.reflect类库一起对反射技术进行了全力的支持。在反射包中，我们常用的类主要有Constructor类表示的是Class 对象所表示的类的构造方法，利用它可以在运行时动态创建对象、Field表示Class对象所表示的类的成员变量，通过它可以在运行时动态修改成员变量的属性值(包含private)、Method表示Class对象所表示的类的成员方法，通过它可以动态调用对象的方法(包含private)，下面将对这几个重要类进行分别说明。\n\n\n# Class类对象的获取\n\n在类加载的时候，jvm会创建一个class对象\n\nclass对象是可以说是反射中最常用的，获取class对象的方式的主要有三种\n\n * 根据类名：类名.class\n * 根据对象：对象.getClass()\n * 根据全限定类名：Class.forName(全限定类名)\n\n    @Test\n    public void classTest() throws Exception {\n        // 获取Class对象的三种方式\n        logger.info("根据类名:  \\t" + User.class);\n        logger.info("根据对象:  \\t" + new User().getClass());\n        logger.info("根据全限定类名:\\t" + Class.forName("com.test.User"));\n        // 常用的方法\n        logger.info("获取全限定类名:\\t" + userClass.getName());\n        logger.info("获取类名:\\t" + userClass.getSimpleName());\n        logger.info("实例化:\\t" + userClass.newInstance());\n    }\n\n    // ...\n    package com.test;\n\n    public class User {\n        private String name = "init";\n        private int age;\n        public User() {}\n        public User(String name, int age) {\n            super();\n            this.name = name;\n            this.age = age;\n        }\n        private String getName() {\n            return name;\n        }\n        private void setName(String name) {\n            this.name = name;\n        }\n        public int getAge() {\n            return age;\n        }\n        public void setAge(int age) {\n            this.age = age;\n        }\n        @Override\n        public String toString() {\n            return "User [name=" + name + ", age=" + age + "]";\n        }\n    }\n\n\n输出结果：\n\n根据类名:  \tclass com.test.User\n根据对象:  \tclass com.test.User\n根据全限定类名:\tclass com.test.User\n获取全限定类名:\tcom.test.User\n获取类名:\tUser\n实例化:\tUser [name=init, age=0]\n\n\n * 再来看看 Class类的方法\n\n方法名                                  说明\nforName()                            (1)获取Class对象的一个引用，但引用的类还没有加载(该类的第一个对象没有生成)就加载了这个类。\n(2)为了产生Class引用，forName()立即就进行了初始化。   \nObject-getClass()                    获取Class对象的一个引用，返回表示该对象的实际类型的Class引用。\ngetName()                            取全限定的类名(包括包名)，即类的完整名字。\ngetSimpleName()                      获取类名(不包括包名)\ngetCanonicalName()                   获取全限定的类名(包括包名)\nisInterface()                        判断Class对象是否是表示一个接口\ngetInterfaces()                      返回Class对象数组，表示Class对象所引用的类所实现的所有接口。\ngetSupercalss()                      返回Class对象，表示Class对象所引用的类所继承的直接基类。应用该方法可在运行时发现一个对象完整的继承结构。\nnewInstance()                        返回一个Oject对象，是实现“虚拟构造器”的一种途径。使用该方法创建的类，必须带有无参的构造器。\ngetFields()                          获得某个类的所有的公共（public）的字段，包括继承自父类的所有公共字段。\n                                     类似的还有getMethods和getConstructors。\ngetDeclaredFields                    获得某个类的自己声明的字段，即包括public、private和proteced，默认但是不包括父类声明的任何字段。类似的还有getDeclaredMethods和getDeclaredConstructors。\n\n简单测试下（这里例子源于https://blog.csdn.net/mcryeasy/article/details/52344729）\n\npackage com.cry;\nimport java.lang.reflect.Field;\ninterface I1 {\n}\ninterface I2 {\n}\nclass Cell{\n    public int mCellPublic;\n}\nclass Animal extends  Cell{\n    private int mAnimalPrivate;\n    protected int mAnimalProtected;\n    int mAnimalDefault;\n    public int mAnimalPublic;\n    private static int sAnimalPrivate;\n    protected static int sAnimalProtected;\n    static int sAnimalDefault;\n    public static int sAnimalPublic;\n}\nclass Dog extends Animal implements I1, I2 {\n    private int mDogPrivate;\n    public int mDogPublic;\n    protected int mDogProtected;\n    private int mDogDefault;\n    private static int sDogPrivate;\n    protected static int sDogProtected;\n    static int sDogDefault;\n    public static int sDogPublic;\n}\npublic class Test {\n    public static void main(String[] args) throws IllegalAccessException, InstantiationException {\n        Class<Dog> dog = Dog.class;\n        //类名打印\n        System.out.println(dog.getName()); //com.cry.Dog\n        System.out.println(dog.getSimpleName()); //Dog\n        System.out.println(dog.getCanonicalName());//com.cry.Dog\n        //接口\n        System.out.println(dog.isInterface()); //false\n        for (Class iI : dog.getInterfaces()) {\n            System.out.println(iI);\n        }\n         /*\n          interface com.cry.I1\n          interface com.cry.I2\n         */\n\n        //父类\n        System.out.println(dog.getSuperclass());//class com.cry.Animal\n        //创建对象\n        Dog d = dog.newInstance();\n        //字段\n        for (Field f : dog.getFields()) {\n            System.out.println(f.getName());\n        }\n        /*\n            mDogPublic\n            sDogPublic\n            mAnimalPublic\n            sAnimalPublic\n            mCellPublic  //父类的父类的公共字段也打印出来了\n         */\n        System.out.println("---------");\n        for (Field f : dog.getDeclaredFields()) {\n            System.out.println(f.getName());\n        }\n        /** 只有自己类声明的字段\n         mDogPrivate\n         mDogPublic\n         mDogProtected\n         mDogDefault\n         sDogPrivate\n         sDogProtected\n         sDogDefault\n         sDogPublic\n         */\n    }\n}\n\n\ngetName、getCanonicalName与getSimpleName的区别：\n\n * getSimpleName：只获取类名\n * getName：类的全限定名，jvm中Class的表示，可以用于动态加载Class对象，例如Class.forName。\n * getCanonicalName：返回更容易理解的表示，主要用于输出（toString）或log打印，大多数情况下和getName一样，但是在内部类、数组等类型的表示形式就不同了。\n\npackage com.cry;\npublic class Test {\n    private  class inner{\n    }\n    public static void main(String[] args) throws ClassNotFoundException {\n        //普通类\n        System.out.println(Test.class.getSimpleName()); //Test\n        System.out.println(Test.class.getName()); //com.cry.Test\n        System.out.println(Test.class.getCanonicalName()); //com.cry.Test\n        //内部类\n        System.out.println(inner.class.getSimpleName()); //inner\n        System.out.println(inner.class.getName()); //com.cry.Test$inner\n        System.out.println(inner.class.getCanonicalName()); //com.cry.Test.inner\n        //数组\n        System.out.println(args.getClass().getSimpleName()); //String[]\n        System.out.println(args.getClass().getName()); //[Ljava.lang.String;\n        System.out.println(args.getClass().getCanonicalName()); //java.lang.String[]\n        //我们不能用getCanonicalName去加载类对象，必须用getName\n        //Class.forName(inner.class.getCanonicalName()); 报错\n        Class.forName(inner.class.getName());\n    }\n}\n\n\n\n# Constructor类及其用法\n\n> Constructor类存在于反射包(java.lang.reflect)中，反映的是Class 对象所表示的类的构造方法。\n\n获取Constructor对象是通过Class类中的方法获取的，Class类与Constructor相关的主要方法如下：\n\n方法返回值              方法名称                                                 方法说明\nstatic Class<?>    forName(String className)                            返回与带有给定字符串名的类或接口相关联的 Class 对象。\nConstructor        getConstructor(Class<?>... parameterTypes)           返回指定参数类型、具有public访问权限的构造函数对象\nConstructor<?>[]   getConstructors()                                    返回所有具有public访问权限的构造函数的Constructor对象数组\nConstructor        getDeclaredConstructor(Class<?>... parameterTypes)   返回指定参数类型、所有声明的（包括private）构造函数对象\nConstructor<?>[]   getDeclaredConstructors()                            返回所有声明的（包括private）构造函数对象\nT                  newInstance()                                        调用无参构造器创建此 Class 对象所表示的类的一个新实例。\n\n下面看一个简单例子来了解Constructor对象的使用：\n\npublic class ConstructionTest implements Serializable {\n    public static void main(String[] args) throws Exception {\n\n        Class<?> clazz = null;\n\n        //获取Class对象的引用\n        clazz = Class.forName("com.example.javabase.User");\n\n        //第一种方法，实例化默认构造方法，User必须无参构造函数,否则将抛异常\n        User user = (User) clazz.newInstance();\n        user.setAge(20);\n        user.setName("Jack");\n        System.out.println(user);\n\n        System.out.println("--------------------------------------------");\n\n        //获取带String参数的public构造函数\n        Constructor cs1 =clazz.getConstructor(String.class);\n        //创建User\n        User user1= (User) cs1.newInstance("hiway");\n        user1.setAge(22);\n        System.out.println("user1:"+user1.toString());\n\n        System.out.println("--------------------------------------------");\n\n        //取得指定带int和String参数构造函数,该方法是私有构造private\n        Constructor cs2=clazz.getDeclaredConstructor(int.class,String.class);\n        //由于是private必须设置可访问\n        cs2.setAccessible(true);\n        //创建user对象\n        User user2= (User) cs2.newInstance(25,"hiway2");\n        System.out.println("user2:"+user2.toString());\n\n        System.out.println("--------------------------------------------");\n\n        //获取所有构造包含private\n        Constructor<?> cons[] = clazz.getDeclaredConstructors();\n        // 查看每个构造方法需要的参数\n        for (int i = 0; i < cons.length; i++) {\n            //获取构造函数参数类型\n            Class<?> clazzs[] = cons[i].getParameterTypes();\n            System.out.println("构造函数["+i+"]:"+cons[i].toString() );\n            System.out.print("参数类型["+i+"]:(");\n            for (int j = 0; j < clazzs.length; j++) {\n                if (j == clazzs.length - 1)\n                    System.out.print(clazzs[j].getName());\n                else\n                    System.out.print(clazzs[j].getName() + ",");\n            }\n            System.out.println(")");\n        }\n    }\n}\n\n\nclass User {\n    private int age;\n    private String name;\n    public User() {\n        super();\n    }\n    public User(String name) {\n        super();\n        this.name = name;\n    }\n\n    /**\n     * 私有构造\n     * @param age\n     * @param name\n     */\n    private User(int age, String name) {\n        super();\n        this.age = age;\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return "User{" +\n                "age=" + age +\n                ", name=\'" + name + \'\\\'\' +\n                \'}\';\n    }\n}\n\n\n输出结果\n\n/* output \nUser{age=20, name=\'Jack\'}\n--------------------------------------------\nuser1:User{age=22, name=\'hiway\'}\n--------------------------------------------\nuser2:User{age=25, name=\'hiway2\'}\n--------------------------------------------\n构造函数[0]:private com.example.javabase.User(int,java.lang.String)\n参数类型[0]:(int,java.lang.String)\n构造函数[1]:public com.example.javabase.User(java.lang.String)\n参数类型[1]:(java.lang.String)\n构造函数[2]:public com.example.javabase.User()\n参数类型[2]:()\n\n\n关于Constructor类本身一些常用方法如下(仅部分，其他可查API)\n\n方法返回值        方法名称                              方法说明\nClass        getDeclaringClass()               返回 Class 对象，该对象表示声明由此 Constructor\n                                               对象表示的构造方法的类,其实就是返回真实类型（不包含参数）\nType[]       getGenericParameterTypes()        按照声明顺序返回一组 Type 对象，返回的就是 Constructor对象构造函数的形参类型。\nString       getName()                         以字符串形式返回此构造方法的名称。\nClass<?>[]   getParameterTypes()               按照声明顺序返回一组 Class 对象，即返回Constructor 对象所表示构造方法的形参类型\nT            newInstance(Object... initargs)   使用此 Constructor对象表示的构造函数来创建新实例\nString       toGenericString()                 返回描述此 Constructor 的字符串，其中包括类型参数。\n\n代码演示如下：\n\nConstructor cs3 = clazz.getDeclaredConstructor(int.class,String.class);\nSystem.out.println("-----getDeclaringClass-----");\nClass uclazz=cs3.getDeclaringClass();\n//Constructor对象表示的构造方法的类\nSystem.out.println("构造方法的类:"+uclazz.getName());\n\nSystem.out.println("-----getGenericParameterTypes-----");\n//对象表示此 Constructor 对象所表示的方法的形参类型\nType[] tps=cs3.getGenericParameterTypes();\nfor (Type tp:tps) {\n    System.out.println("参数名称tp:"+tp);\n}\nSystem.out.println("-----getParameterTypes-----");\n//获取构造函数参数类型\nClass<?> clazzs[] = cs3.getParameterTypes();\nfor (Class claz:clazzs) {\n    System.out.println("参数名称:"+claz.getName());\n}\nSystem.out.println("-----getName-----");\n//以字符串形式返回此构造方法的名称\nSystem.out.println("getName:"+cs3.getName());\n\nSystem.out.println("-----getoGenericString-----");\n//返回描述此 Constructor 的字符串，其中包括类型参数。\nSystem.out.println("getoGenericString():"+cs3.toGenericString());\n\n\n输出结果\n\n-----getDeclaringClass-----\n构造方法的类:com.example.javabase.User\n-----getGenericParameterTypes-----\n参数名称tp:int\n参数名称tp:class java.lang.String\n-----getParameterTypes-----\n参数名称:int\n参数名称:java.lang.String\n-----getName-----\ngetName:com.example.javabase.User\n-----getoGenericString-----\ngetoGenericString():private com.example.javabase.User(int,java.lang.String)\n\n\n\n# Field类及其用法\n\n> Field 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段。\n\n同样的道理，我们可以通过Class类的提供的方法来获取代表字段信息的Field对象，Class类与Field对象相关方法如下：\n\n方法返回值     方法名称                            方法说明\nField     getDeclaredField(String name)   获取指定name名称的(包含private修饰的)字段，不包括继承的字段\nField[]   getDeclaredFields()             获取Class对象所表示的类或接口的所有(包含private修饰的)字段,不包括继承的字段\nField     getField(String name)           获取指定name名称、具有public修饰的字段，包含继承字段\nField[]   getFields()                     获取修饰符为public的字段，包含继承字段\n\n下面的代码演示了上述方法的使用过程\n\npublic class ReflectField {\n\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {\n        Class<?> clazz = Class.forName("reflect.Student");\n        //获取指定字段名称的Field类,注意字段修饰符必须为public而且存在该字段,\n        // 否则抛NoSuchFieldException\n        Field field = clazz.getField("age");\n        System.out.println("field:"+field);\n\n        //获取所有修饰符为public的字段,包含父类字段,注意修饰符为public才会获取\n        Field fields[] = clazz.getFields();\n        for (Field f:fields) {\n            System.out.println("f:"+f.getDeclaringClass());\n        }\n\n        System.out.println("================getDeclaredFields====================");\n        //获取当前类所字段(包含private字段),注意不包含父类的字段\n        Field fields2[] = clazz.getDeclaredFields();\n        for (Field f:fields2) {\n            System.out.println("f2:"+f.getDeclaringClass());\n        }\n        //获取指定字段名称的Field类,可以是任意修饰符的自动,注意不包含父类的字段\n        Field field2 = clazz.getDeclaredField("desc");\n        System.out.println("field2:"+field2);\n    }\n    /**\n      输出结果: \n     field:public int reflect.Person.age\n     f:public java.lang.String reflect.Student.desc\n     f:public int reflect.Person.age\n     f:public java.lang.String reflect.Person.name\n\n     ================getDeclaredFields====================\n     f2:public java.lang.String reflect.Student.desc\n     f2:private int reflect.Student.score\n     field2:public java.lang.String reflect.Student.desc\n     */\n}\n\nclass Person{\n    public int age;\n    public String name;\n    //省略set和get方法\n}\n\nclass Student extends Person{\n    public String desc;\n    private int score;\n    //省略set和get方法\n}\n\n\n上述方法需要注意的是，如果我们不期望获取其父类的字段，则需使用Class类的getDeclaredField/getDeclaredFields方法来获取字段即可，倘若需要连带获取到父类的字段，那么请使用Class类的getField/getFields，但是也只能获取到public修饰的的字段，无法获取父类的私有字段。下面将通过Field类本身的方法对指定类属性赋值，代码演示如下：\n\n//获取Class对象引用\nClass<?> clazz = Class.forName("reflect.Student");\n\nStudent st= (Student) clazz.newInstance();\n//获取父类public字段并赋值\nField ageField = clazz.getField("age");\nageField.set(st,18);\nField nameField = clazz.getField("name");\nnameField.set(st,"Lily");\n\n//只获取当前类的字段,不获取父类的字段\nField descField = clazz.getDeclaredField("desc");\ndescField.set(st,"I am student");\nField scoreField = clazz.getDeclaredField("score");\n//设置可访问，score是private的\nscoreField.setAccessible(true);\nscoreField.set(st,88);\nSystem.out.println(st.toString());\n\n//输出结果：Student{age=18, name=\'Lily ,desc=\'I am student\', score=88} \n\n//获取字段值\nSystem.out.println(scoreField.get(st));\n// 88\n\n\n其中的set(Object obj, Object value)方法是Field类本身的方法，用于设置字段的值，而get(Object obj)则是获取字段的值，当然关于Field类还有其他常用的方法如下：\n\n方法返回值      方法名称                            方法说明\nvoid       set(Object obj, Object value)   将指定对象变量上此 Field 对象表示的字段设置为指定的新值。\nObject     get(Object obj)                 返回指定对象上此 Field 表示的字段的值\nClass<?>   getType()                       返回一个 Class 对象，它标识了此Field 对象所表示字段的声明类型。\nboolean    isEnumConstant()                如果此字段表示枚举类型的元素则返回 true；否则返回 false\nString     toGenericString()               返回一个描述此 Field（包括其一般类型）的字符串\nString     getName()                       返回此 Field 对象表示的字段的名称\nClass<?>   getDeclaringClass()             返回表示类或接口的 Class 对象，该类或接口声明由此 Field 对象表示的字段\nvoid       setAccessible(boolean flag)     将此对象的 accessible 标志设置为指示的布尔值,即设置其可访问性\n\n上述方法可能是较为常用的，事实上在设置值的方法上，Field类还提供了专门针对基本数据类型的方法，如setInt()/getInt()、setBoolean()/getBoolean、setChar()/getChar()等等方法，这里就不全部列出了，需要时查API文档即可。需要特别注意的是被final关键字修饰的Field字段是安全的，在运行时可以接收任何修改，但最终其实际值是不会发生改变的。\n\n\n# Method类及其用法\n\n> Method 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息，所反映的方法可能是类方法或实例方法（包括抽象方法）。\n\n下面是Class类获取Method对象相关的方法：\n\n方法返回值      方法名称                                                         方法说明\nMethod     getDeclaredMethod(String name, Class<?>... parameterTypes)   返回一个指定参数的Method对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。\nMethod[]   getDeclaredMethods()                                         返回 Method 对象的一个数组，这些对象反映此 Class\n                                                                        对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。\nMethod     getMethod(String name, Class<?>... parameterTypes)           返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。\nMethod[]   getMethods()                                                 返回一个包含某些 Method 对象的数组，这些对象反映此 Class\n                                                                        对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。\n\n同样通过案例演示上述方法：\n\nimport java.lang.reflect.Method;\n\npublic class ReflectMethod  {\n\n\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException {\n\n        Class clazz = Class.forName("reflect.Circle");\n\n        //根据参数获取public的Method,包含继承自父类的方法\n        Method method = clazz.getMethod("draw",int.class,String.class);\n\n        System.out.println("method:"+method);\n\n        //获取所有public的方法:\n        Method[] methods =clazz.getMethods();\n        for (Method m:methods){\n            System.out.println("m::"+m);\n        }\n\n        System.out.println("=========================================");\n\n        //获取当前类的方法包含private,该方法无法获取继承自父类的method\n        Method method1 = clazz.getDeclaredMethod("drawCircle");\n        System.out.println("method1::"+method1);\n        //获取当前类的所有方法包含private,该方法无法获取继承自父类的method\n        Method[] methods1=clazz.getDeclaredMethods();\n        for (Method m:methods1){\n            System.out.println("m1::"+m);\n        }\n    }\n}\n\nclass Shape {\n    public void draw(){\n        System.out.println("draw");\n    }\n\n    public void draw(int count , String name){\n        System.out.println("draw "+ name +",count="+count);\n    }\n\n}\nclass Circle extends Shape{\n\n    private void drawCircle(){\n        System.out.println("drawCircle");\n    }\n    public int getAllCount(){\n        return 100;\n    }\n}\n\n\n输出结果:\n\nmethod:public void reflect.Shape.draw(int,java.lang.String)\n\nm::public int reflect.Circle.getAllCount()\nm::public void reflect.Shape.draw()\nm::public void reflect.Shape.draw(int,java.lang.String)\nm::public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException\nm::public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException\nm::public final void java.lang.Object.wait() throws java.lang.InterruptedException\nm::public boolean java.lang.Object.equals(java.lang.Object)\nm::public java.lang.String java.lang.Object.toString()\nm::public native int java.lang.Object.hashCode()\nm::public final native java.lang.Class java.lang.Object.getClass()\nm::public final native void java.lang.Object.notify()\nm::public final native void java.lang.Object.notifyAll()\n\n=========================================\nmethod1::private void reflect.Circle.drawCircle()\n\nm1::public int reflect.Circle.getAllCount()\nm1::private void reflect.Circle.drawCircle()\n\n\n在通过getMethods方法获取Method对象时，会把父类的方法也获取到，如上的输出结果，把Object类的方法都打印出来了。而getDeclaredMethod/getDeclaredMethods方法都只能获取当前类的方法。我们在使用时根据情况选择即可。下面将演示通过Method对象调用指定类的方法：\n\nClass clazz = Class.forName("reflect.Circle");\n//创建对象\nCircle circle = (Circle) clazz.newInstance();\n\n//获取指定参数的方法对象Method\nMethod method = clazz.getMethod("draw",int.class,String.class);\n\n//通过Method对象的invoke(Object obj,Object... args)方法调用\nmethod.invoke(circle,15,"圈圈");\n\n//对私有无参方法的操作\nMethod method1 = clazz.getDeclaredMethod("drawCircle");\n//修改私有方法的访问标识\nmethod1.setAccessible(true);\nmethod1.invoke(circle);\n\n//对有返回值得方法操作\nMethod method2 =clazz.getDeclaredMethod("getAllCount");\nInteger count = (Integer) method2.invoke(circle);\nSystem.out.println("count:"+count);\n\n\n输出结果\n\ndraw 圈圈,count=15\ndrawCircle\ncount:100\n\n\n在上述代码中调用方法，使用了Method类的invoke(Object obj,Object... args)第一个参数代表调用的对象，第二个参数传递的调用方法的参数。这样就完成了类方法的动态调用。\n\n方法返回值        方法名称                                 方法说明\nObject       invoke(Object obj, Object... args)   对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。\nClass<?>     getReturnType()                      返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型,即方法的返回类型\nType         getGenericReturnType()               返回表示由此 Method 对象所表示方法的正式返回类型的 Type 对象，也是方法的返回类型。\nClass<?>[]   getParameterTypes()                  按照声明顺序返回 Class 对象的数组，这些对象描述了此 Method\n                                                  对象所表示的方法的形参类型。即返回方法的参数类型组成的数组\nType[]       getGenericParameterTypes()           按照声明顺序返回 Type 对象的数组，这些对象描述了此 Method\n                                                  对象所表示的方法的形参类型的，也是返回方法的参数类型\nString       getName()                            以 String 形式返回此 Method 对象表示的方法名称，即返回方法的名称\nboolean      isVarArgs()                          判断方法是否带可变参数，如果将此方法声明为带有可变数量的参数，则返回 true；否则，返回 false。\nString       toGenericString()                    返回描述此 Method 的字符串，包括类型参数。\n\ngetReturnType方法/getGenericReturnType方法都是获取Method对象表示的方法的返回类型，只不过前者返回的Class类型后者返回的Type(前面已分析过)，Type就是一个接口而已，在Java8中新增一个默认的方法实现，返回的就参数类型信息\n\npublic interface Type {\n    //1.8新增\n    default String getTypeName() {\n        return toString();\n    }\n}\n\n\n而getParameterTypes/getGenericParameterTypes也是同样的道理，都是获取Method对象所表示的方法的参数类型，其他方法与前面的Field和Constructor是类似的。\n\n\n# 反射机制执行的流程\n\n> 这部分主要参考自https://www.cnblogs.com/yougewe/p/10125073.html\n\n先看个例子\n\npublic class HelloReflect {\n    public static void main(String[] args) {\n        try {\n            // 1. 使用外部配置的实现，进行动态加载类\n            TempFunctionTest test = (TempFunctionTest)Class.forName("com.tester.HelloReflect").newInstance();\n            test.sayHello("call directly");\n            // 2. 根据配置的函数名，进行方法调用（不需要通用的接口抽象）\n            Object t2 = new TempFunctionTest();\n            Method method = t2.getClass().getDeclaredMethod("sayHello", String.class);\n            method.invoke(test, "method invoke");\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (NoSuchMethodException e ) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public void sayHello(String word) {\n        System.out.println("hello," + word);\n    }\n\n}\n\n\n来看执行流程\n\n\n\n\n# 反射获取类实例\n\n首先调用了 java.lang.Class 的静态方法，获取类信息。\n\n    @CallerSensitive\n    public static Class<?> forName(String className)\n                throws ClassNotFoundException {\n        // 先通过反射，获取调用进来的类信息，从而获取当前的 classLoader\n        Class<?> caller = Reflection.getCallerClass();\n        // 调用native方法进行获取class信息\n        return forName0(className, true, ClassLoader.getClassLoader(caller), caller);\n    }\n\n\nforName()反射获取类信息，并没有将实现留给了java,而是交给了jvm去加载。\n\n主要是先获取 ClassLoader, 然后调用 native 方法，获取信息，加载类则是回调 java.lang.ClassLoader.\n\n最后，jvm又会回调 ClassLoader 进类加载。\n\n\n    // \n    public Class<?> loadClass(String name) throws ClassNotFoundException {\n        return loadClass(name, false);\n    }\n    \n        // sun.misc.Launcher\n        public Class<?> loadClass(String var1, boolean var2) throws ClassNotFoundException {\n            int var3 = var1.lastIndexOf(46);\n            if(var3 != -1) {\n                SecurityManager var4 = System.getSecurityManager();\n                if(var4 != null) {\n                    var4.checkPackageAccess(var1.substring(0, var3));\n                }\n            }\n\n            if(this.ucp.knownToNotExist(var1)) {\n                Class var5 = this.findLoadedClass(var1);\n                if(var5 != null) {\n                    if(var2) {\n                        this.resolveClass(var5);\n                    }\n\n                    return var5;\n                } else {\n                    throw new ClassNotFoundException(var1);\n                }\n            } else {\n                return super.loadClass(var1, var2);\n            }\n        }\n    // java.lang.ClassLoader\n    protected Class<?> loadClass(String name, boolean resolve)\n        throws ClassNotFoundException\n    {\n        // 先获取锁\n        synchronized (getClassLoadingLock(name)) {\n            // First, check if the class has already been loaded\n            // 如果已经加载了的话，就不用再加载了\n            Class<?> c = findLoadedClass(name);\n            if (c == null) {\n                long t0 = System.nanoTime();\n                try {\n                    // 双亲委托加载\n                    if (parent != null) {\n                        c = parent.loadClass(name, false);\n                    } else {\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // ClassNotFoundException thrown if class not found\n                    // from the non-null parent class loader\n                }\n\n                // 父类没有加载到时，再自己加载\n                if (c == null) {\n                    // If still not found, then invoke findClass in order\n                    // to find the class.\n                    long t1 = System.nanoTime();\n                    c = findClass(name);\n\n                    // this is the defining class loader; record the stats\n                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                    sun.misc.PerfCounter.getFindClasses().increment();\n                }\n            }\n            if (resolve) {\n                resolveClass(c);\n            }\n            return c;\n        }\n    }\n    \n    protected Object getClassLoadingLock(String className) {\n        Object lock = this;\n        if (parallelLockMap != null) {\n            // 使用 ConcurrentHashMap来保存锁\n            Object newLock = new Object();\n            lock = parallelLockMap.putIfAbsent(className, newLock);\n            if (lock == null) {\n                lock = newLock;\n            }\n        }\n        return lock;\n    }\n    \n    protected final Class<?> findLoadedClass(String name) {\n        if (!checkName(name))\n            return null;\n        return findLoadedClass0(name);\n    }\n\n\n\n下面来看一下 newInstance() 的实现方式。\n\n    // 首先肯定是 Class.newInstance\n    @CallerSensitive\n    public T newInstance()\n        throws InstantiationException, IllegalAccessException\n    {\n        if (System.getSecurityManager() != null) {\n            checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), false);\n        }\n\n        // NOTE: the following code may not be strictly correct under\n        // the current Java memory model.\n\n        // Constructor lookup\n        // newInstance() 其实相当于调用类的无参构造函数，所以，首先要找到其无参构造器\n        if (cachedConstructor == null) {\n            if (this == Class.class) {\n                // 不允许调用 Class 的 newInstance() 方法\n                throw new IllegalAccessException(\n                    "Can not call newInstance() on the Class for java.lang.Class"\n                );\n            }\n            try {\n                // 获取无参构造器\n                Class<?>[] empty = {};\n                final Constructor<T> c = getConstructor0(empty, Member.DECLARED);\n                // Disable accessibility checks on the constructor\n                // since we have to do the security check here anyway\n                // (the stack depth is wrong for the Constructor\'s\n                // security check to work)\n                java.security.AccessController.doPrivileged(\n                    new java.security.PrivilegedAction<Void>() {\n                        public Void run() {\n                                c.setAccessible(true);\n                                return null;\n                            }\n                        });\n                cachedConstructor = c;\n            } catch (NoSuchMethodException e) {\n                throw (InstantiationException)\n                    new InstantiationException(getName()).initCause(e);\n            }\n        }\n        Constructor<T> tmpConstructor = cachedConstructor;\n        // Security check (same as in java.lang.reflect.Constructor)\n        int modifiers = tmpConstructor.getModifiers();\n        if (!Reflection.quickCheckMemberAccess(this, modifiers)) {\n            Class<?> caller = Reflection.getCallerClass();\n            if (newInstanceCallerCache != caller) {\n                Reflection.ensureMemberAccess(caller, this, null, modifiers);\n                newInstanceCallerCache = caller;\n            }\n        }\n        // Run constructor\n        try {\n            // 调用无参构造器\n            return tmpConstructor.newInstance((Object[])null);\n        } catch (InvocationTargetException e) {\n            Unsafe.getUnsafe().throwException(e.getTargetException());\n            // Not reached\n            return null;\n        }\n    }\n\n\nnewInstance() 主要做了三件事：\n\n * 1. 权限检测，如果不通过直接抛出异常；\n * 2. 查找无参构造器，并将其缓存起来；\n * 3. 调用具体方法的无参构造方法，生成实例并返回；\n\n下面是获取构造器的过程：\n\n    private Constructor<T> getConstructor0(Class<?>[] parameterTypes,\n                                        int which) throws NoSuchMethodException\n    {\n        // 获取所有构造器\n        Constructor<T>[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC));\n        for (Constructor<T> constructor : constructors) {\n            if (arrayContentsEq(parameterTypes,\n                                constructor.getParameterTypes())) {\n                return getReflectionFactory().copyConstructor(constructor);\n            }\n        }\n        throw new NoSuchMethodException(getName() + ".<init>" + argumentTypesToString(parameterTypes));\n    }\n\n\ngetConstructor0() 为获取匹配的构造方器；分三步：\n\n * 1. 先获取所有的constructors, 然后通过进行参数类型比较；\n * 2. 找到匹配后，通过 ReflectionFactory copy一份constructor返回；\n * 3. 否则抛出 NoSuchMethodException;\n\n\n    // 获取当前类所有的构造方法，通过jvm或者缓存\n    // Returns an array of "root" constructors. These Constructor\n    // objects must NOT be propagated to the outside world, but must\n    // instead be copied via ReflectionFactory.copyConstructor.\n    private Constructor<T>[] privateGetDeclaredConstructors(boolean publicOnly) {\n        checkInitted();\n        Constructor<T>[] res;\n        // 调用 reflectionData(), 获取保存的信息，使用软引用保存，从而使内存不够可以回收\n        ReflectionData<T> rd = reflectionData();\n        if (rd != null) {\n            res = publicOnly ? rd.publicConstructors : rd.declaredConstructors;\n            // 存在缓存，则直接返回\n            if (res != null) return res;\n        }\n        // No cached value available; request value from VM\n        if (isInterface()) {\n            @SuppressWarnings("unchecked")\n            Constructor<T>[] temporaryRes = (Constructor<T>[]) new Constructor<?>[0];\n            res = temporaryRes;\n        } else {\n            // 使用native方法从jvm获取构造器\n            res = getDeclaredConstructors0(publicOnly);\n        }\n        if (rd != null) {\n            // 最后，将从jvm中读取的内容，存入缓存\n            if (publicOnly) {\n                rd.publicConstructors = res;\n            } else {\n                rd.declaredConstructors = res;\n            }\n        }\n        return res;\n    }\n    \n    // Lazily create and cache ReflectionData\n    private ReflectionData<T> reflectionData() {\n        SoftReference<ReflectionData<T>> reflectionData = this.reflectionData;\n        int classRedefinedCount = this.classRedefinedCount;\n        ReflectionData<T> rd;\n        if (useCaches &&\n            reflectionData != null &&\n            (rd = reflectionData.get()) != null &&\n            rd.redefinedCount == classRedefinedCount) {\n            return rd;\n        }\n        // else no SoftReference or cleared SoftReference or stale ReflectionData\n        // -> create and replace new instance\n        return newReflectionData(reflectionData, classRedefinedCount);\n    }\n    \n    // 新创建缓存，保存反射信息\n    private ReflectionData<T> newReflectionData(SoftReference<ReflectionData<T>> oldReflectionData,\n                                                int classRedefinedCount) {\n        if (!useCaches) return null;\n\n        // 使用cas保证更新的线程安全性，所以反射是保证线程安全的\n        while (true) {\n            ReflectionData<T> rd = new ReflectionData<>(classRedefinedCount);\n            // try to CAS it...\n            if (Atomic.casReflectionData(this, oldReflectionData, new SoftReference<>(rd))) {\n                return rd;\n            }\n            // 先使用CAS更新，如果更新成功，则立即返回，否则测查当前已被其他线程更新的情况，如果和自己想要更新的状态一致，则也算是成功了\n            oldReflectionData = this.reflectionData;\n            classRedefinedCount = this.classRedefinedCount;\n            if (oldReflectionData != null &&\n                (rd = oldReflectionData.get()) != null &&\n                rd.redefinedCount == classRedefinedCount) {\n                return rd;\n            }\n        }\n    }\n\n\n如上，privateGetDeclaredConstructors(), 获取所有的构造器主要步骤；\n\n * 1. 先尝试从缓存中获取；\n * 2. 如果缓存没有，则从jvm中重新获取，并存入缓存，缓存使用软引用进行保存，保证内存可用；\n\n另外，使用 relactionData() 进行缓存保存；ReflectionData 的数据结构如下。\n\n\n    // reflection data that might get invalidated when JVM TI RedefineClasses() is called\n    private static class ReflectionData<T> {\n        volatile Field[] declaredFields;\n        volatile Field[] publicFields;\n        volatile Method[] declaredMethods;\n        volatile Method[] publicMethods;\n        volatile Constructor<T>[] declaredConstructors;\n        volatile Constructor<T>[] publicConstructors;\n        // Intermediate results for getFields and getMethods\n        volatile Field[] declaredPublicFields;\n        volatile Method[] declaredPublicMethods;\n        volatile Class<?>[] interfaces;\n\n        // Value of classRedefinedCount when we created this ReflectionData instance\n        final int redefinedCount;\n\n        ReflectionData(int redefinedCount) {\n            this.redefinedCount = redefinedCount;\n        }\n    }\n\n\n其中，还有一个点，就是如何比较构造是否是要查找构造器，其实就是比较类型完成相等就完了，有一个不相等则返回false。\n\n    private static boolean arrayContentsEq(Object[] a1, Object[] a2) {\n        if (a1 == null) {\n            return a2 == null || a2.length == 0;\n        }\n\n        if (a2 == null) {\n            return a1.length == 0;\n        }\n\n        if (a1.length != a2.length) {\n            return false;\n        }\n\n        for (int i = 0; i < a1.length; i++) {\n            if (a1[i] != a2[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n    // sun.reflect.ReflectionFactory\n    /** Makes a copy of the passed constructor. The returned\n        constructor is a "child" of the passed one; see the comments\n        in Constructor.java for details. */\n    public <T> Constructor<T> copyConstructor(Constructor<T> arg) {\n        return langReflectAccess().copyConstructor(arg);\n    }\n    \n    // java.lang.reflect.Constructor, copy 其实就是新new一个 Constructor 出来\n    Constructor<T> copy() {\n        // This routine enables sharing of ConstructorAccessor objects\n        // among Constructor objects which refer to the same underlying\n        // method in the VM. (All of this contortion is only necessary\n        // because of the "accessibility" bit in AccessibleObject,\n        // which implicitly requires that new java.lang.reflect\n        // objects be fabricated for each reflective call on Class\n        // objects.)\n        if (this.root != null)\n            throw new IllegalArgumentException("Can not copy a non-root Constructor");\n\n        Constructor<T> res = new Constructor<>(clazz,\n                                               parameterTypes,\n                                               exceptionTypes, modifiers, slot,\n                                               signature,\n                                               annotations,\n                                               parameterAnnotations);\n        // root 指向当前 constructor\n        res.root = this;\n        // Might as well eagerly propagate this if already present\n        res.constructorAccessor = constructorAccessor;\n        return res;\n    }\n\n\n通过上面，获取到 Constructor 了。\n\n接下来就只需调用其相应构造器的 newInstance()，即返回实例了。\n\n    // return tmpConstructor.newInstance((Object[])null); \n    // java.lang.reflect.Constructor\n    @CallerSensitive\n    public T newInstance(Object ... initargs)\n        throws InstantiationException, IllegalAccessException,\n               IllegalArgumentException, InvocationTargetException\n    {\n        if (!override) {\n            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {\n                Class<?> caller = Reflection.getCallerClass();\n                checkAccess(caller, clazz, null, modifiers);\n            }\n        }\n        if ((clazz.getModifiers() & Modifier.ENUM) != 0)\n            throw new IllegalArgumentException("Cannot reflectively create enum objects");\n        ConstructorAccessor ca = constructorAccessor;   // read volatile\n        if (ca == null) {\n            ca = acquireConstructorAccessor();\n        }\n        @SuppressWarnings("unchecked")\n        T inst = (T) ca.newInstance(initargs);\n        return inst;\n    }\n    // sun.reflect.DelegatingConstructorAccessorImpl\n    public Object newInstance(Object[] args)\n      throws InstantiationException,\n             IllegalArgumentException,\n             InvocationTargetException\n    {\n        return delegate.newInstance(args);\n    }\n    // sun.reflect.NativeConstructorAccessorImpl\n    public Object newInstance(Object[] args)\n        throws InstantiationException,\n               IllegalArgumentException,\n               InvocationTargetException\n    {\n        // We can\'t inflate a constructor belonging to a vm-anonymous class\n        // because that kind of class can\'t be referred to by name, hence can\'t\n        // be found from the generated bytecode.\n        if (++numInvocations > ReflectionFactory.inflationThreshold()\n                && !ReflectUtil.isVMAnonymousClass(c.getDeclaringClass())) {\n            ConstructorAccessorImpl acc = (ConstructorAccessorImpl)\n                new MethodAccessorGenerator().\n                    generateConstructor(c.getDeclaringClass(),\n                                        c.getParameterTypes(),\n                                        c.getExceptionTypes(),\n                                        c.getModifiers());\n            parent.setDelegate(acc);\n        }\n\n        // 调用native方法，进行调用 constructor\n        return newInstance0(c, args);\n    }\n\n\n返回构造器的实例后，可以根据外部进行进行类型转换，从而使用接口或方法进行调用实例功能了。\n\n\n# 反射获取方法\n\n * 第一步，先获取 Method;\n\n    // java.lang.Class\n    @CallerSensitive\n    public Method getDeclaredMethod(String name, Class<?>... parameterTypes)\n        throws NoSuchMethodException, SecurityException {\n        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);\n        Method method = searchMethods(privateGetDeclaredMethods(false), name, parameterTypes);\n        if (method == null) {\n            throw new NoSuchMethodException(getName() + "." + name + argumentTypesToString(parameterTypes));\n        }\n        return method;\n    }\n\n\n忽略第一个检查权限，剩下就只有两个动作了。\n\n * 1. 获取所有方法列表；\n * 2. 根据方法名称和方法列表，选出符合要求的方法；\n * 3. 如果没有找到相应方法，抛出异常，否则返回对应方法；\n\n所以，先看一下怎样获取类声明的所有方法？\n\n    // Returns an array of "root" methods. These Method objects must NOT\n    // be propagated to the outside world, but must instead be copied\n    // via ReflectionFactory.copyMethod.\n    private Method[] privateGetDeclaredMethods(boolean publicOnly) {\n        checkInitted();\n        Method[] res;\n        ReflectionData<T> rd = reflectionData();\n        if (rd != null) {\n            res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;\n            if (res != null) return res;\n        }\n        // No cached value available; request value from VM\n        res = Reflection.filterMethods(this, getDeclaredMethods0(publicOnly));\n        if (rd != null) {\n            if (publicOnly) {\n                rd.declaredPublicMethods = res;\n            } else {\n                rd.declaredMethods = res;\n            }\n        }\n        return res;\n    }\n\n\n很相似，和获取所有构造器的方法很相似，都是先从缓存中获取方法，如果没有，则从jvm中获取。\n\n不同的是，方法列表需要进行过滤 Reflection.filterMethods;当然后面看来，这个方法我们一般不会派上用场。\n\n\n    // sun.misc.Reflection\n    public static Method[] filterMethods(Class<?> containingClass, Method[] methods) {\n        if (methodFilterMap == null) {\n            // Bootstrapping\n            return methods;\n        }\n        return (Method[])filter(methods, methodFilterMap.get(containingClass));\n    }\n    // 可以过滤指定的方法，一般为空，如果要指定过滤，可以调用 registerMethodsToFilter(), 或者...\n    private static Member[] filter(Member[] members, String[] filteredNames) {\n        if ((filteredNames == null) || (members.length == 0)) {\n            return members;\n        }\n        int numNewMembers = 0;\n        for (Member member : members) {\n            boolean shouldSkip = false;\n            for (String filteredName : filteredNames) {\n                if (member.getName() == filteredName) {\n                    shouldSkip = true;\n                    break;\n                }\n            }\n            if (!shouldSkip) {\n                ++numNewMembers;\n            }\n        }\n        Member[] newMembers =\n            (Member[])Array.newInstance(members[0].getClass(), numNewMembers);\n        int destIdx = 0;\n        for (Member member : members) {\n            boolean shouldSkip = false;\n            for (String filteredName : filteredNames) {\n                if (member.getName() == filteredName) {\n                    shouldSkip = true;\n                    break;\n                }\n            }\n            if (!shouldSkip) {\n                newMembers[destIdx++] = member;\n            }\n        }\n        return newMembers;\n    }\n\n\n\n * 第二步，根据方法名和参数类型过滤指定方法返回：\n\n    private static Method searchMethods(Method[] methods,\n                                        String name,\n                                        Class<?>[] parameterTypes)\n    {\n        Method res = null;\n        // 使用常量池，避免重复创建String\n        String internedName = name.intern();\n        for (int i = 0; i < methods.length; i++) {\n            Method m = methods[i];\n            if (m.getName() == internedName\n                && arrayContentsEq(parameterTypes, m.getParameterTypes())\n                && (res == null\n                    || res.getReturnType().isAssignableFrom(m.getReturnType())))\n                res = m;\n        }\n\n        return (res == null ? res : getReflectionFactory().copyMethod(res));\n    }\n\n\n大概意思看得明白，就是匹配到方法名，然后参数类型匹配，才可以。\n\n * 但是可以看到，匹配到一个方法，并没有退出for循环，而是继续进行匹配。\n * 这里是匹配最精确的子类进行返回（最优匹配）\n * 最后，还是通过 ReflectionFactory, copy 方法后返回。\n\n\n# 调用 method.invoke() 方法\n\n    @CallerSensitive\n    public Object invoke(Object obj, Object... args)\n        throws IllegalAccessException, IllegalArgumentException,\n           InvocationTargetException\n    {\n        if (!override) {\n            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {\n                Class<?> caller = Reflection.getCallerClass();\n                checkAccess(caller, clazz, obj, modifiers);\n            }\n        }\n        MethodAccessor ma = methodAccessor;             // read volatile\n        if (ma == null) {\n            ma = acquireMethodAccessor();\n        }\n        return ma.invoke(obj, args);\n    }\n\n\ninvoke时，是通过 MethodAccessor 进行调用的，而 MethodAccessor 是个接口，在第一次时调用 acquireMethodAccessor() 进行新创建。\n\n    // probably make the implementation more scalable.\n    private MethodAccessor acquireMethodAccessor() {\n        // First check to see if one has been created yet, and take it\n        // if so\n        MethodAccessor tmp = null;\n        if (root != null) tmp = root.getMethodAccessor();\n        if (tmp != null) {\n            // 存在缓存时，存入 methodAccessor，否则调用 ReflectionFactory 创建新的 MethodAccessor\n            methodAccessor = tmp;\n        } else {\n            // Otherwise fabricate one and propagate it up to the root\n            tmp = reflectionFactory.newMethodAccessor(this);\n            setMethodAccessor(tmp);\n        }\n\n        return tmp;\n    }\n    // sun.reflect.ReflectionFactory\n    public MethodAccessor newMethodAccessor(Method method) {\n        checkInitted();\n\n        if (noInflation && !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) {\n            return new MethodAccessorGenerator().\n                generateMethod(method.getDeclaringClass(),\n                               method.getName(),\n                               method.getParameterTypes(),\n                               method.getReturnType(),\n                               method.getExceptionTypes(),\n                               method.getModifiers());\n        } else {\n            NativeMethodAccessorImpl acc =\n                new NativeMethodAccessorImpl(method);\n            DelegatingMethodAccessorImpl res =\n                new DelegatingMethodAccessorImpl(acc);\n            acc.setParent(res);\n            return res;\n        }\n    }\n\n\n两个Accessor详情：\n\n\n//     NativeMethodAccessorImpl / DelegatingMethodAccessorImpl\nclass NativeMethodAccessorImpl extends MethodAccessorImpl {\n    private final Method method;\n    private DelegatingMethodAccessorImpl parent;\n    private int numInvocations;\n\n    NativeMethodAccessorImpl(Method method) {\n        this.method = method;\n    }\n\n    public Object invoke(Object obj, Object[] args)\n        throws IllegalArgumentException, InvocationTargetException\n    {\n        // We can\'t inflate methods belonging to vm-anonymous classes because\n        // that kind of class can\'t be referred to by name, hence can\'t be\n        // found from the generated bytecode.\n        if (++numInvocations > ReflectionFactory.inflationThreshold()\n                && !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) {\n            MethodAccessorImpl acc = (MethodAccessorImpl)\n                new MethodAccessorGenerator().\n                    generateMethod(method.getDeclaringClass(),\n                                   method.getName(),\n                                   method.getParameterTypes(),\n                                   method.getReturnType(),\n                                   method.getExceptionTypes(),\n                                   method.getModifiers());\n            parent.setDelegate(acc);\n        }\n\n        return invoke0(method, obj, args);\n    }\n\n    void setParent(DelegatingMethodAccessorImpl parent) {\n        this.parent = parent;\n    }\n\n    private static native Object invoke0(Method m, Object obj, Object[] args);\n}\nclass DelegatingMethodAccessorImpl extends MethodAccessorImpl {\n    private MethodAccessorImpl delegate;\n\n    DelegatingMethodAccessorImpl(MethodAccessorImpl delegate) {\n        setDelegate(delegate);\n    }\n\n    public Object invoke(Object obj, Object[] args)\n        throws IllegalArgumentException, InvocationTargetException\n    {\n        return delegate.invoke(obj, args);\n    }\n\n    void setDelegate(MethodAccessorImpl delegate) {\n        this.delegate = delegate;\n    }\n}\n\n\n进行 ma.invoke(obj, args); 调用时，调用 DelegatingMethodAccessorImpl.invoke();\n\n最后被委托到 NativeMethodAccessorImpl.invoke(), 即：\n\n    public Object invoke(Object obj, Object[] args)\n        throws IllegalArgumentException, InvocationTargetException\n    {\n        // We can\'t inflate methods belonging to vm-anonymous classes because\n        // that kind of class can\'t be referred to by name, hence can\'t be\n        // found from the generated bytecode.\n        if (++numInvocations > ReflectionFactory.inflationThreshold()\n                && !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) {\n            MethodAccessorImpl acc = (MethodAccessorImpl)\n                new MethodAccessorGenerator().\n                    generateMethod(method.getDeclaringClass(),\n                                   method.getName(),\n                                   method.getParameterTypes(),\n                                   method.getReturnType(),\n                                   method.getExceptionTypes(),\n                                   method.getModifiers());\n            parent.setDelegate(acc);\n        }\n\n        // invoke0 是个 native 方法，由jvm进行调用业务方法。从而完成反射调用功能。\n        return invoke0(method, obj, args);\n    }\n\n\n其中， generateMethod() 是生成具体类的方法：\n\n    /** This routine is not thread-safe */\n    public MethodAccessor generateMethod(Class<?> declaringClass,\n                                         String   name,\n                                         Class<?>[] parameterTypes,\n                                         Class<?>   returnType,\n                                         Class<?>[] checkedExceptions,\n                                         int modifiers)\n    {\n        return (MethodAccessor) generate(declaringClass,\n                                         name,\n                                         parameterTypes,\n                                         returnType,\n                                         checkedExceptions,\n                                         modifiers,\n                                         false,\n                                         false,\n                                         null);\n    }\n\n\ngenerate() 戳详情。\n\n    /** This routine is not thread-safe */\n    private MagicAccessorImpl generate(final Class<?> declaringClass,\n                                       String name,\n                                       Class<?>[] parameterTypes,\n                                       Class<?>   returnType,\n                                       Class<?>[] checkedExceptions,\n                                       int modifiers,\n                                       boolean isConstructor,\n                                       boolean forSerialization,\n                                       Class<?> serializationTargetClass)\n    {\n        ByteVector vec = ByteVectorFactory.create();\n        asm = new ClassFileAssembler(vec);\n        this.declaringClass = declaringClass;\n        this.parameterTypes = parameterTypes;\n        this.returnType = returnType;\n        this.modifiers = modifiers;\n        this.isConstructor = isConstructor;\n        this.forSerialization = forSerialization;\n\n        asm.emitMagicAndVersion();\n\n        // Constant pool entries:\n        // ( * = Boxing information: optional)\n        // (+  = Shared entries provided by AccessorGenerator)\n        // (^  = Only present if generating SerializationConstructorAccessor)\n        //     [UTF-8] [This class\'s name]\n        //     [CONSTANT_Class_info] for above\n        //     [UTF-8] "sun/reflect/{MethodAccessorImpl,ConstructorAccessorImpl,SerializationConstructorAccessorImpl}"\n        //     [CONSTANT_Class_info] for above\n        //     [UTF-8] [Target class\'s name]\n        //     [CONSTANT_Class_info] for above\n        // ^   [UTF-8] [Serialization: Class\'s name in which to invoke constructor]\n        // ^   [CONSTANT_Class_info] for above\n        //     [UTF-8] target method or constructor name\n        //     [UTF-8] target method or constructor signature\n        //     [CONSTANT_NameAndType_info] for above\n        //     [CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info] for target method\n        //     [UTF-8] "invoke" or "newInstance"\n        //     [UTF-8] invoke or newInstance descriptor\n        //     [UTF-8] descriptor for type of non-primitive parameter 1\n        //     [CONSTANT_Class_info] for type of non-primitive parameter 1\n        //     ...\n        //     [UTF-8] descriptor for type of non-primitive parameter n\n        //     [CONSTANT_Class_info] for type of non-primitive parameter n\n        // +   [UTF-8] "java/lang/Exception"\n        // +   [CONSTANT_Class_info] for above\n        // +   [UTF-8] "java/lang/ClassCastException"\n        // +   [CONSTANT_Class_info] for above\n        // +   [UTF-8] "java/lang/NullPointerException"\n        // +   [CONSTANT_Class_info] for above\n        // +   [UTF-8] "java/lang/IllegalArgumentException"\n        // +   [CONSTANT_Class_info] for above\n        // +   [UTF-8] "java/lang/InvocationTargetException"\n        // +   [CONSTANT_Class_info] for above\n        // +   [UTF-8] "<init>"\n        // +   [UTF-8] "()V"\n        // +   [CONSTANT_NameAndType_info] for above\n        // +   [CONSTANT_Methodref_info] for NullPointerException\'s constructor\n        // +   [CONSTANT_Methodref_info] for IllegalArgumentException\'s constructor\n        // +   [UTF-8] "(Ljava/lang/String;)V"\n        // +   [CONSTANT_NameAndType_info] for "<init>(Ljava/lang/String;)V"\n        // +   [CONSTANT_Methodref_info] for IllegalArgumentException\'s constructor taking a String\n        // +   [UTF-8] "(Ljava/lang/Throwable;)V"\n        // +   [CONSTANT_NameAndType_info] for "<init>(Ljava/lang/Throwable;)V"\n        // +   [CONSTANT_Methodref_info] for InvocationTargetException\'s constructor\n        // +   [CONSTANT_Methodref_info] for "super()"\n        // +   [UTF-8] "java/lang/Object"\n        // +   [CONSTANT_Class_info] for above\n        // +   [UTF-8] "toString"\n        // +   [UTF-8] "()Ljava/lang/String;"\n        // +   [CONSTANT_NameAndType_info] for "toString()Ljava/lang/String;"\n        // +   [CONSTANT_Methodref_info] for Object\'s toString method\n        // +   [UTF-8] "Code"\n        // +   [UTF-8] "Exceptions"\n        //  *  [UTF-8] "java/lang/Boolean"\n        //  *  [CONSTANT_Class_info] for above\n        //  *  [UTF-8] "(Z)V"\n        //  *  [CONSTANT_NameAndType_info] for above\n        //  *  [CONSTANT_Methodref_info] for above\n        //  *  [UTF-8] "booleanValue"\n        //  *  [UTF-8] "()Z"\n        //  *  [CONSTANT_NameAndType_info] for above\n        //  *  [CONSTANT_Methodref_info] for above\n        //  *  [UTF-8] "java/lang/Byte"\n        //  *  [CONSTANT_Class_info] for above\n        //  *  [UTF-8] "(B)V"\n        //  *  [CONSTANT_NameAndType_info] for above\n        //  *  [CONSTANT_Methodref_info] for above\n        //  *  [UTF-8] "byteValue"\n        //  *  [UTF-8] "()B"\n        //  *  [CONSTANT_NameAndType_info] for above\n        //  *  [CONSTANT_Methodref_info] for above\n        //  *  [UTF-8] "java/lang/Character"\n        //  *  [CONSTANT_Class_info] for above\n        //  *  [UTF-8] "(C)V"\n        //  *  [CONSTANT_NameAndType_info] for above\n        //  *  [CONSTANT_Methodref_info] for above\n        //  *  [UTF-8] "charValue"\n        //  *  [UTF-8] "()C"\n        //  *  [CONSTANT_NameAndType_info] for above\n        //  *  [CONSTANT_Methodref_info] for above\n        //  *  [UTF-8] "java/lang/Double"\n        //  *  [CONSTANT_Class_info] for above\n        //  *  [UTF-8] "(D)V"\n        //  *  [CONSTANT_NameAndType_info] for above\n        //  *  [CONSTANT_Methodref_info] for above\n        //  *  [UTF-8] "doubleValue"\n        //  *  [UTF-8] "()D"\n        //  *  [CONSTANT_NameAndType_info] for above\n        //  *  [CONSTANT_Methodref_info] for above\n        //  *  [UTF-8] "java/lang/Float"\n        //  *  [CONSTANT_Class_info] for above\n        //  *  [UTF-8] "(F)V"\n        //  *  [CONSTANT_NameAndType_info] for above\n        //  *  [CONSTANT_Methodref_info] for above\n        //  *  [UTF-8] "floatValue"\n        //  *  [UTF-8] "()F"\n        //  *  [CONSTANT_NameAndType_info] for above\n        //  *  [CONSTANT_Methodref_info] for above\n        //  *  [UTF-8] "java/lang/Integer"\n        //  *  [CONSTANT_Class_info] for above\n        //  *  [UTF-8] "(I)V"\n        //  *  [CONSTANT_NameAndType_info] for above\n        //  *  [CONSTANT_Methodref_info] for above\n        //  *  [UTF-8] "intValue"\n        //  *  [UTF-8] "()I"\n        //  *  [CONSTANT_NameAndType_info] for above\n        //  *  [CONSTANT_Methodref_info] for above\n        //  *  [UTF-8] "java/lang/Long"\n        //  *  [CONSTANT_Class_info] for above\n        //  *  [UTF-8] "(J)V"\n        //  *  [CONSTANT_NameAndType_info] for above\n        //  *  [CONSTANT_Methodref_info] for above\n        //  *  [UTF-8] "longValue"\n        //  *  [UTF-8] "()J"\n        //  *  [CONSTANT_NameAndType_info] for above\n        //  *  [CONSTANT_Methodref_info] for above\n        //  *  [UTF-8] "java/lang/Short"\n        //  *  [CONSTANT_Class_info] for above\n        //  *  [UTF-8] "(S)V"\n        //  *  [CONSTANT_NameAndType_info] for above\n        //  *  [CONSTANT_Methodref_info] for above\n        //  *  [UTF-8] "shortValue"\n        //  *  [UTF-8] "()S"\n        //  *  [CONSTANT_NameAndType_info] for above\n        //  *  [CONSTANT_Methodref_info] for above\n\n        short numCPEntries = NUM_BASE_CPOOL_ENTRIES + NUM_COMMON_CPOOL_ENTRIES;\n        boolean usesPrimitives = usesPrimitiveTypes();\n        if (usesPrimitives) {\n            numCPEntries += NUM_BOXING_CPOOL_ENTRIES;\n        }\n        if (forSerialization) {\n            numCPEntries += NUM_SERIALIZATION_CPOOL_ENTRIES;\n        }\n\n        // Add in variable-length number of entries to be able to describe\n        // non-primitive parameter types and checked exceptions.\n        numCPEntries += (short) (2 * numNonPrimitiveParameterTypes());\n\n        asm.emitShort(add(numCPEntries, S1));\n\n        final String generatedName = generateName(isConstructor, forSerialization);\n        asm.emitConstantPoolUTF8(generatedName);\n        asm.emitConstantPoolClass(asm.cpi());\n        thisClass = asm.cpi();\n        if (isConstructor) {\n            if (forSerialization) {\n                asm.emitConstantPoolUTF8\n                    ("sun/reflect/SerializationConstructorAccessorImpl");\n            } else {\n                asm.emitConstantPoolUTF8("sun/reflect/ConstructorAccessorImpl");\n            }\n        } else {\n            asm.emitConstantPoolUTF8("sun/reflect/MethodAccessorImpl");\n        }\n        asm.emitConstantPoolClass(asm.cpi());\n        superClass = asm.cpi();\n        asm.emitConstantPoolUTF8(getClassName(declaringClass, false));\n        asm.emitConstantPoolClass(asm.cpi());\n        targetClass = asm.cpi();\n        short serializationTargetClassIdx = (short) 0;\n        if (forSerialization) {\n            asm.emitConstantPoolUTF8(getClassName(serializationTargetClass, false));\n            asm.emitConstantPoolClass(asm.cpi());\n            serializationTargetClassIdx = asm.cpi();\n        }\n        asm.emitConstantPoolUTF8(name);\n        asm.emitConstantPoolUTF8(buildInternalSignature());\n        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());\n        if (isInterface()) {\n            asm.emitConstantPoolInterfaceMethodref(targetClass, asm.cpi());\n        } else {\n            if (forSerialization) {\n                asm.emitConstantPoolMethodref(serializationTargetClassIdx, asm.cpi());\n            } else {\n                asm.emitConstantPoolMethodref(targetClass, asm.cpi());\n            }\n        }\n        targetMethodRef = asm.cpi();\n        if (isConstructor) {\n            asm.emitConstantPoolUTF8("newInstance");\n        } else {\n            asm.emitConstantPoolUTF8("invoke");\n        }\n        invokeIdx = asm.cpi();\n        if (isConstructor) {\n            asm.emitConstantPoolUTF8("([Ljava/lang/Object;)Ljava/lang/Object;");\n        } else {\n            asm.emitConstantPoolUTF8\n                ("(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;");\n        }\n        invokeDescriptorIdx = asm.cpi();\n\n        // Output class information for non-primitive parameter types\n        nonPrimitiveParametersBaseIdx = add(asm.cpi(), S2);\n        for (int i = 0; i < parameterTypes.length; i++) {\n            Class<?> c = parameterTypes[i];\n            if (!isPrimitive(c)) {\n                asm.emitConstantPoolUTF8(getClassName(c, false));\n                asm.emitConstantPoolClass(asm.cpi());\n            }\n        }\n\n        // Entries common to FieldAccessor, MethodAccessor and ConstructorAccessor\n        emitCommonConstantPoolEntries();\n\n        // Boxing entries\n        if (usesPrimitives) {\n            emitBoxingContantPoolEntries();\n        }\n\n        if (asm.cpi() != numCPEntries) {\n            throw new InternalError("Adjust this code (cpi = " + asm.cpi() +\n                                    ", numCPEntries = " + numCPEntries + ")");\n        }\n\n        // Access flags\n        asm.emitShort(ACC_PUBLIC);\n\n        // This class\n        asm.emitShort(thisClass);\n\n        // Superclass\n        asm.emitShort(superClass);\n\n        // Interfaces count and interfaces\n        asm.emitShort(S0);\n\n        // Fields count and fields\n        asm.emitShort(S0);\n\n        // Methods count and methods\n        asm.emitShort(NUM_METHODS);\n\n        emitConstructor();\n        emitInvoke();\n\n        // Additional attributes (none)\n        asm.emitShort(S0);\n\n        // Load class\n        vec.trim();\n        final byte[] bytes = vec.getData();\n        // Note: the class loader is the only thing that really matters\n        // here -- it\'s important to get the generated code into the\n        // same namespace as the target class. Since the generated code\n        // is privileged anyway, the protection domain probably doesn\'t\n        // matter.\n        return AccessController.doPrivileged(\n            new PrivilegedAction<MagicAccessorImpl>() {\n                public MagicAccessorImpl run() {\n                        try {\n                        return (MagicAccessorImpl)\n                        ClassDefiner.defineClass\n                                (generatedName,\n                                 bytes,\n                                 0,\n                                 bytes.length,\n                                 declaringClass.getClassLoader()).newInstance();\n                        } catch (InstantiationException | IllegalAccessException e) {\n                            throw new InternalError(e);\n                        }\n                    }\n                });\n    }\n\n\n咱们主要看这一句：ClassDefiner.defineClass(xx, declaringClass.getClassLoader()).newInstance();\n\n在ClassDefiner.defineClass方法实现中，每被调用一次都会生成一个DelegatingClassLoader类加载器对象 ，这里每次都生成新的类加载器，是为了性能考虑，在某些情况下可以卸载这些生成的类，因为类的卸载是只有在类加载器可以被回收的情况下才会被回收的，如果用了原来的类加载器，那可能导致这些新创建的类一直无法被卸载。\n\n而反射生成的类，有时候可能用了就可以卸载了，所以使用其独立的类加载器，从而使得更容易控制反射类的生命周期。\n\n\n# 反射调用流程小结\n\n最后，用几句话总结反射的实现原理：\n\n 1. 反射类及反射方法的获取，都是通过从列表中搜寻查找匹配的方法，所以查找性能会随类的大小方法多少而变化；\n\n 2. 每个类都会有一个与之对应的Class实例，从而每个类都可以获取method反射方法，并作用到其他实例身上；\n\n 3. 反射也是考虑了线程安全的，放心使用；\n\n 4. 反射使用软引用relectionData缓存class信息，避免每次重新从jvm获取带来的开销；\n\n 5. 反射调用多次生成新代理Accessor, 而通过字节码生存的则考虑了卸载功能，所以会使用独立的类加载器；\n\n 6. 当找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证数据隔离；\n\n 7. 调度反射方法，最终是由jvm执行invoke0()执行；\n\n\n# 参考文章\n\n * https://www.codercto.com/a/46094.html\n * https://blog.csdn.net/sinat_38259539/article/details/71799078\n * https://blog.csdn.net/qq_40896997/article/details/94483820\n * https://www.cnblogs.com/zhaoguhong/p/6937364.html\n * https://juejin.im/post/5c160420e51d452a60684431\n * https://blog.csdn.net/mcryeasy/java/article/details/52344729\n * 转载 https://www.pdai.tech/md/java/basic/java-basic-x-reflection.html',normalizedContent:'# java 基础 - 反射机制详解\n\n> java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。java反射机制在框架设计中极为广泛，需要深入理解。本文综合多篇文章后，总结了java 反射的相关知识，希望可以提升你对java中反射的认知效率。\n\n * java 基础 - 反射机制详解\n   * 反射基础\n     * class类\n     * 类加载\n   * 反射的使用\n     * class类对象的获取\n     * constructor类及其用法\n     * field类及其用法\n     * method类及其用法\n   * 反射机制执行的流程\n     * 反射获取类实例\n     * 反射获取方法\n     * 调用 method.invoke() 方法\n     * 反射调用流程小结\n   * 参考文章\n\n\n# 反射基础\n\nrtti（run-time type identification）运行时类型识别。在《thinking in java》一书第十四章中有提到，其作用是在运行时识别一个对象的类型和类的信息。主要有两种方式：一种是“传统的”rtti，它假定我们在编译时已经知道了所有的类型；另一种是“反射”机制，它允许我们在运行时发现和使用类的信息。\n\n反射就是把java类中的各种成分映射成一个个的java对象\n\n例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。\n\n> 这里我们首先需要理解 class类，以及类的加载机制； 然后基于此我们如何通过反射获取class类以及类中的成员变量、方法、构造方法等。\n\n\n# class类\n\nclass类，class类也是一个实实在在的类，存在于jdk的java.lang包中。class类的实例表示java应用运行时的类(class ans enum)或接口(interface and annotation)（每个java类运行时都在jvm里表现为一个class对象，可通过类名.class、类型.getclass()、class.forname("类名")等方法获取class对象）。数组同样也被映射为class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 class 对象。基本类型boolean，byte，char，short，int，long，float，double和关键字void同样表现为 class 对象。\n\npublic final class class<t> implements java.io.serializable,\n                              genericdeclaration,\n                              type,\n                              annotatedelement {\n    private static final int annotation= 0x00002000;\n    private static final int enum      = 0x00004000;\n    private static final int synthetic = 0x00001000;\n\n    private static native void registernatives();\n    static {\n        registernatives();\n    }\n\n    /*\n     * private constructor. only the java virtual machine creates class objects.   //私有构造器，只有jvm才能调用创建class对象\n     * this constructor is not used and prevents the default constructor being\n     * generated.\n     */\n    private class(classloader loader) {\n        // initialize final field for classloader.  the initialization value of non-null\n        // prevents future jit optimizations from assuming this final field is null.\n        classloader = loader;\n    }\n\n\n到这我们也就可以得出以下几点信息：\n\n * class类也是类的一种，与class关键字是不一样的。\n\n * 手动编写的类被编译后会产生一个class对象，其表示的是创建的类的类型信息，而且这个class对象保存在同名.class的文件中(字节码文件)\n\n * 每个通过关键字class标识的类，在内存中有且只有一个与之对应的class对象来描述其类型信息，无论创建多少个实例对象，其依据的都是用一个class对象。\n\n * class类只存私有构造函数，因此对应class对象只能有jvm创建和加载\n\n * class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要(关于反射稍后分析)。\n\n\n# 类加载\n\n类加载机制和类字节码技术可以参考如下两篇文章：\n\n * jvm基础 - 类字节码详解\n   * 源代码通过编译器编译为字节码，再通过类加载子系统进行加载到jvm中运行\n * jvm基础 - java 类加载机制\n   * 这篇文章将带你深入理解java 类加载机制\n\n其中，这里我们需要回顾的是：\n\n 1. 类加载机制流程\n\n\n\n 2. 类的加载\n\n\n\n\n# 反射的使用\n\n提示\n\n基于此我们如何通过反射获取class类对象以及类中的成员变量、方法、构造方法等\n\n在java中，class类与java.lang.reflect类库一起对反射技术进行了全力的支持。在反射包中，我们常用的类主要有constructor类表示的是class 对象所表示的类的构造方法，利用它可以在运行时动态创建对象、field表示class对象所表示的类的成员变量，通过它可以在运行时动态修改成员变量的属性值(包含private)、method表示class对象所表示的类的成员方法，通过它可以动态调用对象的方法(包含private)，下面将对这几个重要类进行分别说明。\n\n\n# class类对象的获取\n\n在类加载的时候，jvm会创建一个class对象\n\nclass对象是可以说是反射中最常用的，获取class对象的方式的主要有三种\n\n * 根据类名：类名.class\n * 根据对象：对象.getclass()\n * 根据全限定类名：class.forname(全限定类名)\n\n    @test\n    public void classtest() throws exception {\n        // 获取class对象的三种方式\n        logger.info("根据类名:  \\t" + user.class);\n        logger.info("根据对象:  \\t" + new user().getclass());\n        logger.info("根据全限定类名:\\t" + class.forname("com.test.user"));\n        // 常用的方法\n        logger.info("获取全限定类名:\\t" + userclass.getname());\n        logger.info("获取类名:\\t" + userclass.getsimplename());\n        logger.info("实例化:\\t" + userclass.newinstance());\n    }\n\n    // ...\n    package com.test;\n\n    public class user {\n        private string name = "init";\n        private int age;\n        public user() {}\n        public user(string name, int age) {\n            super();\n            this.name = name;\n            this.age = age;\n        }\n        private string getname() {\n            return name;\n        }\n        private void setname(string name) {\n            this.name = name;\n        }\n        public int getage() {\n            return age;\n        }\n        public void setage(int age) {\n            this.age = age;\n        }\n        @override\n        public string tostring() {\n            return "user [name=" + name + ", age=" + age + "]";\n        }\n    }\n\n\n输出结果：\n\n根据类名:  \tclass com.test.user\n根据对象:  \tclass com.test.user\n根据全限定类名:\tclass com.test.user\n获取全限定类名:\tcom.test.user\n获取类名:\tuser\n实例化:\tuser [name=init, age=0]\n\n\n * 再来看看 class类的方法\n\n方法名                                  说明\nforname()                            (1)获取class对象的一个引用，但引用的类还没有加载(该类的第一个对象没有生成)就加载了这个类。\n(2)为了产生class引用，forname()立即就进行了初始化。   \nobject-getclass()                    获取class对象的一个引用，返回表示该对象的实际类型的class引用。\ngetname()                            取全限定的类名(包括包名)，即类的完整名字。\ngetsimplename()                      获取类名(不包括包名)\ngetcanonicalname()                   获取全限定的类名(包括包名)\nisinterface()                        判断class对象是否是表示一个接口\ngetinterfaces()                      返回class对象数组，表示class对象所引用的类所实现的所有接口。\ngetsupercalss()                      返回class对象，表示class对象所引用的类所继承的直接基类。应用该方法可在运行时发现一个对象完整的继承结构。\nnewinstance()                        返回一个oject对象，是实现“虚拟构造器”的一种途径。使用该方法创建的类，必须带有无参的构造器。\ngetfields()                          获得某个类的所有的公共（public）的字段，包括继承自父类的所有公共字段。\n                                     类似的还有getmethods和getconstructors。\ngetdeclaredfields                    获得某个类的自己声明的字段，即包括public、private和proteced，默认但是不包括父类声明的任何字段。类似的还有getdeclaredmethods和getdeclaredconstructors。\n\n简单测试下（这里例子源于https://blog.csdn.net/mcryeasy/article/details/52344729）\n\npackage com.cry;\nimport java.lang.reflect.field;\ninterface i1 {\n}\ninterface i2 {\n}\nclass cell{\n    public int mcellpublic;\n}\nclass animal extends  cell{\n    private int manimalprivate;\n    protected int manimalprotected;\n    int manimaldefault;\n    public int manimalpublic;\n    private static int sanimalprivate;\n    protected static int sanimalprotected;\n    static int sanimaldefault;\n    public static int sanimalpublic;\n}\nclass dog extends animal implements i1, i2 {\n    private int mdogprivate;\n    public int mdogpublic;\n    protected int mdogprotected;\n    private int mdogdefault;\n    private static int sdogprivate;\n    protected static int sdogprotected;\n    static int sdogdefault;\n    public static int sdogpublic;\n}\npublic class test {\n    public static void main(string[] args) throws illegalaccessexception, instantiationexception {\n        class<dog> dog = dog.class;\n        //类名打印\n        system.out.println(dog.getname()); //com.cry.dog\n        system.out.println(dog.getsimplename()); //dog\n        system.out.println(dog.getcanonicalname());//com.cry.dog\n        //接口\n        system.out.println(dog.isinterface()); //false\n        for (class ii : dog.getinterfaces()) {\n            system.out.println(ii);\n        }\n         /*\n          interface com.cry.i1\n          interface com.cry.i2\n         */\n\n        //父类\n        system.out.println(dog.getsuperclass());//class com.cry.animal\n        //创建对象\n        dog d = dog.newinstance();\n        //字段\n        for (field f : dog.getfields()) {\n            system.out.println(f.getname());\n        }\n        /*\n            mdogpublic\n            sdogpublic\n            manimalpublic\n            sanimalpublic\n            mcellpublic  //父类的父类的公共字段也打印出来了\n         */\n        system.out.println("---------");\n        for (field f : dog.getdeclaredfields()) {\n            system.out.println(f.getname());\n        }\n        /** 只有自己类声明的字段\n         mdogprivate\n         mdogpublic\n         mdogprotected\n         mdogdefault\n         sdogprivate\n         sdogprotected\n         sdogdefault\n         sdogpublic\n         */\n    }\n}\n\n\ngetname、getcanonicalname与getsimplename的区别：\n\n * getsimplename：只获取类名\n * getname：类的全限定名，jvm中class的表示，可以用于动态加载class对象，例如class.forname。\n * getcanonicalname：返回更容易理解的表示，主要用于输出（tostring）或log打印，大多数情况下和getname一样，但是在内部类、数组等类型的表示形式就不同了。\n\npackage com.cry;\npublic class test {\n    private  class inner{\n    }\n    public static void main(string[] args) throws classnotfoundexception {\n        //普通类\n        system.out.println(test.class.getsimplename()); //test\n        system.out.println(test.class.getname()); //com.cry.test\n        system.out.println(test.class.getcanonicalname()); //com.cry.test\n        //内部类\n        system.out.println(inner.class.getsimplename()); //inner\n        system.out.println(inner.class.getname()); //com.cry.test$inner\n        system.out.println(inner.class.getcanonicalname()); //com.cry.test.inner\n        //数组\n        system.out.println(args.getclass().getsimplename()); //string[]\n        system.out.println(args.getclass().getname()); //[ljava.lang.string;\n        system.out.println(args.getclass().getcanonicalname()); //java.lang.string[]\n        //我们不能用getcanonicalname去加载类对象，必须用getname\n        //class.forname(inner.class.getcanonicalname()); 报错\n        class.forname(inner.class.getname());\n    }\n}\n\n\n\n# constructor类及其用法\n\n> constructor类存在于反射包(java.lang.reflect)中，反映的是class 对象所表示的类的构造方法。\n\n获取constructor对象是通过class类中的方法获取的，class类与constructor相关的主要方法如下：\n\n方法返回值              方法名称                                                 方法说明\nstatic class<?>    forname(string classname)                            返回与带有给定字符串名的类或接口相关联的 class 对象。\nconstructor        getconstructor(class<?>... parametertypes)           返回指定参数类型、具有public访问权限的构造函数对象\nconstructor<?>[]   getconstructors()                                    返回所有具有public访问权限的构造函数的constructor对象数组\nconstructor        getdeclaredconstructor(class<?>... parametertypes)   返回指定参数类型、所有声明的（包括private）构造函数对象\nconstructor<?>[]   getdeclaredconstructors()                            返回所有声明的（包括private）构造函数对象\nt                  newinstance()                                        调用无参构造器创建此 class 对象所表示的类的一个新实例。\n\n下面看一个简单例子来了解constructor对象的使用：\n\npublic class constructiontest implements serializable {\n    public static void main(string[] args) throws exception {\n\n        class<?> clazz = null;\n\n        //获取class对象的引用\n        clazz = class.forname("com.example.javabase.user");\n\n        //第一种方法，实例化默认构造方法，user必须无参构造函数,否则将抛异常\n        user user = (user) clazz.newinstance();\n        user.setage(20);\n        user.setname("jack");\n        system.out.println(user);\n\n        system.out.println("--------------------------------------------");\n\n        //获取带string参数的public构造函数\n        constructor cs1 =clazz.getconstructor(string.class);\n        //创建user\n        user user1= (user) cs1.newinstance("hiway");\n        user1.setage(22);\n        system.out.println("user1:"+user1.tostring());\n\n        system.out.println("--------------------------------------------");\n\n        //取得指定带int和string参数构造函数,该方法是私有构造private\n        constructor cs2=clazz.getdeclaredconstructor(int.class,string.class);\n        //由于是private必须设置可访问\n        cs2.setaccessible(true);\n        //创建user对象\n        user user2= (user) cs2.newinstance(25,"hiway2");\n        system.out.println("user2:"+user2.tostring());\n\n        system.out.println("--------------------------------------------");\n\n        //获取所有构造包含private\n        constructor<?> cons[] = clazz.getdeclaredconstructors();\n        // 查看每个构造方法需要的参数\n        for (int i = 0; i < cons.length; i++) {\n            //获取构造函数参数类型\n            class<?> clazzs[] = cons[i].getparametertypes();\n            system.out.println("构造函数["+i+"]:"+cons[i].tostring() );\n            system.out.print("参数类型["+i+"]:(");\n            for (int j = 0; j < clazzs.length; j++) {\n                if (j == clazzs.length - 1)\n                    system.out.print(clazzs[j].getname());\n                else\n                    system.out.print(clazzs[j].getname() + ",");\n            }\n            system.out.println(")");\n        }\n    }\n}\n\n\nclass user {\n    private int age;\n    private string name;\n    public user() {\n        super();\n    }\n    public user(string name) {\n        super();\n        this.name = name;\n    }\n\n    /**\n     * 私有构造\n     * @param age\n     * @param name\n     */\n    private user(int age, string name) {\n        super();\n        this.age = age;\n        this.name = name;\n    }\n\n    public int getage() {\n        return age;\n    }\n\n    public void setage(int age) {\n        this.age = age;\n    }\n\n    public string getname() {\n        return name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    @override\n    public string tostring() {\n        return "user{" +\n                "age=" + age +\n                ", name=\'" + name + \'\\\'\' +\n                \'}\';\n    }\n}\n\n\n输出结果\n\n/* output \nuser{age=20, name=\'jack\'}\n--------------------------------------------\nuser1:user{age=22, name=\'hiway\'}\n--------------------------------------------\nuser2:user{age=25, name=\'hiway2\'}\n--------------------------------------------\n构造函数[0]:private com.example.javabase.user(int,java.lang.string)\n参数类型[0]:(int,java.lang.string)\n构造函数[1]:public com.example.javabase.user(java.lang.string)\n参数类型[1]:(java.lang.string)\n构造函数[2]:public com.example.javabase.user()\n参数类型[2]:()\n\n\n关于constructor类本身一些常用方法如下(仅部分，其他可查api)\n\n方法返回值        方法名称                              方法说明\nclass        getdeclaringclass()               返回 class 对象，该对象表示声明由此 constructor\n                                               对象表示的构造方法的类,其实就是返回真实类型（不包含参数）\ntype[]       getgenericparametertypes()        按照声明顺序返回一组 type 对象，返回的就是 constructor对象构造函数的形参类型。\nstring       getname()                         以字符串形式返回此构造方法的名称。\nclass<?>[]   getparametertypes()               按照声明顺序返回一组 class 对象，即返回constructor 对象所表示构造方法的形参类型\nt            newinstance(object... initargs)   使用此 constructor对象表示的构造函数来创建新实例\nstring       togenericstring()                 返回描述此 constructor 的字符串，其中包括类型参数。\n\n代码演示如下：\n\nconstructor cs3 = clazz.getdeclaredconstructor(int.class,string.class);\nsystem.out.println("-----getdeclaringclass-----");\nclass uclazz=cs3.getdeclaringclass();\n//constructor对象表示的构造方法的类\nsystem.out.println("构造方法的类:"+uclazz.getname());\n\nsystem.out.println("-----getgenericparametertypes-----");\n//对象表示此 constructor 对象所表示的方法的形参类型\ntype[] tps=cs3.getgenericparametertypes();\nfor (type tp:tps) {\n    system.out.println("参数名称tp:"+tp);\n}\nsystem.out.println("-----getparametertypes-----");\n//获取构造函数参数类型\nclass<?> clazzs[] = cs3.getparametertypes();\nfor (class claz:clazzs) {\n    system.out.println("参数名称:"+claz.getname());\n}\nsystem.out.println("-----getname-----");\n//以字符串形式返回此构造方法的名称\nsystem.out.println("getname:"+cs3.getname());\n\nsystem.out.println("-----getogenericstring-----");\n//返回描述此 constructor 的字符串，其中包括类型参数。\nsystem.out.println("getogenericstring():"+cs3.togenericstring());\n\n\n输出结果\n\n-----getdeclaringclass-----\n构造方法的类:com.example.javabase.user\n-----getgenericparametertypes-----\n参数名称tp:int\n参数名称tp:class java.lang.string\n-----getparametertypes-----\n参数名称:int\n参数名称:java.lang.string\n-----getname-----\ngetname:com.example.javabase.user\n-----getogenericstring-----\ngetogenericstring():private com.example.javabase.user(int,java.lang.string)\n\n\n\n# field类及其用法\n\n> field 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段。\n\n同样的道理，我们可以通过class类的提供的方法来获取代表字段信息的field对象，class类与field对象相关方法如下：\n\n方法返回值     方法名称                            方法说明\nfield     getdeclaredfield(string name)   获取指定name名称的(包含private修饰的)字段，不包括继承的字段\nfield[]   getdeclaredfields()             获取class对象所表示的类或接口的所有(包含private修饰的)字段,不包括继承的字段\nfield     getfield(string name)           获取指定name名称、具有public修饰的字段，包含继承字段\nfield[]   getfields()                     获取修饰符为public的字段，包含继承字段\n\n下面的代码演示了上述方法的使用过程\n\npublic class reflectfield {\n\n    public static void main(string[] args) throws classnotfoundexception, nosuchfieldexception {\n        class<?> clazz = class.forname("reflect.student");\n        //获取指定字段名称的field类,注意字段修饰符必须为public而且存在该字段,\n        // 否则抛nosuchfieldexception\n        field field = clazz.getfield("age");\n        system.out.println("field:"+field);\n\n        //获取所有修饰符为public的字段,包含父类字段,注意修饰符为public才会获取\n        field fields[] = clazz.getfields();\n        for (field f:fields) {\n            system.out.println("f:"+f.getdeclaringclass());\n        }\n\n        system.out.println("================getdeclaredfields====================");\n        //获取当前类所字段(包含private字段),注意不包含父类的字段\n        field fields2[] = clazz.getdeclaredfields();\n        for (field f:fields2) {\n            system.out.println("f2:"+f.getdeclaringclass());\n        }\n        //获取指定字段名称的field类,可以是任意修饰符的自动,注意不包含父类的字段\n        field field2 = clazz.getdeclaredfield("desc");\n        system.out.println("field2:"+field2);\n    }\n    /**\n      输出结果: \n     field:public int reflect.person.age\n     f:public java.lang.string reflect.student.desc\n     f:public int reflect.person.age\n     f:public java.lang.string reflect.person.name\n\n     ================getdeclaredfields====================\n     f2:public java.lang.string reflect.student.desc\n     f2:private int reflect.student.score\n     field2:public java.lang.string reflect.student.desc\n     */\n}\n\nclass person{\n    public int age;\n    public string name;\n    //省略set和get方法\n}\n\nclass student extends person{\n    public string desc;\n    private int score;\n    //省略set和get方法\n}\n\n\n上述方法需要注意的是，如果我们不期望获取其父类的字段，则需使用class类的getdeclaredfield/getdeclaredfields方法来获取字段即可，倘若需要连带获取到父类的字段，那么请使用class类的getfield/getfields，但是也只能获取到public修饰的的字段，无法获取父类的私有字段。下面将通过field类本身的方法对指定类属性赋值，代码演示如下：\n\n//获取class对象引用\nclass<?> clazz = class.forname("reflect.student");\n\nstudent st= (student) clazz.newinstance();\n//获取父类public字段并赋值\nfield agefield = clazz.getfield("age");\nagefield.set(st,18);\nfield namefield = clazz.getfield("name");\nnamefield.set(st,"lily");\n\n//只获取当前类的字段,不获取父类的字段\nfield descfield = clazz.getdeclaredfield("desc");\ndescfield.set(st,"i am student");\nfield scorefield = clazz.getdeclaredfield("score");\n//设置可访问，score是private的\nscorefield.setaccessible(true);\nscorefield.set(st,88);\nsystem.out.println(st.tostring());\n\n//输出结果：student{age=18, name=\'lily ,desc=\'i am student\', score=88} \n\n//获取字段值\nsystem.out.println(scorefield.get(st));\n// 88\n\n\n其中的set(object obj, object value)方法是field类本身的方法，用于设置字段的值，而get(object obj)则是获取字段的值，当然关于field类还有其他常用的方法如下：\n\n方法返回值      方法名称                            方法说明\nvoid       set(object obj, object value)   将指定对象变量上此 field 对象表示的字段设置为指定的新值。\nobject     get(object obj)                 返回指定对象上此 field 表示的字段的值\nclass<?>   gettype()                       返回一个 class 对象，它标识了此field 对象所表示字段的声明类型。\nboolean    isenumconstant()                如果此字段表示枚举类型的元素则返回 true；否则返回 false\nstring     togenericstring()               返回一个描述此 field（包括其一般类型）的字符串\nstring     getname()                       返回此 field 对象表示的字段的名称\nclass<?>   getdeclaringclass()             返回表示类或接口的 class 对象，该类或接口声明由此 field 对象表示的字段\nvoid       setaccessible(boolean flag)     将此对象的 accessible 标志设置为指示的布尔值,即设置其可访问性\n\n上述方法可能是较为常用的，事实上在设置值的方法上，field类还提供了专门针对基本数据类型的方法，如setint()/getint()、setboolean()/getboolean、setchar()/getchar()等等方法，这里就不全部列出了，需要时查api文档即可。需要特别注意的是被final关键字修饰的field字段是安全的，在运行时可以接收任何修改，但最终其实际值是不会发生改变的。\n\n\n# method类及其用法\n\n> method 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息，所反映的方法可能是类方法或实例方法（包括抽象方法）。\n\n下面是class类获取method对象相关的方法：\n\n方法返回值      方法名称                                                         方法说明\nmethod     getdeclaredmethod(string name, class<?>... parametertypes)   返回一个指定参数的method对象，该对象反映此 class 对象所表示的类或接口的指定已声明方法。\nmethod[]   getdeclaredmethods()                                         返回 method 对象的一个数组，这些对象反映此 class\n                                                                        对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。\nmethod     getmethod(string name, class<?>... parametertypes)           返回一个 method 对象，它反映此 class 对象所表示的类或接口的指定公共成员方法。\nmethod[]   getmethods()                                                 返回一个包含某些 method 对象的数组，这些对象反映此 class\n                                                                        对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。\n\n同样通过案例演示上述方法：\n\nimport java.lang.reflect.method;\n\npublic class reflectmethod  {\n\n\n    public static void main(string[] args) throws classnotfoundexception, nosuchmethodexception {\n\n        class clazz = class.forname("reflect.circle");\n\n        //根据参数获取public的method,包含继承自父类的方法\n        method method = clazz.getmethod("draw",int.class,string.class);\n\n        system.out.println("method:"+method);\n\n        //获取所有public的方法:\n        method[] methods =clazz.getmethods();\n        for (method m:methods){\n            system.out.println("m::"+m);\n        }\n\n        system.out.println("=========================================");\n\n        //获取当前类的方法包含private,该方法无法获取继承自父类的method\n        method method1 = clazz.getdeclaredmethod("drawcircle");\n        system.out.println("method1::"+method1);\n        //获取当前类的所有方法包含private,该方法无法获取继承自父类的method\n        method[] methods1=clazz.getdeclaredmethods();\n        for (method m:methods1){\n            system.out.println("m1::"+m);\n        }\n    }\n}\n\nclass shape {\n    public void draw(){\n        system.out.println("draw");\n    }\n\n    public void draw(int count , string name){\n        system.out.println("draw "+ name +",count="+count);\n    }\n\n}\nclass circle extends shape{\n\n    private void drawcircle(){\n        system.out.println("drawcircle");\n    }\n    public int getallcount(){\n        return 100;\n    }\n}\n\n\n输出结果:\n\nmethod:public void reflect.shape.draw(int,java.lang.string)\n\nm::public int reflect.circle.getallcount()\nm::public void reflect.shape.draw()\nm::public void reflect.shape.draw(int,java.lang.string)\nm::public final void java.lang.object.wait(long,int) throws java.lang.interruptedexception\nm::public final native void java.lang.object.wait(long) throws java.lang.interruptedexception\nm::public final void java.lang.object.wait() throws java.lang.interruptedexception\nm::public boolean java.lang.object.equals(java.lang.object)\nm::public java.lang.string java.lang.object.tostring()\nm::public native int java.lang.object.hashcode()\nm::public final native java.lang.class java.lang.object.getclass()\nm::public final native void java.lang.object.notify()\nm::public final native void java.lang.object.notifyall()\n\n=========================================\nmethod1::private void reflect.circle.drawcircle()\n\nm1::public int reflect.circle.getallcount()\nm1::private void reflect.circle.drawcircle()\n\n\n在通过getmethods方法获取method对象时，会把父类的方法也获取到，如上的输出结果，把object类的方法都打印出来了。而getdeclaredmethod/getdeclaredmethods方法都只能获取当前类的方法。我们在使用时根据情况选择即可。下面将演示通过method对象调用指定类的方法：\n\nclass clazz = class.forname("reflect.circle");\n//创建对象\ncircle circle = (circle) clazz.newinstance();\n\n//获取指定参数的方法对象method\nmethod method = clazz.getmethod("draw",int.class,string.class);\n\n//通过method对象的invoke(object obj,object... args)方法调用\nmethod.invoke(circle,15,"圈圈");\n\n//对私有无参方法的操作\nmethod method1 = clazz.getdeclaredmethod("drawcircle");\n//修改私有方法的访问标识\nmethod1.setaccessible(true);\nmethod1.invoke(circle);\n\n//对有返回值得方法操作\nmethod method2 =clazz.getdeclaredmethod("getallcount");\ninteger count = (integer) method2.invoke(circle);\nsystem.out.println("count:"+count);\n\n\n输出结果\n\ndraw 圈圈,count=15\ndrawcircle\ncount:100\n\n\n在上述代码中调用方法，使用了method类的invoke(object obj,object... args)第一个参数代表调用的对象，第二个参数传递的调用方法的参数。这样就完成了类方法的动态调用。\n\n方法返回值        方法名称                                 方法说明\nobject       invoke(object obj, object... args)   对带有指定参数的指定对象调用由此 method 对象表示的底层方法。\nclass<?>     getreturntype()                      返回一个 class 对象，该对象描述了此 method 对象所表示的方法的正式返回类型,即方法的返回类型\ntype         getgenericreturntype()               返回表示由此 method 对象所表示方法的正式返回类型的 type 对象，也是方法的返回类型。\nclass<?>[]   getparametertypes()                  按照声明顺序返回 class 对象的数组，这些对象描述了此 method\n                                                  对象所表示的方法的形参类型。即返回方法的参数类型组成的数组\ntype[]       getgenericparametertypes()           按照声明顺序返回 type 对象的数组，这些对象描述了此 method\n                                                  对象所表示的方法的形参类型的，也是返回方法的参数类型\nstring       getname()                            以 string 形式返回此 method 对象表示的方法名称，即返回方法的名称\nboolean      isvarargs()                          判断方法是否带可变参数，如果将此方法声明为带有可变数量的参数，则返回 true；否则，返回 false。\nstring       togenericstring()                    返回描述此 method 的字符串，包括类型参数。\n\ngetreturntype方法/getgenericreturntype方法都是获取method对象表示的方法的返回类型，只不过前者返回的class类型后者返回的type(前面已分析过)，type就是一个接口而已，在java8中新增一个默认的方法实现，返回的就参数类型信息\n\npublic interface type {\n    //1.8新增\n    default string gettypename() {\n        return tostring();\n    }\n}\n\n\n而getparametertypes/getgenericparametertypes也是同样的道理，都是获取method对象所表示的方法的参数类型，其他方法与前面的field和constructor是类似的。\n\n\n# 反射机制执行的流程\n\n> 这部分主要参考自https://www.cnblogs.com/yougewe/p/10125073.html\n\n先看个例子\n\npublic class helloreflect {\n    public static void main(string[] args) {\n        try {\n            // 1. 使用外部配置的实现，进行动态加载类\n            tempfunctiontest test = (tempfunctiontest)class.forname("com.tester.helloreflect").newinstance();\n            test.sayhello("call directly");\n            // 2. 根据配置的函数名，进行方法调用（不需要通用的接口抽象）\n            object t2 = new tempfunctiontest();\n            method method = t2.getclass().getdeclaredmethod("sayhello", string.class);\n            method.invoke(test, "method invoke");\n        } catch (classnotfoundexception e) {\n            e.printstacktrace();\n        } catch (instantiationexception e) {\n            e.printstacktrace();\n        } catch (illegalaccessexception e) {\n            e.printstacktrace();\n        } catch (nosuchmethodexception e ) {\n            e.printstacktrace();\n        } catch (invocationtargetexception e) {\n            e.printstacktrace();\n        }\n    }\n    \n    public void sayhello(string word) {\n        system.out.println("hello," + word);\n    }\n\n}\n\n\n来看执行流程\n\n\n\n\n# 反射获取类实例\n\n首先调用了 java.lang.class 的静态方法，获取类信息。\n\n    @callersensitive\n    public static class<?> forname(string classname)\n                throws classnotfoundexception {\n        // 先通过反射，获取调用进来的类信息，从而获取当前的 classloader\n        class<?> caller = reflection.getcallerclass();\n        // 调用native方法进行获取class信息\n        return forname0(classname, true, classloader.getclassloader(caller), caller);\n    }\n\n\nforname()反射获取类信息，并没有将实现留给了java,而是交给了jvm去加载。\n\n主要是先获取 classloader, 然后调用 native 方法，获取信息，加载类则是回调 java.lang.classloader.\n\n最后，jvm又会回调 classloader 进类加载。\n\n\n    // \n    public class<?> loadclass(string name) throws classnotfoundexception {\n        return loadclass(name, false);\n    }\n    \n        // sun.misc.launcher\n        public class<?> loadclass(string var1, boolean var2) throws classnotfoundexception {\n            int var3 = var1.lastindexof(46);\n            if(var3 != -1) {\n                securitymanager var4 = system.getsecuritymanager();\n                if(var4 != null) {\n                    var4.checkpackageaccess(var1.substring(0, var3));\n                }\n            }\n\n            if(this.ucp.knowntonotexist(var1)) {\n                class var5 = this.findloadedclass(var1);\n                if(var5 != null) {\n                    if(var2) {\n                        this.resolveclass(var5);\n                    }\n\n                    return var5;\n                } else {\n                    throw new classnotfoundexception(var1);\n                }\n            } else {\n                return super.loadclass(var1, var2);\n            }\n        }\n    // java.lang.classloader\n    protected class<?> loadclass(string name, boolean resolve)\n        throws classnotfoundexception\n    {\n        // 先获取锁\n        synchronized (getclassloadinglock(name)) {\n            // first, check if the class has already been loaded\n            // 如果已经加载了的话，就不用再加载了\n            class<?> c = findloadedclass(name);\n            if (c == null) {\n                long t0 = system.nanotime();\n                try {\n                    // 双亲委托加载\n                    if (parent != null) {\n                        c = parent.loadclass(name, false);\n                    } else {\n                        c = findbootstrapclassornull(name);\n                    }\n                } catch (classnotfoundexception e) {\n                    // classnotfoundexception thrown if class not found\n                    // from the non-null parent class loader\n                }\n\n                // 父类没有加载到时，再自己加载\n                if (c == null) {\n                    // if still not found, then invoke findclass in order\n                    // to find the class.\n                    long t1 = system.nanotime();\n                    c = findclass(name);\n\n                    // this is the defining class loader; record the stats\n                    sun.misc.perfcounter.getparentdelegationtime().addtime(t1 - t0);\n                    sun.misc.perfcounter.getfindclasstime().addelapsedtimefrom(t1);\n                    sun.misc.perfcounter.getfindclasses().increment();\n                }\n            }\n            if (resolve) {\n                resolveclass(c);\n            }\n            return c;\n        }\n    }\n    \n    protected object getclassloadinglock(string classname) {\n        object lock = this;\n        if (parallellockmap != null) {\n            // 使用 concurrenthashmap来保存锁\n            object newlock = new object();\n            lock = parallellockmap.putifabsent(classname, newlock);\n            if (lock == null) {\n                lock = newlock;\n            }\n        }\n        return lock;\n    }\n    \n    protected final class<?> findloadedclass(string name) {\n        if (!checkname(name))\n            return null;\n        return findloadedclass0(name);\n    }\n\n\n\n下面来看一下 newinstance() 的实现方式。\n\n    // 首先肯定是 class.newinstance\n    @callersensitive\n    public t newinstance()\n        throws instantiationexception, illegalaccessexception\n    {\n        if (system.getsecuritymanager() != null) {\n            checkmemberaccess(member.public, reflection.getcallerclass(), false);\n        }\n\n        // note: the following code may not be strictly correct under\n        // the current java memory model.\n\n        // constructor lookup\n        // newinstance() 其实相当于调用类的无参构造函数，所以，首先要找到其无参构造器\n        if (cachedconstructor == null) {\n            if (this == class.class) {\n                // 不允许调用 class 的 newinstance() 方法\n                throw new illegalaccessexception(\n                    "can not call newinstance() on the class for java.lang.class"\n                );\n            }\n            try {\n                // 获取无参构造器\n                class<?>[] empty = {};\n                final constructor<t> c = getconstructor0(empty, member.declared);\n                // disable accessibility checks on the constructor\n                // since we have to do the security check here anyway\n                // (the stack depth is wrong for the constructor\'s\n                // security check to work)\n                java.security.accesscontroller.doprivileged(\n                    new java.security.privilegedaction<void>() {\n                        public void run() {\n                                c.setaccessible(true);\n                                return null;\n                            }\n                        });\n                cachedconstructor = c;\n            } catch (nosuchmethodexception e) {\n                throw (instantiationexception)\n                    new instantiationexception(getname()).initcause(e);\n            }\n        }\n        constructor<t> tmpconstructor = cachedconstructor;\n        // security check (same as in java.lang.reflect.constructor)\n        int modifiers = tmpconstructor.getmodifiers();\n        if (!reflection.quickcheckmemberaccess(this, modifiers)) {\n            class<?> caller = reflection.getcallerclass();\n            if (newinstancecallercache != caller) {\n                reflection.ensurememberaccess(caller, this, null, modifiers);\n                newinstancecallercache = caller;\n            }\n        }\n        // run constructor\n        try {\n            // 调用无参构造器\n            return tmpconstructor.newinstance((object[])null);\n        } catch (invocationtargetexception e) {\n            unsafe.getunsafe().throwexception(e.gettargetexception());\n            // not reached\n            return null;\n        }\n    }\n\n\nnewinstance() 主要做了三件事：\n\n * 1. 权限检测，如果不通过直接抛出异常；\n * 2. 查找无参构造器，并将其缓存起来；\n * 3. 调用具体方法的无参构造方法，生成实例并返回；\n\n下面是获取构造器的过程：\n\n    private constructor<t> getconstructor0(class<?>[] parametertypes,\n                                        int which) throws nosuchmethodexception\n    {\n        // 获取所有构造器\n        constructor<t>[] constructors = privategetdeclaredconstructors((which == member.public));\n        for (constructor<t> constructor : constructors) {\n            if (arraycontentseq(parametertypes,\n                                constructor.getparametertypes())) {\n                return getreflectionfactory().copyconstructor(constructor);\n            }\n        }\n        throw new nosuchmethodexception(getname() + ".<init>" + argumenttypestostring(parametertypes));\n    }\n\n\ngetconstructor0() 为获取匹配的构造方器；分三步：\n\n * 1. 先获取所有的constructors, 然后通过进行参数类型比较；\n * 2. 找到匹配后，通过 reflectionfactory copy一份constructor返回；\n * 3. 否则抛出 nosuchmethodexception;\n\n\n    // 获取当前类所有的构造方法，通过jvm或者缓存\n    // returns an array of "root" constructors. these constructor\n    // objects must not be propagated to the outside world, but must\n    // instead be copied via reflectionfactory.copyconstructor.\n    private constructor<t>[] privategetdeclaredconstructors(boolean publiconly) {\n        checkinitted();\n        constructor<t>[] res;\n        // 调用 reflectiondata(), 获取保存的信息，使用软引用保存，从而使内存不够可以回收\n        reflectiondata<t> rd = reflectiondata();\n        if (rd != null) {\n            res = publiconly ? rd.publicconstructors : rd.declaredconstructors;\n            // 存在缓存，则直接返回\n            if (res != null) return res;\n        }\n        // no cached value available; request value from vm\n        if (isinterface()) {\n            @suppresswarnings("unchecked")\n            constructor<t>[] temporaryres = (constructor<t>[]) new constructor<?>[0];\n            res = temporaryres;\n        } else {\n            // 使用native方法从jvm获取构造器\n            res = getdeclaredconstructors0(publiconly);\n        }\n        if (rd != null) {\n            // 最后，将从jvm中读取的内容，存入缓存\n            if (publiconly) {\n                rd.publicconstructors = res;\n            } else {\n                rd.declaredconstructors = res;\n            }\n        }\n        return res;\n    }\n    \n    // lazily create and cache reflectiondata\n    private reflectiondata<t> reflectiondata() {\n        softreference<reflectiondata<t>> reflectiondata = this.reflectiondata;\n        int classredefinedcount = this.classredefinedcount;\n        reflectiondata<t> rd;\n        if (usecaches &&\n            reflectiondata != null &&\n            (rd = reflectiondata.get()) != null &&\n            rd.redefinedcount == classredefinedcount) {\n            return rd;\n        }\n        // else no softreference or cleared softreference or stale reflectiondata\n        // -> create and replace new instance\n        return newreflectiondata(reflectiondata, classredefinedcount);\n    }\n    \n    // 新创建缓存，保存反射信息\n    private reflectiondata<t> newreflectiondata(softreference<reflectiondata<t>> oldreflectiondata,\n                                                int classredefinedcount) {\n        if (!usecaches) return null;\n\n        // 使用cas保证更新的线程安全性，所以反射是保证线程安全的\n        while (true) {\n            reflectiondata<t> rd = new reflectiondata<>(classredefinedcount);\n            // try to cas it...\n            if (atomic.casreflectiondata(this, oldreflectiondata, new softreference<>(rd))) {\n                return rd;\n            }\n            // 先使用cas更新，如果更新成功，则立即返回，否则测查当前已被其他线程更新的情况，如果和自己想要更新的状态一致，则也算是成功了\n            oldreflectiondata = this.reflectiondata;\n            classredefinedcount = this.classredefinedcount;\n            if (oldreflectiondata != null &&\n                (rd = oldreflectiondata.get()) != null &&\n                rd.redefinedcount == classredefinedcount) {\n                return rd;\n            }\n        }\n    }\n\n\n如上，privategetdeclaredconstructors(), 获取所有的构造器主要步骤；\n\n * 1. 先尝试从缓存中获取；\n * 2. 如果缓存没有，则从jvm中重新获取，并存入缓存，缓存使用软引用进行保存，保证内存可用；\n\n另外，使用 relactiondata() 进行缓存保存；reflectiondata 的数据结构如下。\n\n\n    // reflection data that might get invalidated when jvm ti redefineclasses() is called\n    private static class reflectiondata<t> {\n        volatile field[] declaredfields;\n        volatile field[] publicfields;\n        volatile method[] declaredmethods;\n        volatile method[] publicmethods;\n        volatile constructor<t>[] declaredconstructors;\n        volatile constructor<t>[] publicconstructors;\n        // intermediate results for getfields and getmethods\n        volatile field[] declaredpublicfields;\n        volatile method[] declaredpublicmethods;\n        volatile class<?>[] interfaces;\n\n        // value of classredefinedcount when we created this reflectiondata instance\n        final int redefinedcount;\n\n        reflectiondata(int redefinedcount) {\n            this.redefinedcount = redefinedcount;\n        }\n    }\n\n\n其中，还有一个点，就是如何比较构造是否是要查找构造器，其实就是比较类型完成相等就完了，有一个不相等则返回false。\n\n    private static boolean arraycontentseq(object[] a1, object[] a2) {\n        if (a1 == null) {\n            return a2 == null || a2.length == 0;\n        }\n\n        if (a2 == null) {\n            return a1.length == 0;\n        }\n\n        if (a1.length != a2.length) {\n            return false;\n        }\n\n        for (int i = 0; i < a1.length; i++) {\n            if (a1[i] != a2[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n    // sun.reflect.reflectionfactory\n    /** makes a copy of the passed constructor. the returned\n        constructor is a "child" of the passed one; see the comments\n        in constructor.java for details. */\n    public <t> constructor<t> copyconstructor(constructor<t> arg) {\n        return langreflectaccess().copyconstructor(arg);\n    }\n    \n    // java.lang.reflect.constructor, copy 其实就是新new一个 constructor 出来\n    constructor<t> copy() {\n        // this routine enables sharing of constructoraccessor objects\n        // among constructor objects which refer to the same underlying\n        // method in the vm. (all of this contortion is only necessary\n        // because of the "accessibility" bit in accessibleobject,\n        // which implicitly requires that new java.lang.reflect\n        // objects be fabricated for each reflective call on class\n        // objects.)\n        if (this.root != null)\n            throw new illegalargumentexception("can not copy a non-root constructor");\n\n        constructor<t> res = new constructor<>(clazz,\n                                               parametertypes,\n                                               exceptiontypes, modifiers, slot,\n                                               signature,\n                                               annotations,\n                                               parameterannotations);\n        // root 指向当前 constructor\n        res.root = this;\n        // might as well eagerly propagate this if already present\n        res.constructoraccessor = constructoraccessor;\n        return res;\n    }\n\n\n通过上面，获取到 constructor 了。\n\n接下来就只需调用其相应构造器的 newinstance()，即返回实例了。\n\n    // return tmpconstructor.newinstance((object[])null); \n    // java.lang.reflect.constructor\n    @callersensitive\n    public t newinstance(object ... initargs)\n        throws instantiationexception, illegalaccessexception,\n               illegalargumentexception, invocationtargetexception\n    {\n        if (!override) {\n            if (!reflection.quickcheckmemberaccess(clazz, modifiers)) {\n                class<?> caller = reflection.getcallerclass();\n                checkaccess(caller, clazz, null, modifiers);\n            }\n        }\n        if ((clazz.getmodifiers() & modifier.enum) != 0)\n            throw new illegalargumentexception("cannot reflectively create enum objects");\n        constructoraccessor ca = constructoraccessor;   // read volatile\n        if (ca == null) {\n            ca = acquireconstructoraccessor();\n        }\n        @suppresswarnings("unchecked")\n        t inst = (t) ca.newinstance(initargs);\n        return inst;\n    }\n    // sun.reflect.delegatingconstructoraccessorimpl\n    public object newinstance(object[] args)\n      throws instantiationexception,\n             illegalargumentexception,\n             invocationtargetexception\n    {\n        return delegate.newinstance(args);\n    }\n    // sun.reflect.nativeconstructoraccessorimpl\n    public object newinstance(object[] args)\n        throws instantiationexception,\n               illegalargumentexception,\n               invocationtargetexception\n    {\n        // we can\'t inflate a constructor belonging to a vm-anonymous class\n        // because that kind of class can\'t be referred to by name, hence can\'t\n        // be found from the generated bytecode.\n        if (++numinvocations > reflectionfactory.inflationthreshold()\n                && !reflectutil.isvmanonymousclass(c.getdeclaringclass())) {\n            constructoraccessorimpl acc = (constructoraccessorimpl)\n                new methodaccessorgenerator().\n                    generateconstructor(c.getdeclaringclass(),\n                                        c.getparametertypes(),\n                                        c.getexceptiontypes(),\n                                        c.getmodifiers());\n            parent.setdelegate(acc);\n        }\n\n        // 调用native方法，进行调用 constructor\n        return newinstance0(c, args);\n    }\n\n\n返回构造器的实例后，可以根据外部进行进行类型转换，从而使用接口或方法进行调用实例功能了。\n\n\n# 反射获取方法\n\n * 第一步，先获取 method;\n\n    // java.lang.class\n    @callersensitive\n    public method getdeclaredmethod(string name, class<?>... parametertypes)\n        throws nosuchmethodexception, securityexception {\n        checkmemberaccess(member.declared, reflection.getcallerclass(), true);\n        method method = searchmethods(privategetdeclaredmethods(false), name, parametertypes);\n        if (method == null) {\n            throw new nosuchmethodexception(getname() + "." + name + argumenttypestostring(parametertypes));\n        }\n        return method;\n    }\n\n\n忽略第一个检查权限，剩下就只有两个动作了。\n\n * 1. 获取所有方法列表；\n * 2. 根据方法名称和方法列表，选出符合要求的方法；\n * 3. 如果没有找到相应方法，抛出异常，否则返回对应方法；\n\n所以，先看一下怎样获取类声明的所有方法？\n\n    // returns an array of "root" methods. these method objects must not\n    // be propagated to the outside world, but must instead be copied\n    // via reflectionfactory.copymethod.\n    private method[] privategetdeclaredmethods(boolean publiconly) {\n        checkinitted();\n        method[] res;\n        reflectiondata<t> rd = reflectiondata();\n        if (rd != null) {\n            res = publiconly ? rd.declaredpublicmethods : rd.declaredmethods;\n            if (res != null) return res;\n        }\n        // no cached value available; request value from vm\n        res = reflection.filtermethods(this, getdeclaredmethods0(publiconly));\n        if (rd != null) {\n            if (publiconly) {\n                rd.declaredpublicmethods = res;\n            } else {\n                rd.declaredmethods = res;\n            }\n        }\n        return res;\n    }\n\n\n很相似，和获取所有构造器的方法很相似，都是先从缓存中获取方法，如果没有，则从jvm中获取。\n\n不同的是，方法列表需要进行过滤 reflection.filtermethods;当然后面看来，这个方法我们一般不会派上用场。\n\n\n    // sun.misc.reflection\n    public static method[] filtermethods(class<?> containingclass, method[] methods) {\n        if (methodfiltermap == null) {\n            // bootstrapping\n            return methods;\n        }\n        return (method[])filter(methods, methodfiltermap.get(containingclass));\n    }\n    // 可以过滤指定的方法，一般为空，如果要指定过滤，可以调用 registermethodstofilter(), 或者...\n    private static member[] filter(member[] members, string[] filterednames) {\n        if ((filterednames == null) || (members.length == 0)) {\n            return members;\n        }\n        int numnewmembers = 0;\n        for (member member : members) {\n            boolean shouldskip = false;\n            for (string filteredname : filterednames) {\n                if (member.getname() == filteredname) {\n                    shouldskip = true;\n                    break;\n                }\n            }\n            if (!shouldskip) {\n                ++numnewmembers;\n            }\n        }\n        member[] newmembers =\n            (member[])array.newinstance(members[0].getclass(), numnewmembers);\n        int destidx = 0;\n        for (member member : members) {\n            boolean shouldskip = false;\n            for (string filteredname : filterednames) {\n                if (member.getname() == filteredname) {\n                    shouldskip = true;\n                    break;\n                }\n            }\n            if (!shouldskip) {\n                newmembers[destidx++] = member;\n            }\n        }\n        return newmembers;\n    }\n\n\n\n * 第二步，根据方法名和参数类型过滤指定方法返回：\n\n    private static method searchmethods(method[] methods,\n                                        string name,\n                                        class<?>[] parametertypes)\n    {\n        method res = null;\n        // 使用常量池，避免重复创建string\n        string internedname = name.intern();\n        for (int i = 0; i < methods.length; i++) {\n            method m = methods[i];\n            if (m.getname() == internedname\n                && arraycontentseq(parametertypes, m.getparametertypes())\n                && (res == null\n                    || res.getreturntype().isassignablefrom(m.getreturntype())))\n                res = m;\n        }\n\n        return (res == null ? res : getreflectionfactory().copymethod(res));\n    }\n\n\n大概意思看得明白，就是匹配到方法名，然后参数类型匹配，才可以。\n\n * 但是可以看到，匹配到一个方法，并没有退出for循环，而是继续进行匹配。\n * 这里是匹配最精确的子类进行返回（最优匹配）\n * 最后，还是通过 reflectionfactory, copy 方法后返回。\n\n\n# 调用 method.invoke() 方法\n\n    @callersensitive\n    public object invoke(object obj, object... args)\n        throws illegalaccessexception, illegalargumentexception,\n           invocationtargetexception\n    {\n        if (!override) {\n            if (!reflection.quickcheckmemberaccess(clazz, modifiers)) {\n                class<?> caller = reflection.getcallerclass();\n                checkaccess(caller, clazz, obj, modifiers);\n            }\n        }\n        methodaccessor ma = methodaccessor;             // read volatile\n        if (ma == null) {\n            ma = acquiremethodaccessor();\n        }\n        return ma.invoke(obj, args);\n    }\n\n\ninvoke时，是通过 methodaccessor 进行调用的，而 methodaccessor 是个接口，在第一次时调用 acquiremethodaccessor() 进行新创建。\n\n    // probably make the implementation more scalable.\n    private methodaccessor acquiremethodaccessor() {\n        // first check to see if one has been created yet, and take it\n        // if so\n        methodaccessor tmp = null;\n        if (root != null) tmp = root.getmethodaccessor();\n        if (tmp != null) {\n            // 存在缓存时，存入 methodaccessor，否则调用 reflectionfactory 创建新的 methodaccessor\n            methodaccessor = tmp;\n        } else {\n            // otherwise fabricate one and propagate it up to the root\n            tmp = reflectionfactory.newmethodaccessor(this);\n            setmethodaccessor(tmp);\n        }\n\n        return tmp;\n    }\n    // sun.reflect.reflectionfactory\n    public methodaccessor newmethodaccessor(method method) {\n        checkinitted();\n\n        if (noinflation && !reflectutil.isvmanonymousclass(method.getdeclaringclass())) {\n            return new methodaccessorgenerator().\n                generatemethod(method.getdeclaringclass(),\n                               method.getname(),\n                               method.getparametertypes(),\n                               method.getreturntype(),\n                               method.getexceptiontypes(),\n                               method.getmodifiers());\n        } else {\n            nativemethodaccessorimpl acc =\n                new nativemethodaccessorimpl(method);\n            delegatingmethodaccessorimpl res =\n                new delegatingmethodaccessorimpl(acc);\n            acc.setparent(res);\n            return res;\n        }\n    }\n\n\n两个accessor详情：\n\n\n//     nativemethodaccessorimpl / delegatingmethodaccessorimpl\nclass nativemethodaccessorimpl extends methodaccessorimpl {\n    private final method method;\n    private delegatingmethodaccessorimpl parent;\n    private int numinvocations;\n\n    nativemethodaccessorimpl(method method) {\n        this.method = method;\n    }\n\n    public object invoke(object obj, object[] args)\n        throws illegalargumentexception, invocationtargetexception\n    {\n        // we can\'t inflate methods belonging to vm-anonymous classes because\n        // that kind of class can\'t be referred to by name, hence can\'t be\n        // found from the generated bytecode.\n        if (++numinvocations > reflectionfactory.inflationthreshold()\n                && !reflectutil.isvmanonymousclass(method.getdeclaringclass())) {\n            methodaccessorimpl acc = (methodaccessorimpl)\n                new methodaccessorgenerator().\n                    generatemethod(method.getdeclaringclass(),\n                                   method.getname(),\n                                   method.getparametertypes(),\n                                   method.getreturntype(),\n                                   method.getexceptiontypes(),\n                                   method.getmodifiers());\n            parent.setdelegate(acc);\n        }\n\n        return invoke0(method, obj, args);\n    }\n\n    void setparent(delegatingmethodaccessorimpl parent) {\n        this.parent = parent;\n    }\n\n    private static native object invoke0(method m, object obj, object[] args);\n}\nclass delegatingmethodaccessorimpl extends methodaccessorimpl {\n    private methodaccessorimpl delegate;\n\n    delegatingmethodaccessorimpl(methodaccessorimpl delegate) {\n        setdelegate(delegate);\n    }\n\n    public object invoke(object obj, object[] args)\n        throws illegalargumentexception, invocationtargetexception\n    {\n        return delegate.invoke(obj, args);\n    }\n\n    void setdelegate(methodaccessorimpl delegate) {\n        this.delegate = delegate;\n    }\n}\n\n\n进行 ma.invoke(obj, args); 调用时，调用 delegatingmethodaccessorimpl.invoke();\n\n最后被委托到 nativemethodaccessorimpl.invoke(), 即：\n\n    public object invoke(object obj, object[] args)\n        throws illegalargumentexception, invocationtargetexception\n    {\n        // we can\'t inflate methods belonging to vm-anonymous classes because\n        // that kind of class can\'t be referred to by name, hence can\'t be\n        // found from the generated bytecode.\n        if (++numinvocations > reflectionfactory.inflationthreshold()\n                && !reflectutil.isvmanonymousclass(method.getdeclaringclass())) {\n            methodaccessorimpl acc = (methodaccessorimpl)\n                new methodaccessorgenerator().\n                    generatemethod(method.getdeclaringclass(),\n                                   method.getname(),\n                                   method.getparametertypes(),\n                                   method.getreturntype(),\n                                   method.getexceptiontypes(),\n                                   method.getmodifiers());\n            parent.setdelegate(acc);\n        }\n\n        // invoke0 是个 native 方法，由jvm进行调用业务方法。从而完成反射调用功能。\n        return invoke0(method, obj, args);\n    }\n\n\n其中， generatemethod() 是生成具体类的方法：\n\n    /** this routine is not thread-safe */\n    public methodaccessor generatemethod(class<?> declaringclass,\n                                         string   name,\n                                         class<?>[] parametertypes,\n                                         class<?>   returntype,\n                                         class<?>[] checkedexceptions,\n                                         int modifiers)\n    {\n        return (methodaccessor) generate(declaringclass,\n                                         name,\n                                         parametertypes,\n                                         returntype,\n                                         checkedexceptions,\n                                         modifiers,\n                                         false,\n                                         false,\n                                         null);\n    }\n\n\ngenerate() 戳详情。\n\n    /** this routine is not thread-safe */\n    private magicaccessorimpl generate(final class<?> declaringclass,\n                                       string name,\n                                       class<?>[] parametertypes,\n                                       class<?>   returntype,\n                                       class<?>[] checkedexceptions,\n                                       int modifiers,\n                                       boolean isconstructor,\n                                       boolean forserialization,\n                                       class<?> serializationtargetclass)\n    {\n        bytevector vec = bytevectorfactory.create();\n        asm = new classfileassembler(vec);\n        this.declaringclass = declaringclass;\n        this.parametertypes = parametertypes;\n        this.returntype = returntype;\n        this.modifiers = modifiers;\n        this.isconstructor = isconstructor;\n        this.forserialization = forserialization;\n\n        asm.emitmagicandversion();\n\n        // constant pool entries:\n        // ( * = boxing information: optional)\n        // (+  = shared entries provided by accessorgenerator)\n        // (^  = only present if generating serializationconstructoraccessor)\n        //     [utf-8] [this class\'s name]\n        //     [constant_class_info] for above\n        //     [utf-8] "sun/reflect/{methodaccessorimpl,constructoraccessorimpl,serializationconstructoraccessorimpl}"\n        //     [constant_class_info] for above\n        //     [utf-8] [target class\'s name]\n        //     [constant_class_info] for above\n        // ^   [utf-8] [serialization: class\'s name in which to invoke constructor]\n        // ^   [constant_class_info] for above\n        //     [utf-8] target method or constructor name\n        //     [utf-8] target method or constructor signature\n        //     [constant_nameandtype_info] for above\n        //     [constant_methodref_info or constant_interfacemethodref_info] for target method\n        //     [utf-8] "invoke" or "newinstance"\n        //     [utf-8] invoke or newinstance descriptor\n        //     [utf-8] descriptor for type of non-primitive parameter 1\n        //     [constant_class_info] for type of non-primitive parameter 1\n        //     ...\n        //     [utf-8] descriptor for type of non-primitive parameter n\n        //     [constant_class_info] for type of non-primitive parameter n\n        // +   [utf-8] "java/lang/exception"\n        // +   [constant_class_info] for above\n        // +   [utf-8] "java/lang/classcastexception"\n        // +   [constant_class_info] for above\n        // +   [utf-8] "java/lang/nullpointerexception"\n        // +   [constant_class_info] for above\n        // +   [utf-8] "java/lang/illegalargumentexception"\n        // +   [constant_class_info] for above\n        // +   [utf-8] "java/lang/invocationtargetexception"\n        // +   [constant_class_info] for above\n        // +   [utf-8] "<init>"\n        // +   [utf-8] "()v"\n        // +   [constant_nameandtype_info] for above\n        // +   [constant_methodref_info] for nullpointerexception\'s constructor\n        // +   [constant_methodref_info] for illegalargumentexception\'s constructor\n        // +   [utf-8] "(ljava/lang/string;)v"\n        // +   [constant_nameandtype_info] for "<init>(ljava/lang/string;)v"\n        // +   [constant_methodref_info] for illegalargumentexception\'s constructor taking a string\n        // +   [utf-8] "(ljava/lang/throwable;)v"\n        // +   [constant_nameandtype_info] for "<init>(ljava/lang/throwable;)v"\n        // +   [constant_methodref_info] for invocationtargetexception\'s constructor\n        // +   [constant_methodref_info] for "super()"\n        // +   [utf-8] "java/lang/object"\n        // +   [constant_class_info] for above\n        // +   [utf-8] "tostring"\n        // +   [utf-8] "()ljava/lang/string;"\n        // +   [constant_nameandtype_info] for "tostring()ljava/lang/string;"\n        // +   [constant_methodref_info] for object\'s tostring method\n        // +   [utf-8] "code"\n        // +   [utf-8] "exceptions"\n        //  *  [utf-8] "java/lang/boolean"\n        //  *  [constant_class_info] for above\n        //  *  [utf-8] "(z)v"\n        //  *  [constant_nameandtype_info] for above\n        //  *  [constant_methodref_info] for above\n        //  *  [utf-8] "booleanvalue"\n        //  *  [utf-8] "()z"\n        //  *  [constant_nameandtype_info] for above\n        //  *  [constant_methodref_info] for above\n        //  *  [utf-8] "java/lang/byte"\n        //  *  [constant_class_info] for above\n        //  *  [utf-8] "(b)v"\n        //  *  [constant_nameandtype_info] for above\n        //  *  [constant_methodref_info] for above\n        //  *  [utf-8] "bytevalue"\n        //  *  [utf-8] "()b"\n        //  *  [constant_nameandtype_info] for above\n        //  *  [constant_methodref_info] for above\n        //  *  [utf-8] "java/lang/character"\n        //  *  [constant_class_info] for above\n        //  *  [utf-8] "(c)v"\n        //  *  [constant_nameandtype_info] for above\n        //  *  [constant_methodref_info] for above\n        //  *  [utf-8] "charvalue"\n        //  *  [utf-8] "()c"\n        //  *  [constant_nameandtype_info] for above\n        //  *  [constant_methodref_info] for above\n        //  *  [utf-8] "java/lang/double"\n        //  *  [constant_class_info] for above\n        //  *  [utf-8] "(d)v"\n        //  *  [constant_nameandtype_info] for above\n        //  *  [constant_methodref_info] for above\n        //  *  [utf-8] "doublevalue"\n        //  *  [utf-8] "()d"\n        //  *  [constant_nameandtype_info] for above\n        //  *  [constant_methodref_info] for above\n        //  *  [utf-8] "java/lang/float"\n        //  *  [constant_class_info] for above\n        //  *  [utf-8] "(f)v"\n        //  *  [constant_nameandtype_info] for above\n        //  *  [constant_methodref_info] for above\n        //  *  [utf-8] "floatvalue"\n        //  *  [utf-8] "()f"\n        //  *  [constant_nameandtype_info] for above\n        //  *  [constant_methodref_info] for above\n        //  *  [utf-8] "java/lang/integer"\n        //  *  [constant_class_info] for above\n        //  *  [utf-8] "(i)v"\n        //  *  [constant_nameandtype_info] for above\n        //  *  [constant_methodref_info] for above\n        //  *  [utf-8] "intvalue"\n        //  *  [utf-8] "()i"\n        //  *  [constant_nameandtype_info] for above\n        //  *  [constant_methodref_info] for above\n        //  *  [utf-8] "java/lang/long"\n        //  *  [constant_class_info] for above\n        //  *  [utf-8] "(j)v"\n        //  *  [constant_nameandtype_info] for above\n        //  *  [constant_methodref_info] for above\n        //  *  [utf-8] "longvalue"\n        //  *  [utf-8] "()j"\n        //  *  [constant_nameandtype_info] for above\n        //  *  [constant_methodref_info] for above\n        //  *  [utf-8] "java/lang/short"\n        //  *  [constant_class_info] for above\n        //  *  [utf-8] "(s)v"\n        //  *  [constant_nameandtype_info] for above\n        //  *  [constant_methodref_info] for above\n        //  *  [utf-8] "shortvalue"\n        //  *  [utf-8] "()s"\n        //  *  [constant_nameandtype_info] for above\n        //  *  [constant_methodref_info] for above\n\n        short numcpentries = num_base_cpool_entries + num_common_cpool_entries;\n        boolean usesprimitives = usesprimitivetypes();\n        if (usesprimitives) {\n            numcpentries += num_boxing_cpool_entries;\n        }\n        if (forserialization) {\n            numcpentries += num_serialization_cpool_entries;\n        }\n\n        // add in variable-length number of entries to be able to describe\n        // non-primitive parameter types and checked exceptions.\n        numcpentries += (short) (2 * numnonprimitiveparametertypes());\n\n        asm.emitshort(add(numcpentries, s1));\n\n        final string generatedname = generatename(isconstructor, forserialization);\n        asm.emitconstantpoolutf8(generatedname);\n        asm.emitconstantpoolclass(asm.cpi());\n        thisclass = asm.cpi();\n        if (isconstructor) {\n            if (forserialization) {\n                asm.emitconstantpoolutf8\n                    ("sun/reflect/serializationconstructoraccessorimpl");\n            } else {\n                asm.emitconstantpoolutf8("sun/reflect/constructoraccessorimpl");\n            }\n        } else {\n            asm.emitconstantpoolutf8("sun/reflect/methodaccessorimpl");\n        }\n        asm.emitconstantpoolclass(asm.cpi());\n        superclass = asm.cpi();\n        asm.emitconstantpoolutf8(getclassname(declaringclass, false));\n        asm.emitconstantpoolclass(asm.cpi());\n        targetclass = asm.cpi();\n        short serializationtargetclassidx = (short) 0;\n        if (forserialization) {\n            asm.emitconstantpoolutf8(getclassname(serializationtargetclass, false));\n            asm.emitconstantpoolclass(asm.cpi());\n            serializationtargetclassidx = asm.cpi();\n        }\n        asm.emitconstantpoolutf8(name);\n        asm.emitconstantpoolutf8(buildinternalsignature());\n        asm.emitconstantpoolnameandtype(sub(asm.cpi(), s1), asm.cpi());\n        if (isinterface()) {\n            asm.emitconstantpoolinterfacemethodref(targetclass, asm.cpi());\n        } else {\n            if (forserialization) {\n                asm.emitconstantpoolmethodref(serializationtargetclassidx, asm.cpi());\n            } else {\n                asm.emitconstantpoolmethodref(targetclass, asm.cpi());\n            }\n        }\n        targetmethodref = asm.cpi();\n        if (isconstructor) {\n            asm.emitconstantpoolutf8("newinstance");\n        } else {\n            asm.emitconstantpoolutf8("invoke");\n        }\n        invokeidx = asm.cpi();\n        if (isconstructor) {\n            asm.emitconstantpoolutf8("([ljava/lang/object;)ljava/lang/object;");\n        } else {\n            asm.emitconstantpoolutf8\n                ("(ljava/lang/object;[ljava/lang/object;)ljava/lang/object;");\n        }\n        invokedescriptoridx = asm.cpi();\n\n        // output class information for non-primitive parameter types\n        nonprimitiveparametersbaseidx = add(asm.cpi(), s2);\n        for (int i = 0; i < parametertypes.length; i++) {\n            class<?> c = parametertypes[i];\n            if (!isprimitive(c)) {\n                asm.emitconstantpoolutf8(getclassname(c, false));\n                asm.emitconstantpoolclass(asm.cpi());\n            }\n        }\n\n        // entries common to fieldaccessor, methodaccessor and constructoraccessor\n        emitcommonconstantpoolentries();\n\n        // boxing entries\n        if (usesprimitives) {\n            emitboxingcontantpoolentries();\n        }\n\n        if (asm.cpi() != numcpentries) {\n            throw new internalerror("adjust this code (cpi = " + asm.cpi() +\n                                    ", numcpentries = " + numcpentries + ")");\n        }\n\n        // access flags\n        asm.emitshort(acc_public);\n\n        // this class\n        asm.emitshort(thisclass);\n\n        // superclass\n        asm.emitshort(superclass);\n\n        // interfaces count and interfaces\n        asm.emitshort(s0);\n\n        // fields count and fields\n        asm.emitshort(s0);\n\n        // methods count and methods\n        asm.emitshort(num_methods);\n\n        emitconstructor();\n        emitinvoke();\n\n        // additional attributes (none)\n        asm.emitshort(s0);\n\n        // load class\n        vec.trim();\n        final byte[] bytes = vec.getdata();\n        // note: the class loader is the only thing that really matters\n        // here -- it\'s important to get the generated code into the\n        // same namespace as the target class. since the generated code\n        // is privileged anyway, the protection domain probably doesn\'t\n        // matter.\n        return accesscontroller.doprivileged(\n            new privilegedaction<magicaccessorimpl>() {\n                public magicaccessorimpl run() {\n                        try {\n                        return (magicaccessorimpl)\n                        classdefiner.defineclass\n                                (generatedname,\n                                 bytes,\n                                 0,\n                                 bytes.length,\n                                 declaringclass.getclassloader()).newinstance();\n                        } catch (instantiationexception | illegalaccessexception e) {\n                            throw new internalerror(e);\n                        }\n                    }\n                });\n    }\n\n\n咱们主要看这一句：classdefiner.defineclass(xx, declaringclass.getclassloader()).newinstance();\n\n在classdefiner.defineclass方法实现中，每被调用一次都会生成一个delegatingclassloader类加载器对象 ，这里每次都生成新的类加载器，是为了性能考虑，在某些情况下可以卸载这些生成的类，因为类的卸载是只有在类加载器可以被回收的情况下才会被回收的，如果用了原来的类加载器，那可能导致这些新创建的类一直无法被卸载。\n\n而反射生成的类，有时候可能用了就可以卸载了，所以使用其独立的类加载器，从而使得更容易控制反射类的生命周期。\n\n\n# 反射调用流程小结\n\n最后，用几句话总结反射的实现原理：\n\n 1. 反射类及反射方法的获取，都是通过从列表中搜寻查找匹配的方法，所以查找性能会随类的大小方法多少而变化；\n\n 2. 每个类都会有一个与之对应的class实例，从而每个类都可以获取method反射方法，并作用到其他实例身上；\n\n 3. 反射也是考虑了线程安全的，放心使用；\n\n 4. 反射使用软引用relectiondata缓存class信息，避免每次重新从jvm获取带来的开销；\n\n 5. 反射调用多次生成新代理accessor, 而通过字节码生存的则考虑了卸载功能，所以会使用独立的类加载器；\n\n 6. 当找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证数据隔离；\n\n 7. 调度反射方法，最终是由jvm执行invoke0()执行；\n\n\n# 参考文章\n\n * https://www.codercto.com/a/46094.html\n * https://blog.csdn.net/sinat_38259539/article/details/71799078\n * https://blog.csdn.net/qq_40896997/article/details/94483820\n * https://www.cnblogs.com/zhaoguhong/p/6937364.html\n * https://juejin.im/post/5c160420e51d452a60684431\n * https://blog.csdn.net/mcryeasy/java/article/details/52344729\n * 转载 https://www.pdai.tech/md/java/basic/java-basic-x-reflection.html',charsets:{cjk:!0}},{title:"Collection - ArrayList 源码解析",frontmatter:{},regularPath:"/java/collection/java-collection-ArrayList.html",relativePath:"java/collection/java-collection-ArrayList.md",key:"v-38eee2e4",path:"/java/collection/java-collection-ArrayList.html",headers:[{level:2,title:"Collection - ArrayList 源码解析",slug:"collection-arraylist-源码解析",normalizedTitle:"collection - arraylist 源码解析",charIndex:2},{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:105},{level:2,title:"ArrayList的实现",slug:"arraylist的实现",normalizedTitle:"arraylist的实现",charIndex:113},{level:3,title:"底层数据结构",slug:"底层数据结构",normalizedTitle:"底层数据结构",charIndex:133},{level:3,title:"构造函数",slug:"构造函数",normalizedTitle:"构造函数",charIndex:147},{level:3,title:"自动扩容",slug:"自动扩容",normalizedTitle:"自动扩容",charIndex:159},{level:3,title:"add(), addAll()",slug:"add-addall",normalizedTitle:"add(), addall()",charIndex:171},{level:3,title:"set()",slug:"set",normalizedTitle:"set()",charIndex:194},{level:3,title:"get()",slug:"get",normalizedTitle:"get()",charIndex:207},{level:3,title:"remove()",slug:"remove",normalizedTitle:"remove()",charIndex:220},{level:3,title:"trimToSize()",slug:"trimtosize",normalizedTitle:"trimtosize()",charIndex:236},{level:3,title:"indexOf(), lastIndexOf()",slug:"indexof-lastindexof",normalizedTitle:"indexof(), lastindexof()",charIndex:256},{level:3,title:"Fail-Fast机制:",slug:"fail-fast机制",normalizedTitle:"fail-fast机制:",charIndex:288},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:306}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Collection - ArrayList 源码解析 概述 ArrayList的实现 底层数据结构 构造函数 自动扩容 add(), addAll() set() get() remove() trimToSize() indexOf(), lastIndexOf() Fail-Fast机制: 参考",content:"# Collection - ArrayList 源码解析\n\n> 本文主要对Collection - ArrayList进行源码解析。\n\n * Collection - ArrayList 源码解析\n   * 概述\n   * ArrayList的实现\n     * 底层数据结构\n     * 构造函数\n     * 自动扩容\n     * add(), addAll()\n     * set()\n     * get()\n     * remove()\n     * trimToSize()\n     * indexOf(), lastIndexOf()\n     * Fail-Fast机制:\n   * 参考\n\n\n# 概述\n\n_ArrayList_实现了_List_接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入null元素，底层通过数组实现。除该类未实现同步外，其余跟_Vector_大致相同。每个_ArrayList_都有一个容量(capacity)，表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。\n\n\n\nsize(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。\n\n为追求效率，ArrayList没有实现同步(synchronized)，如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。\n\n\n# ArrayList的实现\n\n\n# 底层数据结构\n\n/**\n     * The array buffer into which the elements of the ArrayList are stored.\n     * The capacity of the ArrayList is the length of this array buffer. Any\n     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n     * will be expanded to DEFAULT_CAPACITY when the first element is added.\n     */\n    transient Object[] elementData; // non-private to simplify nested class access\n\n    /**\n     * The size of the ArrayList (the number of elements it contains).\n     *\n     * @serial\n     */\n    private int size;\n\n\n\n# 构造函数\n\n/**\n     * Constructs an empty list with the specified initial capacity.\n     *\n     * @param  initialCapacity  the initial capacity of the list\n     * @throws IllegalArgumentException if the specified initial capacity\n     *         is negative\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n    /**\n     * Constructs an empty list with an initial capacity of ten.\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n\n    /**\n     * Constructs a list containing the elements of the specified\n     * collection, in the order they are returned by the collection's\n     * iterator.\n     *\n     * @param c the collection whose elements are to be placed into this list\n     * @throws NullPointerException if the specified collection is null\n     */\n    public ArrayList(Collection<? extends E> c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n\n\n\n# 自动扩容\n\n每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组扩容通过一个公开的方法ensureCapacity(int minCapacity)来实现。在实际添加大量元素前，我也可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。\n\n数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。\n\n    /**\n     * Increases the capacity of this <tt>ArrayList</tt> instance, if\n     * necessary, to ensure that it can hold at least the number of elements\n     * specified by the minimum capacity argument.\n     *\n     * @param   minCapacity   the desired minimum capacity\n     */\n    public void ensureCapacity(int minCapacity) {\n        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n            // any size if not default element table\n            ? 0\n            // larger than default for default empty table. It's already\n            // supposed to be at default size.\n            : DEFAULT_CAPACITY;\n\n        if (minCapacity > minExpand) {\n            ensureExplicitCapacity(minCapacity);\n        }\n    }\n\n    private void ensureCapacityInternal(int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n\n        ensureExplicitCapacity(minCapacity);\n    }\n\n    private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // overflow-conscious code\n        if (minCapacity - elementData.length > 0)\n            grow(minCapacity);\n    }\n\n    /**\n     * The maximum size of array to allocate.\n     * Some VMs reserve some header words in an array.\n     * Attempts to allocate larger arrays may result in\n     * OutOfMemoryError: Requested array size exceeds VM limit\n     */\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    /**\n     * Increases the capacity to ensure that it can hold at least the\n     * number of elements specified by the minimum capacity argument.\n     *\n     * @param minCapacity the desired minimum capacity\n     */\n    private void grow(int minCapacity) {\n        // overflow-conscious code\n        int oldCapacity = elementData.length;\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n\n    private static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    }\n\n\n\n\n\n# add(), addAll()\n\n跟C++ 的_vector_不同，_ArrayList_没有push_back()方法，对应的方法是add(E e)，_ArrayList_也没有insert()方法，对应的方法是add(int index, E e)。这两个方法都是向容器中添加新元素，这可能会导致_capacity_不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过grow()方法完成的。\n\n    /**\n     * Appends the specified element to the end of this list.\n     *\n     * @param e element to be appended to this list\n     * @return <tt>true</tt> (as specified by {@link Collection#add})\n     */\n    public boolean add(E e) {\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        elementData[size++] = e;\n        return true;\n    }\n\n    /**\n     * Inserts the specified element at the specified position in this\n     * list. Shifts the element currently at that position (if any) and\n     * any subsequent elements to the right (adds one to their indices).\n     *\n     * @param index index at which the specified element is to be inserted\n     * @param element element to be inserted\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        System.arraycopy(elementData, index, elementData, index + 1,\n                         size - index);\n        elementData[index] = element;\n        size++;\n    }\n\n\n\n\nadd(int index, E e)需要先对元素进行移动，然后完成插入操作，也就意味着该方法有着线性的时间复杂度。\n\naddAll()方法能够一次添加多个元素，根据位置不同也有两个版本，一个是在末尾添加的addAll(Collection<? extends E> c)方法，一个是从指定位置开始插入的addAll(int index, Collection<? extends E> c)方法。跟add()方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。 addAll()的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。\n\n    /**\n     * Appends all of the elements in the specified collection to the end of\n     * this list, in the order that they are returned by the\n     * specified collection's Iterator.  The behavior of this operation is\n     * undefined if the specified collection is modified while the operation\n     * is in progress.  (This implies that the behavior of this call is\n     * undefined if the specified collection is this list, and this\n     * list is nonempty.)\n     *\n     * @param c collection containing elements to be added to this list\n     * @return <tt>true</tt> if this list changed as a result of the call\n     * @throws NullPointerException if the specified collection is null\n     */\n    public boolean addAll(Collection<? extends E> c) {\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        ensureCapacityInternal(size + numNew);  // Increments modCount\n        System.arraycopy(a, 0, elementData, size, numNew);\n        size += numNew;\n        return numNew != 0;\n    }\n\n    /**\n     * Inserts all of the elements in the specified collection into this\n     * list, starting at the specified position.  Shifts the element\n     * currently at that position (if any) and any subsequent elements to\n     * the right (increases their indices).  The new elements will appear\n     * in the list in the order that they are returned by the\n     * specified collection's iterator.\n     *\n     * @param index index at which to insert the first element from the\n     *              specified collection\n     * @param c collection containing elements to be added to this list\n     * @return <tt>true</tt> if this list changed as a result of the call\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     * @throws NullPointerException if the specified collection is null\n     */\n    public boolean addAll(int index, Collection<? extends E> c) {\n        rangeCheckForAdd(index);\n\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        ensureCapacityInternal(size + numNew);  // Increments modCount\n\n        int numMoved = size - index;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index, elementData, index + numNew,\n                             numMoved);\n\n        System.arraycopy(a, 0, elementData, index, numNew);\n        size += numNew;\n        return numNew != 0;\n    }\n\n\n\n# set()\n\n既然底层是一个数组_ArrayList_的set()方法也就变得非常简单，直接对数组的指定位置赋值即可。\n\npublic E set(int index, E element) {\n    rangeCheck(index);//下标越界检查\n    E oldValue = elementData(index);\n    elementData[index] = element;//赋值到指定位置，复制的仅仅是引用\n    return oldValue;\n}\n\n\n\n# get()\n\nget()方法同样很简单，唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。\n\npublic E get(int index) {\n    rangeCheck(index);\n    return (E) elementData[index];//注意类型转换\n}\n\n\n\n# remove()\n\nremove()方法也有两个版本，一个是remove(int index)删除指定位置的元素，另一个是remove(Object o)删除第一个满足o.equals(elementData[index])的元素。删除操作是add()操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋null值。\n\npublic E remove(int index) {\n    rangeCheck(index);\n    modCount++;\n    E oldValue = elementData(index);\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        System.arraycopy(elementData, index+1, elementData, index, numMoved);\n    elementData[--size] = null; //清除该位置的引用，让GC起作用\n    return oldValue;\n}\n\n\n关于Java GC这里需要特别说明一下，有了垃圾收集器并不意味着一定不会有内存泄漏。对象能否被GC的依据是是否还有引用指向它，上面代码中如果不手动赋null值，除非对应的位置被其他元素覆盖，否则原来的对象就一直不会被回收。\n\n\n# trimToSize()\n\nArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过trimToSize方法来实现。代码如下:\n\n    /**\n     * Trims the capacity of this <tt>ArrayList</tt> instance to be the\n     * list's current size.  An application can use this operation to minimize\n     * the storage of an <tt>ArrayList</tt> instance.\n     */\n    public void trimToSize() {\n        modCount++;\n        if (size < elementData.length) {\n            elementData = (size == 0)\n              ? EMPTY_ELEMENTDATA\n              : Arrays.copyOf(elementData, size);\n        }\n    }\n\n\n\n# indexOf(), lastIndexOf()\n\n获取元素的第一次出现的index:\n\n/**\n     * Returns the index of the first occurrence of the specified element\n     * in this list, or -1 if this list does not contain the element.\n     * More formally, returns the lowest index <tt>i</tt> such that\n     * <tt>(o==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;o.equals(get(i)))</tt>,\n     * or -1 if there is no such index.\n     */\n    public int indexOf(Object o) {\n        if (o == null) {\n            for (int i = 0; i < size; i++)\n                if (elementData[i]==null)\n                    return i;\n        } else {\n            for (int i = 0; i < size; i++)\n                if (o.equals(elementData[i]))\n                    return i;\n        }\n        return -1;\n    }\n\n\n获取元素的最后一次出现的index:\n\n    /**\n     * Returns the index of the last occurrence of the specified element\n     * in this list, or -1 if this list does not contain the element.\n     * More formally, returns the highest index <tt>i</tt> such that\n     * <tt>(o==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;o.equals(get(i)))</tt>,\n     * or -1 if there is no such index.\n     */\n    public int lastIndexOf(Object o) {\n        if (o == null) {\n            for (int i = size-1; i >= 0; i--)\n                if (elementData[i]==null)\n                    return i;\n        } else {\n            for (int i = size-1; i >= 0; i--)\n                if (o.equals(elementData[i]))\n                    return i;\n        }\n        return -1;\n    }\n\n\n\n# Fail-Fast机制:\n\nArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。\n\n\n# 参考\n\n * 深入Java集合学习系列: ArrayList的实现原理 http://zhangshixi.iteye.com/blog/674856\n * Java ArrayList源码剖析 结合源码对ArrayList进行讲解 http://www.cnblogs.com/CarpenterLee/p/5419880.html\n * 转载 https://www.pdai.tech/md/java/collection/java-collection-ArrayList.html",normalizedContent:"# collection - arraylist 源码解析\n\n> 本文主要对collection - arraylist进行源码解析。\n\n * collection - arraylist 源码解析\n   * 概述\n   * arraylist的实现\n     * 底层数据结构\n     * 构造函数\n     * 自动扩容\n     * add(), addall()\n     * set()\n     * get()\n     * remove()\n     * trimtosize()\n     * indexof(), lastindexof()\n     * fail-fast机制:\n   * 参考\n\n\n# 概述\n\n_arraylist_实现了_list_接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入null元素，底层通过数组实现。除该类未实现同步外，其余跟_vector_大致相同。每个_arraylist_都有一个容量(capacity)，表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，java泛型只是编译器提供的语法糖，所以这里的数组是一个object数组，以便能够容纳任何类型的对象。\n\n\n\nsize(), isempty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addall()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。\n\n为追求效率，arraylist没有实现同步(synchronized)，如果需要多个线程并发访问，用户可以手动同步，也可使用vector替代。\n\n\n# arraylist的实现\n\n\n# 底层数据结构\n\n/**\n     * the array buffer into which the elements of the arraylist are stored.\n     * the capacity of the arraylist is the length of this array buffer. any\n     * empty arraylist with elementdata == defaultcapacity_empty_elementdata\n     * will be expanded to default_capacity when the first element is added.\n     */\n    transient object[] elementdata; // non-private to simplify nested class access\n\n    /**\n     * the size of the arraylist (the number of elements it contains).\n     *\n     * @serial\n     */\n    private int size;\n\n\n\n# 构造函数\n\n/**\n     * constructs an empty list with the specified initial capacity.\n     *\n     * @param  initialcapacity  the initial capacity of the list\n     * @throws illegalargumentexception if the specified initial capacity\n     *         is negative\n     */\n    public arraylist(int initialcapacity) {\n        if (initialcapacity > 0) {\n            this.elementdata = new object[initialcapacity];\n        } else if (initialcapacity == 0) {\n            this.elementdata = empty_elementdata;\n        } else {\n            throw new illegalargumentexception(\"illegal capacity: \"+\n                                               initialcapacity);\n        }\n    }\n\n    /**\n     * constructs an empty list with an initial capacity of ten.\n     */\n    public arraylist() {\n        this.elementdata = defaultcapacity_empty_elementdata;\n    }\n\n    /**\n     * constructs a list containing the elements of the specified\n     * collection, in the order they are returned by the collection's\n     * iterator.\n     *\n     * @param c the collection whose elements are to be placed into this list\n     * @throws nullpointerexception if the specified collection is null\n     */\n    public arraylist(collection<? extends e> c) {\n        elementdata = c.toarray();\n        if ((size = elementdata.length) != 0) {\n            // c.toarray might (incorrectly) not return object[] (see 6260652)\n            if (elementdata.getclass() != object[].class)\n                elementdata = arrays.copyof(elementdata, size, object[].class);\n        } else {\n            // replace with empty array.\n            this.elementdata = empty_elementdata;\n        }\n    }\n\n\n\n# 自动扩容\n\n每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组扩容通过一个公开的方法ensurecapacity(int mincapacity)来实现。在实际添加大量元素前，我也可以使用ensurecapacity来手动增加arraylist实例的容量，以减少递增式再分配的数量。\n\n数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造arraylist实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensurecapacity方法来手动增加arraylist实例的容量。\n\n    /**\n     * increases the capacity of this <tt>arraylist</tt> instance, if\n     * necessary, to ensure that it can hold at least the number of elements\n     * specified by the minimum capacity argument.\n     *\n     * @param   mincapacity   the desired minimum capacity\n     */\n    public void ensurecapacity(int mincapacity) {\n        int minexpand = (elementdata != defaultcapacity_empty_elementdata)\n            // any size if not default element table\n            ? 0\n            // larger than default for default empty table. it's already\n            // supposed to be at default size.\n            : default_capacity;\n\n        if (mincapacity > minexpand) {\n            ensureexplicitcapacity(mincapacity);\n        }\n    }\n\n    private void ensurecapacityinternal(int mincapacity) {\n        if (elementdata == defaultcapacity_empty_elementdata) {\n            mincapacity = math.max(default_capacity, mincapacity);\n        }\n\n        ensureexplicitcapacity(mincapacity);\n    }\n\n    private void ensureexplicitcapacity(int mincapacity) {\n        modcount++;\n\n        // overflow-conscious code\n        if (mincapacity - elementdata.length > 0)\n            grow(mincapacity);\n    }\n\n    /**\n     * the maximum size of array to allocate.\n     * some vms reserve some header words in an array.\n     * attempts to allocate larger arrays may result in\n     * outofmemoryerror: requested array size exceeds vm limit\n     */\n    private static final int max_array_size = integer.max_value - 8;\n\n    /**\n     * increases the capacity to ensure that it can hold at least the\n     * number of elements specified by the minimum capacity argument.\n     *\n     * @param mincapacity the desired minimum capacity\n     */\n    private void grow(int mincapacity) {\n        // overflow-conscious code\n        int oldcapacity = elementdata.length;\n        int newcapacity = oldcapacity + (oldcapacity >> 1);\n        if (newcapacity - mincapacity < 0)\n            newcapacity = mincapacity;\n        if (newcapacity - max_array_size > 0)\n            newcapacity = hugecapacity(mincapacity);\n        // mincapacity is usually close to size, so this is a win:\n        elementdata = arrays.copyof(elementdata, newcapacity);\n    }\n\n    private static int hugecapacity(int mincapacity) {\n        if (mincapacity < 0) // overflow\n            throw new outofmemoryerror();\n        return (mincapacity > max_array_size) ?\n            integer.max_value :\n            max_array_size;\n    }\n\n\n\n\n\n# add(), addall()\n\n跟c++ 的_vector_不同，_arraylist_没有push_back()方法，对应的方法是add(e e)，_arraylist_也没有insert()方法，对应的方法是add(int index, e e)。这两个方法都是向容器中添加新元素，这可能会导致_capacity_不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过grow()方法完成的。\n\n    /**\n     * appends the specified element to the end of this list.\n     *\n     * @param e element to be appended to this list\n     * @return <tt>true</tt> (as specified by {@link collection#add})\n     */\n    public boolean add(e e) {\n        ensurecapacityinternal(size + 1);  // increments modcount!!\n        elementdata[size++] = e;\n        return true;\n    }\n\n    /**\n     * inserts the specified element at the specified position in this\n     * list. shifts the element currently at that position (if any) and\n     * any subsequent elements to the right (adds one to their indices).\n     *\n     * @param index index at which the specified element is to be inserted\n     * @param element element to be inserted\n     * @throws indexoutofboundsexception {@inheritdoc}\n     */\n    public void add(int index, e element) {\n        rangecheckforadd(index);\n\n        ensurecapacityinternal(size + 1);  // increments modcount!!\n        system.arraycopy(elementdata, index, elementdata, index + 1,\n                         size - index);\n        elementdata[index] = element;\n        size++;\n    }\n\n\n\n\nadd(int index, e e)需要先对元素进行移动，然后完成插入操作，也就意味着该方法有着线性的时间复杂度。\n\naddall()方法能够一次添加多个元素，根据位置不同也有两个版本，一个是在末尾添加的addall(collection<? extends e> c)方法，一个是从指定位置开始插入的addall(int index, collection<? extends e> c)方法。跟add()方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。 addall()的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。\n\n    /**\n     * appends all of the elements in the specified collection to the end of\n     * this list, in the order that they are returned by the\n     * specified collection's iterator.  the behavior of this operation is\n     * undefined if the specified collection is modified while the operation\n     * is in progress.  (this implies that the behavior of this call is\n     * undefined if the specified collection is this list, and this\n     * list is nonempty.)\n     *\n     * @param c collection containing elements to be added to this list\n     * @return <tt>true</tt> if this list changed as a result of the call\n     * @throws nullpointerexception if the specified collection is null\n     */\n    public boolean addall(collection<? extends e> c) {\n        object[] a = c.toarray();\n        int numnew = a.length;\n        ensurecapacityinternal(size + numnew);  // increments modcount\n        system.arraycopy(a, 0, elementdata, size, numnew);\n        size += numnew;\n        return numnew != 0;\n    }\n\n    /**\n     * inserts all of the elements in the specified collection into this\n     * list, starting at the specified position.  shifts the element\n     * currently at that position (if any) and any subsequent elements to\n     * the right (increases their indices).  the new elements will appear\n     * in the list in the order that they are returned by the\n     * specified collection's iterator.\n     *\n     * @param index index at which to insert the first element from the\n     *              specified collection\n     * @param c collection containing elements to be added to this list\n     * @return <tt>true</tt> if this list changed as a result of the call\n     * @throws indexoutofboundsexception {@inheritdoc}\n     * @throws nullpointerexception if the specified collection is null\n     */\n    public boolean addall(int index, collection<? extends e> c) {\n        rangecheckforadd(index);\n\n        object[] a = c.toarray();\n        int numnew = a.length;\n        ensurecapacityinternal(size + numnew);  // increments modcount\n\n        int nummoved = size - index;\n        if (nummoved > 0)\n            system.arraycopy(elementdata, index, elementdata, index + numnew,\n                             nummoved);\n\n        system.arraycopy(a, 0, elementdata, index, numnew);\n        size += numnew;\n        return numnew != 0;\n    }\n\n\n\n# set()\n\n既然底层是一个数组_arraylist_的set()方法也就变得非常简单，直接对数组的指定位置赋值即可。\n\npublic e set(int index, e element) {\n    rangecheck(index);//下标越界检查\n    e oldvalue = elementdata(index);\n    elementdata[index] = element;//赋值到指定位置，复制的仅仅是引用\n    return oldvalue;\n}\n\n\n\n# get()\n\nget()方法同样很简单，唯一要注意的是由于底层数组是object[]，得到元素后需要进行类型转换。\n\npublic e get(int index) {\n    rangecheck(index);\n    return (e) elementdata[index];//注意类型转换\n}\n\n\n\n# remove()\n\nremove()方法也有两个版本，一个是remove(int index)删除指定位置的元素，另一个是remove(object o)删除第一个满足o.equals(elementdata[index])的元素。删除操作是add()操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让gc起作用，必须显式的为最后一个位置赋null值。\n\npublic e remove(int index) {\n    rangecheck(index);\n    modcount++;\n    e oldvalue = elementdata(index);\n    int nummoved = size - index - 1;\n    if (nummoved > 0)\n        system.arraycopy(elementdata, index+1, elementdata, index, nummoved);\n    elementdata[--size] = null; //清除该位置的引用，让gc起作用\n    return oldvalue;\n}\n\n\n关于java gc这里需要特别说明一下，有了垃圾收集器并不意味着一定不会有内存泄漏。对象能否被gc的依据是是否还有引用指向它，上面代码中如果不手动赋null值，除非对应的位置被其他元素覆盖，否则原来的对象就一直不会被回收。\n\n\n# trimtosize()\n\narraylist还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过trimtosize方法来实现。代码如下:\n\n    /**\n     * trims the capacity of this <tt>arraylist</tt> instance to be the\n     * list's current size.  an application can use this operation to minimize\n     * the storage of an <tt>arraylist</tt> instance.\n     */\n    public void trimtosize() {\n        modcount++;\n        if (size < elementdata.length) {\n            elementdata = (size == 0)\n              ? empty_elementdata\n              : arrays.copyof(elementdata, size);\n        }\n    }\n\n\n\n# indexof(), lastindexof()\n\n获取元素的第一次出现的index:\n\n/**\n     * returns the index of the first occurrence of the specified element\n     * in this list, or -1 if this list does not contain the element.\n     * more formally, returns the lowest index <tt>i</tt> such that\n     * <tt>(o==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;o.equals(get(i)))</tt>,\n     * or -1 if there is no such index.\n     */\n    public int indexof(object o) {\n        if (o == null) {\n            for (int i = 0; i < size; i++)\n                if (elementdata[i]==null)\n                    return i;\n        } else {\n            for (int i = 0; i < size; i++)\n                if (o.equals(elementdata[i]))\n                    return i;\n        }\n        return -1;\n    }\n\n\n获取元素的最后一次出现的index:\n\n    /**\n     * returns the index of the last occurrence of the specified element\n     * in this list, or -1 if this list does not contain the element.\n     * more formally, returns the highest index <tt>i</tt> such that\n     * <tt>(o==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;o.equals(get(i)))</tt>,\n     * or -1 if there is no such index.\n     */\n    public int lastindexof(object o) {\n        if (o == null) {\n            for (int i = size-1; i >= 0; i--)\n                if (elementdata[i]==null)\n                    return i;\n        } else {\n            for (int i = size-1; i >= 0; i--)\n                if (o.equals(elementdata[i]))\n                    return i;\n        }\n        return -1;\n    }\n\n\n\n# fail-fast机制:\n\narraylist也采用了快速失败的机制，通过记录modcount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。\n\n\n# 参考\n\n * 深入java集合学习系列: arraylist的实现原理 http://zhangshixi.iteye.com/blog/674856\n * java arraylist源码剖析 结合源码对arraylist进行讲解 http://www.cnblogs.com/carpenterlee/p/5419880.html\n * 转载 https://www.pdai.tech/md/java/collection/java-collection-arraylist.html",charsets:{cjk:!0}},{title:"Collection - PriorityQueue源码解析",frontmatter:{},regularPath:"/java/collection/java-collection-PriorityQueue.html",relativePath:"java/collection/java-collection-PriorityQueue.md",key:"v-1cc09c4e",path:"/java/collection/java-collection-PriorityQueue.html",headers:[{level:2,title:"Collection - PriorityQueue源码解析",slug:"collection-priorityqueue源码解析",normalizedTitle:"collection - priorityqueue源码解析",charIndex:2},{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:115},{level:2,title:"方法剖析",slug:"方法剖析",normalizedTitle:"方法剖析",charIndex:123},{level:3,title:"add()和offer()",slug:"add-和offer",normalizedTitle:"add()和offer()",charIndex:135},{level:3,title:"element()和peek()",slug:"element-和peek",normalizedTitle:"element()和peek()",charIndex:156},{level:3,title:"remove()和poll()",slug:"remove-和poll",normalizedTitle:"remove()和poll()",charIndex:180},{level:3,title:"remove(Object o)",slug:"remove-object-o",normalizedTitle:"remove(object o)",charIndex:203},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:225}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Collection - PriorityQueue源码解析 概述 方法剖析 add()和offer() element()和peek() remove()和poll() remove(Object o) 参考",content:"# Collection - PriorityQueue源码解析\n\n> 本文主要对Collection - PriorityQueue进行源码解析。\n\n * Collection - PriorityQueue源码解析\n   * 概述\n   * 方法剖析\n     * add()和offer()\n     * element()和peek()\n     * remove()和poll()\n     * remove(Object o)\n   * 参考\n\n\n# 概述\n\n前面以Java ArrayDeque_为例讲解了_Stack_和_Queue，其实还有一种特殊的队列叫做_PriorityQueue_，即优先队列。优先队列的作用是能保证每次取出的元素都是队列中权值最小的(Java的优先队列每次取最小元素，C++的优先队列每次取最大元素)。这里牵涉到了大小关系，元素大小的评判可以通过元素本身的自然顺序(natural ordering)，也可以通过构造时传入的比较器(Comparator，类似于C++的仿函数)。\n\nJava中_PriorityQueue_实现了_Queue_接口，不允许放入null元素；其通过堆实现，具体说是通过完全二叉树(complete binary tree)实现的小顶堆(任意一个非叶子节点的权值，都不大于其左右子节点的权值)，也就意味着可以通过数组来作为_PriorityQueue_的底层实现。\n\n\n\n上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系:\n\nleftNo = parentNo*2+1\n\nrightNo = parentNo*2+2\n\nparentNo = (nodeNo-1)/2\n\n通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。\n\nPriorityQueue_的peek()和element操作是常数时间，add(), offer(), 无参数的remove()以及poll()方法的时间复杂度都是_log(N)。\n\n\n# 方法剖析\n\n\n# add()和offer()\n\nadd(E e)和offer(E e)的语义相同，都是向优先队列中插入元素，只是Queue接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回false。对于_PriorityQueue_这两个方法其实没什么差别。\n\n\n\n新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。\n\n//offer(E e)\npublic boolean offer(E e) {\n    if (e == null)//不允许放入null元素\n        throw new NullPointerException();\n    modCount++;\n    int i = size;\n    if (i >= queue.length)\n        grow(i + 1);//自动扩容\n    size = i + 1;\n    if (i == 0)//队列原来为空，这是插入的第一个元素\n        queue[0] = e;\n    else\n        siftUp(i, e);//调整\n    return true;\n}\n\n\n上述代码中，扩容函数grow()类似于ArrayList里的grow()函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是siftUp(int k, E x)方法，该方法用于插入元素x并维持堆的特性。\n\n//siftUp()\nprivate void siftUp(int k, E x) {\n    while (k > 0) {\n        int parent = (k - 1) >>> 1;//parentNo = (nodeNo-1)/2\n        Object e = queue[parent];\n        if (comparator.compare(x, (E) e) >= 0)//调用比较器的比较方法\n            break;\n        queue[k] = e;\n        k = parent;\n    }\n    queue[k] = x;\n}\n\n\n新加入的元素x可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为** : 从k指定的位置开始，将x逐层与当前点的parent进行比较并交换，直到满足x >= queue[parent]为止**。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。\n\n\n# element()和peek()\n\nelement()和peek()的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，0下标处的那个元素既是堆顶元素。所以直接返回数组0下标处的那个元素即可。\n\n\n\n代码也就非常简洁:\n\n//peek()\npublic E peek() {\n    if (size == 0)\n        return null;\n    return (E) queue[0];//0下标处的那个元素就是最小的那个\n}\n\n\n\n# remove()和poll()\n\nremove()和poll()方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回null。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。\n\n代码如下:\n\npublic E poll() {\n    if (size == 0)\n        return null;\n    int s = --size;\n    modCount++;\n    E result = (E) queue[0];//0下标处的那个元素就是最小的那个\n    E x = (E) queue[s];\n    queue[s] = null;\n    if (s != 0)\n        siftDown(0, x);//调整\n    return result;\n}\n\n\n上述代码首先记录0下标处的元素，并用最后一个元素替换0下标位置的元素，之后调用siftDown()方法对堆进行调整，最后返回原来0下标处的那个元素(也就是最小的那个元素)。重点是siftDown(int k, E x)方法，该方法的作用是从k指定的位置开始，将x逐层向下与当前点的左右孩子中较小的那个交换，直到x小于或等于左右孩子中的任何一个为止。\n\n//siftDown()\nprivate void siftDown(int k, E x) {\n    int half = size >>> 1;\n    while (k < half) {\n    //首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标\n        int child = (k << 1) + 1;//leftNo = parentNo*2+1\n        Object c = queue[child];\n        int right = child + 1;\n        if (right < size &&\n            comparator.compare((E) c, (E) queue[right]) > 0)\n            c = queue[child = right];\n        if (comparator.compare(x, (E) c) <= 0)\n            break;\n        queue[k] = c;//然后用c取代原来的值\n        k = child;\n    }\n    queue[k] = x;\n}\n\n\n\n# remove(Object o)\n\nremove(Object o)方法用于删除队列中跟o相等的某一个元素(如果有多个相等，只删除一个)，该方法不是_Queue_接口内的方法，而是_Collection_接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，remove(Object o)可以分为2种情况: 1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次siftDown()即可。此处不再赘述。\n\n\n\n具体代码如下:\n\n//remove(Object o)\npublic boolean remove(Object o) {\n//通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标\n    int i = indexOf(o);\n    if (i == -1)\n        return false;\n    int s = --size;\n    if (s == i) //情况1\n        queue[i] = null;\n    else {\n        E moved = (E) queue[s];\n        queue[s] = null;\n        siftDown(i, moved);//情况2\n        ......\n    }\n    return true;\n}\n\n\n\n# 参考\n\n * 深入理解Java PriorityQueue 结合源码对PriorityQueue进行讲解 http://www.cnblogs.com/CarpenterLee/p/5488070.html\n * 转载 https://www.pdai.tech/md/java/collection/java-collection-PriorityQueue.html",normalizedContent:"# collection - priorityqueue源码解析\n\n> 本文主要对collection - priorityqueue进行源码解析。\n\n * collection - priorityqueue源码解析\n   * 概述\n   * 方法剖析\n     * add()和offer()\n     * element()和peek()\n     * remove()和poll()\n     * remove(object o)\n   * 参考\n\n\n# 概述\n\n前面以java arraydeque_为例讲解了_stack_和_queue，其实还有一种特殊的队列叫做_priorityqueue_，即优先队列。优先队列的作用是能保证每次取出的元素都是队列中权值最小的(java的优先队列每次取最小元素，c++的优先队列每次取最大元素)。这里牵涉到了大小关系，元素大小的评判可以通过元素本身的自然顺序(natural ordering)，也可以通过构造时传入的比较器(comparator，类似于c++的仿函数)。\n\njava中_priorityqueue_实现了_queue_接口，不允许放入null元素；其通过堆实现，具体说是通过完全二叉树(complete binary tree)实现的小顶堆(任意一个非叶子节点的权值，都不大于其左右子节点的权值)，也就意味着可以通过数组来作为_priorityqueue_的底层实现。\n\n\n\n上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系:\n\nleftno = parentno*2+1\n\nrightno = parentno*2+2\n\nparentno = (nodeno-1)/2\n\n通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。\n\npriorityqueue_的peek()和element操作是常数时间，add(), offer(), 无参数的remove()以及poll()方法的时间复杂度都是_log(n)。\n\n\n# 方法剖析\n\n\n# add()和offer()\n\nadd(e e)和offer(e e)的语义相同，都是向优先队列中插入元素，只是queue接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回false。对于_priorityqueue_这两个方法其实没什么差别。\n\n\n\n新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。\n\n//offer(e e)\npublic boolean offer(e e) {\n    if (e == null)//不允许放入null元素\n        throw new nullpointerexception();\n    modcount++;\n    int i = size;\n    if (i >= queue.length)\n        grow(i + 1);//自动扩容\n    size = i + 1;\n    if (i == 0)//队列原来为空，这是插入的第一个元素\n        queue[0] = e;\n    else\n        siftup(i, e);//调整\n    return true;\n}\n\n\n上述代码中，扩容函数grow()类似于arraylist里的grow()函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是siftup(int k, e x)方法，该方法用于插入元素x并维持堆的特性。\n\n//siftup()\nprivate void siftup(int k, e x) {\n    while (k > 0) {\n        int parent = (k - 1) >>> 1;//parentno = (nodeno-1)/2\n        object e = queue[parent];\n        if (comparator.compare(x, (e) e) >= 0)//调用比较器的比较方法\n            break;\n        queue[k] = e;\n        k = parent;\n    }\n    queue[k] = x;\n}\n\n\n新加入的元素x可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为** : 从k指定的位置开始，将x逐层与当前点的parent进行比较并交换，直到满足x >= queue[parent]为止**。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。\n\n\n# element()和peek()\n\nelement()和peek()的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，0下标处的那个元素既是堆顶元素。所以直接返回数组0下标处的那个元素即可。\n\n\n\n代码也就非常简洁:\n\n//peek()\npublic e peek() {\n    if (size == 0)\n        return null;\n    return (e) queue[0];//0下标处的那个元素就是最小的那个\n}\n\n\n\n# remove()和poll()\n\nremove()和poll()方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回null。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。\n\n代码如下:\n\npublic e poll() {\n    if (size == 0)\n        return null;\n    int s = --size;\n    modcount++;\n    e result = (e) queue[0];//0下标处的那个元素就是最小的那个\n    e x = (e) queue[s];\n    queue[s] = null;\n    if (s != 0)\n        siftdown(0, x);//调整\n    return result;\n}\n\n\n上述代码首先记录0下标处的元素，并用最后一个元素替换0下标位置的元素，之后调用siftdown()方法对堆进行调整，最后返回原来0下标处的那个元素(也就是最小的那个元素)。重点是siftdown(int k, e x)方法，该方法的作用是从k指定的位置开始，将x逐层向下与当前点的左右孩子中较小的那个交换，直到x小于或等于左右孩子中的任何一个为止。\n\n//siftdown()\nprivate void siftdown(int k, e x) {\n    int half = size >>> 1;\n    while (k < half) {\n    //首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标\n        int child = (k << 1) + 1;//leftno = parentno*2+1\n        object c = queue[child];\n        int right = child + 1;\n        if (right < size &&\n            comparator.compare((e) c, (e) queue[right]) > 0)\n            c = queue[child = right];\n        if (comparator.compare(x, (e) c) <= 0)\n            break;\n        queue[k] = c;//然后用c取代原来的值\n        k = child;\n    }\n    queue[k] = x;\n}\n\n\n\n# remove(object o)\n\nremove(object o)方法用于删除队列中跟o相等的某一个元素(如果有多个相等，只删除一个)，该方法不是_queue_接口内的方法，而是_collection_接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，remove(object o)可以分为2种情况: 1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次siftdown()即可。此处不再赘述。\n\n\n\n具体代码如下:\n\n//remove(object o)\npublic boolean remove(object o) {\n//通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标\n    int i = indexof(o);\n    if (i == -1)\n        return false;\n    int s = --size;\n    if (s == i) //情况1\n        queue[i] = null;\n    else {\n        e moved = (e) queue[s];\n        queue[s] = null;\n        siftdown(i, moved);//情况2\n        ......\n    }\n    return true;\n}\n\n\n\n# 参考\n\n * 深入理解java priorityqueue 结合源码对priorityqueue进行讲解 http://www.cnblogs.com/carpenterlee/p/5488070.html\n * 转载 https://www.pdai.tech/md/java/collection/java-collection-priorityqueue.html",charsets:{cjk:!0}},{title:"Collection - Stack & Queue 源码解析",frontmatter:{},regularPath:"/java/collection/java-collection-Queue&Stack.html",relativePath:"java/collection/java-collection-Queue&Stack.md",key:"v-b2e6d364",path:"/java/collection/java-collection-Queue&Stack.html",headers:[{level:2,title:"Collection - Stack & Queue 源码解析",slug:"collection-stack-queue-源码解析",normalizedTitle:"collection - stack &amp; queue 源码解析",charIndex:null},{level:2,title:"Stack & Queue概述",slug:"stack-queue概述",normalizedTitle:"stack &amp; queue概述",charIndex:null},{level:2,title:"Queue",slug:"queue",normalizedTitle:"queue",charIndex:23},{level:2,title:"Deque",slug:"deque",normalizedTitle:"deque",charIndex:149},{level:2,title:"方法剖析",slug:"方法剖析",normalizedTitle:"方法剖析",charIndex:160},{level:3,title:"addFirst()",slug:"addfirst",normalizedTitle:"addfirst()",charIndex:172},{level:3,title:"addLast()",slug:"addlast",normalizedTitle:"addlast()",charIndex:190},{level:3,title:"pollFirst()",slug:"pollfirst",normalizedTitle:"pollfirst()",charIndex:207},{level:3,title:"pollLast()",slug:"polllast",normalizedTitle:"polllast()",charIndex:226},{level:3,title:"peekFirst()",slug:"peekfirst",normalizedTitle:"peekfirst()",charIndex:244},{level:3,title:"peekLast()",slug:"peeklast",normalizedTitle:"peeklast()",charIndex:263},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:5995}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Collection - Stack & Queue 源码解析 Stack & Queue概述 Queue Deque 方法剖析 addFirst() addLast() pollFirst() pollLast() peekFirst() peekLast() 参考文章",content:'# Collection - Stack & Queue 源码解析\n\n> 本文主要对Collection - Stack & Queue进行源码解析。\n\n * Collection - Stack & Queue 源码解析\n   * Stack & Queue概述\n   * Queue\n   * Deque\n   * 方法剖析\n     * addFirst()\n     * addLast()\n     * pollFirst()\n     * pollLast()\n     * peekFirst()\n     * peekLast()\n\n\n# Stack & Queue概述\n\nJava里有一个叫做Stack的类，却没有叫做Queue的类(它是个接口名字)。当需要使用栈时，Java已不推荐使用Stack，而是推荐使用更高效的ArrayDeque；既然Queue只是一个接口，当需要使用队列时也就首选ArrayDeque了(次选是LinkedList)。\n\n\n# Queue\n\nQueue接口继承自Collection接口，除了最基本的Collection的方法之外，它还支持额外的insertion, extraction和inspection操作。这里有两组格式，共6个方法，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。\n\n          THROWS EXCEPTION   RETURNS SPECIAL VALUE\nInsert    add(e)             offer(e)\nRemove    remove()           poll()\nExamine   element()          peek()\n\n\n# Deque\n\nDeque是"double ended queue", 表示双向的队列，英文读作"deck". Deque 继承自 Queue接口，除了支持Queue的方法之外，还支持insert, remove和examine操作，由于Deque是双向的，所以可以对队列的头和尾都进行操作，它同时也支持两组格式，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。共12个方法如下:\n\n          FIRST ELEMENT - HEAD                   LAST ELEMENT - TAIL   \n          Throws exception       Special value   Throws exception      Special value\nInsert    addFirst(e)            offerFirst(e)   addLast(e)            offerLast(e)\nRemove    removeFirst()          pollFirst()     removeLast()          pollLast()\nExamine   getFirst()             peekFirst()     getLast()             peekLast()\n\n当把Deque当做FIFO的queue来使用时，元素是从deque的尾部添加，从头部进行删除的； 所以deque的部分方法是和queue是等同的。具体如下:\n\nQUEUE METHOD   EQUIVALENT DEQUE METHOD\nadd(e)         addLast(e)\noffer(e)       offerLast(e)\nremove()       removeFirst()\npoll()         pollFirst()\nelement()      getFirst()\npeek()         peekFirst()\n\nDeque的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了Deque与Queue相对应的接口:\n\nQUEUE METHOD   EQUIVALENT DEQUE METHOD   说明\nadd(e)         addLast(e)                向队尾插入元素，失败则抛出异常\noffer(e)       offerLast(e)              向队尾插入元素，失败则返回false\nremove()       removeFirst()             获取并删除队首元素，失败则抛出异常\npoll()         pollFirst()               获取并删除队首元素，失败则返回null\nelement()      getFirst()                获取但不删除队首元素，失败则抛出异常\npeek()         peekFirst()               获取但不删除队首元素，失败则返回null\n\n下表列出了Deque与Stack对应的接口:\n\nSTACK METHOD   EQUIVALENT DEQUE METHOD   说明\npush(e)        addFirst(e)               向栈顶插入元素，失败则抛出异常\n无              offerFirst(e)             向栈顶插入元素，失败则返回false\npop()          removeFirst()             获取并删除栈顶元素，失败则抛出异常\n无              pollFirst()               获取并删除栈顶元素，失败则返回null\npeek()         getFirst()                获取但不删除栈顶元素，失败则抛出异常\n无              peekFirst()               获取但不删除栈顶元素，失败则返回null\n\n上面两个表共定义了Deque的12个接口。添加，删除，取值都有两套接口，它们功能相同，区别是对失败情况的处理不同。一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值(false或null)。除非某种实现对容量有限制，大多数情况下，添加操作是不会失败的。虽然Deque的接口有12个之多，但无非就是对容器的两端进行操作，或添加，或删除，或查看。明白了这一点讲解起来就会非常简单。\n\nArrayDeque和LinkedList是Deque的两个通用实现，由于官方更推荐使用AarryDeque用作栈和队列，加之上一篇已经讲解过LinkedList，本文将着重讲解ArrayDeque的具体实现。\n\n从名字可以看出ArrayDeque底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即循环数组(circular array)，也就是说数组的任何一点都可能被看作起点或者终点。ArrayDeque是非线程安全的(not thread-safe)，当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入null元素。\n\n\n\n上图中我们看到，head指向首端第一个有效元素，tail指向尾端第一个可以插入元素的空位。因为是循环数组，所以head不一定总等于0，tail也不一定总是比head大。\n\n\n# 方法剖析\n\n\n# addFirst()\n\naddFirst(E e)的作用是在Deque的首端插入元素，也就是在head的前面插入元素，在空间足够且下标没有越界的情况下，只需要将elements[--head] = e即可。\n\n\n\n实际需要考虑: 1.空间是否够用，以及2.下标是否越界的问题。上图中，如果head为0之后接着调用addFirst()，虽然空余空间还够用，但head为-1，下标越界了。下列代码很好的解决了这两个问题。\n\n//addFirst(E e)\npublic void addFirst(E e) {\n    if (e == null)//不允许放入null\n        throw new NullPointerException();\n    elements[head = (head - 1) & (elements.length - 1)] = e;//2.下标是否越界\n    if (head == tail)//1.空间是否够用\n        doubleCapacity();//扩容\n}\n\n\n上述代码我们看到，空间问题是在插入之后解决的，因为tail总是指向下一个可插入的空位，也就意味着elements数组至少有一个空位，所以插入元素的时候不用考虑空间问题。\n\n下标越界的处理解决起来非常简单，head = (head - 1) & (elements.length - 1)就可以了，这段代码相当于取余，同时解决了head为负值的情况。因为elements.length必需是2的指数倍，elements - 1就是二进制低位全1，跟head - 1相与之后就起到了取模的作用，如果head - 1为负数(其实只可能是-1)，则相当于对其取相对于elements.length的补码。\n\n下面再说说扩容函数doubleCapacity()，其逻辑是申请一个更大的数组(原数组的两倍)，然后将原数组复制过去。过程如下图所示:\n\n\n\n图中我们看到，复制分两次进行，第一次复制head右边的元素，第二次复制head左边的元素。\n\n//doubleCapacity()\nprivate void doubleCapacity() {\n    assert head == tail;\n    int p = head;\n    int n = elements.length;\n    int r = n - p; // head右边元素的个数\n    int newCapacity = n << 1;//原空间的2倍\n    if (newCapacity < 0)\n        throw new IllegalStateException("Sorry, deque too big");\n    Object[] a = new Object[newCapacity];\n    System.arraycopy(elements, p, a, 0, r);//复制右半部分，对应上图中绿色部分\n    System.arraycopy(elements, 0, a, r, p);//复制左半部分，对应上图中灰色部分\n    elements = (E[])a;\n    head = 0;\n    tail = n;\n}\n\n\n\n# addLast()\n\naddLast(E e)的作用是在Deque的尾端插入元素，也就是在tail的位置插入元素，由于tail总是指向下一个可以插入的空位，因此只需要elements[tail] = e;即可。插入完成后再检查空间，如果空间已经用光，则调用doubleCapacity()进行扩容。\n\n\n\npublic void addLast(E e) {\n    if (e == null)//不允许放入null\n        throw new NullPointerException();\n    elements[tail] = e;//赋值\n    if ( (tail = (tail + 1) & (elements.length - 1)) == head)//下标越界处理\n        doubleCapacity();//扩容\n}\n\n\n下标越界处理方式addFirt()中已经讲过，不再赘述。\n\n\n# pollFirst()\n\npollFirst()的作用是删除并返回Deque首端元素，也即是head位置处的元素。如果容器不空，只需要直接返回elements[head]即可，当然还需要处理下标的问题。由于ArrayDeque中不允许放入null，当elements[head] == null时，意味着容器为空。\n\npublic E pollFirst() {\n    int h = head;\n    E result = elements[head];\n    if (result == null)//null值意味着deque为空\n        return null;\n    elements[h] = null;//let GC work\n    head = (head + 1) & (elements.length - 1);//下标越界处理\n    return result;\n}\n\n\n\n# pollLast()\n\npollLast()的作用是删除并返回Deque尾端元素，也即是tail位置前面的那个元素。\n\npublic E pollLast() {\n    int t = (tail - 1) & (elements.length - 1);//tail的上一个位置是最后一个元素\n    E result = elements[t];\n    if (result == null)//null值意味着deque为空\n        return null;\n    elements[t] = null;//let GC work\n    tail = t;\n    return result;\n}\n\n\n\n# peekFirst()\n\npeekFirst()的作用是返回但不删除Deque首端元素，也即是head位置处的元素，直接返回elements[head]即可。\n\npublic E peekFirst() {\n    return elements[head]; // elements[head] is null if deque empty\n}\n\n\n\n# peekLast()\n\npeekLast()的作用是返回但不删除Deque尾端元素，也即是tail位置前面的那个元素。\n\npublic E peekLast() {\n    return elements[(tail - 1) & (elements.length - 1)];\n}\n\n\n\n# 参考文章\n\n * 转载 https://www.pdai.tech/md/java/collection/java-collection-Queue&Stack.html',normalizedContent:'# collection - stack & queue 源码解析\n\n> 本文主要对collection - stack & queue进行源码解析。\n\n * collection - stack & queue 源码解析\n   * stack & queue概述\n   * queue\n   * deque\n   * 方法剖析\n     * addfirst()\n     * addlast()\n     * pollfirst()\n     * polllast()\n     * peekfirst()\n     * peeklast()\n\n\n# stack & queue概述\n\njava里有一个叫做stack的类，却没有叫做queue的类(它是个接口名字)。当需要使用栈时，java已不推荐使用stack，而是推荐使用更高效的arraydeque；既然queue只是一个接口，当需要使用队列时也就首选arraydeque了(次选是linkedlist)。\n\n\n# queue\n\nqueue接口继承自collection接口，除了最基本的collection的方法之外，它还支持额外的insertion, extraction和inspection操作。这里有两组格式，共6个方法，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。\n\n          throws exception   returns special value\ninsert    add(e)             offer(e)\nremove    remove()           poll()\nexamine   element()          peek()\n\n\n# deque\n\ndeque是"double ended queue", 表示双向的队列，英文读作"deck". deque 继承自 queue接口，除了支持queue的方法之外，还支持insert, remove和examine操作，由于deque是双向的，所以可以对队列的头和尾都进行操作，它同时也支持两组格式，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。共12个方法如下:\n\n          first element - head                   last element - tail   \n          throws exception       special value   throws exception      special value\ninsert    addfirst(e)            offerfirst(e)   addlast(e)            offerlast(e)\nremove    removefirst()          pollfirst()     removelast()          polllast()\nexamine   getfirst()             peekfirst()     getlast()             peeklast()\n\n当把deque当做fifo的queue来使用时，元素是从deque的尾部添加，从头部进行删除的； 所以deque的部分方法是和queue是等同的。具体如下:\n\nqueue method   equivalent deque method\nadd(e)         addlast(e)\noffer(e)       offerlast(e)\nremove()       removefirst()\npoll()         pollfirst()\nelement()      getfirst()\npeek()         peekfirst()\n\ndeque的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了deque与queue相对应的接口:\n\nqueue method   equivalent deque method   说明\nadd(e)         addlast(e)                向队尾插入元素，失败则抛出异常\noffer(e)       offerlast(e)              向队尾插入元素，失败则返回false\nremove()       removefirst()             获取并删除队首元素，失败则抛出异常\npoll()         pollfirst()               获取并删除队首元素，失败则返回null\nelement()      getfirst()                获取但不删除队首元素，失败则抛出异常\npeek()         peekfirst()               获取但不删除队首元素，失败则返回null\n\n下表列出了deque与stack对应的接口:\n\nstack method   equivalent deque method   说明\npush(e)        addfirst(e)               向栈顶插入元素，失败则抛出异常\n无              offerfirst(e)             向栈顶插入元素，失败则返回false\npop()          removefirst()             获取并删除栈顶元素，失败则抛出异常\n无              pollfirst()               获取并删除栈顶元素，失败则返回null\npeek()         getfirst()                获取但不删除栈顶元素，失败则抛出异常\n无              peekfirst()               获取但不删除栈顶元素，失败则返回null\n\n上面两个表共定义了deque的12个接口。添加，删除，取值都有两套接口，它们功能相同，区别是对失败情况的处理不同。一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值(false或null)。除非某种实现对容量有限制，大多数情况下，添加操作是不会失败的。虽然deque的接口有12个之多，但无非就是对容器的两端进行操作，或添加，或删除，或查看。明白了这一点讲解起来就会非常简单。\n\narraydeque和linkedlist是deque的两个通用实现，由于官方更推荐使用aarrydeque用作栈和队列，加之上一篇已经讲解过linkedlist，本文将着重讲解arraydeque的具体实现。\n\n从名字可以看出arraydeque底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即循环数组(circular array)，也就是说数组的任何一点都可能被看作起点或者终点。arraydeque是非线程安全的(not thread-safe)，当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入null元素。\n\n\n\n上图中我们看到，head指向首端第一个有效元素，tail指向尾端第一个可以插入元素的空位。因为是循环数组，所以head不一定总等于0，tail也不一定总是比head大。\n\n\n# 方法剖析\n\n\n# addfirst()\n\naddfirst(e e)的作用是在deque的首端插入元素，也就是在head的前面插入元素，在空间足够且下标没有越界的情况下，只需要将elements[--head] = e即可。\n\n\n\n实际需要考虑: 1.空间是否够用，以及2.下标是否越界的问题。上图中，如果head为0之后接着调用addfirst()，虽然空余空间还够用，但head为-1，下标越界了。下列代码很好的解决了这两个问题。\n\n//addfirst(e e)\npublic void addfirst(e e) {\n    if (e == null)//不允许放入null\n        throw new nullpointerexception();\n    elements[head = (head - 1) & (elements.length - 1)] = e;//2.下标是否越界\n    if (head == tail)//1.空间是否够用\n        doublecapacity();//扩容\n}\n\n\n上述代码我们看到，空间问题是在插入之后解决的，因为tail总是指向下一个可插入的空位，也就意味着elements数组至少有一个空位，所以插入元素的时候不用考虑空间问题。\n\n下标越界的处理解决起来非常简单，head = (head - 1) & (elements.length - 1)就可以了，这段代码相当于取余，同时解决了head为负值的情况。因为elements.length必需是2的指数倍，elements - 1就是二进制低位全1，跟head - 1相与之后就起到了取模的作用，如果head - 1为负数(其实只可能是-1)，则相当于对其取相对于elements.length的补码。\n\n下面再说说扩容函数doublecapacity()，其逻辑是申请一个更大的数组(原数组的两倍)，然后将原数组复制过去。过程如下图所示:\n\n\n\n图中我们看到，复制分两次进行，第一次复制head右边的元素，第二次复制head左边的元素。\n\n//doublecapacity()\nprivate void doublecapacity() {\n    assert head == tail;\n    int p = head;\n    int n = elements.length;\n    int r = n - p; // head右边元素的个数\n    int newcapacity = n << 1;//原空间的2倍\n    if (newcapacity < 0)\n        throw new illegalstateexception("sorry, deque too big");\n    object[] a = new object[newcapacity];\n    system.arraycopy(elements, p, a, 0, r);//复制右半部分，对应上图中绿色部分\n    system.arraycopy(elements, 0, a, r, p);//复制左半部分，对应上图中灰色部分\n    elements = (e[])a;\n    head = 0;\n    tail = n;\n}\n\n\n\n# addlast()\n\naddlast(e e)的作用是在deque的尾端插入元素，也就是在tail的位置插入元素，由于tail总是指向下一个可以插入的空位，因此只需要elements[tail] = e;即可。插入完成后再检查空间，如果空间已经用光，则调用doublecapacity()进行扩容。\n\n\n\npublic void addlast(e e) {\n    if (e == null)//不允许放入null\n        throw new nullpointerexception();\n    elements[tail] = e;//赋值\n    if ( (tail = (tail + 1) & (elements.length - 1)) == head)//下标越界处理\n        doublecapacity();//扩容\n}\n\n\n下标越界处理方式addfirt()中已经讲过，不再赘述。\n\n\n# pollfirst()\n\npollfirst()的作用是删除并返回deque首端元素，也即是head位置处的元素。如果容器不空，只需要直接返回elements[head]即可，当然还需要处理下标的问题。由于arraydeque中不允许放入null，当elements[head] == null时，意味着容器为空。\n\npublic e pollfirst() {\n    int h = head;\n    e result = elements[head];\n    if (result == null)//null值意味着deque为空\n        return null;\n    elements[h] = null;//let gc work\n    head = (head + 1) & (elements.length - 1);//下标越界处理\n    return result;\n}\n\n\n\n# polllast()\n\npolllast()的作用是删除并返回deque尾端元素，也即是tail位置前面的那个元素。\n\npublic e polllast() {\n    int t = (tail - 1) & (elements.length - 1);//tail的上一个位置是最后一个元素\n    e result = elements[t];\n    if (result == null)//null值意味着deque为空\n        return null;\n    elements[t] = null;//let gc work\n    tail = t;\n    return result;\n}\n\n\n\n# peekfirst()\n\npeekfirst()的作用是返回但不删除deque首端元素，也即是head位置处的元素，直接返回elements[head]即可。\n\npublic e peekfirst() {\n    return elements[head]; // elements[head] is null if deque empty\n}\n\n\n\n# peeklast()\n\npeeklast()的作用是返回但不删除deque尾端元素，也即是tail位置前面的那个元素。\n\npublic e peeklast() {\n    return elements[(tail - 1) & (elements.length - 1)];\n}\n\n\n\n# 参考文章\n\n * 转载 https://www.pdai.tech/md/java/collection/java-collection-queue&stack.html',charsets:{cjk:!0}},{title:"Map - HashSet & HashMap 源码解析",frontmatter:{},regularPath:"/java/collection/java-map-HashMap&HashSet.html",relativePath:"java/collection/java-map-HashMap&HashSet.md",key:"v-07a8195c",path:"/java/collection/java-map-HashMap&HashSet.html",headers:[{level:2,title:"Map - HashSet & HashMap 源码解析",slug:"map-hashset-hashmap-源码解析",normalizedTitle:"map - hashset &amp; hashmap 源码解析",charIndex:null},{level:2,title:"Java7 HashMap",slug:"java7-hashmap",normalizedTitle:"java7 hashmap",charIndex:108},{level:3,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:129},{level:3,title:"get()",slug:"get",normalizedTitle:"get()",charIndex:139},{level:3,title:"put()",slug:"put",normalizedTitle:"put()",charIndex:152},{level:3,title:"remove()",slug:"remove",normalizedTitle:"remove()",charIndex:165},{level:2,title:"Java8 HashMap",slug:"java8-hashmap",normalizedTitle:"java8 hashmap",charIndex:179},{level:3,title:"put 过程分析",slug:"put-过程分析",normalizedTitle:"put 过程分析",charIndex:200},{level:3,title:"数组扩容",slug:"数组扩容",normalizedTitle:"数组扩容",charIndex:216},{level:3,title:"get 过程分析",slug:"get-过程分析",normalizedTitle:"get 过程分析",charIndex:228},{level:2,title:"HashSet",slug:"hashset",normalizedTitle:"hashset",charIndex:8},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:11400}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Map - HashSet & HashMap 源码解析 Java7 HashMap 概述 get() put() remove() Java8 HashMap put 过程分析 数组扩容 get 过程分析 HashSet 参考文章",content:'# Map - HashSet & HashMap 源码解析\n\n> 本文主要对Map - HashSet & HashMap进行源码解析。\n\n * Map - HashSet & HashMap 源码解析\n   * Java7 HashMap\n     * 概述\n     * get()\n     * put()\n     * remove()\n   * Java8 HashMap\n     * put 过程分析\n     * 数组扩容\n     * get 过程分析\n   * HashSet\n\n\n# Java7 HashMap\n\n\n# 概述\n\n之所以把_HashSet_和_HashMap_放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说_HashSet_里面有一个_HashMap_(适配器模式)。因此本文将重点分析_HashMap_。\n\n_HashMap_实现了_Map_接口，即允许放入key为null的元素，也允许插入value为null的元素；除该类未实现同步外，其余跟Hashtable大致相同；跟_TreeMap_不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个_HashMap_的顺序可能会不同。 根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式(Open addressing)，另一种是冲突链表方式(Separate chaining with linked lists)。Java7 _HashMap_采用的是冲突链表方式。\n\n\n\n从上图容易看出，如果选择合适的哈希函数，put()和get()方法可以在常数时间内完成。但在对_HashMap_进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将_HashMap_的初始大小设的过大。\n\n有两个参数可以影响_HashMap_的性能: 初始容量(inital capacity)和负载系数(load factor)。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过capacity*load_factor时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。\n\n将对象放入到_HashMap_或_HashSet_中时，有两个方法需要特别关心: hashCode()和equals()。hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到HashMap或HashSet中，需要**@Override** hashCode()和equals()方法。\n\n\n# get()\n\nget(Object key)方法根据指定的key值返回对应的value，该方法调用了getEntry(Object key)得到相应的entry，然后返回entry.getValue()。因此getEntry()是算法的核心。 算法思想是首先通过hash()函数得到对应bucket的下标，然后依次遍历冲突链表，通过key.equals(k)方法来判断是否是要找的那个entry。\n\n\n\n上图中hash(k)&(table.length-1)等价于hash(k)%table.length，原因是_HashMap_要求table.length必须是2的指数，因此table.length-1就是二进制低位全是1，跟hash(k)相与会将哈希值的高位全抹掉，剩下的就是余数了。\n\n//getEntry()方法\nfinal Entry<K,V> getEntry(Object key) {\n......\nint hash = (key == null) ? 0 : hash(key);\n    for (Entry<K,V> e = table[hash&(table.length-1)];//得到冲突链表\n         e != null; e = e.next) {//依次遍历冲突链表中的每个entry\n        Object k;\n        //依据equals()方法判断是否相等\n        if (e.hash == hash &&\n            ((k = e.key) == key || (key != null && key.equals(k))))\n            return e;\n    }\n    return null;\n}\n\n\n\n# put()\n\nput(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于getEntry()方法；如果没有找到，则会通过addEntry(int hash, K key, V value, int bucketIndex)方法插入新的entry，插入方式为头插法。\n\n\n\n//addEntry()\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n    if ((size >= threshold) && (null != table[bucketIndex])) {\n        resize(2 * table.length);//自动扩容，并重新哈希\n        hash = (null != key) ? hash(key) : 0;\n        bucketIndex = hash & (table.length-1);//hash%table.length\n    }\n    //在冲突链表头部插入新的entry\n    Entry<K,V> e = table[bucketIndex];\n    table[bucketIndex] = new Entry<>(hash, key, value, e);\n    size++;\n}\n\n\n\n# remove()\n\nremove(Object key)的作用是删除key值对应的entry，该方法的具体逻辑是在removeEntryForKey(Object key)里实现的。removeEntryForKey()方法会首先找到key值对应的entry，然后删除该entry(修改链表的相应引用)。查找过程跟getEntry()过程类似。\n\n\n\n//removeEntryForKey()\nfinal Entry<K,V> removeEntryForKey(Object key) {\n......\nint hash = (key == null) ? 0 : hash(key);\n    int i = indexFor(hash, table.length);//hash&(table.length-1)\n    Entry<K,V> prev = table[i];//得到冲突链表\n    Entry<K,V> e = prev;\n    while (e != null) {//遍历冲突链表\n        Entry<K,V> next = e.next;\n        Object k;\n        if (e.hash == hash &&\n            ((k = e.key) == key || (key != null && key.equals(k)))) {//找到要删除的entry\n            modCount++; size--;\n            if (prev == e) table[i] = next;//删除的是冲突链表的第一个entry\n            else prev.next = next;\n            return e;\n        }\n        prev = e; e = next;\n    }\n    return e;\n}\n\n\n\n# Java8 HashMap\n\nJava8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。\n\n根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。\n\n为了降低这部分的开销，在 Java8 中，当链表中的元素达到了 8 个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。\n\n来一张图简单示意一下吧：\n\n\n\n注意，上图是示意图，主要是描述结构，不会达到这个状态的，因为这么多数据的时候早就扩容了。\n\n下面，我们还是用代码来介绍吧，个人感觉，Java8 的源码可读性要差一些，不过精简一些。\n\nJava7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 Node，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。\n\n我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。\n\n\n# put 过程分析\n\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\n// 第四个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作\n// 第五个参数 evict 我们这里不关心\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    // 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度\n    // 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n\n    else {// 数组该位置有数据\n        Node<K,V> e; K k;\n        // 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是"相等"，如果是，取出这个节点\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        // 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树\n        else if (p instanceof TreeNode)\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        else {\n            // 到这里，说明数组该位置上是一个链表\n            for (int binCount = 0; ; ++binCount) {\n                // 插入到链表的最后面(Java7 是插入到链表的最前面)\n                if ((e = p.next) == null) {\n                    p.next = newNode(hash, key, value, null);\n                    // TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 8 个\n                    // 会触发下面的 treeifyBin，也就是将链表转换为红黑树\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                // 如果在该链表中找到了"相等"的 key(== 或 equals)\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    // 此时 break，那么 e 为链表中[与要插入的新值的 key "相等"]的 node\n                    break;\n                p = e;\n            }\n        }\n        // e!=null 说明存在旧值的key与要插入的key"相等"\n        // 对于我们分析的put操作，下面这个 if 其实就是进行 "值覆盖"，然后返回旧值\n        if (e != null) {\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    ++modCount;\n    // 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容\n    if (++size > threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n\n\n和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容，不过这个不重要。\n\n\n# 数组扩容\n\nresize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移。\n\nfinal Node<K,V>[] resize() {\n    Node<K,V>[] oldTab = table;\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    if (oldCap > 0) { // 对应数组扩容\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        // 将数组大小扩大一倍\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            // 将阈值扩大一倍\n            newThr = oldThr << 1; // double threshold\n    }\n    else if (oldThr > 0) // 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候\n        newCap = oldThr;\n    else {// 对应使用 new HashMap() 初始化后，第一次 put 的时候\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n\n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n    \n    // 用新的数组大小初始化新的数组\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    table = newTab; // 如果是初始化数组，到这里就结束了，返回 newTab 即可\n    \n    if (oldTab != null) {\n        // 开始遍历原数组，进行数据迁移。\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                // 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了\n                if (e.next == null)\n                    newTab[e.hash & (newCap - 1)] = e;\n                // 如果是红黑树，具体我们就不展开了\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else { \n                    // 这块是处理链表的情况，\n                    // 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序\n                    // loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的\n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do {\n                        next = e.next;\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    if (loTail != null) {\n                        loTail.next = null;\n                        // 第一条链表\n                        newTab[j] = loHead;\n                    }\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        // 第二条链表的新的位置是 j + oldCap，这个很好理解\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n\n\n\n# get 过程分析\n\n相对于 put 来说，get 真的太简单了。\n\n * 计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash & (length-1)\n * 判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步\n * 判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步\n * 遍历链表，直到找到相等(==或equals)的 key\n\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\nfinal Node<K,V> getNode(int hash, Object key) {\n    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (first = tab[(n - 1) & hash]) != null) {\n        // 判断第一个节点是不是就是需要的\n        if (first.hash == hash && // always check first node\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        if ((e = first.next) != null) {\n            // 判断是否是红黑树\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n\n            // 链表遍历\n            do {\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n\n\n\n# HashSet\n\n前面已经说过_HashSet_是对_HashMap_的简单包装，对_HashSet_的函数调用都会转换成合适的_HashMap_方法，因此_HashSet_的实现非常简单，只有不到300行代码。这里不再赘述。\n\n//HashSet是对HashMap的简单包装\npublic class HashSet<E>\n{\n......\nprivate transient HashMap<E,Object> map;//HashSet里面有一个HashMap\n    // Dummy value to associate with an Object in the backing Map\n    private static final Object PRESENT = new Object();\n    public HashSet() {\n        map = new HashMap<>();\n    }\n    ......\n    public boolean add(E e) {//简单的方法转换\n        return map.put(e, PRESENT)==null;\n    }\n    ......\n}\n\n\n\n# 参考文章\n\n * 转载 https://www.pdai.tech/md/java/collection/java-map-HashMap&HashSet.html',normalizedContent:'# map - hashset & hashmap 源码解析\n\n> 本文主要对map - hashset & hashmap进行源码解析。\n\n * map - hashset & hashmap 源码解析\n   * java7 hashmap\n     * 概述\n     * get()\n     * put()\n     * remove()\n   * java8 hashmap\n     * put 过程分析\n     * 数组扩容\n     * get 过程分析\n   * hashset\n\n\n# java7 hashmap\n\n\n# 概述\n\n之所以把_hashset_和_hashmap_放在一起讲解，是因为二者在java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说_hashset_里面有一个_hashmap_(适配器模式)。因此本文将重点分析_hashmap_。\n\n_hashmap_实现了_map_接口，即允许放入key为null的元素，也允许插入value为null的元素；除该类未实现同步外，其余跟hashtable大致相同；跟_treemap_不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个_hashmap_的顺序可能会不同。 根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式(open addressing)，另一种是冲突链表方式(separate chaining with linked lists)。java7 _hashmap_采用的是冲突链表方式。\n\n\n\n从上图容易看出，如果选择合适的哈希函数，put()和get()方法可以在常数时间内完成。但在对_hashmap_进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将_hashmap_的初始大小设的过大。\n\n有两个参数可以影响_hashmap_的性能: 初始容量(inital capacity)和负载系数(load factor)。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过capacity*load_factor时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。\n\n将对象放入到_hashmap_或_hashset_中时，有两个方法需要特别关心: hashcode()和equals()。hashcode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到hashmap或hashset中，需要**@override** hashcode()和equals()方法。\n\n\n# get()\n\nget(object key)方法根据指定的key值返回对应的value，该方法调用了getentry(object key)得到相应的entry，然后返回entry.getvalue()。因此getentry()是算法的核心。 算法思想是首先通过hash()函数得到对应bucket的下标，然后依次遍历冲突链表，通过key.equals(k)方法来判断是否是要找的那个entry。\n\n\n\n上图中hash(k)&(table.length-1)等价于hash(k)%table.length，原因是_hashmap_要求table.length必须是2的指数，因此table.length-1就是二进制低位全是1，跟hash(k)相与会将哈希值的高位全抹掉，剩下的就是余数了。\n\n//getentry()方法\nfinal entry<k,v> getentry(object key) {\n......\nint hash = (key == null) ? 0 : hash(key);\n    for (entry<k,v> e = table[hash&(table.length-1)];//得到冲突链表\n         e != null; e = e.next) {//依次遍历冲突链表中的每个entry\n        object k;\n        //依据equals()方法判断是否相等\n        if (e.hash == hash &&\n            ((k = e.key) == key || (key != null && key.equals(k))))\n            return e;\n    }\n    return null;\n}\n\n\n\n# put()\n\nput(k key, v value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于getentry()方法；如果没有找到，则会通过addentry(int hash, k key, v value, int bucketindex)方法插入新的entry，插入方式为头插法。\n\n\n\n//addentry()\nvoid addentry(int hash, k key, v value, int bucketindex) {\n    if ((size >= threshold) && (null != table[bucketindex])) {\n        resize(2 * table.length);//自动扩容，并重新哈希\n        hash = (null != key) ? hash(key) : 0;\n        bucketindex = hash & (table.length-1);//hash%table.length\n    }\n    //在冲突链表头部插入新的entry\n    entry<k,v> e = table[bucketindex];\n    table[bucketindex] = new entry<>(hash, key, value, e);\n    size++;\n}\n\n\n\n# remove()\n\nremove(object key)的作用是删除key值对应的entry，该方法的具体逻辑是在removeentryforkey(object key)里实现的。removeentryforkey()方法会首先找到key值对应的entry，然后删除该entry(修改链表的相应引用)。查找过程跟getentry()过程类似。\n\n\n\n//removeentryforkey()\nfinal entry<k,v> removeentryforkey(object key) {\n......\nint hash = (key == null) ? 0 : hash(key);\n    int i = indexfor(hash, table.length);//hash&(table.length-1)\n    entry<k,v> prev = table[i];//得到冲突链表\n    entry<k,v> e = prev;\n    while (e != null) {//遍历冲突链表\n        entry<k,v> next = e.next;\n        object k;\n        if (e.hash == hash &&\n            ((k = e.key) == key || (key != null && key.equals(k)))) {//找到要删除的entry\n            modcount++; size--;\n            if (prev == e) table[i] = next;//删除的是冲突链表的第一个entry\n            else prev.next = next;\n            return e;\n        }\n        prev = e; e = next;\n    }\n    return e;\n}\n\n\n\n# java8 hashmap\n\njava8 对 hashmap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。\n\n根据 java7 hashmap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 o(n)。\n\n为了降低这部分的开销，在 java8 中，当链表中的元素达到了 8 个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 o(logn)。\n\n来一张图简单示意一下吧：\n\n\n\n注意，上图是示意图，主要是描述结构，不会达到这个状态的，因为这么多数据的时候早就扩容了。\n\n下面，我们还是用代码来介绍吧，个人感觉，java8 的源码可读性要差一些，不过精简一些。\n\njava7 中使用 entry 来代表每个 hashmap 中的数据节点，java8 中使用 node，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，node 只能用于链表的情况，红黑树的情况需要使用 treenode。\n\n我们根据数组元素中，第一个节点数据类型是 node 还是 treenode 来判断该位置下是链表还是红黑树的。\n\n\n# put 过程分析\n\npublic v put(k key, v value) {\n    return putval(hash(key), key, value, false, true);\n}\n\n// 第四个参数 onlyifabsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作\n// 第五个参数 evict 我们这里不关心\nfinal v putval(int hash, k key, v value, boolean onlyifabsent,\n               boolean evict) {\n    node<k,v>[] tab; node<k,v> p; int n, i;\n    // 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度\n    // 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 node 并放置在这个位置就可以了\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newnode(hash, key, value, null);\n\n    else {// 数组该位置有数据\n        node<k,v> e; k k;\n        // 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是"相等"，如果是，取出这个节点\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        // 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树\n        else if (p instanceof treenode)\n            e = ((treenode<k,v>)p).puttreeval(this, tab, hash, key, value);\n        else {\n            // 到这里，说明数组该位置上是一个链表\n            for (int bincount = 0; ; ++bincount) {\n                // 插入到链表的最后面(java7 是插入到链表的最前面)\n                if ((e = p.next) == null) {\n                    p.next = newnode(hash, key, value, null);\n                    // treeify_threshold 为 8，所以，如果新插入的值是链表中的第 8 个\n                    // 会触发下面的 treeifybin，也就是将链表转换为红黑树\n                    if (bincount >= treeify_threshold - 1) // -1 for 1st\n                        treeifybin(tab, hash);\n                    break;\n                }\n                // 如果在该链表中找到了"相等"的 key(== 或 equals)\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    // 此时 break，那么 e 为链表中[与要插入的新值的 key "相等"]的 node\n                    break;\n                p = e;\n            }\n        }\n        // e!=null 说明存在旧值的key与要插入的key"相等"\n        // 对于我们分析的put操作，下面这个 if 其实就是进行 "值覆盖"，然后返回旧值\n        if (e != null) {\n            v oldvalue = e.value;\n            if (!onlyifabsent || oldvalue == null)\n                e.value = value;\n            afternodeaccess(e);\n            return oldvalue;\n        }\n    }\n    ++modcount;\n    // 如果 hashmap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容\n    if (++size > threshold)\n        resize();\n    afternodeinsertion(evict);\n    return null;\n}\n\n\n和 java7 稍微有点不一样的地方就是，java7 是先扩容后插入新值的，java8 先插值再扩容，不过这个不重要。\n\n\n# 数组扩容\n\nresize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移。\n\nfinal node<k,v>[] resize() {\n    node<k,v>[] oldtab = table;\n    int oldcap = (oldtab == null) ? 0 : oldtab.length;\n    int oldthr = threshold;\n    int newcap, newthr = 0;\n    if (oldcap > 0) { // 对应数组扩容\n        if (oldcap >= maximum_capacity) {\n            threshold = integer.max_value;\n            return oldtab;\n        }\n        // 将数组大小扩大一倍\n        else if ((newcap = oldcap << 1) < maximum_capacity &&\n                 oldcap >= default_initial_capacity)\n            // 将阈值扩大一倍\n            newthr = oldthr << 1; // double threshold\n    }\n    else if (oldthr > 0) // 对应使用 new hashmap(int initialcapacity) 初始化后，第一次 put 的时候\n        newcap = oldthr;\n    else {// 对应使用 new hashmap() 初始化后，第一次 put 的时候\n        newcap = default_initial_capacity;\n        newthr = (int)(default_load_factor * default_initial_capacity);\n    }\n\n    if (newthr == 0) {\n        float ft = (float)newcap * loadfactor;\n        newthr = (newcap < maximum_capacity && ft < (float)maximum_capacity ?\n                  (int)ft : integer.max_value);\n    }\n    threshold = newthr;\n    \n    // 用新的数组大小初始化新的数组\n    node<k,v>[] newtab = (node<k,v>[])new node[newcap];\n    table = newtab; // 如果是初始化数组，到这里就结束了，返回 newtab 即可\n    \n    if (oldtab != null) {\n        // 开始遍历原数组，进行数据迁移。\n        for (int j = 0; j < oldcap; ++j) {\n            node<k,v> e;\n            if ((e = oldtab[j]) != null) {\n                oldtab[j] = null;\n                // 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了\n                if (e.next == null)\n                    newtab[e.hash & (newcap - 1)] = e;\n                // 如果是红黑树，具体我们就不展开了\n                else if (e instanceof treenode)\n                    ((treenode<k,v>)e).split(this, newtab, j, oldcap);\n                else { \n                    // 这块是处理链表的情况，\n                    // 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序\n                    // lohead、lotail 对应一条链表，hihead、hitail 对应另一条链表，代码还是比较简单的\n                    node<k,v> lohead = null, lotail = null;\n                    node<k,v> hihead = null, hitail = null;\n                    node<k,v> next;\n                    do {\n                        next = e.next;\n                        if ((e.hash & oldcap) == 0) {\n                            if (lotail == null)\n                                lohead = e;\n                            else\n                                lotail.next = e;\n                            lotail = e;\n                        }\n                        else {\n                            if (hitail == null)\n                                hihead = e;\n                            else\n                                hitail.next = e;\n                            hitail = e;\n                        }\n                    } while ((e = next) != null);\n                    if (lotail != null) {\n                        lotail.next = null;\n                        // 第一条链表\n                        newtab[j] = lohead;\n                    }\n                    if (hitail != null) {\n                        hitail.next = null;\n                        // 第二条链表的新的位置是 j + oldcap，这个很好理解\n                        newtab[j + oldcap] = hihead;\n                    }\n                }\n            }\n        }\n    }\n    return newtab;\n}\n\n\n\n# get 过程分析\n\n相对于 put 来说，get 真的太简单了。\n\n * 计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash & (length-1)\n * 判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步\n * 判断该元素类型是否是 treenode，如果是，用红黑树的方法取数据，如果不是，走第四步\n * 遍历链表，直到找到相等(==或equals)的 key\n\npublic v get(object key) {\n    node<k,v> e;\n    return (e = getnode(hash(key), key)) == null ? null : e.value;\n}\nfinal node<k,v> getnode(int hash, object key) {\n    node<k,v>[] tab; node<k,v> first, e; int n; k k;\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (first = tab[(n - 1) & hash]) != null) {\n        // 判断第一个节点是不是就是需要的\n        if (first.hash == hash && // always check first node\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        if ((e = first.next) != null) {\n            // 判断是否是红黑树\n            if (first instanceof treenode)\n                return ((treenode<k,v>)first).gettreenode(hash, key);\n\n            // 链表遍历\n            do {\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n\n\n\n# hashset\n\n前面已经说过_hashset_是对_hashmap_的简单包装，对_hashset_的函数调用都会转换成合适的_hashmap_方法，因此_hashset_的实现非常简单，只有不到300行代码。这里不再赘述。\n\n//hashset是对hashmap的简单包装\npublic class hashset<e>\n{\n......\nprivate transient hashmap<e,object> map;//hashset里面有一个hashmap\n    // dummy value to associate with an object in the backing map\n    private static final object present = new object();\n    public hashset() {\n        map = new hashmap<>();\n    }\n    ......\n    public boolean add(e e) {//简单的方法转换\n        return map.put(e, present)==null;\n    }\n    ......\n}\n\n\n\n# 参考文章\n\n * 转载 https://www.pdai.tech/md/java/collection/java-map-hashmap&hashset.html',charsets:{cjk:!0}},{title:"Collection 类关系图",frontmatter:{},regularPath:"/java/collection/java-collection-all.html",relativePath:"java/collection/java-collection-all.md",key:"v-b516cde4",path:"/java/collection/java-collection-all.html",headers:[{level:2,title:"Collection 类关系图",slug:"collection-类关系图",normalizedTitle:"collection 类关系图",charIndex:2},{level:2,title:"知识体系结构",slug:"知识体系结构",normalizedTitle:"知识体系结构",charIndex:95},{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:25},{level:2,title:"Collection",slug:"collection",normalizedTitle:"collection",charIndex:2},{level:3,title:"Set",slug:"set",normalizedTitle:"set",charIndex:133},{level:3,title:"List",slug:"list",normalizedTitle:"list",charIndex:201},{level:3,title:"Queue",slug:"queue",normalizedTitle:"queue",charIndex:268},{level:2,title:"Map",slug:"map",normalizedTitle:"map",charIndex:42},{level:3,title:"TreeMap",slug:"treemap",normalizedTitle:"treemap",charIndex:333},{level:3,title:"HashMap",slug:"hashmap",normalizedTitle:"hashmap",charIndex:348},{level:3,title:"HashTable",slug:"hashtable",normalizedTitle:"hashtable",charIndex:363},{level:3,title:"LinkedHashMap",slug:"linkedhashmap",normalizedTitle:"linkedhashmap",charIndex:380},{level:2,title:"参考内容",slug:"参考内容",normalizedTitle:"参考内容",charIndex:399}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Collection 类关系图 知识体系结构 介绍 Collection Set List Queue Map TreeMap HashMap HashTable LinkedHashMap 参考内容",content:"# Collection 类关系图\n\n> 本文主要介绍JDK中Collection和Map相关知识体系，后续章节将对主要对类进行源码解读。\n\n * Collection 类关系图\n   * 知识体系结构\n   * 介绍\n   * Collection\n     * Set\n       * TreeSet\n       * HashSet\n       * LinkedHashSet\n     * List\n       * ArrayList\n       * Vector\n       * LinkedList\n     * Queue\n       * LinkedList\n       * PriorityQueue\n   * Map\n     * TreeMap\n     * HashMap\n     * HashTable\n     * LinkedHashMap\n   * 参考内容\n\n\n# 知识体系结构\n\n\n\n\n# 介绍\n\n容器，就是可以容纳其他Java对象的对象。*Java Collections Framework(JCF)*为Java开发者提供了通用的容器，其始于JDK 1.2，优点是:\n\n * 降低编程难度\n * 提高程序性能\n * 提高API间的互操作性\n * 降低学习难度\n * 降低设计和实现相关API的难度\n * 增加程序的重用性\n\nJava容器里只能放对象，对于基本类型(int, long, float, double等)，需要将其包装成对象类型后(Integer, Long, Float, Double等)才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。\n\n\n# Collection\n\n> 容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对(两个对象)的映射表。\n\n\n# Set\n\n# TreeSet\n\n基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。\n\n# HashSet\n\n基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。\n\n# LinkedHashSet\n\n具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。\n\n\n# List\n\n# ArrayList\n\n基于动态数组实现，支持随机访问。\n\n# Vector\n\n和 ArrayList 类似，但它是线程安全的。\n\n# LinkedList\n\n基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。\n\n\n# Queue\n\n# LinkedList\n\n可以用它来实现双向队列。\n\n# PriorityQueue\n\n基于堆结构实现，可以用它来实现优先队列。\n\n\n# Map\n\n\n# TreeMap\n\n基于红黑树实现。\n\n\n# HashMap\n\n基于哈希表实现。\n\n\n# HashTable\n\n和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。\n\n\n# LinkedHashMap\n\n使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序。\n\n\n# 参考内容\n\n * CarpenterLee/JCFInternals https://github.com/CarpenterLee/JCFInternals\n * 转载 https://www.pdai.tech/md/java/collection/java-collection-all.html",normalizedContent:"# collection 类关系图\n\n> 本文主要介绍jdk中collection和map相关知识体系，后续章节将对主要对类进行源码解读。\n\n * collection 类关系图\n   * 知识体系结构\n   * 介绍\n   * collection\n     * set\n       * treeset\n       * hashset\n       * linkedhashset\n     * list\n       * arraylist\n       * vector\n       * linkedlist\n     * queue\n       * linkedlist\n       * priorityqueue\n   * map\n     * treemap\n     * hashmap\n     * hashtable\n     * linkedhashmap\n   * 参考内容\n\n\n# 知识体系结构\n\n\n\n\n# 介绍\n\n容器，就是可以容纳其他java对象的对象。*java collections framework(jcf)*为java开发者提供了通用的容器，其始于jdk 1.2，优点是:\n\n * 降低编程难度\n * 提高程序性能\n * 提高api间的互操作性\n * 降低学习难度\n * 降低设计和实现相关api的难度\n * 增加程序的重用性\n\njava容器里只能放对象，对于基本类型(int, long, float, double等)，需要将其包装成对象类型后(integer, long, float, double等)才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。\n\n\n# collection\n\n> 容器主要包括 collection 和 map 两种，collection 存储着对象的集合，而 map 存储着键值对(两个对象)的映射表。\n\n\n# set\n\n# treeset\n\n基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 hashset，hashset 查找的时间复杂度为 o(1)，treeset 则为 o(logn)。\n\n# hashset\n\n基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 iterator 遍历 hashset 得到的结果是不确定的。\n\n# linkedhashset\n\n具有 hashset 的查找效率，且内部使用双向链表维护元素的插入顺序。\n\n\n# list\n\n# arraylist\n\n基于动态数组实现，支持随机访问。\n\n# vector\n\n和 arraylist 类似，但它是线程安全的。\n\n# linkedlist\n\n基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，linkedlist 还可以用作栈、队列和双向队列。\n\n\n# queue\n\n# linkedlist\n\n可以用它来实现双向队列。\n\n# priorityqueue\n\n基于堆结构实现，可以用它来实现优先队列。\n\n\n# map\n\n\n# treemap\n\n基于红黑树实现。\n\n\n# hashmap\n\n基于哈希表实现。\n\n\n# hashtable\n\n和 hashmap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 hashtable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 concurrenthashmap 来支持线程安全，并且 concurrenthashmap 的效率会更高，因为 concurrenthashmap 引入了分段锁。\n\n\n# linkedhashmap\n\n使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(lru)顺序。\n\n\n# 参考内容\n\n * carpenterlee/jcfinternals https://github.com/carpenterlee/jcfinternals\n * 转载 https://www.pdai.tech/md/java/collection/java-collection-all.html",charsets:{cjk:!0}},{title:"Map - TreeSet & TreeMap 源码解析",frontmatter:{},regularPath:"/java/collection/java-map-TreeMap&TreeSet.html",relativePath:"java/collection/java-map-TreeMap&TreeSet.md",key:"v-7b0a2d92",path:"/java/collection/java-map-TreeMap&TreeSet.html",headers:[{level:2,title:"Map - TreeSet & TreeMap 源码解析",slug:"map-treeset-treemap-源码解析",normalizedTitle:"map - treeset &amp; treemap 源码解析",charIndex:null},{level:2,title:"Java 7 - TreeSet & TreeMap",slug:"java-7-treeset-treemap",normalizedTitle:"java 7 - treeset &amp; treemap",charIndex:null},{level:3,title:"总体介绍",slug:"总体介绍",normalizedTitle:"总体介绍",charIndex:105},{level:3,title:"预备知识",slug:"预备知识",normalizedTitle:"预备知识",charIndex:115},{level:3,title:"方法剖析",slug:"方法剖析",normalizedTitle:"方法剖析",charIndex:125},{level:3,title:"TreeSet",slug:"treeset",normalizedTitle:"treeset",charIndex:8},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:12129}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Map - TreeSet & TreeMap 源码解析 Java 7 - TreeSet & TreeMap 总体介绍 预备知识 方法剖析 TreeSet 参考文章",content:"# Map - TreeSet & TreeMap 源码解析\n\n> 本文主要对Map - TreeSet & TreeMap 源码解析。\n\n * Java 7 - TreeSet & TreeMap\n   * 总体介绍\n   * 预备知识\n   * 方法剖析\n   * TreeSet\n\n\n# Java 7 - TreeSet & TreeMap\n\n\n# 总体介绍\n\n之所以把_TreeSet_和_TreeMap_放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说___TreeSet_里面有一个_TreeMap_(适配器模式)**。因此本文将重点分析_TreeMap_。\n\nJava _TreeMap_实现了_SortedMap_接口，也就是说会按照key的大小顺序对_Map_中的元素进行排序，key大小的评判可以通过其本身的自然顺序(natural ordering)，也可以通过构造时传入的比较器(Comparator)。\n\n_TreeMap_底层通过红黑树(Red-Black tree)实现，也就意味着containsKey(), get(), put(), remove()都有着log(n)的时间复杂度。其具体算法实现参照了《算法导论》。\n\n\n\n出于性能原因，_TreeMap_是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将_TreeMap_包装成(wrapped)同步的:\n\nSortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));\n\n红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍。具体来说，红黑树是满足如下条件的二叉查找树(binary search tree):\n\n 1. 每个节点要么是红色，要么是黑色。\n 2. 根节点必须是黑色\n 3. 红色节点不能连续(也即是，红色节点的孩子和父亲都不能是红色)。\n 4. 对于每个节点，从该点至null(树尾端)的任何路径，都含有相同个数的黑色节点。\n\n在树的结构发生改变时(插入或者删除操作)，往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的约束条件。\n\n\n# 预备知识\n\n前文说到当查找树的结构发生改变时，红黑树的约束条件可能被破坏，需要通过调整使得查找树重新满足红黑树的约束条件。调整可以分为两类: 一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，即改变检索树的结构关系。结构调整过程包含两个基本操作** : 左旋(Rotate Left)，右旋(RotateRight)**。\n\n# 左旋\n\n左旋的过程是将x的右子树绕x逆时针旋转，使得x的右子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。\n\n\n\n_TreeMap_中左旋代码如下:\n\n//Rotate Left\nprivate void rotateLeft(Entry<K,V> p) {\n    if (p != null) {\n        Entry<K,V> r = p.right;\n        p.right = r.left;\n        if (r.left != null)\n            r.left.parent = p;\n        r.parent = p.parent;\n        if (p.parent == null)\n            root = r;\n        else if (p.parent.left == p)\n            p.parent.left = r;\n        else\n            p.parent.right = r;\n        r.left = p;\n        p.parent = r;\n    }\n}\n\n\n# 右旋\n\n右旋的过程是将x的左子树绕x顺时针旋转，使得x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。\n\n\n\n_TreeMap_中右旋代码如下:\n\n//Rotate Right\nprivate void rotateRight(Entry<K,V> p) {\n    if (p != null) {\n        Entry<K,V> l = p.left;\n        p.left = l.right;\n        if (l.right != null) l.right.parent = p;\n        l.parent = p.parent;\n        if (p.parent == null)\n            root = l;\n        else if (p.parent.right == p)\n            p.parent.right = l;\n        else p.parent.left = l;\n        l.right = p;\n        p.parent = l;\n    }\n}\n\n\n# 寻找节点后继\n\n对于一棵二叉查找树，给定节点t，其后继(树中比大于t的最小的那个元素)可以通过如下方式找到:\n\n>  1. t的右子树不空，则t的后继是其右子树中最小的那个元素。\n>  2. t的右孩子为空，则t的后继是其第一个向左走的祖先。\n\n后继节点在红黑树的删除操作中将会用到。\n\n\n\n_TreeMap_中寻找节点后继的代码如下:\n\n// 寻找节点后继函数successor()\nstatic <K,V> TreeMap.Entry<K,V> successor(Entry<K,V> t) {\n    if (t == null)\n        return null;\n    else if (t.right != null) {// 1. t的右子树不空，则t的后继是其右子树中最小的那个元素\n        Entry<K,V> p = t.right;\n        while (p.left != null)\n            p = p.left;\n        return p;\n    } else {// 2. t的右孩子为空，则t的后继是其第一个向左走的祖先\n        Entry<K,V> p = t.parent;\n        Entry<K,V> ch = t;\n        while (p != null && ch == p.right) {\n            ch = p;\n            p = p.parent;\n        }\n        return p;\n    }\n}\n\n\n\n# 方法剖析\n\n# get()\n\nget(Object key)方法根据指定的key值返回对应的value，该方法调用了getEntry(Object key)得到相应的entry，然后返回entry.value。因此getEntry()是算法的核心。算法思想是根据key的自然顺序(或者比较器顺序)对二叉查找树进行查找，直到找到满足k.compareTo(p.key) == 0的entry。\n\n\n\n具体代码如下:\n\n//getEntry()方法\nfinal Entry<K,V> getEntry(Object key) {\n    ......\n    if (key == null)//不允许key值为null\n        throw new NullPointerException();\n    Comparable<? super K> k = (Comparable<? super K>) key;//使用元素的自然顺序\n    Entry<K,V> p = root;\n    while (p != null) {\n        int cmp = k.compareTo(p.key);\n        if (cmp < 0)//向左找\n            p = p.left;\n        else if (cmp > 0)//向右找\n            p = p.right;\n        else\n            return p;\n    }\n    return null;\n}\n\n\n# put()\n\nput(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于getEntry()方法；如果没有找到则会在红黑树中插入新的entry，如果插入之后破坏了红黑树的约束条件，还需要进行调整(旋转，改变某些节点的颜色)。\n\npublic V put(K key, V value) {\n......\n    int cmp;\n    Entry<K,V> parent;\n    if (key == null)\n        throw new NullPointerException();\n    Comparable<? super K> k = (Comparable<? super K>) key;//使用元素的自然顺序\n    do {\n        parent = t;\n        cmp = k.compareTo(t.key);\n        if (cmp < 0) t = t.left;//向左找\n        else if (cmp > 0) t = t.right;//向右找\n        else return t.setValue(value);\n    } while (t != null);\n    Entry<K,V> e = new Entry<>(key, value, parent);//创建并插入新的entry\n    if (cmp < 0) parent.left = e;\n    else parent.right = e;\n    fixAfterInsertion(e);//调整\n    size++;\n    return null;\n}\n\n\n上述代码的插入部分并不难理解: 首先在红黑树上找到合适的位置，然后创建新的entry并插入(当然，新插入的节点一定是树的叶子)。难点是调整函数fixAfterInsertion()，前面已经说过，调整往往需要1.改变某些节点的颜色，2.对某些节点进行旋转。\n\n\n\n调整函数fixAfterInsertion()的具体代码如下，其中用到了上文中提到的rotateLeft()和rotateRight()函数。通过代码我们能够看到，情况2其实是落在情况3内的。情况4～情况6跟前三种情况是对称的，因此图解中并没有画出后三种情况，读者可以参考代码自行理解。\n\n//红黑树调整函数fixAfterInsertion()\nprivate void fixAfterInsertion(Entry<K,V> x) {\n    x.color = RED;\n    while (x != null && x != root && x.parent.color == RED) {\n        if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {\n            Entry<K,V> y = rightOf(parentOf(parentOf(x)));\n            if (colorOf(y) == RED) {\n                setColor(parentOf(x), BLACK);              // 情况1\n                setColor(y, BLACK);                        // 情况1\n                setColor(parentOf(parentOf(x)), RED);      // 情况1\n                x = parentOf(parentOf(x));                 // 情况1\n            } else {\n                if (x == rightOf(parentOf(x))) {\n                    x = parentOf(x);                       // 情况2\n                    rotateLeft(x);                         // 情况2\n                }\n                setColor(parentOf(x), BLACK);              // 情况3\n                setColor(parentOf(parentOf(x)), RED);      // 情况3\n                rotateRight(parentOf(parentOf(x)));        // 情况3\n            }\n        } else {\n            Entry<K,V> y = leftOf(parentOf(parentOf(x)));\n            if (colorOf(y) == RED) {\n                setColor(parentOf(x), BLACK);              // 情况4\n                setColor(y, BLACK);                        // 情况4\n                setColor(parentOf(parentOf(x)), RED);      // 情况4\n                x = parentOf(parentOf(x));                 // 情况4\n            } else {\n                if (x == leftOf(parentOf(x))) {\n                    x = parentOf(x);                       // 情况5\n                    rotateRight(x);                        // 情况5\n                }\n                setColor(parentOf(x), BLACK);              // 情况6\n                setColor(parentOf(parentOf(x)), RED);      // 情况6\n                rotateLeft(parentOf(parentOf(x)));         // 情况6\n            }\n        }\n    }\n    root.color = BLACK;\n}\n\n\n# remove()\n\nremove(Object key)的作用是删除key值对应的entry，该方法首先通过上文中提到的getEntry(Object key)方法找到key值对应的entry，然后调用deleteEntry(Entry<K,V> entry)删除对应的entry。由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束条件，因此有可能要进行调整。\n\ngetEntry()函数前面已经讲解过，这里重点放deleteEntry()上，该函数删除指定的entry并在红黑树的约束被破坏时进行调用fixAfterDeletion(Entry<K,V> x)进行调整。\n\n由于红黑树是一棵增强版的二叉查找树，红黑树的删除操作跟普通二叉查找树的删除操作也就非常相似，唯一的区别是红黑树在节点删除之后可能需要进行调整。现在考虑一棵普通二叉查找树的删除过程，可以简单分为两种情况:\n\n>  1. 删除点p的左右子树都为空，或者只有一棵子树非空。\n>  2. 删除点p的左右子树都非空。\n\n对于上述情况1，处理起来比较简单，直接将p删除(左右子树都为空时)，或者用非空子树替代p(只有一棵子树非空时)；对于情况2，可以用p的后继s(树中大于x的最小的那个元素)代替p，然后使用情况1删除s(此时s一定满足情况1.可以画画看)。\n\n基于以上逻辑，红黑树的节点删除函数deleteEntry()代码如下:\n\n// 红黑树entry删除函数deleteEntry()\nprivate void deleteEntry(Entry<K,V> p) {\n    modCount++;\n    size--;\n    if (p.left != null && p.right != null) {// 2. 删除点p的左右子树都非空。\n        Entry<K,V> s = successor(p);// 后继\n        p.key = s.key;\n        p.value = s.value;\n        p = s;\n    }\n    Entry<K,V> replacement = (p.left != null ? p.left : p.right);\n    if (replacement != null) {// 1. 删除点p只有一棵子树非空。\n        replacement.parent = p.parent;\n        if (p.parent == null)\n            root = replacement;\n        else if (p == p.parent.left)\n            p.parent.left  = replacement;\n        else\n            p.parent.right = replacement;\n        p.left = p.right = p.parent = null;\n        if (p.color == BLACK)\n            fixAfterDeletion(replacement);// 调整\n    } else if (p.parent == null) {\n        root = null;\n    } else { // 1. 删除点p的左右子树都为空\n        if (p.color == BLACK)\n            fixAfterDeletion(p);// 调整\n        if (p.parent != null) {\n            if (p == p.parent.left)\n                p.parent.left = null;\n            else if (p == p.parent.right)\n                p.parent.right = null;\n            p.parent = null;\n        }\n    }\n}\n\n\n上述代码中占据大量代码行的，是用来修改父子节点间引用关系的代码，其逻辑并不难理解。下面着重讲解删除后调整函数fixAfterDeletion()。首先请思考一下，删除了哪些点才会导致调整？只有删除点是BLACK的时候，才会触发调整函数，因为删除RED节点不会破坏红黑树的任何约束，而删除BLACK节点会破坏规则4。\n\n跟上文中讲过的fixAfterInsertion()函数一样，这里也要分成若干种情况。记住，无论有多少情况，具体的调整操作只有两种: 1.改变某些节点的颜色，2.对某些节点进行旋转。\n\n\n\n上述图解的总体思想是: 将情况1首先转换成情况2，或者转换成情况3和情况4。当然，该图解并不意味着调整过程一定是从情况1开始。通过后续代码我们还会发现几个有趣的规则: a).如果是由情况1之后紧接着进入的情况2，那么情况2之后一定会退出循环(因为x为红色)；b).一旦进入情况3和情况4，一定会退出循环(因为x为root)。\n\n删除后调整函数fixAfterDeletion()的具体代码如下，其中用到了上文中提到的rotateLeft()和rotateRight()函数。通过代码我们能够看到，情况3其实是落在情况4内的。情况5～情况8跟前四种情况是对称的，因此图解中并没有画出后四种情况，读者可以参考代码自行理解。\n\nprivate void fixAfterDeletion(Entry<K,V> x) {\n    while (x != root && colorOf(x) == BLACK) {\n        if (x == leftOf(parentOf(x))) {\n            Entry<K,V> sib = rightOf(parentOf(x));\n            if (colorOf(sib) == RED) {\n                setColor(sib, BLACK);                   // 情况1\n                setColor(parentOf(x), RED);             // 情况1\n                rotateLeft(parentOf(x));                // 情况1\n                sib = rightOf(parentOf(x));             // 情况1\n            }\n            if (colorOf(leftOf(sib))  == BLACK &&\n                colorOf(rightOf(sib)) == BLACK) {\n                setColor(sib, RED);                     // 情况2\n                x = parentOf(x);                        // 情况2\n            } else {\n                if (colorOf(rightOf(sib)) == BLACK) {\n                    setColor(leftOf(sib), BLACK);       // 情况3\n                    setColor(sib, RED);                 // 情况3\n                    rotateRight(sib);                   // 情况3\n                    sib = rightOf(parentOf(x));         // 情况3\n                }\n                setColor(sib, colorOf(parentOf(x)));    // 情况4\n                setColor(parentOf(x), BLACK);           // 情况4\n                setColor(rightOf(sib), BLACK);          // 情况4\n                rotateLeft(parentOf(x));                // 情况4\n                x = root;                               // 情况4\n            }\n        } else { // 跟前四种情况对称\n            Entry<K,V> sib = leftOf(parentOf(x));\n            if (colorOf(sib) == RED) {\n                setColor(sib, BLACK);                   // 情况5\n                setColor(parentOf(x), RED);             // 情况5\n                rotateRight(parentOf(x));               // 情况5\n                sib = leftOf(parentOf(x));              // 情况5\n            }\n            if (colorOf(rightOf(sib)) == BLACK &&\n                colorOf(leftOf(sib)) == BLACK) {\n                setColor(sib, RED);                     // 情况6\n                x = parentOf(x);                        // 情况6\n            } else {\n                if (colorOf(leftOf(sib)) == BLACK) {\n                    setColor(rightOf(sib), BLACK);      // 情况7\n                    setColor(sib, RED);                 // 情况7\n                    rotateLeft(sib);                    // 情况7\n                    sib = leftOf(parentOf(x));          // 情况7\n                }\n                setColor(sib, colorOf(parentOf(x)));    // 情况8\n                setColor(parentOf(x), BLACK);           // 情况8\n                setColor(leftOf(sib), BLACK);           // 情况8\n                rotateRight(parentOf(x));               // 情况8\n                x = root;                               // 情况8\n            }\n        }\n    }\n    setColor(x, BLACK);\n}\n\n\n\n# TreeSet\n\n前面已经说过TreeSet是对TreeMap的简单包装，对TreeSet的函数调用都会转换成合适的TreeMap方法，因此TreeSet的实现非常简单。这里不再赘述。\n\n// TreeSet是对TreeMap的简单包装\npublic class TreeSet<E> extends AbstractSet<E>\n    implements NavigableSet<E>, Cloneable, java.io.Serializable\n{\n......\n    private transient NavigableMap<E,Object> m;\n    // Dummy value to associate with an Object in the backing Map\n    private static final Object PRESENT = new Object();\n    public TreeSet() {\n        this.m = new TreeMap<E,Object>();// TreeSet里面有一个TreeMap\n    }\n    ......\n    public boolean add(E e) {\n        return m.put(e, PRESENT)==null;\n    }\n    ......\n}\n\n\n\n# 参考文章\n\n * 转载 https://www.pdai.tech/md/java/collection/java-map-TreeMap&TreeSet.html",normalizedContent:"# map - treeset & treemap 源码解析\n\n> 本文主要对map - treeset & treemap 源码解析。\n\n * java 7 - treeset & treemap\n   * 总体介绍\n   * 预备知识\n   * 方法剖析\n   * treeset\n\n\n# java 7 - treeset & treemap\n\n\n# 总体介绍\n\n之所以把_treeset_和_treemap_放在一起讲解，是因为二者在java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说___treeset_里面有一个_treemap_(适配器模式)**。因此本文将重点分析_treemap_。\n\njava _treemap_实现了_sortedmap_接口，也就是说会按照key的大小顺序对_map_中的元素进行排序，key大小的评判可以通过其本身的自然顺序(natural ordering)，也可以通过构造时传入的比较器(comparator)。\n\n_treemap_底层通过红黑树(red-black tree)实现，也就意味着containskey(), get(), put(), remove()都有着log(n)的时间复杂度。其具体算法实现参照了《算法导论》。\n\n\n\n出于性能原因，_treemap_是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将_treemap_包装成(wrapped)同步的:\n\nsortedmap m = collections.synchronizedsortedmap(new treemap(...));\n\n红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍。具体来说，红黑树是满足如下条件的二叉查找树(binary search tree):\n\n 1. 每个节点要么是红色，要么是黑色。\n 2. 根节点必须是黑色\n 3. 红色节点不能连续(也即是，红色节点的孩子和父亲都不能是红色)。\n 4. 对于每个节点，从该点至null(树尾端)的任何路径，都含有相同个数的黑色节点。\n\n在树的结构发生改变时(插入或者删除操作)，往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的约束条件。\n\n\n# 预备知识\n\n前文说到当查找树的结构发生改变时，红黑树的约束条件可能被破坏，需要通过调整使得查找树重新满足红黑树的约束条件。调整可以分为两类: 一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，即改变检索树的结构关系。结构调整过程包含两个基本操作** : 左旋(rotate left)，右旋(rotateright)**。\n\n# 左旋\n\n左旋的过程是将x的右子树绕x逆时针旋转，使得x的右子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。\n\n\n\n_treemap_中左旋代码如下:\n\n//rotate left\nprivate void rotateleft(entry<k,v> p) {\n    if (p != null) {\n        entry<k,v> r = p.right;\n        p.right = r.left;\n        if (r.left != null)\n            r.left.parent = p;\n        r.parent = p.parent;\n        if (p.parent == null)\n            root = r;\n        else if (p.parent.left == p)\n            p.parent.left = r;\n        else\n            p.parent.right = r;\n        r.left = p;\n        p.parent = r;\n    }\n}\n\n\n# 右旋\n\n右旋的过程是将x的左子树绕x顺时针旋转，使得x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。\n\n\n\n_treemap_中右旋代码如下:\n\n//rotate right\nprivate void rotateright(entry<k,v> p) {\n    if (p != null) {\n        entry<k,v> l = p.left;\n        p.left = l.right;\n        if (l.right != null) l.right.parent = p;\n        l.parent = p.parent;\n        if (p.parent == null)\n            root = l;\n        else if (p.parent.right == p)\n            p.parent.right = l;\n        else p.parent.left = l;\n        l.right = p;\n        p.parent = l;\n    }\n}\n\n\n# 寻找节点后继\n\n对于一棵二叉查找树，给定节点t，其后继(树中比大于t的最小的那个元素)可以通过如下方式找到:\n\n>  1. t的右子树不空，则t的后继是其右子树中最小的那个元素。\n>  2. t的右孩子为空，则t的后继是其第一个向左走的祖先。\n\n后继节点在红黑树的删除操作中将会用到。\n\n\n\n_treemap_中寻找节点后继的代码如下:\n\n// 寻找节点后继函数successor()\nstatic <k,v> treemap.entry<k,v> successor(entry<k,v> t) {\n    if (t == null)\n        return null;\n    else if (t.right != null) {// 1. t的右子树不空，则t的后继是其右子树中最小的那个元素\n        entry<k,v> p = t.right;\n        while (p.left != null)\n            p = p.left;\n        return p;\n    } else {// 2. t的右孩子为空，则t的后继是其第一个向左走的祖先\n        entry<k,v> p = t.parent;\n        entry<k,v> ch = t;\n        while (p != null && ch == p.right) {\n            ch = p;\n            p = p.parent;\n        }\n        return p;\n    }\n}\n\n\n\n# 方法剖析\n\n# get()\n\nget(object key)方法根据指定的key值返回对应的value，该方法调用了getentry(object key)得到相应的entry，然后返回entry.value。因此getentry()是算法的核心。算法思想是根据key的自然顺序(或者比较器顺序)对二叉查找树进行查找，直到找到满足k.compareto(p.key) == 0的entry。\n\n\n\n具体代码如下:\n\n//getentry()方法\nfinal entry<k,v> getentry(object key) {\n    ......\n    if (key == null)//不允许key值为null\n        throw new nullpointerexception();\n    comparable<? super k> k = (comparable<? super k>) key;//使用元素的自然顺序\n    entry<k,v> p = root;\n    while (p != null) {\n        int cmp = k.compareto(p.key);\n        if (cmp < 0)//向左找\n            p = p.left;\n        else if (cmp > 0)//向右找\n            p = p.right;\n        else\n            return p;\n    }\n    return null;\n}\n\n\n# put()\n\nput(k key, v value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于getentry()方法；如果没有找到则会在红黑树中插入新的entry，如果插入之后破坏了红黑树的约束条件，还需要进行调整(旋转，改变某些节点的颜色)。\n\npublic v put(k key, v value) {\n......\n    int cmp;\n    entry<k,v> parent;\n    if (key == null)\n        throw new nullpointerexception();\n    comparable<? super k> k = (comparable<? super k>) key;//使用元素的自然顺序\n    do {\n        parent = t;\n        cmp = k.compareto(t.key);\n        if (cmp < 0) t = t.left;//向左找\n        else if (cmp > 0) t = t.right;//向右找\n        else return t.setvalue(value);\n    } while (t != null);\n    entry<k,v> e = new entry<>(key, value, parent);//创建并插入新的entry\n    if (cmp < 0) parent.left = e;\n    else parent.right = e;\n    fixafterinsertion(e);//调整\n    size++;\n    return null;\n}\n\n\n上述代码的插入部分并不难理解: 首先在红黑树上找到合适的位置，然后创建新的entry并插入(当然，新插入的节点一定是树的叶子)。难点是调整函数fixafterinsertion()，前面已经说过，调整往往需要1.改变某些节点的颜色，2.对某些节点进行旋转。\n\n\n\n调整函数fixafterinsertion()的具体代码如下，其中用到了上文中提到的rotateleft()和rotateright()函数。通过代码我们能够看到，情况2其实是落在情况3内的。情况4～情况6跟前三种情况是对称的，因此图解中并没有画出后三种情况，读者可以参考代码自行理解。\n\n//红黑树调整函数fixafterinsertion()\nprivate void fixafterinsertion(entry<k,v> x) {\n    x.color = red;\n    while (x != null && x != root && x.parent.color == red) {\n        if (parentof(x) == leftof(parentof(parentof(x)))) {\n            entry<k,v> y = rightof(parentof(parentof(x)));\n            if (colorof(y) == red) {\n                setcolor(parentof(x), black);              // 情况1\n                setcolor(y, black);                        // 情况1\n                setcolor(parentof(parentof(x)), red);      // 情况1\n                x = parentof(parentof(x));                 // 情况1\n            } else {\n                if (x == rightof(parentof(x))) {\n                    x = parentof(x);                       // 情况2\n                    rotateleft(x);                         // 情况2\n                }\n                setcolor(parentof(x), black);              // 情况3\n                setcolor(parentof(parentof(x)), red);      // 情况3\n                rotateright(parentof(parentof(x)));        // 情况3\n            }\n        } else {\n            entry<k,v> y = leftof(parentof(parentof(x)));\n            if (colorof(y) == red) {\n                setcolor(parentof(x), black);              // 情况4\n                setcolor(y, black);                        // 情况4\n                setcolor(parentof(parentof(x)), red);      // 情况4\n                x = parentof(parentof(x));                 // 情况4\n            } else {\n                if (x == leftof(parentof(x))) {\n                    x = parentof(x);                       // 情况5\n                    rotateright(x);                        // 情况5\n                }\n                setcolor(parentof(x), black);              // 情况6\n                setcolor(parentof(parentof(x)), red);      // 情况6\n                rotateleft(parentof(parentof(x)));         // 情况6\n            }\n        }\n    }\n    root.color = black;\n}\n\n\n# remove()\n\nremove(object key)的作用是删除key值对应的entry，该方法首先通过上文中提到的getentry(object key)方法找到key值对应的entry，然后调用deleteentry(entry<k,v> entry)删除对应的entry。由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束条件，因此有可能要进行调整。\n\ngetentry()函数前面已经讲解过，这里重点放deleteentry()上，该函数删除指定的entry并在红黑树的约束被破坏时进行调用fixafterdeletion(entry<k,v> x)进行调整。\n\n由于红黑树是一棵增强版的二叉查找树，红黑树的删除操作跟普通二叉查找树的删除操作也就非常相似，唯一的区别是红黑树在节点删除之后可能需要进行调整。现在考虑一棵普通二叉查找树的删除过程，可以简单分为两种情况:\n\n>  1. 删除点p的左右子树都为空，或者只有一棵子树非空。\n>  2. 删除点p的左右子树都非空。\n\n对于上述情况1，处理起来比较简单，直接将p删除(左右子树都为空时)，或者用非空子树替代p(只有一棵子树非空时)；对于情况2，可以用p的后继s(树中大于x的最小的那个元素)代替p，然后使用情况1删除s(此时s一定满足情况1.可以画画看)。\n\n基于以上逻辑，红黑树的节点删除函数deleteentry()代码如下:\n\n// 红黑树entry删除函数deleteentry()\nprivate void deleteentry(entry<k,v> p) {\n    modcount++;\n    size--;\n    if (p.left != null && p.right != null) {// 2. 删除点p的左右子树都非空。\n        entry<k,v> s = successor(p);// 后继\n        p.key = s.key;\n        p.value = s.value;\n        p = s;\n    }\n    entry<k,v> replacement = (p.left != null ? p.left : p.right);\n    if (replacement != null) {// 1. 删除点p只有一棵子树非空。\n        replacement.parent = p.parent;\n        if (p.parent == null)\n            root = replacement;\n        else if (p == p.parent.left)\n            p.parent.left  = replacement;\n        else\n            p.parent.right = replacement;\n        p.left = p.right = p.parent = null;\n        if (p.color == black)\n            fixafterdeletion(replacement);// 调整\n    } else if (p.parent == null) {\n        root = null;\n    } else { // 1. 删除点p的左右子树都为空\n        if (p.color == black)\n            fixafterdeletion(p);// 调整\n        if (p.parent != null) {\n            if (p == p.parent.left)\n                p.parent.left = null;\n            else if (p == p.parent.right)\n                p.parent.right = null;\n            p.parent = null;\n        }\n    }\n}\n\n\n上述代码中占据大量代码行的，是用来修改父子节点间引用关系的代码，其逻辑并不难理解。下面着重讲解删除后调整函数fixafterdeletion()。首先请思考一下，删除了哪些点才会导致调整？只有删除点是black的时候，才会触发调整函数，因为删除red节点不会破坏红黑树的任何约束，而删除black节点会破坏规则4。\n\n跟上文中讲过的fixafterinsertion()函数一样，这里也要分成若干种情况。记住，无论有多少情况，具体的调整操作只有两种: 1.改变某些节点的颜色，2.对某些节点进行旋转。\n\n\n\n上述图解的总体思想是: 将情况1首先转换成情况2，或者转换成情况3和情况4。当然，该图解并不意味着调整过程一定是从情况1开始。通过后续代码我们还会发现几个有趣的规则: a).如果是由情况1之后紧接着进入的情况2，那么情况2之后一定会退出循环(因为x为红色)；b).一旦进入情况3和情况4，一定会退出循环(因为x为root)。\n\n删除后调整函数fixafterdeletion()的具体代码如下，其中用到了上文中提到的rotateleft()和rotateright()函数。通过代码我们能够看到，情况3其实是落在情况4内的。情况5～情况8跟前四种情况是对称的，因此图解中并没有画出后四种情况，读者可以参考代码自行理解。\n\nprivate void fixafterdeletion(entry<k,v> x) {\n    while (x != root && colorof(x) == black) {\n        if (x == leftof(parentof(x))) {\n            entry<k,v> sib = rightof(parentof(x));\n            if (colorof(sib) == red) {\n                setcolor(sib, black);                   // 情况1\n                setcolor(parentof(x), red);             // 情况1\n                rotateleft(parentof(x));                // 情况1\n                sib = rightof(parentof(x));             // 情况1\n            }\n            if (colorof(leftof(sib))  == black &&\n                colorof(rightof(sib)) == black) {\n                setcolor(sib, red);                     // 情况2\n                x = parentof(x);                        // 情况2\n            } else {\n                if (colorof(rightof(sib)) == black) {\n                    setcolor(leftof(sib), black);       // 情况3\n                    setcolor(sib, red);                 // 情况3\n                    rotateright(sib);                   // 情况3\n                    sib = rightof(parentof(x));         // 情况3\n                }\n                setcolor(sib, colorof(parentof(x)));    // 情况4\n                setcolor(parentof(x), black);           // 情况4\n                setcolor(rightof(sib), black);          // 情况4\n                rotateleft(parentof(x));                // 情况4\n                x = root;                               // 情况4\n            }\n        } else { // 跟前四种情况对称\n            entry<k,v> sib = leftof(parentof(x));\n            if (colorof(sib) == red) {\n                setcolor(sib, black);                   // 情况5\n                setcolor(parentof(x), red);             // 情况5\n                rotateright(parentof(x));               // 情况5\n                sib = leftof(parentof(x));              // 情况5\n            }\n            if (colorof(rightof(sib)) == black &&\n                colorof(leftof(sib)) == black) {\n                setcolor(sib, red);                     // 情况6\n                x = parentof(x);                        // 情况6\n            } else {\n                if (colorof(leftof(sib)) == black) {\n                    setcolor(rightof(sib), black);      // 情况7\n                    setcolor(sib, red);                 // 情况7\n                    rotateleft(sib);                    // 情况7\n                    sib = leftof(parentof(x));          // 情况7\n                }\n                setcolor(sib, colorof(parentof(x)));    // 情况8\n                setcolor(parentof(x), black);           // 情况8\n                setcolor(leftof(sib), black);           // 情况8\n                rotateright(parentof(x));               // 情况8\n                x = root;                               // 情况8\n            }\n        }\n    }\n    setcolor(x, black);\n}\n\n\n\n# treeset\n\n前面已经说过treeset是对treemap的简单包装，对treeset的函数调用都会转换成合适的treemap方法，因此treeset的实现非常简单。这里不再赘述。\n\n// treeset是对treemap的简单包装\npublic class treeset<e> extends abstractset<e>\n    implements navigableset<e>, cloneable, java.io.serializable\n{\n......\n    private transient navigablemap<e,object> m;\n    // dummy value to associate with an object in the backing map\n    private static final object present = new object();\n    public treeset() {\n        this.m = new treemap<e,object>();// treeset里面有一个treemap\n    }\n    ......\n    public boolean add(e e) {\n        return m.put(e, present)==null;\n    }\n    ......\n}\n\n\n\n# 参考文章\n\n * 转载 https://www.pdai.tech/md/java/collection/java-map-treemap&treeset.html",charsets:{cjk:!0}},{title:"Map - LinkedHashSet&Map源码解析",frontmatter:{},regularPath:"/java/collection/java-map-LinkedHashMap&LinkedHashSet.html",relativePath:"java/collection/java-map-LinkedHashMap&LinkedHashSet.md",key:"v-6c3f60b6",path:"/java/collection/java-map-LinkedHashMap&LinkedHashSet.html",headers:[{level:2,title:"Map - LinkedHashSet&Map源码解析",slug:"map-linkedhashset-map源码解析",normalizedTitle:"map - linkedhashset&amp;map源码解析",charIndex:null},{level:2,title:"Java 7 - LinkedHashSet&Map",slug:"java-7-linkedhashset-map",normalizedTitle:"java 7 - linkedhashset&amp;map",charIndex:null},{level:3,title:"总体介绍",slug:"总体介绍",normalizedTitle:"总体介绍",charIndex:139},{level:3,title:"方法剖析",slug:"方法剖析",normalizedTitle:"方法剖析",charIndex:151},{level:3,title:"LinkedHashSet",slug:"linkedhashset",normalizedTitle:"linkedhashset",charIndex:8},{level:3,title:"LinkedHashMap经典用法",slug:"linkedhashmap经典用法",normalizedTitle:"linkedhashmap经典用法",charIndex:232},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:5566}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Map - LinkedHashSet&Map源码解析 Java 7 - LinkedHashSet&Map 总体介绍 方法剖析 LinkedHashSet LinkedHashMap经典用法 参考文章",content:"# Map - LinkedHashSet&Map源码解析\n\n> 本文主要对Map - LinkedHashSet&Map 源码解析。\n\n * Map - LinkedHashSet&Map源码解析\n   * Java 7 - LinkedHashSet&Map\n     * 总体介绍\n     * 方法剖析\n       * get()\n       * put()\n       * remove()\n     * LinkedHashSet\n     * LinkedHashMap经典用法\n\n\n# Java 7 - LinkedHashSet&Map\n\n\n# 总体介绍\n\n如果你已看过前面关于_HashSet_和_HashMap_，以及_TreeSet_和_TreeMap_的讲解，一定能够想到本文将要讲解的_LinkedHashSet_和_LinkedHashMap_其实也是一回事。LinkedHashSet_和_LinkedHashMap_在Java里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说LinkedHashSet里面有一个LinkedHashMap(适配器模式)。因此本文将重点分析_LinkedHashMap。\n\nLinkedHashMap_实现了_Map_接口，即允许放入key为null的元素，也允许插入value为null的元素。从名字上可以看出该容器是_linked list_和_HashMap_的混合体，也就是说它同时满足_HashMap_和_linked list_的某些特性。**可将_LinkedHashMap_看作采用_linked list_增强的_HashMap。**\n\n\n\n事实上_LinkedHashMap_是_HashMap_的直接子类，二者唯一的区别是_LinkedHashMap_在_HashMap_的基础上，采用双向链表(doubly-linked list)的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同。上图给出了_LinkedHashMap_的结构图，主体部分跟_HashMap_完全一样，多了header指向双向链表的头部(是一个哑元)，该双向链表的迭代顺序就是entry的插入顺序。\n\n除了可以保迭代历顺序，这种结构还有一个好处 : 迭代_LinkedHashMap_时不需要像_HashMap_那样遍历整个table，而只需要直接遍历header指向的双向链表即可，也就是说_LinkedHashMap_的迭代时间就只跟entry的个数相关，而跟table的大小无关。\n\n有两个参数可以影响_LinkedHashMap_的性能: 初始容量(inital capacity)和负载系数(load factor)。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过capacity*load_factor时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。\n\n将对象放入到_LinkedHashMap_或_LinkedHashSet_中时，有两个方法需要特别关心: hashCode()和equals()。hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到LinkedHashMap或LinkedHashSet中，需要@Override hashCode()和equals()方法。\n\n通过如下方式可以得到一个跟源_Map_ 迭代顺序一样的_LinkedHashMap_:\n\nvoid foo(Map m) {\n    Map copy = new LinkedHashMap(m);\n    ...\n}\n\n\n出于性能原因，_LinkedHashMap_是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将_LinkedHashMap_包装成(wrapped)同步的:\n\nMap m = Collections.synchronizedMap(new LinkedHashMap(...));\n\n\n# 方法剖析\n\n# get()\n\nget(Object key)方法根据指定的key值返回对应的value。该方法跟HashMap.get()方法的流程几乎完全一样，读者可自行参考前文在新窗口打开，这里不再赘述。\n\n# put()\n\nput(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于get()方法；如果没有找到，则会通过addEntry(int hash, K key, V value, int bucketIndex)方法插入新的entry。\n\n注意，这里的插入有两重含义:\n\n>  1. 从table的角度看，新的entry需要插入到对应的bucket里，当有哈希冲突时，采用头插法将新的entry插入到冲突链表的头部。\n>  2. 从header的角度看，新的entry需要插入到双向链表的尾部。\n\n\n\naddEntry()代码如下:\n\n// LinkedHashMap.addEntry()\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n    if ((size >= threshold) && (null != table[bucketIndex])) {\n        resize(2 * table.length);// 自动扩容，并重新哈希\n        hash = (null != key) ? hash(key) : 0;\n        bucketIndex = hash & (table.length-1);// hash%table.length\n    }\n    // 1.在冲突链表头部插入新的entry\n    HashMap.Entry<K,V> old = table[bucketIndex];\n    Entry<K,V> e = new Entry<>(hash, key, value, old);\n    table[bucketIndex] = e;\n    // 2.在双向链表的尾部插入新的entry\n    e.addBefore(header);\n    size++;\n}\n\n\n上述代码中用到了addBefore()方法将新entry e插入到双向链表头引用header的前面，这样e就成为双向链表中的最后一个元素。addBefore()的代码如下:\n\n// LinkedHashMap.Entry.addBefor()，将this插入到existingEntry的前面\nprivate void addBefore(Entry<K,V> existingEntry) {\n    after  = existingEntry;\n    before = existingEntry.before;\n    before.after = this;\n    after.before = this;\n}\n\n\n上述代码只是简单修改相关entry的引用而已。\n\n# remove()\n\nremove(Object key)的作用是删除key值对应的entry，该方法的具体逻辑是在removeEntryForKey(Object key)里实现的。removeEntryForKey()方法会首先找到key值对应的entry，然后删除该entry(修改链表的相应引用)。查找过程跟get()方法类似。\n\n注意，这里的删除也有两重含义:\n\n>  1. 从table的角度看，需要将该entry从对应的bucket里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。\n>  2. 从header的角度来看，需要将该entry从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。\n\n\n\nremoveEntryForKey()对应的代码如下:\n\n// LinkedHashMap.removeEntryForKey()，删除key值对应的entry\nfinal Entry<K,V> removeEntryForKey(Object key) {\n......\nint hash = (key == null) ? 0 : hash(key);\n    int i = indexFor(hash, table.length);// hash&(table.length-1)\n    Entry<K,V> prev = table[i];// 得到冲突链表\n    Entry<K,V> e = prev;\n    while (e != null) {// 遍历冲突链表\n        Entry<K,V> next = e.next;\n        Object k;\n        if (e.hash == hash &&\n            ((k = e.key) == key || (key != null && key.equals(k)))) {// 找到要删除的entry\n            modCount++; size--;\n            // 1. 将e从对应bucket的冲突链表中删除\n            if (prev == e) table[i] = next;\n            else prev.next = next;\n            // 2. 将e从双向链表中删除\n            e.before.after = e.after;\n            e.after.before = e.before;\n            return e;\n        }\n        prev = e; e = next;\n    }\n    return e;\n}\n\n\n\n# LinkedHashSet\n\n前面已经说过_LinkedHashSet_是对_LinkedHashMap_的简单包装，对_LinkedHashSet_的函数调用都会转换成合适的_LinkedHashMap_方法，因此_LinkedHashSet_的实现非常简单，这里不再赘述。\n\npublic class LinkedHashSet<E>\n    extends HashSet<E>\n    implements Set<E>, Cloneable, java.io.Serializable {\n    ......\n    // LinkedHashSet里面有一个LinkedHashMap\n    public LinkedHashSet(int initialCapacity, float loadFactor) {\n        map = new LinkedHashMap<>(initialCapacity, loadFactor);\n    }\n......\n    public boolean add(E e) {//简单的方法转换\n        return map.put(e, PRESENT)==null;\n    }\n    ......\n}\n\n\n\n# LinkedHashMap经典用法\n\n_LinkedHashMap_除了可以保证迭代顺序外，还有一个非常有用的用法: 可以轻松实现一个采用了FIFO替换策略的缓存。具体说来，LinkedHashMap有一个子类方法protected boolean removeEldestEntry(Map.Entry<K,V> eldest)，该方法的作用是告诉Map是否要删除“最老”的Entry，所谓最老就是当前Map中最早插入的Entry，如果该方法返回true，最老的那个元素就会被删除。在每次插入新元素的之后LinkedHashMap会自动询问removeEldestEntry()是否要删除最老的元素。这样只需要在子类中重载该方法，当元素个数超过一定数量时让removeEldestEntry()返回true，就能够实现一个固定大小的FIFO策略的缓存。示例代码如下:\n\n/** 一个固定大小的FIFO替换策略的缓存 */\nclass FIFOCache<K, V> extends LinkedHashMap<K, V>{\n    private final int cacheSize;\n    public FIFOCache(int cacheSize){\n        this.cacheSize = cacheSize;\n    }\n\n    // 当Entry个数超过cacheSize时，删除最老的Entry\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {\n       return size() > cacheSize;\n    }\n}\n\n\n\n# 参考文章\n\n * 转载 https://www.pdai.tech/md/java/collection/java-map-LinkedHashMap&LinkedHashSet.html",normalizedContent:"# map - linkedhashset&map源码解析\n\n> 本文主要对map - linkedhashset&map 源码解析。\n\n * map - linkedhashset&map源码解析\n   * java 7 - linkedhashset&map\n     * 总体介绍\n     * 方法剖析\n       * get()\n       * put()\n       * remove()\n     * linkedhashset\n     * linkedhashmap经典用法\n\n\n# java 7 - linkedhashset&map\n\n\n# 总体介绍\n\n如果你已看过前面关于_hashset_和_hashmap_，以及_treeset_和_treemap_的讲解，一定能够想到本文将要讲解的_linkedhashset_和_linkedhashmap_其实也是一回事。linkedhashset_和_linkedhashmap_在java里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说linkedhashset里面有一个linkedhashmap(适配器模式)。因此本文将重点分析_linkedhashmap。\n\nlinkedhashmap_实现了_map_接口，即允许放入key为null的元素，也允许插入value为null的元素。从名字上可以看出该容器是_linked list_和_hashmap_的混合体，也就是说它同时满足_hashmap_和_linked list_的某些特性。**可将_linkedhashmap_看作采用_linked list_增强的_hashmap。**\n\n\n\n事实上_linkedhashmap_是_hashmap_的直接子类，二者唯一的区别是_linkedhashmap_在_hashmap_的基础上，采用双向链表(doubly-linked list)的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同。上图给出了_linkedhashmap_的结构图，主体部分跟_hashmap_完全一样，多了header指向双向链表的头部(是一个哑元)，该双向链表的迭代顺序就是entry的插入顺序。\n\n除了可以保迭代历顺序，这种结构还有一个好处 : 迭代_linkedhashmap_时不需要像_hashmap_那样遍历整个table，而只需要直接遍历header指向的双向链表即可，也就是说_linkedhashmap_的迭代时间就只跟entry的个数相关，而跟table的大小无关。\n\n有两个参数可以影响_linkedhashmap_的性能: 初始容量(inital capacity)和负载系数(load factor)。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过capacity*load_factor时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。\n\n将对象放入到_linkedhashmap_或_linkedhashset_中时，有两个方法需要特别关心: hashcode()和equals()。hashcode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到linkedhashmap或linkedhashset中，需要@override hashcode()和equals()方法。\n\n通过如下方式可以得到一个跟源_map_ 迭代顺序一样的_linkedhashmap_:\n\nvoid foo(map m) {\n    map copy = new linkedhashmap(m);\n    ...\n}\n\n\n出于性能原因，_linkedhashmap_是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将_linkedhashmap_包装成(wrapped)同步的:\n\nmap m = collections.synchronizedmap(new linkedhashmap(...));\n\n\n# 方法剖析\n\n# get()\n\nget(object key)方法根据指定的key值返回对应的value。该方法跟hashmap.get()方法的流程几乎完全一样，读者可自行参考前文在新窗口打开，这里不再赘述。\n\n# put()\n\nput(k key, v value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于get()方法；如果没有找到，则会通过addentry(int hash, k key, v value, int bucketindex)方法插入新的entry。\n\n注意，这里的插入有两重含义:\n\n>  1. 从table的角度看，新的entry需要插入到对应的bucket里，当有哈希冲突时，采用头插法将新的entry插入到冲突链表的头部。\n>  2. 从header的角度看，新的entry需要插入到双向链表的尾部。\n\n\n\naddentry()代码如下:\n\n// linkedhashmap.addentry()\nvoid addentry(int hash, k key, v value, int bucketindex) {\n    if ((size >= threshold) && (null != table[bucketindex])) {\n        resize(2 * table.length);// 自动扩容，并重新哈希\n        hash = (null != key) ? hash(key) : 0;\n        bucketindex = hash & (table.length-1);// hash%table.length\n    }\n    // 1.在冲突链表头部插入新的entry\n    hashmap.entry<k,v> old = table[bucketindex];\n    entry<k,v> e = new entry<>(hash, key, value, old);\n    table[bucketindex] = e;\n    // 2.在双向链表的尾部插入新的entry\n    e.addbefore(header);\n    size++;\n}\n\n\n上述代码中用到了addbefore()方法将新entry e插入到双向链表头引用header的前面，这样e就成为双向链表中的最后一个元素。addbefore()的代码如下:\n\n// linkedhashmap.entry.addbefor()，将this插入到existingentry的前面\nprivate void addbefore(entry<k,v> existingentry) {\n    after  = existingentry;\n    before = existingentry.before;\n    before.after = this;\n    after.before = this;\n}\n\n\n上述代码只是简单修改相关entry的引用而已。\n\n# remove()\n\nremove(object key)的作用是删除key值对应的entry，该方法的具体逻辑是在removeentryforkey(object key)里实现的。removeentryforkey()方法会首先找到key值对应的entry，然后删除该entry(修改链表的相应引用)。查找过程跟get()方法类似。\n\n注意，这里的删除也有两重含义:\n\n>  1. 从table的角度看，需要将该entry从对应的bucket里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。\n>  2. 从header的角度来看，需要将该entry从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。\n\n\n\nremoveentryforkey()对应的代码如下:\n\n// linkedhashmap.removeentryforkey()，删除key值对应的entry\nfinal entry<k,v> removeentryforkey(object key) {\n......\nint hash = (key == null) ? 0 : hash(key);\n    int i = indexfor(hash, table.length);// hash&(table.length-1)\n    entry<k,v> prev = table[i];// 得到冲突链表\n    entry<k,v> e = prev;\n    while (e != null) {// 遍历冲突链表\n        entry<k,v> next = e.next;\n        object k;\n        if (e.hash == hash &&\n            ((k = e.key) == key || (key != null && key.equals(k)))) {// 找到要删除的entry\n            modcount++; size--;\n            // 1. 将e从对应bucket的冲突链表中删除\n            if (prev == e) table[i] = next;\n            else prev.next = next;\n            // 2. 将e从双向链表中删除\n            e.before.after = e.after;\n            e.after.before = e.before;\n            return e;\n        }\n        prev = e; e = next;\n    }\n    return e;\n}\n\n\n\n# linkedhashset\n\n前面已经说过_linkedhashset_是对_linkedhashmap_的简单包装，对_linkedhashset_的函数调用都会转换成合适的_linkedhashmap_方法，因此_linkedhashset_的实现非常简单，这里不再赘述。\n\npublic class linkedhashset<e>\n    extends hashset<e>\n    implements set<e>, cloneable, java.io.serializable {\n    ......\n    // linkedhashset里面有一个linkedhashmap\n    public linkedhashset(int initialcapacity, float loadfactor) {\n        map = new linkedhashmap<>(initialcapacity, loadfactor);\n    }\n......\n    public boolean add(e e) {//简单的方法转换\n        return map.put(e, present)==null;\n    }\n    ......\n}\n\n\n\n# linkedhashmap经典用法\n\n_linkedhashmap_除了可以保证迭代顺序外，还有一个非常有用的用法: 可以轻松实现一个采用了fifo替换策略的缓存。具体说来，linkedhashmap有一个子类方法protected boolean removeeldestentry(map.entry<k,v> eldest)，该方法的作用是告诉map是否要删除“最老”的entry，所谓最老就是当前map中最早插入的entry，如果该方法返回true，最老的那个元素就会被删除。在每次插入新元素的之后linkedhashmap会自动询问removeeldestentry()是否要删除最老的元素。这样只需要在子类中重载该方法，当元素个数超过一定数量时让removeeldestentry()返回true，就能够实现一个固定大小的fifo策略的缓存。示例代码如下:\n\n/** 一个固定大小的fifo替换策略的缓存 */\nclass fifocache<k, v> extends linkedhashmap<k, v>{\n    private final int cachesize;\n    public fifocache(int cachesize){\n        this.cachesize = cachesize;\n    }\n\n    // 当entry个数超过cachesize时，删除最老的entry\n    @override\n    protected boolean removeeldestentry(map.entry<k,v> eldest) {\n       return size() > cachesize;\n    }\n}\n\n\n\n# 参考文章\n\n * 转载 https://www.pdai.tech/md/java/collection/java-map-linkedhashmap&linkedhashset.html",charsets:{cjk:!0}},{title:"Map - WeakHashMap源码解析",frontmatter:{},regularPath:"/java/collection/java-map-WeakHashMap.html",relativePath:"java/collection/java-map-WeakHashMap.md",key:"v-7b44edde",path:"/java/collection/java-map-WeakHashMap.html",headers:[{level:2,title:"Map - WeakHashMap源码解析",slug:"map-weakhashmap源码解析",normalizedTitle:"map - weakhashmap源码解析",charIndex:2},{level:2,title:"Java 7- WeakHashMap",slug:"java-7-weakhashmap",normalizedTitle:"java 7- weakhashmap",charIndex:91},{level:3,title:"总体介绍",slug:"总体介绍",normalizedTitle:"总体介绍",charIndex:118},{level:3,title:"具体实现",slug:"具体实现",normalizedTitle:"具体实现",charIndex:130},{level:3,title:"Weak HashSet?",slug:"weak-hashset",normalizedTitle:"weak hashset?",charIndex:142},{level:3,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:163}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Map - WeakHashMap源码解析 Java 7- WeakHashMap 总体介绍 具体实现 Weak HashSet? 参考文章",content:'# Map - WeakHashMap源码解析\n\n> 本文主要对Map - WeakHashMap源码解析 源码解析。\n\n * Map - WeakHashMap源码解析\n   * Java 7- WeakHashMap\n     * 总体介绍\n     * 具体实现\n     * Weak HashSet?\n     * 参考文章\n\n\n# Java 7- WeakHashMap\n\n\n# 总体介绍\n\n在Java集合框架系列文章的最后，笔者打算介绍一个特殊的成员: WeakHashMap，从名字可以看出它是某种 Map。它的特殊之处在于 WeakHashMap 里的entry可能会被GC自动删除，即使程序员没有调用remove()或者clear()方法。\n\n更直观的说，当使用 WeakHashMap 时，即使没有显示的添加或删除任何元素，也可能发生如下情况:\n\n>  * 调用两次size()方法返回不同的值；\n>  * 两次调用isEmpty()方法，第一次返回false，第二次返回true；\n>  * 两次调用containsKey()方法，第一次返回true，第二次返回false，尽管两次使用的是同一个key；\n>  * 两次调用get()方法，第一次返回一个value，第二次返回null，尽管两次使用的是同一个对象。\n\n遇到这么奇葩的现象，你是不是觉得使用者一定会疯掉? 其实不然，WeakHashMap 的这个特点特别适用于需要缓存的场景。在缓存场景下，由于内存是有限的，不能缓存所有对象；对象缓存命中可以提高系统效率，但缓存MISS也不会造成错误，因为可以通过计算重新得到。\n\n要明白 WeakHashMap 的工作原理，还需要引入一个概念 : 弱引用(WeakReference)。我们都知道Java中内存是通过GC自动管理的，GC会在程序运行过程中自动判断哪些对象是可以被回收的，并在合适的时机进行内存释放。GC判断某个对象是否可被回收的依据是，是否有有效的引用指向该对象。如果没有有效引用指向该对象(基本意味着不存在访问该对象的方式)，那么该对象就是可回收的。这里的有效引用 并不包括弱引用。也就是说，虽然弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收。\n\nWeakHashMap 内部是通过弱引用来管理entry的，弱引用的特性对应到 WeakHashMap 上意味着什么呢？将一对key, value放入到 WeakHashMap 里并不能避免该key值被GC回收，除非在 WeakHashMap 之外还有对该key的强引用。\n\n关于强引用，弱引用等概念以后再具体讲解，这里只需要知道Java中引用也是分种类的，并且不同种类的引用对GC的影响不同就够了。\n\n\n# 具体实现\n\nWeakHashMap的存储结构类似于Map - HashSet & HashMap 源码解析，这里不再赘述。\n\n关于强弱引用的管理方式，博主将会另开专题单独讲解。\n\n\n# Weak HashSet?\n\n如果你看过前几篇关于 Map 和 Set 的讲解，一定会问: 既然有 WeakHashMap，是否有 WeekHashSet 呢? 答案是没有:( 。不过Java _Collections_工具类给出了解决方案，Collections.newSetFromMap(Map<E,Boolean> map)方法可以将任何 Map_包装成一个_Set。通过如下方式可以快速得到一个 Weak HashSet:\n\n// 将WeakHashMap包装成一个Set\nSet<Object> weakHashSet = Collections.newSetFromMap(\n        new WeakHashMap<Object, Boolean>());\n\n\n不出你所料，newSetFromMap()方法只是对传入的 _Map_做了简单包装:\n\n// Collections.newSetFromMap()用于将任何Map包装成一个Set\npublic static <E> Set<E> newSetFromMap(Map<E, Boolean> map) {\n    return new SetFromMap<>(map);\n}\n\nprivate static class SetFromMap<E> extends AbstractSet<E>\n    implements Set<E>, Serializable\n{\n    private final Map<E, Boolean> m;  // The backing map\n    private transient Set<E> s;       // Its keySet\n    SetFromMap(Map<E, Boolean> map) {\n        if (!map.isEmpty())\n            throw new IllegalArgumentException("Map is non-empty");\n        m = map;\n        s = map.keySet();\n    }\n    public void clear()               {        m.clear(); }\n    public int size()                 { return m.size(); }\n    public boolean isEmpty()          { return m.isEmpty(); }\n    public boolean contains(Object o) { return m.containsKey(o); }\n    public boolean remove(Object o)   { return m.remove(o) != null; }\n    public boolean add(E e) { return m.put(e, Boolean.TRUE) == null; }\n    public Iterator<E> iterator()     { return s.iterator(); }\n    public Object[] toArray()         { return s.toArray(); }\n    public <T> T[] toArray(T[] a)     { return s.toArray(a); }\n    public String toString()          { return s.toString(); }\n    public int hashCode()             { return s.hashCode(); }\n    public boolean equals(Object o)   { return o == this || s.equals(o); }\n    public boolean containsAll(Collection<?> c) {return s.containsAll(c);}\n    public boolean removeAll(Collection<?> c)   {return s.removeAll(c);}\n    public boolean retainAll(Collection<?> c)   {return s.retainAll(c);}\n    // addAll is the only inherited implementation\n    ......\n}\n\n\n\n\n# 参考文章\n\n * 浅谈WeakHashMap https://www.cnblogs.com/CarpenterLee/p/5544598.html\n * 转载 https://www.pdai.tech/md/java/collection/java-map-WeakHashMap.html',normalizedContent:'# map - weakhashmap源码解析\n\n> 本文主要对map - weakhashmap源码解析 源码解析。\n\n * map - weakhashmap源码解析\n   * java 7- weakhashmap\n     * 总体介绍\n     * 具体实现\n     * weak hashset?\n     * 参考文章\n\n\n# java 7- weakhashmap\n\n\n# 总体介绍\n\n在java集合框架系列文章的最后，笔者打算介绍一个特殊的成员: weakhashmap，从名字可以看出它是某种 map。它的特殊之处在于 weakhashmap 里的entry可能会被gc自动删除，即使程序员没有调用remove()或者clear()方法。\n\n更直观的说，当使用 weakhashmap 时，即使没有显示的添加或删除任何元素，也可能发生如下情况:\n\n>  * 调用两次size()方法返回不同的值；\n>  * 两次调用isempty()方法，第一次返回false，第二次返回true；\n>  * 两次调用containskey()方法，第一次返回true，第二次返回false，尽管两次使用的是同一个key；\n>  * 两次调用get()方法，第一次返回一个value，第二次返回null，尽管两次使用的是同一个对象。\n\n遇到这么奇葩的现象，你是不是觉得使用者一定会疯掉? 其实不然，weakhashmap 的这个特点特别适用于需要缓存的场景。在缓存场景下，由于内存是有限的，不能缓存所有对象；对象缓存命中可以提高系统效率，但缓存miss也不会造成错误，因为可以通过计算重新得到。\n\n要明白 weakhashmap 的工作原理，还需要引入一个概念 : 弱引用(weakreference)。我们都知道java中内存是通过gc自动管理的，gc会在程序运行过程中自动判断哪些对象是可以被回收的，并在合适的时机进行内存释放。gc判断某个对象是否可被回收的依据是，是否有有效的引用指向该对象。如果没有有效引用指向该对象(基本意味着不存在访问该对象的方式)，那么该对象就是可回收的。这里的有效引用 并不包括弱引用。也就是说，虽然弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被gc回收。\n\nweakhashmap 内部是通过弱引用来管理entry的，弱引用的特性对应到 weakhashmap 上意味着什么呢？将一对key, value放入到 weakhashmap 里并不能避免该key值被gc回收，除非在 weakhashmap 之外还有对该key的强引用。\n\n关于强引用，弱引用等概念以后再具体讲解，这里只需要知道java中引用也是分种类的，并且不同种类的引用对gc的影响不同就够了。\n\n\n# 具体实现\n\nweakhashmap的存储结构类似于map - hashset & hashmap 源码解析，这里不再赘述。\n\n关于强弱引用的管理方式，博主将会另开专题单独讲解。\n\n\n# weak hashset?\n\n如果你看过前几篇关于 map 和 set 的讲解，一定会问: 既然有 weakhashmap，是否有 weekhashset 呢? 答案是没有:( 。不过java _collections_工具类给出了解决方案，collections.newsetfrommap(map<e,boolean> map)方法可以将任何 map_包装成一个_set。通过如下方式可以快速得到一个 weak hashset:\n\n// 将weakhashmap包装成一个set\nset<object> weakhashset = collections.newsetfrommap(\n        new weakhashmap<object, boolean>());\n\n\n不出你所料，newsetfrommap()方法只是对传入的 _map_做了简单包装:\n\n// collections.newsetfrommap()用于将任何map包装成一个set\npublic static <e> set<e> newsetfrommap(map<e, boolean> map) {\n    return new setfrommap<>(map);\n}\n\nprivate static class setfrommap<e> extends abstractset<e>\n    implements set<e>, serializable\n{\n    private final map<e, boolean> m;  // the backing map\n    private transient set<e> s;       // its keyset\n    setfrommap(map<e, boolean> map) {\n        if (!map.isempty())\n            throw new illegalargumentexception("map is non-empty");\n        m = map;\n        s = map.keyset();\n    }\n    public void clear()               {        m.clear(); }\n    public int size()                 { return m.size(); }\n    public boolean isempty()          { return m.isempty(); }\n    public boolean contains(object o) { return m.containskey(o); }\n    public boolean remove(object o)   { return m.remove(o) != null; }\n    public boolean add(e e) { return m.put(e, boolean.true) == null; }\n    public iterator<e> iterator()     { return s.iterator(); }\n    public object[] toarray()         { return s.toarray(); }\n    public <t> t[] toarray(t[] a)     { return s.toarray(a); }\n    public string tostring()          { return s.tostring(); }\n    public int hashcode()             { return s.hashcode(); }\n    public boolean equals(object o)   { return o == this || s.equals(o); }\n    public boolean containsall(collection<?> c) {return s.containsall(c);}\n    public boolean removeall(collection<?> c)   {return s.removeall(c);}\n    public boolean retainall(collection<?> c)   {return s.retainall(c);}\n    // addall is the only inherited implementation\n    ......\n}\n\n\n\n\n# 参考文章\n\n * 浅谈weakhashmap https://www.cnblogs.com/carpenterlee/p/5544598.html\n * 转载 https://www.pdai.tech/md/java/collection/java-map-weakhashmap.html',charsets:{cjk:!0}},{title:"Java AIO - 异步IO详解",frontmatter:{},regularPath:"/java/io/java-io-aio.html",relativePath:"java/io/java-io-aio.md",key:"v-3d73bcce",path:"/java/io/java-io-aio.html",headers:[{level:2,title:"Java AIO - 异步IO详解",slug:"java-aio-异步io详解",normalizedTitle:"java aio - 异步io详解",charIndex:2},{level:2,title:"异步IO",slug:"异步io",normalizedTitle:"异步io",charIndex:13},{level:2,title:"JAVA对AIO的支持",slug:"java对aio的支持",normalizedTitle:"java对aio的支持",charIndex:91},{level:3,title:"JAVA AIO框架简析",slug:"java-aio框架简析",normalizedTitle:"java aio框架简析",charIndex:110},{level:3,title:"代码实例",slug:"代码实例",normalizedTitle:"代码实例",charIndex:130},{level:3,title:"要点讲解",slug:"要点讲解",normalizedTitle:"要点讲解",charIndex:142},{level:3,title:"还有改进可能",slug:"还有改进可能",normalizedTitle:"还有改进可能",charIndex:154},{level:2,title:"为什么还有Netty",slug:"为什么还有netty",normalizedTitle:"为什么还有netty",charIndex:166},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:182}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java AIO - 异步IO详解 异步IO JAVA对AIO的支持 JAVA AIO框架简析 代码实例 要点讲解 还有改进可能 为什么还有Netty 参考文章",content:'# Java AIO - 异步IO详解\n\n> 本文主要对异步IO和Java中对AIO的支持详解。@pdai\n\n * Java AIO - 异步IO详解\n   * 异步IO\n   * JAVA对AIO的支持\n     * JAVA AIO框架简析\n     * 代码实例\n     * 要点讲解\n     * 还有改进可能\n   * 为什么还有Netty\n   * 参考文章\n\n\n# 异步IO\n\n上面两篇文章中，我们分别讲解了阻塞式同步IO、非阻塞式同步IO、多路复用IO 这三种IO模型，以及JAVA对于这三种IO模型的支持。重点说明了IO模型是由操作系统提供支持，且这三种IO模型都是同步IO，都是采用的“应用程序不询问我，我绝不会主动通知”的方式。\n\n异步IO则是采用“订阅-通知”模式: 即应用程序向操作系统注册IO监听，然后继续做自己的事情。当操作系统发生IO事件，并且准备好数据后，在主动通知应用程序，触发相应的函数:\n\n\n\n和同步IO一样，异步IO也是由操作系统进行支持的。微软的windows系统提供了一种异步IO技术: IOCP(I/O Completion Port，I/O完成端口)；\n\nLinux下由于没有这种异步IO技术，所以使用的是epoll(上文介绍过的一种多路复用IO技术的实现)对异步IO进行模拟。\n\n\n# JAVA对AIO的支持\n\n\n# JAVA AIO框架简析\n\n\n\n这里通过这个结构分析要告诉各位读者JAVA AIO中类设计和操作系统的相关性\n\n在文中我们一再说明JAVA AIO框架在windows下使用windows IOCP技术，在Linux下使用epoll多路复用IO技术模拟异步IO，这个从JAVA AIO框架的部分类设计上就可以看出来。例如框架中，在Windows下负责实现套接字通道的具体类是“sun.nio.ch.WindowsAsynchronousSocketChannelImpl”，其引用的IOCP类型文档注释如是:\n\n/** \n* Windows implementation of AsynchronousChannelGroup encapsulating an I/O \n* completion port. \n*/\n\n\n如果您感兴趣，当然可以去看看全部完整代码(建议从“java.nio.channels.spi.AsynchronousChannelProvider”这个类看起)。\n\n特别说明一下，请注意图中的“java.nio.channels.NetworkChannel”接口，这个接口同样被JAVA NIO框架实现了，如下图所示:\n\n\n\n\n# 代码实例\n\n下面，我们通过一个代码示例，来讲解JAVA AIO框架的具体使用，先上代码，在针对代码编写和运行中的要点进行讲解:\n\npackage testASocket;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.AsynchronousChannelGroup;\nimport java.nio.channels.AsynchronousServerSocketChannel;\nimport java.nio.channels.AsynchronousSocketChannel;\nimport java.nio.channels.CompletionHandler;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.log4j.BasicConfigurator;\n\n/**\n * @author yinwenjie\n */\npublic class SocketServer {\n\n    static {\n        BasicConfigurator.configure();\n    }\n\n    private static final Object waitObject = new Object();\n\n    /**\n     * @param args\n     * @throws Exception\n     */\n    public static void main(String[] args) throws Exception {\n        /*\n         * 对于使用的线程池技术，我一定要多说几句\n         * 1、Executors是线程池生成工具，通过这个工具我们可以很轻松的生成“固定大小的线程池”、“调度池”、“可伸缩线程数量的池”。具体请看API Doc\n         * 2、当然您也可以通过ThreadPoolExecutor直接生成池。\n         * 3、这个线程池是用来得到操作系统的“IO事件通知”的，不是用来进行“得到IO数据后的业务处理的”。要进行后者的操作，您可以再使用一个池(最好不要混用)\n         * 4、您也可以不使用线程池(不推荐)，如果决定不使用线程池，直接AsynchronousServerSocketChannel.open()就行了。\n         * */\n        ExecutorService threadPool = Executors.newFixedThreadPool(20);\n        AsynchronousChannelGroup group = AsynchronousChannelGroup.withThreadPool(threadPool);\n        final AsynchronousServerSocketChannel serverSocket = AsynchronousServerSocketChannel.open(group);\n\n        //设置要监听的端口“0.0.0.0”代表本机所有IP设备\n        serverSocket.bind(new InetSocketAddress("0.0.0.0", 83));\n        //为AsynchronousServerSocketChannel注册监听，注意只是为AsynchronousServerSocketChannel通道注册监听\n        //并不包括为 随后客户端和服务器 socketchannel通道注册的监听\n        serverSocket.accept(null, new ServerSocketChannelHandle(serverSocket));\n\n        //等待，以便观察现象(这个和要讲解的原理本身没有任何关系，只是为了保证守护线程不会退出)\n        synchronized(waitObject) {\n            waitObject.wait();\n        }\n    }\n}\n\n/**\n * 这个处理器类，专门用来响应 ServerSocketChannel 的事件。\n * @author yinwenjie\n */\nclass ServerSocketChannelHandle implements CompletionHandler<AsynchronousSocketChannel, Void> {\n    /**\n     * 日志\n     */\n    private static final Log LOGGER = LogFactory.getLog(ServerSocketChannelHandle.class);\n\n    private AsynchronousServerSocketChannel serverSocketChannel;\n\n    /**\n     * @param serverSocketChannel\n     */\n    public ServerSocketChannelHandle(AsynchronousServerSocketChannel serverSocketChannel) {\n        this.serverSocketChannel = serverSocketChannel;\n    }\n\n    /**\n     * 注意，我们分别观察 this、socketChannel、attachment三个对象的id。\n     * 来观察不同客户端连接到达时，这三个对象的变化，以说明ServerSocketChannelHandle的监听模式\n     */\n    @Override\n    public void completed(AsynchronousSocketChannel socketChannel, Void attachment) {\n        ServerSocketChannelHandle.LOGGER.info("completed(AsynchronousSocketChannel result, ByteBuffer attachment)");\n        //每次都要重新注册监听(一次注册，一次响应)，但是由于“文件状态标示符”是独享的，所以不需要担心有“漏掉的”事件\n        this.serverSocketChannel.accept(attachment, this);\n\n        //为这个新的socketChannel注册“read”事件，以便操作系统在收到数据并准备好后，主动通知应用程序\n        //在这里，由于我们要将这个客户端多次传输的数据累加起来一起处理，所以我们将一个stringbuffer对象作为一个“附件”依附在这个channel上\n        //\n        ByteBuffer readBuffer = ByteBuffer.allocate(50);\n        socketChannel.read(readBuffer, new StringBuffer(), new SocketChannelReadHandle(socketChannel , readBuffer));\n    }\n\n    /* (non-Javadoc)\n     * @see java.nio.channels.CompletionHandler#failed(java.lang.Throwable, java.lang.Object)\n     */\n    @Override\n    public void failed(Throwable exc, Void attachment) {\n        ServerSocketChannelHandle.LOGGER.info("failed(Throwable exc, ByteBuffer attachment)");\n    }\n}\n\n/**\n * 负责对每一个socketChannel的数据获取事件进行监听。<p>\n * \n * 重要的说明: 一个socketchannel都会有一个独立工作的SocketChannelReadHandle对象(CompletionHandler接口的实现)，\n * 其中又都将独享一个“文件状态标示”对象FileDescriptor、\n * 一个独立的由程序员定义的Buffer缓存(这里我们使用的是ByteBuffer)、\n * 所以不用担心在服务器端会出现“窜对象”这种情况，因为JAVA AIO框架已经帮您组织好了。<p>\n * \n * 但是最重要的，用于生成channel的对象: AsynchronousChannelProvider是单例模式，无论在哪组socketchannel，\n * 对是一个对象引用(但这没关系，因为您不会直接操作这个AsynchronousChannelProvider对象)。\n * @author yinwenjie\n */\nclass SocketChannelReadHandle implements CompletionHandler<Integer, StringBuffer> {\n    /**\n     * 日志\n     */\n    private static final Log LOGGER = LogFactory.getLog(SocketChannelReadHandle.class);\n\n    private AsynchronousSocketChannel socketChannel;\n\n    /**\n     * 专门用于进行这个通道数据缓存操作的ByteBuffer<br>\n     * 当然，您也可以作为CompletionHandler的attachment形式传入。<br>\n     * 这是，在这段示例代码中，attachment被我们用来记录所有传送过来的Stringbuffer了。\n     */\n    private ByteBuffer byteBuffer;\n\n    public SocketChannelReadHandle(AsynchronousSocketChannel socketChannel , ByteBuffer byteBuffer) {\n        this.socketChannel = socketChannel;\n        this.byteBuffer = byteBuffer;\n    }\n\n    /* (non-Javadoc)\n     * @see java.nio.channels.CompletionHandler#completed(java.lang.Object, java.lang.Object)\n     */\n    @Override\n    public void completed(Integer result, StringBuffer historyContext) {\n        //如果条件成立，说明客户端主动终止了TCP套接字，这时服务端终止就可以了\n        if(result == -1) {\n            try {\n                this.socketChannel.close();\n            } catch (IOException e) {\n                SocketChannelReadHandle.LOGGER.error(e);\n            }\n            return;\n        }\n\n        SocketChannelReadHandle.LOGGER.info("completed(Integer result, Void attachment) : 然后我们来取出通道中准备好的值");\n        /*\n         * 实际上，由于我们从Integer result知道了本次channel从操作系统获取数据总长度\n         * 所以实际上，我们不需要切换成“读模式”的，但是为了保证编码的规范性，还是建议进行切换。\n         * \n         * 另外，无论是JAVA AIO框架还是JAVA NIO框架，都会出现“buffer的总容量”小于“当前从操作系统获取到的总数据量”，\n         * 但区别是，JAVA AIO框架中，我们不需要专门考虑处理这样的情况，因为JAVA AIO框架已经帮我们做了处理(做成了多次通知)\n         * */\n        this.byteBuffer.flip();\n        byte[] contexts = new byte[1024];\n        this.byteBuffer.get(contexts, 0, result);\n        this.byteBuffer.clear();\n        try {\n            String nowContent = new String(contexts , 0 , result , "UTF-8");\n            historyContext.append(nowContent);\n            SocketChannelReadHandle.LOGGER.info("================目前的传输结果: " + historyContext);\n        } catch (UnsupportedEncodingException e) {\n            SocketChannelReadHandle.LOGGER.error(e);\n        }\n\n        //如果条件成立，说明还没有接收到“结束标记”\n        if(historyContext.indexOf("over") == -1) {\n            return;\n        }\n\n        //=========================================================================\n        //          和上篇文章的代码相同，我们以“over”符号作为客户端完整信息的标记\n        //=========================================================================\n        SocketChannelReadHandle.LOGGER.info("=======收到完整信息，开始处理业务=========");\n        historyContext = new StringBuffer();\n\n        //还要继续监听(一次监听一次通知)\n        this.socketChannel.read(this.byteBuffer, historyContext, this);\n    }\n\n    /* (non-Javadoc)\n     * @see java.nio.channels.CompletionHandler#failed(java.lang.Throwable, java.lang.Object)\n     */\n    @Override\n    public void failed(Throwable exc, StringBuffer historyContext) {\n        SocketChannelReadHandle.LOGGER.info("=====发现客户端异常关闭，服务器将关闭TCP通道");\n        try {\n            this.socketChannel.close();\n        } catch (IOException e) {\n            SocketChannelReadHandle.LOGGER.error(e);\n        }\n    }\n}\n\n\n\n# 要点讲解\n\n注意在JAVA NIO框架中，我们说到了一个重要概念“selector”(选择器)。它负责代替应用查询中所有已注册的通道到操作系统中进行IO事件轮询、管理当前注册的通道集合，定位发生事件的通道等操操作；但是在JAVA AIO框架中，由于应用程序不是“轮询”方式，而是订阅-通知方式，所以不再需要“selector”(选择器)了，改由channel通道直接到操作系统注册监听。\n\nJAVA AIO框架中，只实现了两种网络IO通道“AsynchronousServerSocketChannel”(服务器监听通道)、“AsynchronousSocketChannel”(socket套接字通道)。但是无论哪种通道他们都有独立的fileDescriptor(文件标识符)、attachment(附件，附件可以使任意对象，类似“通道上下文”)，并被独立的SocketChannelReadHandle类实例引用。我们通过debug操作来看看它们的引用结构:\n\n在测试过程中，我们启动了两个客户端(客户端用什么语言来写都行，用阻塞或者非阻塞方式也都行，只要是支持 TCP Socket套接字的就行，然后我们观察服务器端对这两个客户端通道的处理情况:\n\n\n\n可以看到，在服务器端分别为客户端1和客户端2创建的两个WindowsAsynchronousSocketChannelImpl对象为:\n\n\n\n客户端1: WindowsAsynchronousSocketChannelImpl: 760 | FileDescriptor: 762\n\n客户端2: WindowsAsynchronousSocketChannelImpl: 792 | FileDescriptor: 797\n\n接下来，我们让两个客户端发送信息到服务器端，并观察服务器端的处理情况。客户端1发来的消息和客户端2发来的消息，在服务器端的处理情况如下图所示:\n\n\n\n客户端1: WindowsAsynchronousSocketChannelImpl: 760 | FileDescriptor: 762 | SocketChannelReadHandle: 803 | HeapByteBuffer: 808\n\n客户端2: WindowsAsynchronousSocketChannelImpl: 792 | FileDescriptor: 797 | SocketChannelReadHandle: 828 | HeapByteBuffer: 833\n\n可以明显看到，服务器端处理每一个客户端通道所使用的SocketChannelReadHandle(处理器)对象都是独立的，并且所引用的SocketChannel对象都是独立的。\n\nJAVA NIO和JAVA AIO框架，除了因为操作系统的实现不一样而去掉了Selector外，其他的重要概念都是存在的，例如上文中提到的Channel的概念，还有演示代码中使用的Buffer缓存方式。实际上JAVA NIO和JAVA AIO框架您可以看成是一套完整的“高并发IO处理”的实现。\n\n\n# 还有改进可能\n\n当然，以上代码是示例代码，目标是为了让您了解JAVA AIO框架的基本使用。所以它还有很多改造的空间，例如:\n\n在生产环境下，我们需要记录这个通道上“用户的登录信息”。那么这个需求可以使用JAVA AIO中的“附件”功能进行实现。\n\n记住JAVA AIO 和 JAVA NIO 框架都是要使用线程池的(当然您也可以不用)，线程池的使用原则，一定是只有业务处理部分才使用，使用后马上结束线程的执行(还回线程池或者消灭它)。JAVA AIO框架中还有一个线程池，是拿给“通知处理器”使用的，这是因为JAVA AIO框架是基于“订阅-通知”模型的，“订阅”操作可以由主线程完成，但是您总不能要求在应用程序中并发的“通知”操作也在主线程上完成吧_。\n\n最好的改进方式，当然就是使用Netty或者Mina咯。\n\n\n# 为什么还有Netty\n\n * 那么有的读者可能就会问，既然JAVA NIO / JAVA AIO已经实现了各主流操作系统的底层支持，那么为什么现在主流的JAVA NIO技术会是Netty和MINA呢? 答案很简单: 因为更好用，这里举几个方面的例子:\n\n * 虽然JAVA NIO 和 JAVA AIO框架提供了 多路复用IO/异步IO的支持，但是并没有提供上层“信息格式”的良好封装。例如前两者并没有提供针对 Protocol Buffer、JSON这些信息格式的封装，但是Netty框架提供了这些数据格式封装(基于责任链模式的编码和解码功能)\n\n * 要编写一个可靠的、易维护的、高性能的(注意它们的排序)NIO/AIO 服务器应用。除了框架本身要兼容实现各类操作系统的实现外。更重要的是它应该还要处理很多上层特有服务，例如: 客户端的权限、还有上面提到的信息格式封装、简单的数据读取。这些Netty框架都提供了响应的支持。\n\n * JAVA NIO框架存在一个poll/epoll bug: Selector doesn’t block on Selector.select(timeout)，不能block意味着CPU的使用率会变成100%(这是底层JNI的问题，上层要处理这个异常实际上也好办)。当然这个bug只有在Linux内核上才能重现。\n\n * 这个问题在JDK 1.7版本中还没有被完全解决: http://bugs.java.com/bugdatabase/view_bug.do?bug_id=2147719。虽然Netty 4.0中也是基于JAVA NIO框架进行封装的(上文中已经给出了Netty中NioServerSocketChannel类的介绍)，但是Netty已经将这个bug进行了处理。\n\n * 其他原因，用过Netty后，您就可以自己进行比较了。\n\n\n# 参考文章\n\n * 文章主要来源于: 银文杰，笔名“说好不能打脸”，博客地址在新窗口打开。他的书《高性能服务系统构建与实战》。\n * https://blog.csdn.net/yinwenjie/article/details/48784375',normalizedContent:'# java aio - 异步io详解\n\n> 本文主要对异步io和java中对aio的支持详解。@pdai\n\n * java aio - 异步io详解\n   * 异步io\n   * java对aio的支持\n     * java aio框架简析\n     * 代码实例\n     * 要点讲解\n     * 还有改进可能\n   * 为什么还有netty\n   * 参考文章\n\n\n# 异步io\n\n上面两篇文章中，我们分别讲解了阻塞式同步io、非阻塞式同步io、多路复用io 这三种io模型，以及java对于这三种io模型的支持。重点说明了io模型是由操作系统提供支持，且这三种io模型都是同步io，都是采用的“应用程序不询问我，我绝不会主动通知”的方式。\n\n异步io则是采用“订阅-通知”模式: 即应用程序向操作系统注册io监听，然后继续做自己的事情。当操作系统发生io事件，并且准备好数据后，在主动通知应用程序，触发相应的函数:\n\n\n\n和同步io一样，异步io也是由操作系统进行支持的。微软的windows系统提供了一种异步io技术: iocp(i/o completion port，i/o完成端口)；\n\nlinux下由于没有这种异步io技术，所以使用的是epoll(上文介绍过的一种多路复用io技术的实现)对异步io进行模拟。\n\n\n# java对aio的支持\n\n\n# java aio框架简析\n\n\n\n这里通过这个结构分析要告诉各位读者java aio中类设计和操作系统的相关性\n\n在文中我们一再说明java aio框架在windows下使用windows iocp技术，在linux下使用epoll多路复用io技术模拟异步io，这个从java aio框架的部分类设计上就可以看出来。例如框架中，在windows下负责实现套接字通道的具体类是“sun.nio.ch.windowsasynchronoussocketchannelimpl”，其引用的iocp类型文档注释如是:\n\n/** \n* windows implementation of asynchronouschannelgroup encapsulating an i/o \n* completion port. \n*/\n\n\n如果您感兴趣，当然可以去看看全部完整代码(建议从“java.nio.channels.spi.asynchronouschannelprovider”这个类看起)。\n\n特别说明一下，请注意图中的“java.nio.channels.networkchannel”接口，这个接口同样被java nio框架实现了，如下图所示:\n\n\n\n\n# 代码实例\n\n下面，我们通过一个代码示例，来讲解java aio框架的具体使用，先上代码，在针对代码编写和运行中的要点进行讲解:\n\npackage testasocket;\n\nimport java.io.ioexception;\nimport java.io.unsupportedencodingexception;\nimport java.net.inetsocketaddress;\nimport java.nio.bytebuffer;\nimport java.nio.channels.asynchronouschannelgroup;\nimport java.nio.channels.asynchronousserversocketchannel;\nimport java.nio.channels.asynchronoussocketchannel;\nimport java.nio.channels.completionhandler;\nimport java.util.concurrent.executorservice;\nimport java.util.concurrent.executors;\n\nimport org.apache.commons.logging.log;\nimport org.apache.commons.logging.logfactory;\nimport org.apache.log4j.basicconfigurator;\n\n/**\n * @author yinwenjie\n */\npublic class socketserver {\n\n    static {\n        basicconfigurator.configure();\n    }\n\n    private static final object waitobject = new object();\n\n    /**\n     * @param args\n     * @throws exception\n     */\n    public static void main(string[] args) throws exception {\n        /*\n         * 对于使用的线程池技术，我一定要多说几句\n         * 1、executors是线程池生成工具，通过这个工具我们可以很轻松的生成“固定大小的线程池”、“调度池”、“可伸缩线程数量的池”。具体请看api doc\n         * 2、当然您也可以通过threadpoolexecutor直接生成池。\n         * 3、这个线程池是用来得到操作系统的“io事件通知”的，不是用来进行“得到io数据后的业务处理的”。要进行后者的操作，您可以再使用一个池(最好不要混用)\n         * 4、您也可以不使用线程池(不推荐)，如果决定不使用线程池，直接asynchronousserversocketchannel.open()就行了。\n         * */\n        executorservice threadpool = executors.newfixedthreadpool(20);\n        asynchronouschannelgroup group = asynchronouschannelgroup.withthreadpool(threadpool);\n        final asynchronousserversocketchannel serversocket = asynchronousserversocketchannel.open(group);\n\n        //设置要监听的端口“0.0.0.0”代表本机所有ip设备\n        serversocket.bind(new inetsocketaddress("0.0.0.0", 83));\n        //为asynchronousserversocketchannel注册监听，注意只是为asynchronousserversocketchannel通道注册监听\n        //并不包括为 随后客户端和服务器 socketchannel通道注册的监听\n        serversocket.accept(null, new serversocketchannelhandle(serversocket));\n\n        //等待，以便观察现象(这个和要讲解的原理本身没有任何关系，只是为了保证守护线程不会退出)\n        synchronized(waitobject) {\n            waitobject.wait();\n        }\n    }\n}\n\n/**\n * 这个处理器类，专门用来响应 serversocketchannel 的事件。\n * @author yinwenjie\n */\nclass serversocketchannelhandle implements completionhandler<asynchronoussocketchannel, void> {\n    /**\n     * 日志\n     */\n    private static final log logger = logfactory.getlog(serversocketchannelhandle.class);\n\n    private asynchronousserversocketchannel serversocketchannel;\n\n    /**\n     * @param serversocketchannel\n     */\n    public serversocketchannelhandle(asynchronousserversocketchannel serversocketchannel) {\n        this.serversocketchannel = serversocketchannel;\n    }\n\n    /**\n     * 注意，我们分别观察 this、socketchannel、attachment三个对象的id。\n     * 来观察不同客户端连接到达时，这三个对象的变化，以说明serversocketchannelhandle的监听模式\n     */\n    @override\n    public void completed(asynchronoussocketchannel socketchannel, void attachment) {\n        serversocketchannelhandle.logger.info("completed(asynchronoussocketchannel result, bytebuffer attachment)");\n        //每次都要重新注册监听(一次注册，一次响应)，但是由于“文件状态标示符”是独享的，所以不需要担心有“漏掉的”事件\n        this.serversocketchannel.accept(attachment, this);\n\n        //为这个新的socketchannel注册“read”事件，以便操作系统在收到数据并准备好后，主动通知应用程序\n        //在这里，由于我们要将这个客户端多次传输的数据累加起来一起处理，所以我们将一个stringbuffer对象作为一个“附件”依附在这个channel上\n        //\n        bytebuffer readbuffer = bytebuffer.allocate(50);\n        socketchannel.read(readbuffer, new stringbuffer(), new socketchannelreadhandle(socketchannel , readbuffer));\n    }\n\n    /* (non-javadoc)\n     * @see java.nio.channels.completionhandler#failed(java.lang.throwable, java.lang.object)\n     */\n    @override\n    public void failed(throwable exc, void attachment) {\n        serversocketchannelhandle.logger.info("failed(throwable exc, bytebuffer attachment)");\n    }\n}\n\n/**\n * 负责对每一个socketchannel的数据获取事件进行监听。<p>\n * \n * 重要的说明: 一个socketchannel都会有一个独立工作的socketchannelreadhandle对象(completionhandler接口的实现)，\n * 其中又都将独享一个“文件状态标示”对象filedescriptor、\n * 一个独立的由程序员定义的buffer缓存(这里我们使用的是bytebuffer)、\n * 所以不用担心在服务器端会出现“窜对象”这种情况，因为java aio框架已经帮您组织好了。<p>\n * \n * 但是最重要的，用于生成channel的对象: asynchronouschannelprovider是单例模式，无论在哪组socketchannel，\n * 对是一个对象引用(但这没关系，因为您不会直接操作这个asynchronouschannelprovider对象)。\n * @author yinwenjie\n */\nclass socketchannelreadhandle implements completionhandler<integer, stringbuffer> {\n    /**\n     * 日志\n     */\n    private static final log logger = logfactory.getlog(socketchannelreadhandle.class);\n\n    private asynchronoussocketchannel socketchannel;\n\n    /**\n     * 专门用于进行这个通道数据缓存操作的bytebuffer<br>\n     * 当然，您也可以作为completionhandler的attachment形式传入。<br>\n     * 这是，在这段示例代码中，attachment被我们用来记录所有传送过来的stringbuffer了。\n     */\n    private bytebuffer bytebuffer;\n\n    public socketchannelreadhandle(asynchronoussocketchannel socketchannel , bytebuffer bytebuffer) {\n        this.socketchannel = socketchannel;\n        this.bytebuffer = bytebuffer;\n    }\n\n    /* (non-javadoc)\n     * @see java.nio.channels.completionhandler#completed(java.lang.object, java.lang.object)\n     */\n    @override\n    public void completed(integer result, stringbuffer historycontext) {\n        //如果条件成立，说明客户端主动终止了tcp套接字，这时服务端终止就可以了\n        if(result == -1) {\n            try {\n                this.socketchannel.close();\n            } catch (ioexception e) {\n                socketchannelreadhandle.logger.error(e);\n            }\n            return;\n        }\n\n        socketchannelreadhandle.logger.info("completed(integer result, void attachment) : 然后我们来取出通道中准备好的值");\n        /*\n         * 实际上，由于我们从integer result知道了本次channel从操作系统获取数据总长度\n         * 所以实际上，我们不需要切换成“读模式”的，但是为了保证编码的规范性，还是建议进行切换。\n         * \n         * 另外，无论是java aio框架还是java nio框架，都会出现“buffer的总容量”小于“当前从操作系统获取到的总数据量”，\n         * 但区别是，java aio框架中，我们不需要专门考虑处理这样的情况，因为java aio框架已经帮我们做了处理(做成了多次通知)\n         * */\n        this.bytebuffer.flip();\n        byte[] contexts = new byte[1024];\n        this.bytebuffer.get(contexts, 0, result);\n        this.bytebuffer.clear();\n        try {\n            string nowcontent = new string(contexts , 0 , result , "utf-8");\n            historycontext.append(nowcontent);\n            socketchannelreadhandle.logger.info("================目前的传输结果: " + historycontext);\n        } catch (unsupportedencodingexception e) {\n            socketchannelreadhandle.logger.error(e);\n        }\n\n        //如果条件成立，说明还没有接收到“结束标记”\n        if(historycontext.indexof("over") == -1) {\n            return;\n        }\n\n        //=========================================================================\n        //          和上篇文章的代码相同，我们以“over”符号作为客户端完整信息的标记\n        //=========================================================================\n        socketchannelreadhandle.logger.info("=======收到完整信息，开始处理业务=========");\n        historycontext = new stringbuffer();\n\n        //还要继续监听(一次监听一次通知)\n        this.socketchannel.read(this.bytebuffer, historycontext, this);\n    }\n\n    /* (non-javadoc)\n     * @see java.nio.channels.completionhandler#failed(java.lang.throwable, java.lang.object)\n     */\n    @override\n    public void failed(throwable exc, stringbuffer historycontext) {\n        socketchannelreadhandle.logger.info("=====发现客户端异常关闭，服务器将关闭tcp通道");\n        try {\n            this.socketchannel.close();\n        } catch (ioexception e) {\n            socketchannelreadhandle.logger.error(e);\n        }\n    }\n}\n\n\n\n# 要点讲解\n\n注意在java nio框架中，我们说到了一个重要概念“selector”(选择器)。它负责代替应用查询中所有已注册的通道到操作系统中进行io事件轮询、管理当前注册的通道集合，定位发生事件的通道等操操作；但是在java aio框架中，由于应用程序不是“轮询”方式，而是订阅-通知方式，所以不再需要“selector”(选择器)了，改由channel通道直接到操作系统注册监听。\n\njava aio框架中，只实现了两种网络io通道“asynchronousserversocketchannel”(服务器监听通道)、“asynchronoussocketchannel”(socket套接字通道)。但是无论哪种通道他们都有独立的filedescriptor(文件标识符)、attachment(附件，附件可以使任意对象，类似“通道上下文”)，并被独立的socketchannelreadhandle类实例引用。我们通过debug操作来看看它们的引用结构:\n\n在测试过程中，我们启动了两个客户端(客户端用什么语言来写都行，用阻塞或者非阻塞方式也都行，只要是支持 tcp socket套接字的就行，然后我们观察服务器端对这两个客户端通道的处理情况:\n\n\n\n可以看到，在服务器端分别为客户端1和客户端2创建的两个windowsasynchronoussocketchannelimpl对象为:\n\n\n\n客户端1: windowsasynchronoussocketchannelimpl: 760 | filedescriptor: 762\n\n客户端2: windowsasynchronoussocketchannelimpl: 792 | filedescriptor: 797\n\n接下来，我们让两个客户端发送信息到服务器端，并观察服务器端的处理情况。客户端1发来的消息和客户端2发来的消息，在服务器端的处理情况如下图所示:\n\n\n\n客户端1: windowsasynchronoussocketchannelimpl: 760 | filedescriptor: 762 | socketchannelreadhandle: 803 | heapbytebuffer: 808\n\n客户端2: windowsasynchronoussocketchannelimpl: 792 | filedescriptor: 797 | socketchannelreadhandle: 828 | heapbytebuffer: 833\n\n可以明显看到，服务器端处理每一个客户端通道所使用的socketchannelreadhandle(处理器)对象都是独立的，并且所引用的socketchannel对象都是独立的。\n\njava nio和java aio框架，除了因为操作系统的实现不一样而去掉了selector外，其他的重要概念都是存在的，例如上文中提到的channel的概念，还有演示代码中使用的buffer缓存方式。实际上java nio和java aio框架您可以看成是一套完整的“高并发io处理”的实现。\n\n\n# 还有改进可能\n\n当然，以上代码是示例代码，目标是为了让您了解java aio框架的基本使用。所以它还有很多改造的空间，例如:\n\n在生产环境下，我们需要记录这个通道上“用户的登录信息”。那么这个需求可以使用java aio中的“附件”功能进行实现。\n\n记住java aio 和 java nio 框架都是要使用线程池的(当然您也可以不用)，线程池的使用原则，一定是只有业务处理部分才使用，使用后马上结束线程的执行(还回线程池或者消灭它)。java aio框架中还有一个线程池，是拿给“通知处理器”使用的，这是因为java aio框架是基于“订阅-通知”模型的，“订阅”操作可以由主线程完成，但是您总不能要求在应用程序中并发的“通知”操作也在主线程上完成吧_。\n\n最好的改进方式，当然就是使用netty或者mina咯。\n\n\n# 为什么还有netty\n\n * 那么有的读者可能就会问，既然java nio / java aio已经实现了各主流操作系统的底层支持，那么为什么现在主流的java nio技术会是netty和mina呢? 答案很简单: 因为更好用，这里举几个方面的例子:\n\n * 虽然java nio 和 java aio框架提供了 多路复用io/异步io的支持，但是并没有提供上层“信息格式”的良好封装。例如前两者并没有提供针对 protocol buffer、json这些信息格式的封装，但是netty框架提供了这些数据格式封装(基于责任链模式的编码和解码功能)\n\n * 要编写一个可靠的、易维护的、高性能的(注意它们的排序)nio/aio 服务器应用。除了框架本身要兼容实现各类操作系统的实现外。更重要的是它应该还要处理很多上层特有服务，例如: 客户端的权限、还有上面提到的信息格式封装、简单的数据读取。这些netty框架都提供了响应的支持。\n\n * java nio框架存在一个poll/epoll bug: selector doesn’t block on selector.select(timeout)，不能block意味着cpu的使用率会变成100%(这是底层jni的问题，上层要处理这个异常实际上也好办)。当然这个bug只有在linux内核上才能重现。\n\n * 这个问题在jdk 1.7版本中还没有被完全解决: http://bugs.java.com/bugdatabase/view_bug.do?bug_id=2147719。虽然netty 4.0中也是基于java nio框架进行封装的(上文中已经给出了netty中nioserversocketchannel类的介绍)，但是netty已经将这个bug进行了处理。\n\n * 其他原因，用过netty后，您就可以自己进行比较了。\n\n\n# 参考文章\n\n * 文章主要来源于: 银文杰，笔名“说好不能打脸”，博客地址在新窗口打开。他的书《高性能服务系统构建与实战》。\n * https://blog.csdn.net/yinwenjie/article/details/48784375',charsets:{cjk:!0}},{title:"Java IO - 分类(传输，操作)",frontmatter:{},regularPath:"/java/io/java-io-basic-category.html",relativePath:"java/io/java-io-basic-category.md",key:"v-5764f320",path:"/java/io/java-io-basic-category.html",headers:[{level:2,title:"Java IO - 分类(传输，操作)",slug:"java-io-分类-传输-操作",normalizedTitle:"java io - 分类(传输，操作)",charIndex:2},{level:2,title:"IO理解分类 - 从传输方式上",slug:"io理解分类-从传输方式上",normalizedTitle:"io理解分类 - 从传输方式上",charIndex:91},{level:3,title:"字节流",slug:"字节流",normalizedTitle:"字节流",charIndex:114},{level:3,title:"字符流",slug:"字符流",normalizedTitle:"字符流",charIndex:125},{level:3,title:"字节流和字符流的区别",slug:"字节流和字符流的区别",normalizedTitle:"字节流和字符流的区别",charIndex:136},{level:3,title:"字节转字符Input/OutputStreamReader/Writer",slug:"字节转字符input-outputstreamreader-writer",normalizedTitle:"字节转字符input/outputstreamreader/writer",charIndex:154},{level:2,title:"IO理解分类 - 从数据操作上",slug:"io理解分类-从数据操作上",normalizedTitle:"io理解分类 - 从数据操作上",charIndex:196},{level:3,title:"文件(file)",slug:"文件-file",normalizedTitle:"文件(file)",charIndex:219},{level:3,title:"数组(\\[\\])",slug:"数组",normalizedTitle:"数组([])",charIndex:235},{level:3,title:"管道操作",slug:"管道操作",normalizedTitle:"管道操作",charIndex:249},{level:3,title:"基本数据类型",slug:"基本数据类型",normalizedTitle:"基本数据类型",charIndex:261},{level:3,title:"缓冲操作",slug:"缓冲操作",normalizedTitle:"缓冲操作",charIndex:275},{level:3,title:"打印",slug:"打印",normalizedTitle:"打印",charIndex:287},{level:3,title:"对象序列化反序列化",slug:"对象序列化反序列化",normalizedTitle:"对象序列化反序列化",charIndex:297},{level:3,title:"转换",slug:"转换",normalizedTitle:"转换",charIndex:314}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java IO - 分类(传输，操作) IO理解分类 - 从传输方式上 字节流 字符流 字节流和字符流的区别 字节转字符Input/OutputStreamReader/Writer IO理解分类 - 从数据操作上 文件(file) 数组(\\[\\]) 管道操作 基本数据类型 缓冲操作 打印 对象序列化反序列化 转换",content:"# Java IO - 分类(传输，操作)\n\n> 本文主要从传输方式和数据操作两个方面分析Java IO的分类。@pdai\n\n * Java IO - 分类(传输，操作)\n   * IO理解分类 - 从传输方式上\n     * 字节流\n     * 字符流\n     * 字节流和字符流的区别\n     * 字节转字符Input/OutputStreamReader/Writer\n   * IO理解分类 - 从数据操作上\n     * 文件(file)\n     * 数组([])\n     * 管道操作\n     * 基本数据类型\n     * 缓冲操作\n     * 打印\n     * 对象序列化反序列化\n     * 转换\n\n\n# IO理解分类 - 从传输方式上\n\n从数据传输方式或者说是运输方式角度看，可以将 IO 类分为:\n\n * 字节流\n * 字符流\n\n字节是个计算机看的，字符才是给人看的\n\n\n# 字节流\n\n(整体结构如下，部分派生类有缺失)\n\n\n\n\n# 字符流\n\n(整体结构如下，部分派生类有缺失)\n\n\n\n\n# 字节流和字符流的区别\n\n * 字节流读取单个字节，字符流读取单个字符(一个字符根据编码的不同，对应的字节也不同，如 UTF-8 编码中文汉字是 3 个字节，GBK编码中文汉字是 2 个字节。)\n * 字节流用来处理二进制文件(图片、MP3、视频文件)，字符流用来处理文本文件(可以看做是特殊的二进制文件，使用了某种编码，人可以阅读)。\n\n> 简而言之，字节是给计算机看的，字符才是给人看的。\n\n\n# 字节转字符Input/OutputStreamReader/Writer\n\n编码就是把字符转换为字节，而解码是把字节重新组合成字符。\n\n如果编码和解码过程使用不同的编码方式那么就出现了乱码。\n\n * GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；\n * UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；\n * UTF-16be 编码中，中文字符和英文字符都占 2 个字节。\n\nUTF-16be 中的 be 指的是 Big Endian，也就是大端。相应地也有 UTF-16le，le 指的是 Little Endian，也就是小端。\n\nJava 使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。\n\n\n\n\n# IO理解分类 - 从数据操作上\n\n从数据来源或者说是操作对象角度看，IO 类可以分为:\n\n\n\n\n# 文件(file)\n\nFileInputStream、FileOutputStream、FileReader、FileWriter\n\n\n# 数组([])\n\n * 字节数组(byte[]): ByteArrayInputStream、ByteArrayOutputStream\n * 字符数组(char[]): CharArrayReader、CharArrayWriter\n\n\n# 管道操作\n\nPipedInputStream、PipedOutputStream、PipedReader、PipedWriter\n\n\n# 基本数据类型\n\nDataInputStream、DataOutputStream\n\n\n# 缓冲操作\n\nBufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter\n\n\n# 打印\n\nPrintStream、PrintWriter\n\n\n# 对象序列化反序列化\n\nObjectInputStream、ObjectOutputStream\n\n\n# 转换\n\nInputStreamReader、OutputStreamWriter",normalizedContent:"# java io - 分类(传输，操作)\n\n> 本文主要从传输方式和数据操作两个方面分析java io的分类。@pdai\n\n * java io - 分类(传输，操作)\n   * io理解分类 - 从传输方式上\n     * 字节流\n     * 字符流\n     * 字节流和字符流的区别\n     * 字节转字符input/outputstreamreader/writer\n   * io理解分类 - 从数据操作上\n     * 文件(file)\n     * 数组([])\n     * 管道操作\n     * 基本数据类型\n     * 缓冲操作\n     * 打印\n     * 对象序列化反序列化\n     * 转换\n\n\n# io理解分类 - 从传输方式上\n\n从数据传输方式或者说是运输方式角度看，可以将 io 类分为:\n\n * 字节流\n * 字符流\n\n字节是个计算机看的，字符才是给人看的\n\n\n# 字节流\n\n(整体结构如下，部分派生类有缺失)\n\n\n\n\n# 字符流\n\n(整体结构如下，部分派生类有缺失)\n\n\n\n\n# 字节流和字符流的区别\n\n * 字节流读取单个字节，字符流读取单个字符(一个字符根据编码的不同，对应的字节也不同，如 utf-8 编码中文汉字是 3 个字节，gbk编码中文汉字是 2 个字节。)\n * 字节流用来处理二进制文件(图片、mp3、视频文件)，字符流用来处理文本文件(可以看做是特殊的二进制文件，使用了某种编码，人可以阅读)。\n\n> 简而言之，字节是给计算机看的，字符才是给人看的。\n\n\n# 字节转字符input/outputstreamreader/writer\n\n编码就是把字符转换为字节，而解码是把字节重新组合成字符。\n\n如果编码和解码过程使用不同的编码方式那么就出现了乱码。\n\n * gbk 编码中，中文字符占 2 个字节，英文字符占 1 个字节；\n * utf-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；\n * utf-16be 编码中，中文字符和英文字符都占 2 个字节。\n\nutf-16be 中的 be 指的是 big endian，也就是大端。相应地也有 utf-16le，le 指的是 little endian，也就是小端。\n\njava 使用双字节编码 utf-16be，这不是指 java 只支持这一种编码方式，而是说 char 这种类型使用 utf-16be 进行编码。char 类型占 16 位，也就是两个字节，java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。\n\n\n\n\n# io理解分类 - 从数据操作上\n\n从数据来源或者说是操作对象角度看，io 类可以分为:\n\n\n\n\n# 文件(file)\n\nfileinputstream、fileoutputstream、filereader、filewriter\n\n\n# 数组([])\n\n * 字节数组(byte[]): bytearrayinputstream、bytearrayoutputstream\n * 字符数组(char[]): chararrayreader、chararraywriter\n\n\n# 管道操作\n\npipedinputstream、pipedoutputstream、pipedreader、pipedwriter\n\n\n# 基本数据类型\n\ndatainputstream、dataoutputstream\n\n\n# 缓冲操作\n\nbufferedinputstream、bufferedoutputstream、bufferedreader、bufferedwriter\n\n\n# 打印\n\nprintstream、printwriter\n\n\n# 对象序列化反序列化\n\nobjectinputstream、objectoutputstream\n\n\n# 转换\n\ninputstreamreader、outputstreamwriter",charsets:{cjk:!0}},{title:"Java IO - 源码: InputStream",frontmatter:{},regularPath:"/java/io/java-io-basic-code-inputstream.html",relativePath:"java/io/java-io-basic-code-inputstream.md",key:"v-4eee7d98",path:"/java/io/java-io-basic-code-inputstream.html",headers:[{level:2,title:"Java IO - 源码: InputStream",slug:"java-io-源码-inputstream",normalizedTitle:"java io - 源码: inputstream",charIndex:2},{level:2,title:"InputStream 类实现关系",slug:"inputstream-类实现关系",normalizedTitle:"inputstream 类实现关系",charIndex:103},{level:2,title:"InputStream 抽象类",slug:"inputstream-抽象类",normalizedTitle:"inputstream 抽象类",charIndex:126},{level:2,title:"源码实现",slug:"源码实现",normalizedTitle:"源码实现",charIndex:147},{level:3,title:"InputStream",slug:"inputstream",normalizedTitle:"inputstream",charIndex:16},{level:3,title:"FilterInputStream",slug:"filterinputstream",normalizedTitle:"filterinputstream",charIndex:178},{level:3,title:"ByteArrayInputStream",slug:"bytearrayinputstream",normalizedTitle:"bytearrayinputstream",charIndex:203},{level:3,title:"BufferedInputStream",slug:"bufferedinputstream",normalizedTitle:"bufferedinputstream",charIndex:231},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:256}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java IO - 源码: InputStream InputStream 类实现关系 InputStream 抽象类 源码实现 InputStream FilterInputStream ByteArrayInputStream BufferedInputStream 参考文章",content:'# Java IO - 源码: InputStream\n\n> 本文主要从JDK 11 源码角度分析InputStream。 @pdai\n\n * Java IO - 源码: InputStream\n   * InputStream 类实现关系\n   * InputStream 抽象类\n   * 源码实现\n     * InputStream\n     * FilterInputStream\n     * ByteArrayInputStream\n     * BufferedInputStream\n   * 参考文章\n\n\n# InputStream 类实现关系\n\n> InputStream是输入字节流，具体的实现类层次结构如下：\n\n\n\n\n# InputStream 抽象类\n\nInputStream 类重要方法设计如下：\n\n// 读取下一个字节，如果没有则返回-1\npublic abstract int read() \n\n// 将读取到的数据放在 byte 数组中，该方法实际上调用read(byte b[], int off, int len)方法\npublic int read(byte b[]) \n\n// 从第 off 位置读取<b>最多(实际可能小于)</b> len 长度字节的数据放到 byte 数组中，流是以 -1 来判断是否读取结束的; 此方法会一直阻止，直到输入数据可用、检测到stream结尾或引发异常为止。\npublic int read(byte b[], int off, int len) \n\n// JDK9新增：读取 InputStream 中的所有剩余字节，调用readNBytes(Integer.MAX_VALUE)方法\npublic byte[] readAllBytes()\n\n// JDK11更新：读取 InputStream 中的剩余字节的指定上限大小的字节内容；此方法会一直阻塞，直到读取了请求的字节数、检测到流结束或引发异常为止。此方法不会关闭输入流。\npublic byte[] readNBytes(int len)\n\n// JDK9新增：从输入流读取请求的字节数并保存在byte数组中； 此方法会一直阻塞，直到读取了请求的字节数、检测到流结束或引发异常为止。此方法不会关闭输入流。\npublic int readNBytes(byte[] b, int off, int len)\n\n// 跳过指定个数的字节不读取\npublic long skip(long n) \n\n// 返回可读的字节数量\npublic int available() \n\n// 读取完，关闭流，释放资源\npublic void close() \n\n// 标记读取位置，下次还可以从这里开始读取，使用前要看当前流是否支持，可以使用 markSupport() 方法判断\npublic synchronized void mark(int readlimit) \n\n// 重置读取位置为上次 mark 标记的位置\npublic synchronized void reset() \n\n// 判断当前流是否支持标记流，和上面两个方法配套使用\npublic boolean markSupported() \n\n// JDK9新增：读取 InputStream 中的全部字节并写入到指定的 OutputStream 中\npublic long transferTo(OutputStream out)\n\n\n\n\n# 源码实现\n\n> 梳理部分InputStream及其实现类的源码分析。\n\n\n# InputStream\n\nInputStream抽象类源码如下：\n\npublic abstract class InputStream implements Closeable {\n    \n    // 当使用skip方法时，最大的buffer size大小\n    private static final int MAX_SKIP_BUFFER_SIZE = 2048;\n\n    // 默认的buffer size\n    private static final int DEFAULT_BUFFER_SIZE = 8192;\n\n    // JDK11中增加了一个nullInputStream，即空模式实现，以便可以直接调用而不用判空（可以看如下的补充说明）\n    public static InputStream nullInputStream() {\n        return new InputStream() {\n            private volatile boolean closed;\n\n            private void ensureOpen() throws IOException {\n                if (closed) {\n                    throw new IOException("Stream closed");\n                }\n            }\n\n            @Override\n            public int available () throws IOException {\n                ensureOpen();\n                return 0;\n            }\n\n            @Override\n            public int read() throws IOException {\n                ensureOpen();\n                return -1;\n            }\n\n            @Override\n            public int read(byte[] b, int off, int len) throws IOException {\n                Objects.checkFromIndexSize(off, len, b.length);\n                if (len == 0) {\n                    return 0;\n                }\n                ensureOpen();\n                return -1;\n            }\n\n            @Override\n            public byte[] readAllBytes() throws IOException {\n                ensureOpen();\n                return new byte[0];\n            }\n\n            @Override\n            public int readNBytes(byte[] b, int off, int len)\n                throws IOException {\n                Objects.checkFromIndexSize(off, len, b.length);\n                ensureOpen();\n                return 0;\n            }\n\n            @Override\n            public byte[] readNBytes(int len) throws IOException {\n                if (len < 0) {\n                    throw new IllegalArgumentException("len < 0");\n                }\n                ensureOpen();\n                return new byte[0];\n            }\n\n            @Override\n            public long skip(long n) throws IOException {\n                ensureOpen();\n                return 0L;\n            }\n\n            @Override\n            public long transferTo(OutputStream out) throws IOException {\n                Objects.requireNonNull(out);\n                ensureOpen();\n                return 0L;\n            }\n\n            @Override\n            public void close() throws IOException {\n                closed = true;\n            }\n        };\n    }\n    \n    // 读取下一个字节的数据，如果没有则返回-1\n    public abstract int read() throws IOException;\n\n    // 将读取到的数据放在 byte 数组中，该方法实际上调用read(byte b[], int off, int len)方法\n    public int read(byte b[]) throws IOException {\n        return read(b, 0, b.length);\n    }\n\n    // 从第 off 位置读取<b>最多(实际可能小于)</b> len 长度字节的数据放到 byte 数组中，流是以 -1 来判断是否读取结束的; 此方法会一直阻止，直到输入数据可用、检测到stream结尾或引发异常为止。\n    public int read(byte b[], int off, int len) throws IOException {\n        // 检查边界\n        Objects.checkFromIndexSize(off, len, b.length);\n        if (len == 0) {\n            return 0;\n        }\n\n        // 读取下一个字节\n        int c = read();\n        if (c == -1) { // 读到stream末尾，则返回读取的字节数量为-1\n            return -1;\n        }\n        b[off] = (byte)c;\n\n        // i用来记录取了多少个字节\n        int i = 1;\n        try {\n            // 循环读取\n            for (; i < len ; i++) {\n                c = read();\n                if (c == -1) {// 读到stream末尾，则break\n                    break;\n                }\n                b[off + i] = (byte)c;\n            }\n        } catch (IOException ee) {\n        }\n        // 返回读取到的字节个数\n        return i;\n    }\n\n    // 分配的最大数组大小。\n    // 由于一些VM在数组中保留一些头字，所以尝试分配较大的阵列可能会导致OutOfMemoryError（请求的阵列大小超过VM限制）\n    private static final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;\n\n    // JDK9新增：读取 InputStream 中的所有剩余字节，调用readNBytes(Integer.MAX_VALUE)方法\n    public byte[] readAllBytes() throws IOException {\n        return readNBytes(Integer.MAX_VALUE);\n    }\n\n    // JDK11更新：读取 InputStream 中的剩余字节的指定上限大小的字节内容；此方法会一直阻塞，直到读取了请求的字节数、检测到流结束或引发异常为止。此方法不会关闭输入流。\n    public byte[] readNBytes(int len) throws IOException {\n        // 边界检查\n        if (len < 0) {\n            throw new IllegalArgumentException("len < 0");\n        }\n\n        List<byte[]> bufs = null; // 缓存每次读取到的内容放到bufs，最后组装成result\n        byte[] result = null; // 最后读取到的内容\n        int total = 0;\n        int remaining = len; // 剩余字节长度\n        int n;\n        do {\n            byte[] buf = new byte[Math.min(remaining, DEFAULT_BUFFER_SIZE)];\n            int nread = 0;\n\n            // 读取到结束为止，读取大小n可能大于或小于缓冲区大小\n            while ((n = read(buf, nread,\n                    Math.min(buf.length - nread, remaining))) > 0) {\n                nread += n; \n                remaining -= n;\n            }\n\n            if (nread > 0) {\n                if (MAX_BUFFER_SIZE - total < nread) {\n                    throw new OutOfMemoryError("Required array size too large");\n                }\n                total += nread;\n                if (result == null) {\n                    result = buf;\n                } else {\n                    if (bufs == null) {\n                        bufs = new ArrayList<>();\n                        bufs.add(result);\n                    }\n                    bufs.add(buf);\n                }\n            }\n            // 如果读不到内容（返回-1）或者没有剩余的字节，则跳出循环\n        } while (n >= 0 && remaining > 0);\n\n        if (bufs == null) {\n            if (result == null) {\n                return new byte[0];\n            }\n            return result.length == total ?\n                result : Arrays.copyOf(result, total);\n        }\n\n        // 组装最后的result\n        result = new byte[total];\n        int offset = 0;\n        remaining = total;\n        for (byte[] b : bufs) {\n            int count = Math.min(b.length, remaining);\n            System.arraycopy(b, 0, result, offset, count);\n            offset += count;\n            remaining -= count;\n        }\n\n        return result;\n    }\n\n    // JDK9新增：从输入流读取请求的字节数并保存在byte数组中； 此方法会一直阻塞，直到读取了请求的字节数、检测到流结束或引发异常为止。此方法不会关闭输入流。\n    public int readNBytes(byte[] b, int off, int len) throws IOException {\n        Objects.checkFromIndexSize(off, len, b.length);\n\n        int n = 0;\n        while (n < len) {\n            int count = read(b, off + n, len - n);\n            if (count < 0)\n                break;\n            n += count;\n        }\n        return n;\n    }\n\n    // 跳过指定个数的字节不读取\n    public long skip(long n) throws IOException {\n\n        long remaining = n;\n        int nr;\n\n        if (n <= 0) {\n            return 0;\n        }\n\n        int size = (int)Math.min(MAX_SKIP_BUFFER_SIZE, remaining);\n        byte[] skipBuffer = new byte[size];\n        while (remaining > 0) {\n            nr = read(skipBuffer, 0, (int)Math.min(size, remaining));\n            if (nr < 0) {\n                break;\n            }\n            remaining -= nr;\n        }\n\n        return n - remaining;\n    }\n\n    // 返回可读的字节数量\n    public int available() throws IOException {\n        return 0;\n    }\n\n    // 读取完，关闭流，释放资源\n    public void close() throws IOException {}\n\n    // 标记读取位置，下次还可以从这里开始读取，使用前要看当前流是否支持，可以使用 markSupport() 方法判断\n    public synchronized void mark(int readlimit) {}\n\n    // 重置读取位置为上次 mark 标记的位置\n    public synchronized void reset() throws IOException {\n        throw new IOException("mark/reset not supported");\n    }\n\n    // 判断当前流是否支持标记流，和上面两个方法配套使用。默认是false，由子类方法重写\n    public boolean markSupported() {\n        return false;\n    }\n\n    // JDK9新增：读取 InputStream 中的全部字节并写入到指定的 OutputStream 中\n    public long transferTo(OutputStream out) throws IOException {\n        Objects.requireNonNull(out, "out");\n        long transferred = 0;\n        byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];\n        int read;\n        while ((read = this.read(buffer, 0, DEFAULT_BUFFER_SIZE)) >= 0) {\n            out.write(buffer, 0, read);\n            transferred += read;\n        }\n        return transferred;\n    }\n\n\n> 总结下JDK9的更新点\n\n类 java.io.InputStream 中增加了新的方法来读取和复制 InputStream 中包含的数据。\n\n * readAllBytes：读取 InputStream 中的所有剩余字节。\n * readNBytes： 从 InputStream 中读取指定数量的字节到数组中。\n * transferTo：读取 InputStream 中的全部字节并写入到指定的 OutputStream 中 。\n\npublic class TestInputStream {\n    private InputStream inputStream;\n    private static final String CONTENT = "Hello World";\n    @Before\n    public void setUp() throws Exception {\n        this.inputStream =\n            TestInputStream.class.getResourceAsStream("/input.txt");\n    }\n    @Test\n    public void testReadAllBytes() throws Exception {\n        final String content = new String(this.inputStream.readAllBytes());\n        assertEquals(CONTENT, content);\n    }\n    @Test\n    public void testReadNBytes() throws Exception {\n        final byte[] data = new byte[5];\n        this.inputStream.readNBytes(data, 0, 5);\n        assertEquals("Hello", new String(data));\n    }\n    @Test\n    public void testTransferTo() throws Exception {\n        final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        this.inputStream.transferTo(outputStream);\n        assertEquals(CONTENT, outputStream.toString());\n    }\n}\n\n\n * read(byte[], int, int) 和 readNBytes(byte[], int, int)看似是实现的相同功能，为何会设计readNBytes方法呢？\n\n这个问题可以参看这里在新窗口打开\n\n 1. read(byte[], int, int)是尝试读到最多len个bytes，但是读取到的内容长度可能是小于len的。\n 2. readNBytes(byte[], int, int) 会一直（while循环）查找直到stream尾为止\n\n举个例子：如果文本内容是12345<end>, read(s,0,10)是允许返回123的, 而readNbytes(s,0,10)会一直（while循环）查找直到stream尾为止，并返回12345.\n\n> 补充下JDK11为什么会增加nullInputStream方法的设计？即空对象模式\n\n * 空对象模式\n\n举个例子：\n\npublic class MyParser implements Parser {\n  private static Action NO_ACTION = new Action() {\n    public void doSomething() { /* do nothing */ }\n  };\n\n  public Action findAction(String userInput) {\n    // ...\n    if ( /* we can\'t find any actions */ ) {\n      return NO_ACTION;\n    }\n  }\n}\n\n\n然后便可以始终可以这么调用，而不用再判断空了\n\nParserFactory.getParser().findAction(someInput).doSomething();\n\n\n\n# FilterInputStream\n\nFilterInputStream 源码如下\n\npublic class FilterInputStream extends InputStream {\n    \n    // 被装饰的inputStream\n    protected volatile InputStream in;\n    \n    // 构造函数，注入被装饰的inputStream\n    protected FilterInputStream(InputStream in) {\n        this.in = in;\n    }\n\n    // 本质是调用被装饰的inputStream的方法\n    public int read() throws IOException {\n        return in.read();\n    }\n    public int read(byte b[]) throws IOException {\n        return read(b, 0, b.length);\n     }\n    public int read(byte b[], int off, int len) throws IOException {\n        return in.read(b, off, len);\n     }\n    public long skip(long n) throws IOException {\n        return in.skip(n);\n    }\n    public int available() throws IOException {\n        return in.available();\n    }\n    public void close() throws IOException {\n        in.close();\n    }\n    public synchronized void mark(int readlimit) {\n        in.mark(readlimit);\n     }\n    public synchronized void reset() throws IOException {\n        in.reset();\n    }\n    public boolean markSupported() {\n        return in.markSupported();\n    }\n}\n\n\n为什么被装饰的inputStream是volatile类型的？\n\n请参看： 关键字: volatile详解\n\n\n# ByteArrayInputStream\n\nByteArrayInputStream源码如下\n\npublic class ByteArrayInputStream extends InputStream {\n    \n    // 内部保存的byte 数组\n    protected byte buf[];\n    \n    // 读取下一个字节的数组下标，byte[pos]就是read获取的下个字节\n    protected int pos;\n    \n    // mark的数组下标位置\n    protected int mark = 0;\n    \n    // 保存的有效byte的个数\n    protected int count;\n\n    // 构造方法\n    public ByteArrayInputStream(byte buf[]) {\n        this.buf = buf;              \n        this.pos = 0;\n        this.count = buf.length;\n     }\n    \n    // 构造方法，带offset的\n     public ByteArrayInputStream(byte buf[], int offset, int length) {                \n        this.buf = buf;\n        this.pos = offset;\n        this.count = Math.min(offset + length, buf.length);\n        this.mark = offset;\n    }\n    \n    // 从流中读取下一个字节，没有读取到返回 -1\n    public synchronized int read() {\n        return (pos < count) ? (buf[pos++] & 0xff) : -1;\n    }\n    \n    // 从第 off 位置读取<b>最多(实际可能小于)</b> len 长度字节的数据放到 byte 数组中，流是以 -1 来判断是否读取结束的\n    public synchronized int read(byte b[], int off, int len) {\n        // 边界检查\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (off < 0 || len < 0 || len > b.length - off) {\n            throw new IndexOutOfBoundsException();\n        }\n\n        if (pos >= count) {\n            return -1;\n        }\n\n        int avail = count - pos;\n        if (len > avail) {\n            len = avail;\n        }\n        if (len <= 0) {\n            return 0;\n        }\n\n        // 从buf拷贝到byte 数组b中\n        System.arraycopy(buf, pos, b, off, len);\n        pos += len;\n        return len;\n    }\n\n    // 跳过指定个数的字节不读取\n    public synchronized long skip(long n) {\n        long k = count - pos;\n        if (n < k) {\n            k = n < 0 ? 0 : n;\n        }\n\n        pos += k;\n        return k;\n    }\n\n    // 还有稍稍byte在buffer中未读取，即总的count 减去 当前byte位置\n    public synchronized int available() {\n        return count - pos;\n    }\n\n    // 支持mark所以返回true\n    public boolean markSupported() { \n        return true;\n    }  \n\n    // 在流中当前位置mark, readAheadLimit参数未使用    \n    public void mark(int readAheadLimit) {            \n        mark = pos;\n    }\n\n    // 重置流，即回到mark的位置\n    public synchronized void reset() {\n        pos = mark;\n    }\n\n    // 关闭ByteArrayInputStream不会产生任何动作\n    public void close() throws IOException { \n\n    }\n}\n\n\n\n# BufferedInputStream\n\nBufferedInputStream源码如下\n\npublic class BufferedInputStream extends FilterInputStream {\n\n    // 默认的buffer大小\n    private static int DEFAULT_BUFFER_SIZE = 8192;\n\n    // 分配的最大数组大小。\n    // 由于一些VM在数组中保留一些头字，所以尝试分配较大的阵列可能会导致OutOfMemoryError（请求的阵列大小超过VM限制）\n    private static int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;\n\n    // 内部保存在byte 数组中\n    protected volatile byte buf[];\n\n    // 关闭流的方法可能是异步的，所以使用原子AtomicReferenceFieldUpdater提供CAS无锁方式（可以解决CAS的ABA问题）来保证\n    private static final AtomicReferenceFieldUpdater<BufferedInputStream, byte[]> bufUpdater =\n        AtomicReferenceFieldUpdater.newUpdater(BufferedInputStream.class,  byte[].class, "buf");\n\n    // 有效byte的大小\n    protected int count;\n\n    // 当前位置\n    protected int pos;\n\n    // 最后一次，调用mark方法，标记的位置\n    protected int markpos = -1;\n\n    /**\n     * 该变量惟一入口就是mark(int readLimit)，好比调用方法mark(1024)，那么后面读取的数据若是\n     * 超过了1024字节，那么这次mark就为无效标记，子类能够选择抛弃该mark标记，从头开始。不过具体实现\n     * 跟具体的子类有关，在BufferedInputStream中，会抛弃mark标记，从新将markpos赋值为-1\n     */\n    protected int marklimit;\n\n    // 获取被装饰的stream\n    private InputStream getInIfOpen() throws IOException {\n        InputStream input = in;\n        if (input == null)\n            throw new IOException("Stream closed");\n        return input;\n    }\n\n    // 获取实际内部的buffer数组\n    private byte[] getBufIfOpen() throws IOException {\n        byte[] buffer = buf;\n        if (buffer == null)\n            throw new IOException("Stream closed");\n        return buffer;\n    }\n\n    // 构造函数，buffer是8kb\n    public BufferedInputStream(InputStream in) {\n        this(in, DEFAULT_BUFFER_SIZE);\n    }\n\n    // 构造函数，指定buffer大小\n    public BufferedInputStream(InputStream in, int size) {\n        super(in);\n        if (size <= 0) {\n            throw new IllegalArgumentException("Buffer size <= 0");\n        }\n        buf = new byte[size];\n    }\n\n    /**\n     * 用更多的数据填充缓冲区,考虑到shuffling和其他处理标记的技巧，\n     * 假设它是由同步方法调用的。该方法还假设所有数据已经被读入，因此pos >count。\n     */\n    private void fill() throws IOException {\n    \t// 得到内部缓冲区buffer\n        byte[] buffer = getBufIfOpen();\n        // 没有mark的情况下， pos为0\n        if (markpos < 0)\n            pos = 0;            /* no mark: throw away the buffer */\n        // pos >= buffer.length  buffer已经被读取完了 \n        else if (pos >= buffer.length)  /* no room left in buffer */\n        \t// markpos > 0  有标记，标记处在缓存中间\n            if (markpos > 0) {  /* can throw away early part of the buffer */\n            \t// 把buffer中，markpos到pos的部分移动到0-sz处，pos设置为sz，markpos为0\n                int sz = pos - markpos;\n                System.arraycopy(buffer, markpos, buffer, 0, sz);\n                pos = sz;\n                markpos = 0;\n                // markpos已经为0了，marklimit比buffer.length小，再读取buffer已经没有地方了\n            } else if (buffer.length >= marklimit) {\n            \t// 清空缓存，清空标记，markpos为-1，pos为0\n                markpos = -1;   /* buffer got too big, invalidate mark */\n                pos = 0;        /* drop buffer contents */\n                // markpos已经为0了，marklimit比buffer.length大，而buffer.length已经最大了，不能扩容\n            } else if (buffer.length >= MAX_BUFFER_SIZE) {\n                throw new OutOfMemoryError("Required array size too large");\n               // markpos已经为0了，marklimit比buffer.length大\n            } else {            /* grow buffer */\n            \t// 建立一个长度为min(2*pos,marklimit,MAX_BUFFER_SIZE),的缓存数组，然后把原来0-pos移动到新数组的0-pos处\n                int nsz = (pos <= MAX_BUFFER_SIZE - pos) ?\n                        pos * 2 : MAX_BUFFER_SIZE;\n                if (nsz > marklimit)\n                    nsz = marklimit;\n                byte nbuf[] = new byte[nsz];\n                System.arraycopy(buffer, 0, nbuf, 0, pos);\n                // 用bufUpdater替换buffer\n                if (!bufUpdater.compareAndSet(this, buffer, nbuf)) {\n                    // Can\'t replace buf if there was an async close.\n                    // Note: This would need to be changed if fill()\n                    // is ever made accessible to multiple threads.\n                    // But for now, the only way CAS can fail is via close.\n                    // assert buf == null;\n                    throw new IOException("Stream closed");\n                }\n                buffer = nbuf;\n            }\n        // 当前读取上限count为pos\n        count = pos;\n        // 从内部的输入流，读取pos到buffer.length部分，读取的字节数加到count\n        int n = getInIfOpen().read(buffer, pos, buffer.length - pos);\n        if (n > 0)\n            count = n + pos;\n    }\n\n    // 读取byte\n    public synchronized int read() throws IOException {\n        // 说明当前buf[]数组大小不够了，须要fill()\n        if (pos >= count) {\n            fill();\n            // 说明没有读取到任何数据\n            if (pos >= count)\n                return -1;\n        }\n        return getBufIfOpen()[pos++] & 0xff;\n    }\n\n    /**\n     * Read characters into a portion of an array, reading from the underlying\n     * stream at most once if necessary.\n     */\n    private int read1(byte[] b, int off, int len) throws IOException {\n        int avail = count - pos;\n        if (avail <= 0) {\n            // 当写入指定数组b的长度大小超过BufferedInputStream中核心缓存数组buf[]的大小而且 markpos < 0，那么就直接从数据流中读取数据给b数组，而不经过buf[]缓存数组，避免buf[]数组急剧增大\n            if (len >= getBufIfOpen().length && markpos < 0) {\n                return getInIfOpen().read(b, off, len);\n            }\n            fill();\n            avail = count - pos;\n            if (avail <= 0) return -1;\n        }\n        int cnt = (avail < len) ? avail : len;\n        System.arraycopy(getBufIfOpen(), pos, b, off, cnt);\n        pos += cnt;\n        return cnt;\n    }\n\n    // 读取到byte数组b中\n    public synchronized int read(byte b[], int off, int len)\n        throws IOException\n    {\n        getBufIfOpen(); // Check for closed stream\n        if ((off | len | (off + len) | (b.length - (off + len))) < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        }\n\n        int n = 0;\n        for (;;) {\n            int nread = read1(b, off + n, len - n);\n            if (nread <= 0)\n                return (n == 0) ? nread : n;\n            n += nread;\n            if (n >= len)\n                return n;\n            // if not closed but no bytes available, return\n            InputStream input = in;\n            if (input != null && input.available() <= 0)\n                return n;\n        }\n    }\n\n    // 跳过n个\n    public synchronized long skip(long n) throws IOException {\n        getBufIfOpen(); // Check for closed stream\n        if (n <= 0) {\n            return 0;\n        }\n        long avail = count - pos;\n\n        if (avail <= 0) {\n            // If no mark position set then don\'t keep in buffer\n            if (markpos <0)\n                return getInIfOpen().skip(n);\n\n            // Fill in buffer to save bytes for reset\n            fill();\n            avail = count - pos;\n            if (avail <= 0)\n                return 0;\n        }\n\n        long skipped = (avail < n) ? avail : n;\n        pos += skipped;\n        return skipped;\n    }\n\n    // buf[]数组剩余字节数+输入流中剩余字节数\n    public synchronized int available() throws IOException {\n        int n = count - pos;\n        int avail = getInIfOpen().available();\n        return n > (Integer.MAX_VALUE - avail)\n                    ? Integer.MAX_VALUE\n                    : n + avail;\n    }\n\n    \n    // 标记位置，marklimit只有在这里才可以被赋值，readlimit表示mark()方法执行后，最多可以从流中读取的数据\n    // 若是超过该字节大小，那么在fill()的时候，就会认为此mark()标记无效，从新将 markpos = -1，pos = 0\n    public synchronized void mark(int readlimit) {\n        marklimit = readlimit;\n        markpos = pos;\n    }\n\n    // 重置位置\n    public synchronized void reset() throws IOException {\n        getBufIfOpen(); // 如果已经close, 则直接报错\n        if (markpos < 0)\n            throw new IOException("Resetting to invalid mark");\n        pos = markpos;\n    }\n\n    // 支持mark, 所以返回true\n    public boolean markSupported() {\n        return true;\n    }\n\n    // 通过AtomicReferenceFieldUpdater的CAS无锁方式close\n    public void close() throws IOException {\n        byte[] buffer;\n        while ( (buffer = buf) != null) {\n            if (bufUpdater.compareAndSet(this, buffer, null)) {\n                InputStream input = in;\n                in = null;\n                if (input != null)\n                    input.close();\n                return;\n            }\n            // Else retry in case a new buf was CASed in fill()\n        }\n    }\n}\n\n\nAtomicReferenceFieldUpdater具体可以参考：JUC原子类: CAS, Unsafe和原子类详解\n\n\n# 参考文章\n\n * JDK 11 源码\n * https://www.cnblogs.com/winterfells/p/8745297.html\n * https://www.cnblogs.com/AdaiCoffee/p/11369699.html',normalizedContent:'# java io - 源码: inputstream\n\n> 本文主要从jdk 11 源码角度分析inputstream。 @pdai\n\n * java io - 源码: inputstream\n   * inputstream 类实现关系\n   * inputstream 抽象类\n   * 源码实现\n     * inputstream\n     * filterinputstream\n     * bytearrayinputstream\n     * bufferedinputstream\n   * 参考文章\n\n\n# inputstream 类实现关系\n\n> inputstream是输入字节流，具体的实现类层次结构如下：\n\n\n\n\n# inputstream 抽象类\n\ninputstream 类重要方法设计如下：\n\n// 读取下一个字节，如果没有则返回-1\npublic abstract int read() \n\n// 将读取到的数据放在 byte 数组中，该方法实际上调用read(byte b[], int off, int len)方法\npublic int read(byte b[]) \n\n// 从第 off 位置读取<b>最多(实际可能小于)</b> len 长度字节的数据放到 byte 数组中，流是以 -1 来判断是否读取结束的; 此方法会一直阻止，直到输入数据可用、检测到stream结尾或引发异常为止。\npublic int read(byte b[], int off, int len) \n\n// jdk9新增：读取 inputstream 中的所有剩余字节，调用readnbytes(integer.max_value)方法\npublic byte[] readallbytes()\n\n// jdk11更新：读取 inputstream 中的剩余字节的指定上限大小的字节内容；此方法会一直阻塞，直到读取了请求的字节数、检测到流结束或引发异常为止。此方法不会关闭输入流。\npublic byte[] readnbytes(int len)\n\n// jdk9新增：从输入流读取请求的字节数并保存在byte数组中； 此方法会一直阻塞，直到读取了请求的字节数、检测到流结束或引发异常为止。此方法不会关闭输入流。\npublic int readnbytes(byte[] b, int off, int len)\n\n// 跳过指定个数的字节不读取\npublic long skip(long n) \n\n// 返回可读的字节数量\npublic int available() \n\n// 读取完，关闭流，释放资源\npublic void close() \n\n// 标记读取位置，下次还可以从这里开始读取，使用前要看当前流是否支持，可以使用 marksupport() 方法判断\npublic synchronized void mark(int readlimit) \n\n// 重置读取位置为上次 mark 标记的位置\npublic synchronized void reset() \n\n// 判断当前流是否支持标记流，和上面两个方法配套使用\npublic boolean marksupported() \n\n// jdk9新增：读取 inputstream 中的全部字节并写入到指定的 outputstream 中\npublic long transferto(outputstream out)\n\n\n\n\n# 源码实现\n\n> 梳理部分inputstream及其实现类的源码分析。\n\n\n# inputstream\n\ninputstream抽象类源码如下：\n\npublic abstract class inputstream implements closeable {\n    \n    // 当使用skip方法时，最大的buffer size大小\n    private static final int max_skip_buffer_size = 2048;\n\n    // 默认的buffer size\n    private static final int default_buffer_size = 8192;\n\n    // jdk11中增加了一个nullinputstream，即空模式实现，以便可以直接调用而不用判空（可以看如下的补充说明）\n    public static inputstream nullinputstream() {\n        return new inputstream() {\n            private volatile boolean closed;\n\n            private void ensureopen() throws ioexception {\n                if (closed) {\n                    throw new ioexception("stream closed");\n                }\n            }\n\n            @override\n            public int available () throws ioexception {\n                ensureopen();\n                return 0;\n            }\n\n            @override\n            public int read() throws ioexception {\n                ensureopen();\n                return -1;\n            }\n\n            @override\n            public int read(byte[] b, int off, int len) throws ioexception {\n                objects.checkfromindexsize(off, len, b.length);\n                if (len == 0) {\n                    return 0;\n                }\n                ensureopen();\n                return -1;\n            }\n\n            @override\n            public byte[] readallbytes() throws ioexception {\n                ensureopen();\n                return new byte[0];\n            }\n\n            @override\n            public int readnbytes(byte[] b, int off, int len)\n                throws ioexception {\n                objects.checkfromindexsize(off, len, b.length);\n                ensureopen();\n                return 0;\n            }\n\n            @override\n            public byte[] readnbytes(int len) throws ioexception {\n                if (len < 0) {\n                    throw new illegalargumentexception("len < 0");\n                }\n                ensureopen();\n                return new byte[0];\n            }\n\n            @override\n            public long skip(long n) throws ioexception {\n                ensureopen();\n                return 0l;\n            }\n\n            @override\n            public long transferto(outputstream out) throws ioexception {\n                objects.requirenonnull(out);\n                ensureopen();\n                return 0l;\n            }\n\n            @override\n            public void close() throws ioexception {\n                closed = true;\n            }\n        };\n    }\n    \n    // 读取下一个字节的数据，如果没有则返回-1\n    public abstract int read() throws ioexception;\n\n    // 将读取到的数据放在 byte 数组中，该方法实际上调用read(byte b[], int off, int len)方法\n    public int read(byte b[]) throws ioexception {\n        return read(b, 0, b.length);\n    }\n\n    // 从第 off 位置读取<b>最多(实际可能小于)</b> len 长度字节的数据放到 byte 数组中，流是以 -1 来判断是否读取结束的; 此方法会一直阻止，直到输入数据可用、检测到stream结尾或引发异常为止。\n    public int read(byte b[], int off, int len) throws ioexception {\n        // 检查边界\n        objects.checkfromindexsize(off, len, b.length);\n        if (len == 0) {\n            return 0;\n        }\n\n        // 读取下一个字节\n        int c = read();\n        if (c == -1) { // 读到stream末尾，则返回读取的字节数量为-1\n            return -1;\n        }\n        b[off] = (byte)c;\n\n        // i用来记录取了多少个字节\n        int i = 1;\n        try {\n            // 循环读取\n            for (; i < len ; i++) {\n                c = read();\n                if (c == -1) {// 读到stream末尾，则break\n                    break;\n                }\n                b[off + i] = (byte)c;\n            }\n        } catch (ioexception ee) {\n        }\n        // 返回读取到的字节个数\n        return i;\n    }\n\n    // 分配的最大数组大小。\n    // 由于一些vm在数组中保留一些头字，所以尝试分配较大的阵列可能会导致outofmemoryerror（请求的阵列大小超过vm限制）\n    private static final int max_buffer_size = integer.max_value - 8;\n\n    // jdk9新增：读取 inputstream 中的所有剩余字节，调用readnbytes(integer.max_value)方法\n    public byte[] readallbytes() throws ioexception {\n        return readnbytes(integer.max_value);\n    }\n\n    // jdk11更新：读取 inputstream 中的剩余字节的指定上限大小的字节内容；此方法会一直阻塞，直到读取了请求的字节数、检测到流结束或引发异常为止。此方法不会关闭输入流。\n    public byte[] readnbytes(int len) throws ioexception {\n        // 边界检查\n        if (len < 0) {\n            throw new illegalargumentexception("len < 0");\n        }\n\n        list<byte[]> bufs = null; // 缓存每次读取到的内容放到bufs，最后组装成result\n        byte[] result = null; // 最后读取到的内容\n        int total = 0;\n        int remaining = len; // 剩余字节长度\n        int n;\n        do {\n            byte[] buf = new byte[math.min(remaining, default_buffer_size)];\n            int nread = 0;\n\n            // 读取到结束为止，读取大小n可能大于或小于缓冲区大小\n            while ((n = read(buf, nread,\n                    math.min(buf.length - nread, remaining))) > 0) {\n                nread += n; \n                remaining -= n;\n            }\n\n            if (nread > 0) {\n                if (max_buffer_size - total < nread) {\n                    throw new outofmemoryerror("required array size too large");\n                }\n                total += nread;\n                if (result == null) {\n                    result = buf;\n                } else {\n                    if (bufs == null) {\n                        bufs = new arraylist<>();\n                        bufs.add(result);\n                    }\n                    bufs.add(buf);\n                }\n            }\n            // 如果读不到内容（返回-1）或者没有剩余的字节，则跳出循环\n        } while (n >= 0 && remaining > 0);\n\n        if (bufs == null) {\n            if (result == null) {\n                return new byte[0];\n            }\n            return result.length == total ?\n                result : arrays.copyof(result, total);\n        }\n\n        // 组装最后的result\n        result = new byte[total];\n        int offset = 0;\n        remaining = total;\n        for (byte[] b : bufs) {\n            int count = math.min(b.length, remaining);\n            system.arraycopy(b, 0, result, offset, count);\n            offset += count;\n            remaining -= count;\n        }\n\n        return result;\n    }\n\n    // jdk9新增：从输入流读取请求的字节数并保存在byte数组中； 此方法会一直阻塞，直到读取了请求的字节数、检测到流结束或引发异常为止。此方法不会关闭输入流。\n    public int readnbytes(byte[] b, int off, int len) throws ioexception {\n        objects.checkfromindexsize(off, len, b.length);\n\n        int n = 0;\n        while (n < len) {\n            int count = read(b, off + n, len - n);\n            if (count < 0)\n                break;\n            n += count;\n        }\n        return n;\n    }\n\n    // 跳过指定个数的字节不读取\n    public long skip(long n) throws ioexception {\n\n        long remaining = n;\n        int nr;\n\n        if (n <= 0) {\n            return 0;\n        }\n\n        int size = (int)math.min(max_skip_buffer_size, remaining);\n        byte[] skipbuffer = new byte[size];\n        while (remaining > 0) {\n            nr = read(skipbuffer, 0, (int)math.min(size, remaining));\n            if (nr < 0) {\n                break;\n            }\n            remaining -= nr;\n        }\n\n        return n - remaining;\n    }\n\n    // 返回可读的字节数量\n    public int available() throws ioexception {\n        return 0;\n    }\n\n    // 读取完，关闭流，释放资源\n    public void close() throws ioexception {}\n\n    // 标记读取位置，下次还可以从这里开始读取，使用前要看当前流是否支持，可以使用 marksupport() 方法判断\n    public synchronized void mark(int readlimit) {}\n\n    // 重置读取位置为上次 mark 标记的位置\n    public synchronized void reset() throws ioexception {\n        throw new ioexception("mark/reset not supported");\n    }\n\n    // 判断当前流是否支持标记流，和上面两个方法配套使用。默认是false，由子类方法重写\n    public boolean marksupported() {\n        return false;\n    }\n\n    // jdk9新增：读取 inputstream 中的全部字节并写入到指定的 outputstream 中\n    public long transferto(outputstream out) throws ioexception {\n        objects.requirenonnull(out, "out");\n        long transferred = 0;\n        byte[] buffer = new byte[default_buffer_size];\n        int read;\n        while ((read = this.read(buffer, 0, default_buffer_size)) >= 0) {\n            out.write(buffer, 0, read);\n            transferred += read;\n        }\n        return transferred;\n    }\n\n\n> 总结下jdk9的更新点\n\n类 java.io.inputstream 中增加了新的方法来读取和复制 inputstream 中包含的数据。\n\n * readallbytes：读取 inputstream 中的所有剩余字节。\n * readnbytes： 从 inputstream 中读取指定数量的字节到数组中。\n * transferto：读取 inputstream 中的全部字节并写入到指定的 outputstream 中 。\n\npublic class testinputstream {\n    private inputstream inputstream;\n    private static final string content = "hello world";\n    @before\n    public void setup() throws exception {\n        this.inputstream =\n            testinputstream.class.getresourceasstream("/input.txt");\n    }\n    @test\n    public void testreadallbytes() throws exception {\n        final string content = new string(this.inputstream.readallbytes());\n        assertequals(content, content);\n    }\n    @test\n    public void testreadnbytes() throws exception {\n        final byte[] data = new byte[5];\n        this.inputstream.readnbytes(data, 0, 5);\n        assertequals("hello", new string(data));\n    }\n    @test\n    public void testtransferto() throws exception {\n        final bytearrayoutputstream outputstream = new bytearrayoutputstream();\n        this.inputstream.transferto(outputstream);\n        assertequals(content, outputstream.tostring());\n    }\n}\n\n\n * read(byte[], int, int) 和 readnbytes(byte[], int, int)看似是实现的相同功能，为何会设计readnbytes方法呢？\n\n这个问题可以参看这里在新窗口打开\n\n 1. read(byte[], int, int)是尝试读到最多len个bytes，但是读取到的内容长度可能是小于len的。\n 2. readnbytes(byte[], int, int) 会一直（while循环）查找直到stream尾为止\n\n举个例子：如果文本内容是12345<end>, read(s,0,10)是允许返回123的, 而readnbytes(s,0,10)会一直（while循环）查找直到stream尾为止，并返回12345.\n\n> 补充下jdk11为什么会增加nullinputstream方法的设计？即空对象模式\n\n * 空对象模式\n\n举个例子：\n\npublic class myparser implements parser {\n  private static action no_action = new action() {\n    public void dosomething() { /* do nothing */ }\n  };\n\n  public action findaction(string userinput) {\n    // ...\n    if ( /* we can\'t find any actions */ ) {\n      return no_action;\n    }\n  }\n}\n\n\n然后便可以始终可以这么调用，而不用再判断空了\n\nparserfactory.getparser().findaction(someinput).dosomething();\n\n\n\n# filterinputstream\n\nfilterinputstream 源码如下\n\npublic class filterinputstream extends inputstream {\n    \n    // 被装饰的inputstream\n    protected volatile inputstream in;\n    \n    // 构造函数，注入被装饰的inputstream\n    protected filterinputstream(inputstream in) {\n        this.in = in;\n    }\n\n    // 本质是调用被装饰的inputstream的方法\n    public int read() throws ioexception {\n        return in.read();\n    }\n    public int read(byte b[]) throws ioexception {\n        return read(b, 0, b.length);\n     }\n    public int read(byte b[], int off, int len) throws ioexception {\n        return in.read(b, off, len);\n     }\n    public long skip(long n) throws ioexception {\n        return in.skip(n);\n    }\n    public int available() throws ioexception {\n        return in.available();\n    }\n    public void close() throws ioexception {\n        in.close();\n    }\n    public synchronized void mark(int readlimit) {\n        in.mark(readlimit);\n     }\n    public synchronized void reset() throws ioexception {\n        in.reset();\n    }\n    public boolean marksupported() {\n        return in.marksupported();\n    }\n}\n\n\n为什么被装饰的inputstream是volatile类型的？\n\n请参看： 关键字: volatile详解\n\n\n# bytearrayinputstream\n\nbytearrayinputstream源码如下\n\npublic class bytearrayinputstream extends inputstream {\n    \n    // 内部保存的byte 数组\n    protected byte buf[];\n    \n    // 读取下一个字节的数组下标，byte[pos]就是read获取的下个字节\n    protected int pos;\n    \n    // mark的数组下标位置\n    protected int mark = 0;\n    \n    // 保存的有效byte的个数\n    protected int count;\n\n    // 构造方法\n    public bytearrayinputstream(byte buf[]) {\n        this.buf = buf;              \n        this.pos = 0;\n        this.count = buf.length;\n     }\n    \n    // 构造方法，带offset的\n     public bytearrayinputstream(byte buf[], int offset, int length) {                \n        this.buf = buf;\n        this.pos = offset;\n        this.count = math.min(offset + length, buf.length);\n        this.mark = offset;\n    }\n    \n    // 从流中读取下一个字节，没有读取到返回 -1\n    public synchronized int read() {\n        return (pos < count) ? (buf[pos++] & 0xff) : -1;\n    }\n    \n    // 从第 off 位置读取<b>最多(实际可能小于)</b> len 长度字节的数据放到 byte 数组中，流是以 -1 来判断是否读取结束的\n    public synchronized int read(byte b[], int off, int len) {\n        // 边界检查\n        if (b == null) {\n            throw new nullpointerexception();\n        } else if (off < 0 || len < 0 || len > b.length - off) {\n            throw new indexoutofboundsexception();\n        }\n\n        if (pos >= count) {\n            return -1;\n        }\n\n        int avail = count - pos;\n        if (len > avail) {\n            len = avail;\n        }\n        if (len <= 0) {\n            return 0;\n        }\n\n        // 从buf拷贝到byte 数组b中\n        system.arraycopy(buf, pos, b, off, len);\n        pos += len;\n        return len;\n    }\n\n    // 跳过指定个数的字节不读取\n    public synchronized long skip(long n) {\n        long k = count - pos;\n        if (n < k) {\n            k = n < 0 ? 0 : n;\n        }\n\n        pos += k;\n        return k;\n    }\n\n    // 还有稍稍byte在buffer中未读取，即总的count 减去 当前byte位置\n    public synchronized int available() {\n        return count - pos;\n    }\n\n    // 支持mark所以返回true\n    public boolean marksupported() { \n        return true;\n    }  \n\n    // 在流中当前位置mark, readaheadlimit参数未使用    \n    public void mark(int readaheadlimit) {            \n        mark = pos;\n    }\n\n    // 重置流，即回到mark的位置\n    public synchronized void reset() {\n        pos = mark;\n    }\n\n    // 关闭bytearrayinputstream不会产生任何动作\n    public void close() throws ioexception { \n\n    }\n}\n\n\n\n# bufferedinputstream\n\nbufferedinputstream源码如下\n\npublic class bufferedinputstream extends filterinputstream {\n\n    // 默认的buffer大小\n    private static int default_buffer_size = 8192;\n\n    // 分配的最大数组大小。\n    // 由于一些vm在数组中保留一些头字，所以尝试分配较大的阵列可能会导致outofmemoryerror（请求的阵列大小超过vm限制）\n    private static int max_buffer_size = integer.max_value - 8;\n\n    // 内部保存在byte 数组中\n    protected volatile byte buf[];\n\n    // 关闭流的方法可能是异步的，所以使用原子atomicreferencefieldupdater提供cas无锁方式（可以解决cas的aba问题）来保证\n    private static final atomicreferencefieldupdater<bufferedinputstream, byte[]> bufupdater =\n        atomicreferencefieldupdater.newupdater(bufferedinputstream.class,  byte[].class, "buf");\n\n    // 有效byte的大小\n    protected int count;\n\n    // 当前位置\n    protected int pos;\n\n    // 最后一次，调用mark方法，标记的位置\n    protected int markpos = -1;\n\n    /**\n     * 该变量惟一入口就是mark(int readlimit)，好比调用方法mark(1024)，那么后面读取的数据若是\n     * 超过了1024字节，那么这次mark就为无效标记，子类能够选择抛弃该mark标记，从头开始。不过具体实现\n     * 跟具体的子类有关，在bufferedinputstream中，会抛弃mark标记，从新将markpos赋值为-1\n     */\n    protected int marklimit;\n\n    // 获取被装饰的stream\n    private inputstream getinifopen() throws ioexception {\n        inputstream input = in;\n        if (input == null)\n            throw new ioexception("stream closed");\n        return input;\n    }\n\n    // 获取实际内部的buffer数组\n    private byte[] getbufifopen() throws ioexception {\n        byte[] buffer = buf;\n        if (buffer == null)\n            throw new ioexception("stream closed");\n        return buffer;\n    }\n\n    // 构造函数，buffer是8kb\n    public bufferedinputstream(inputstream in) {\n        this(in, default_buffer_size);\n    }\n\n    // 构造函数，指定buffer大小\n    public bufferedinputstream(inputstream in, int size) {\n        super(in);\n        if (size <= 0) {\n            throw new illegalargumentexception("buffer size <= 0");\n        }\n        buf = new byte[size];\n    }\n\n    /**\n     * 用更多的数据填充缓冲区,考虑到shuffling和其他处理标记的技巧，\n     * 假设它是由同步方法调用的。该方法还假设所有数据已经被读入，因此pos >count。\n     */\n    private void fill() throws ioexception {\n    \t// 得到内部缓冲区buffer\n        byte[] buffer = getbufifopen();\n        // 没有mark的情况下， pos为0\n        if (markpos < 0)\n            pos = 0;            /* no mark: throw away the buffer */\n        // pos >= buffer.length  buffer已经被读取完了 \n        else if (pos >= buffer.length)  /* no room left in buffer */\n        \t// markpos > 0  有标记，标记处在缓存中间\n            if (markpos > 0) {  /* can throw away early part of the buffer */\n            \t// 把buffer中，markpos到pos的部分移动到0-sz处，pos设置为sz，markpos为0\n                int sz = pos - markpos;\n                system.arraycopy(buffer, markpos, buffer, 0, sz);\n                pos = sz;\n                markpos = 0;\n                // markpos已经为0了，marklimit比buffer.length小，再读取buffer已经没有地方了\n            } else if (buffer.length >= marklimit) {\n            \t// 清空缓存，清空标记，markpos为-1，pos为0\n                markpos = -1;   /* buffer got too big, invalidate mark */\n                pos = 0;        /* drop buffer contents */\n                // markpos已经为0了，marklimit比buffer.length大，而buffer.length已经最大了，不能扩容\n            } else if (buffer.length >= max_buffer_size) {\n                throw new outofmemoryerror("required array size too large");\n               // markpos已经为0了，marklimit比buffer.length大\n            } else {            /* grow buffer */\n            \t// 建立一个长度为min(2*pos,marklimit,max_buffer_size),的缓存数组，然后把原来0-pos移动到新数组的0-pos处\n                int nsz = (pos <= max_buffer_size - pos) ?\n                        pos * 2 : max_buffer_size;\n                if (nsz > marklimit)\n                    nsz = marklimit;\n                byte nbuf[] = new byte[nsz];\n                system.arraycopy(buffer, 0, nbuf, 0, pos);\n                // 用bufupdater替换buffer\n                if (!bufupdater.compareandset(this, buffer, nbuf)) {\n                    // can\'t replace buf if there was an async close.\n                    // note: this would need to be changed if fill()\n                    // is ever made accessible to multiple threads.\n                    // but for now, the only way cas can fail is via close.\n                    // assert buf == null;\n                    throw new ioexception("stream closed");\n                }\n                buffer = nbuf;\n            }\n        // 当前读取上限count为pos\n        count = pos;\n        // 从内部的输入流，读取pos到buffer.length部分，读取的字节数加到count\n        int n = getinifopen().read(buffer, pos, buffer.length - pos);\n        if (n > 0)\n            count = n + pos;\n    }\n\n    // 读取byte\n    public synchronized int read() throws ioexception {\n        // 说明当前buf[]数组大小不够了，须要fill()\n        if (pos >= count) {\n            fill();\n            // 说明没有读取到任何数据\n            if (pos >= count)\n                return -1;\n        }\n        return getbufifopen()[pos++] & 0xff;\n    }\n\n    /**\n     * read characters into a portion of an array, reading from the underlying\n     * stream at most once if necessary.\n     */\n    private int read1(byte[] b, int off, int len) throws ioexception {\n        int avail = count - pos;\n        if (avail <= 0) {\n            // 当写入指定数组b的长度大小超过bufferedinputstream中核心缓存数组buf[]的大小而且 markpos < 0，那么就直接从数据流中读取数据给b数组，而不经过buf[]缓存数组，避免buf[]数组急剧增大\n            if (len >= getbufifopen().length && markpos < 0) {\n                return getinifopen().read(b, off, len);\n            }\n            fill();\n            avail = count - pos;\n            if (avail <= 0) return -1;\n        }\n        int cnt = (avail < len) ? avail : len;\n        system.arraycopy(getbufifopen(), pos, b, off, cnt);\n        pos += cnt;\n        return cnt;\n    }\n\n    // 读取到byte数组b中\n    public synchronized int read(byte b[], int off, int len)\n        throws ioexception\n    {\n        getbufifopen(); // check for closed stream\n        if ((off | len | (off + len) | (b.length - (off + len))) < 0) {\n            throw new indexoutofboundsexception();\n        } else if (len == 0) {\n            return 0;\n        }\n\n        int n = 0;\n        for (;;) {\n            int nread = read1(b, off + n, len - n);\n            if (nread <= 0)\n                return (n == 0) ? nread : n;\n            n += nread;\n            if (n >= len)\n                return n;\n            // if not closed but no bytes available, return\n            inputstream input = in;\n            if (input != null && input.available() <= 0)\n                return n;\n        }\n    }\n\n    // 跳过n个\n    public synchronized long skip(long n) throws ioexception {\n        getbufifopen(); // check for closed stream\n        if (n <= 0) {\n            return 0;\n        }\n        long avail = count - pos;\n\n        if (avail <= 0) {\n            // if no mark position set then don\'t keep in buffer\n            if (markpos <0)\n                return getinifopen().skip(n);\n\n            // fill in buffer to save bytes for reset\n            fill();\n            avail = count - pos;\n            if (avail <= 0)\n                return 0;\n        }\n\n        long skipped = (avail < n) ? avail : n;\n        pos += skipped;\n        return skipped;\n    }\n\n    // buf[]数组剩余字节数+输入流中剩余字节数\n    public synchronized int available() throws ioexception {\n        int n = count - pos;\n        int avail = getinifopen().available();\n        return n > (integer.max_value - avail)\n                    ? integer.max_value\n                    : n + avail;\n    }\n\n    \n    // 标记位置，marklimit只有在这里才可以被赋值，readlimit表示mark()方法执行后，最多可以从流中读取的数据\n    // 若是超过该字节大小，那么在fill()的时候，就会认为此mark()标记无效，从新将 markpos = -1，pos = 0\n    public synchronized void mark(int readlimit) {\n        marklimit = readlimit;\n        markpos = pos;\n    }\n\n    // 重置位置\n    public synchronized void reset() throws ioexception {\n        getbufifopen(); // 如果已经close, 则直接报错\n        if (markpos < 0)\n            throw new ioexception("resetting to invalid mark");\n        pos = markpos;\n    }\n\n    // 支持mark, 所以返回true\n    public boolean marksupported() {\n        return true;\n    }\n\n    // 通过atomicreferencefieldupdater的cas无锁方式close\n    public void close() throws ioexception {\n        byte[] buffer;\n        while ( (buffer = buf) != null) {\n            if (bufupdater.compareandset(this, buffer, null)) {\n                inputstream input = in;\n                in = null;\n                if (input != null)\n                    input.close();\n                return;\n            }\n            // else retry in case a new buf was cased in fill()\n        }\n    }\n}\n\n\natomicreferencefieldupdater具体可以参考：juc原子类: cas, unsafe和原子类详解\n\n\n# 参考文章\n\n * jdk 11 源码\n * https://www.cnblogs.com/winterfells/p/8745297.html\n * https://www.cnblogs.com/adaicoffee/p/11369699.html',charsets:{cjk:!0}},{title:"Java IO - 源码: OutputStream",frontmatter:{},regularPath:"/java/io/java-io-basic-code-outputstream.html",relativePath:"java/io/java-io-basic-code-outputstream.md",key:"v-b4527ba4",path:"/java/io/java-io-basic-code-outputstream.html",headers:[{level:2,title:"Java IO - 源码: OutputStream",slug:"java-io-源码-outputstream",normalizedTitle:"java io - 源码: outputstream",charIndex:2},{level:2,title:"OutputStream 类实现关系",slug:"outputstream-类实现关系",normalizedTitle:"outputstream 类实现关系",charIndex:106},{level:2,title:"OutputStream 抽象类",slug:"outputstream-抽象类",normalizedTitle:"outputstream 抽象类",charIndex:130},{level:2,title:"源码实现",slug:"源码实现",normalizedTitle:"源码实现",charIndex:152},{level:3,title:"OutputStream",slug:"outputstream",normalizedTitle:"outputstream",charIndex:16},{level:3,title:"FilterOutputStream",slug:"filteroutputstream",normalizedTitle:"filteroutputstream",charIndex:184},{level:3,title:"ByteArrayOutputStream",slug:"bytearrayoutputstream",normalizedTitle:"bytearrayoutputstream",charIndex:210},{level:3,title:"BufferedOutputStream",slug:"bufferedoutputstream",normalizedTitle:"bufferedoutputstream",charIndex:239},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:265}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java IO - 源码: OutputStream OutputStream 类实现关系 OutputStream 抽象类 源码实现 OutputStream FilterOutputStream ByteArrayOutputStream BufferedOutputStream 参考文章",content:'# Java IO - 源码: OutputStream\n\n> 本文主要从JDK 11源码角度分析 OutputStream。 @pdai\n\n * Java IO - 源码: OutputStream\n   * OutputStream 类实现关系\n   * OutputStream 抽象类\n   * 源码实现\n     * OutputStream\n     * FilterOutputStream\n     * ByteArrayOutputStream\n     * BufferedOutputStream\n   * 参考文章\n\n\n# OutputStream 类实现关系\n\n> OutputStream是输出字节流，具体的实现类层次结构如下：\n\n\n\n\n# OutputStream 抽象类\n\nOutputStream 类重要方法设计如下：\n\n// 写入一个字节，可以看到这里的参数是一个 int 类型，对应上面的读方法，int 类型的 32 位，只有低 8 位才写入，高 24 位将舍弃。\npublic abstract void write(int b)\n\n// 将数组中的所有字节写入，实际调用的是write(byte b[], int off, int len)方法。\npublic void write(byte b[])\n\n// 将 byte 数组从 off 位置开始，len 长度的字节写入\npublic void write(byte b[], int off, int len)\n\n// 强制刷新，将缓冲中的数据写入; 默认是空实现，供子类覆盖\npublic void flush()\n\n// 关闭输出流，流被关闭后就不能再输出数据了; 默认是空实现，供子类覆盖\npublic void close()\n\n\n\n\n# 源码实现\n\n> 梳理部分OutputStream及其实现类的源码分析。\n\n\n# OutputStream\n\nOutputStream抽象类源码如下：\n\npublic abstract class OutputStream implements Closeable, Flushable {\n    \n    // JDK11中增加了一个nullOutputStream，即空模式实现，以便可以直接调用而不用判空（可以看如下的补充说明）\n    public static OutputStream nullOutputStream() {\n        return new OutputStream() {\n            private volatile boolean closed;\n\n            private void ensureOpen() throws IOException {\n                if (closed) {\n                    throw new IOException("Stream closed");\n                }\n            }\n\n            @Override\n            public void write(int b) throws IOException {\n                ensureOpen();\n            }\n\n            @Override\n            public void write(byte b[], int off, int len) throws IOException {\n                Objects.checkFromIndexSize(off, len, b.length);\n                ensureOpen();\n            }\n\n            @Override\n            public void close() {\n                closed = true;\n            }\n        };\n    }\n\n    // 写入一个字节，可以看到这里的参数是一个 int 类型，对应上面的读方法，int 类型的 32 位，只有低 8 位才写入，高 24 位将舍弃。\n    public abstract void write(int b) throws IOException;\n\n    // 将数组中的所有字节写入，实际调用的是write(byte b[], int off, int len)方法\n    public void write(byte b[]) throws IOException {\n        write(b, 0, b.length);\n    }\n\n    // 将 byte 数组从 off 位置开始，len 长度的字节写入\n    public void write(byte b[], int off, int len) throws IOException {\n        // 检查边界合理性\n        Objects.checkFromIndexSize(off, len, b.length);\n        // len == 0 的情况已经在如下的for循环中隐式处理了\n        for (int i = 0 ; i < len ; i++) {\n            write(b[off + i]);\n        }\n    }\n\n    // 强制刷新，将缓冲中的数据写入; 默认是空实现，供子类覆盖\n    public void flush() throws IOException {\n    }\n\n    // 关闭输出流，流被关闭后就不能再输出数据了; 默认是空实现，供子类覆盖\n    public void close() throws IOException {\n    }\n\n}\n\n\n> 补充下JDK11为什么会增加nullOutputStream方法的设计？即空对象模式\n\n * 空对象模式\n\n举个例子：\n\npublic class MyParser implements Parser {\n  private static Action NO_ACTION = new Action() {\n    public void doSomething() { /* do nothing */ }\n  };\n\n  public Action findAction(String userInput) {\n    // ...\n    if ( /* we can\'t find any actions */ ) {\n      return NO_ACTION;\n    }\n  }\n}\n\n\n然后便可以始终可以这么调用，而不用再判断空了\n\nParserFactory.getParser().findAction(someInput).doSomething();\n\n\n\n# FilterOutputStream\n\nFilterOutputStream 源码如下\n\npublic class FilterOutputStream extends OutputStream {\n    \n    // 被装饰的实际outputStream\n    protected OutputStream out;\n\n    // 当前stream是否已经被close\n    private volatile boolean closed;\n\n    // close stream时加锁，防止其它线程同时close\n    private final Object closeLock = new Object();\n\n    // 初始化构造函数，传入被装饰的实际outputStream\n    public FilterOutputStream(OutputStream out) {\n        this.out = out;\n    }\n\n    // 写入数据，本质调用被装饰outputStream的方法\n    @Override\n    public void write(int b) throws IOException {\n        out.write(b);\n    }\n\n    // 将数组中的所有字节写入\n    @Override\n    public void write(byte b[]) throws IOException {\n        write(b, 0, b.length);\n    }\n\n    // 一个个写入\n    @Override\n    public void write(byte b[], int off, int len) throws IOException {\n        if ((off | len | (b.length - (len + off)) | (off + len)) < 0)\n            throw new IndexOutOfBoundsException();\n\n        for (int i = 0 ; i < len ; i++) {\n            write(b[off + i]);\n        }\n    }\n\n     // 强制刷新，将缓冲中的数据写入; 本质调用被装饰outputStream的方法\n    @Override\n    public void flush() throws IOException {\n        out.flush();\n    }\n\n    // 关闭Stream\n    @Override\n    public void close() throws IOException {\n        // 如果已经close, 直接退出\n        if (closed) {\n            return;\n        }\n        // 加锁处理，如果已经有线程正在closing则退出；\n        synchronized (closeLock) {\n            if (closed) {\n                return;\n            }\n            closed = true;\n        }\n\n        // close前调用flush\n        Throwable flushException = null;\n        try {\n            flush();\n        } catch (Throwable e) {\n            flushException = e;\n            throw e;\n        } finally {\n            if (flushException == null) {\n                out.close();\n            } else {\n                try {\n                    out.close();\n                } catch (Throwable closeException) {\n                   // evaluate possible precedence of flushException over closeException\n                   if ((flushException instanceof ThreadDeath) &&\n                       !(closeException instanceof ThreadDeath)) {\n                       flushException.addSuppressed(closeException);\n                       throw (ThreadDeath) flushException;\n                   }\n\n                    if (flushException != closeException) {\n                        closeException.addSuppressed(flushException);\n                    }\n\n                    throw closeException;\n                }\n            }\n        }\n    }\n}\n\n\n@pdai: 对比下JDK8中，close方法是没有加锁处理的。这种情况下你可以看JDK8源码中，直接利用java7的try with resources方式，优雅的调用flush方法后对out进行关闭。\n\npublic void close() throws IOException {\n    try (OutputStream ostream = out) {\n        flush();\n    }\n}\n\n\n\n# ByteArrayOutputStream\n\nByteArrayOutputStream 源码如下\n\npublic class ByteArrayOutputStream extends OutputStream {\n\n    // 实际的byte数组\n    protected byte buf[];\n\n    // 数组中实际有效的byte的个数\n    protected int count;\n\n    // 初始化默认构造，初始化byte数组大小为32\n    public ByteArrayOutputStream() {\n        this(32);\n    }\n\n    // 初始化byte的大小\n    public ByteArrayOutputStream(int size) {\n        if (size < 0) {\n            throw new IllegalArgumentException("Negative initial size: "\n                                               + size);\n        }\n        buf = new byte[size];\n    }\n\n    // 扩容，确保它至少可以容纳由最小容量参数指定的元素数\n    private void ensureCapacity(int minCapacity) {\n        // overflow-conscious code\n        if (minCapacity - buf.length > 0)\n            grow(minCapacity);\n    }\n\n    // 分配的最大数组大小。\n    // 由于一些VM在数组中保留一些头字，所以尝试分配较大的阵列可能会导致OutOfMemoryError（请求的阵列大小超过VM限制）\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    // 扩容的实质方法，确保它至少可以容纳由最小容量参数指定的元素数\n    private void grow(int minCapacity) {\n        // overflow-conscious code\n        int oldCapacity = buf.length;\n        int newCapacity = oldCapacity << 1;\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        buf = Arrays.copyOf(buf, newCapacity);\n    }\n\n    private static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    }\n\n    // 写入，写入前确保byte数据长度\n    public synchronized void write(int b) {\n        ensureCapacity(count + 1);\n        buf[count] = (byte) b;\n        count += 1;\n    }\n\n    \n    public synchronized void write(byte b[], int off, int len) {\n        Objects.checkFromIndexSize(off, len, b.length);\n        ensureCapacity(count + len);\n        System.arraycopy(b, off, buf, count, len);\n        count += len;\n    }\n\n    public void writeBytes(byte b[]) {\n        write(b, 0, b.length);\n    }\n\n    public synchronized void writeTo(OutputStream out) throws IOException {\n        out.write(buf, 0, count);\n    }\n\n    // 重置，显然将实际有效的byte数量置为0\n    public synchronized void reset() {\n        count = 0;\n    }\n\n    \n    public synchronized byte[] toByteArray() {\n        return Arrays.copyOf(buf, count);\n    }\n\n    // 长度，即count\n    public synchronized int size() {\n        return count;\n    }\n\n    // 转成string\n    public synchronized String toString() {\n        return new String(buf, 0, count);\n    }\n\n    // 转成string，指定的字符集\n    public synchronized String toString(String charsetName)\n        throws UnsupportedEncodingException\n    {\n        return new String(buf, 0, count, charsetName);\n    }\n\n    public synchronized String toString(Charset charset) {\n        return new String(buf, 0, count, charset);\n    }\n\n    // 弃用\n    @Deprecated\n    public synchronized String toString(int hibyte) {\n        return new String(buf, hibyte, 0, count);\n    }\n\n    // 对byte 数组而言，close没啥实质意义，所以空实现\n    public void close() throws IOException {\n    }\n\n}\n\n\n\n# BufferedOutputStream\n\nBufferedOutputStream 源码如下\n\npublic class BufferedOutputStream extends FilterOutputStream {\n    \n    // Buffered outputStream底层也是byte数组\n    protected byte buf[];\n\n    // 大小，buf[0]到buf[count-1]是实际存储的bytes\n    protected int count;\n\n    // 构造函数，被装饰的outputStream，以及默认buf大小是8192\n    public BufferedOutputStream(OutputStream out) {\n        this(out, 8192);\n    }\n\n    public BufferedOutputStream(OutputStream out, int size) {\n        super(out);\n        if (size <= 0) {\n            throw new IllegalArgumentException("Buffer size <= 0");\n        }\n        buf = new byte[size];\n    }\n\n    /** Flush the internal buffer */\n    // 内部的flush方法，将buffer中的有效bytes(count是有效的bytes大小)通过被装饰的outputStream写入\n    private void flushBuffer() throws IOException {\n        if (count > 0) {\n            out.write(buf, 0, count);\n            count = 0;\n        }\n    }\n\n    // 写入byte\n    @Override\n    public synchronized void write(int b) throws IOException {\n        // 当buffer满了以后，flush buffer\n        if (count >= buf.length) {\n            flushBuffer();\n        }\n        buf[count++] = (byte)b;\n    }\n\n    // 将 byte 数组从 off 位置开始，len 长度的字节写入\n    @Override\n    public synchronized void write(byte b[], int off, int len) throws IOException {\n        if (len >= buf.length) {\n            // 如果请求长度已经超过输出缓冲区的大小，直接刷新输出缓冲区，然后直接写入数据。\n            flushBuffer();\n            out.write(b, off, len);\n            return;\n        }\n        if (len > buf.length - count) {\n            flushBuffer();\n        }\n        System.arraycopy(b, off, buf, count, len);\n        count += len;\n    }\n\n    // flush方法，需要先将buffer中写入，最后在调用被装饰outputStream的flush方法\n    @Override\n    public synchronized void flush() throws IOException {\n        flushBuffer();\n        out.flush();\n    }\n}\n\n\n\n# 参考文章\n\n * JDK 11',normalizedContent:'# java io - 源码: outputstream\n\n> 本文主要从jdk 11源码角度分析 outputstream。 @pdai\n\n * java io - 源码: outputstream\n   * outputstream 类实现关系\n   * outputstream 抽象类\n   * 源码实现\n     * outputstream\n     * filteroutputstream\n     * bytearrayoutputstream\n     * bufferedoutputstream\n   * 参考文章\n\n\n# outputstream 类实现关系\n\n> outputstream是输出字节流，具体的实现类层次结构如下：\n\n\n\n\n# outputstream 抽象类\n\noutputstream 类重要方法设计如下：\n\n// 写入一个字节，可以看到这里的参数是一个 int 类型，对应上面的读方法，int 类型的 32 位，只有低 8 位才写入，高 24 位将舍弃。\npublic abstract void write(int b)\n\n// 将数组中的所有字节写入，实际调用的是write(byte b[], int off, int len)方法。\npublic void write(byte b[])\n\n// 将 byte 数组从 off 位置开始，len 长度的字节写入\npublic void write(byte b[], int off, int len)\n\n// 强制刷新，将缓冲中的数据写入; 默认是空实现，供子类覆盖\npublic void flush()\n\n// 关闭输出流，流被关闭后就不能再输出数据了; 默认是空实现，供子类覆盖\npublic void close()\n\n\n\n\n# 源码实现\n\n> 梳理部分outputstream及其实现类的源码分析。\n\n\n# outputstream\n\noutputstream抽象类源码如下：\n\npublic abstract class outputstream implements closeable, flushable {\n    \n    // jdk11中增加了一个nulloutputstream，即空模式实现，以便可以直接调用而不用判空（可以看如下的补充说明）\n    public static outputstream nulloutputstream() {\n        return new outputstream() {\n            private volatile boolean closed;\n\n            private void ensureopen() throws ioexception {\n                if (closed) {\n                    throw new ioexception("stream closed");\n                }\n            }\n\n            @override\n            public void write(int b) throws ioexception {\n                ensureopen();\n            }\n\n            @override\n            public void write(byte b[], int off, int len) throws ioexception {\n                objects.checkfromindexsize(off, len, b.length);\n                ensureopen();\n            }\n\n            @override\n            public void close() {\n                closed = true;\n            }\n        };\n    }\n\n    // 写入一个字节，可以看到这里的参数是一个 int 类型，对应上面的读方法，int 类型的 32 位，只有低 8 位才写入，高 24 位将舍弃。\n    public abstract void write(int b) throws ioexception;\n\n    // 将数组中的所有字节写入，实际调用的是write(byte b[], int off, int len)方法\n    public void write(byte b[]) throws ioexception {\n        write(b, 0, b.length);\n    }\n\n    // 将 byte 数组从 off 位置开始，len 长度的字节写入\n    public void write(byte b[], int off, int len) throws ioexception {\n        // 检查边界合理性\n        objects.checkfromindexsize(off, len, b.length);\n        // len == 0 的情况已经在如下的for循环中隐式处理了\n        for (int i = 0 ; i < len ; i++) {\n            write(b[off + i]);\n        }\n    }\n\n    // 强制刷新，将缓冲中的数据写入; 默认是空实现，供子类覆盖\n    public void flush() throws ioexception {\n    }\n\n    // 关闭输出流，流被关闭后就不能再输出数据了; 默认是空实现，供子类覆盖\n    public void close() throws ioexception {\n    }\n\n}\n\n\n> 补充下jdk11为什么会增加nulloutputstream方法的设计？即空对象模式\n\n * 空对象模式\n\n举个例子：\n\npublic class myparser implements parser {\n  private static action no_action = new action() {\n    public void dosomething() { /* do nothing */ }\n  };\n\n  public action findaction(string userinput) {\n    // ...\n    if ( /* we can\'t find any actions */ ) {\n      return no_action;\n    }\n  }\n}\n\n\n然后便可以始终可以这么调用，而不用再判断空了\n\nparserfactory.getparser().findaction(someinput).dosomething();\n\n\n\n# filteroutputstream\n\nfilteroutputstream 源码如下\n\npublic class filteroutputstream extends outputstream {\n    \n    // 被装饰的实际outputstream\n    protected outputstream out;\n\n    // 当前stream是否已经被close\n    private volatile boolean closed;\n\n    // close stream时加锁，防止其它线程同时close\n    private final object closelock = new object();\n\n    // 初始化构造函数，传入被装饰的实际outputstream\n    public filteroutputstream(outputstream out) {\n        this.out = out;\n    }\n\n    // 写入数据，本质调用被装饰outputstream的方法\n    @override\n    public void write(int b) throws ioexception {\n        out.write(b);\n    }\n\n    // 将数组中的所有字节写入\n    @override\n    public void write(byte b[]) throws ioexception {\n        write(b, 0, b.length);\n    }\n\n    // 一个个写入\n    @override\n    public void write(byte b[], int off, int len) throws ioexception {\n        if ((off | len | (b.length - (len + off)) | (off + len)) < 0)\n            throw new indexoutofboundsexception();\n\n        for (int i = 0 ; i < len ; i++) {\n            write(b[off + i]);\n        }\n    }\n\n     // 强制刷新，将缓冲中的数据写入; 本质调用被装饰outputstream的方法\n    @override\n    public void flush() throws ioexception {\n        out.flush();\n    }\n\n    // 关闭stream\n    @override\n    public void close() throws ioexception {\n        // 如果已经close, 直接退出\n        if (closed) {\n            return;\n        }\n        // 加锁处理，如果已经有线程正在closing则退出；\n        synchronized (closelock) {\n            if (closed) {\n                return;\n            }\n            closed = true;\n        }\n\n        // close前调用flush\n        throwable flushexception = null;\n        try {\n            flush();\n        } catch (throwable e) {\n            flushexception = e;\n            throw e;\n        } finally {\n            if (flushexception == null) {\n                out.close();\n            } else {\n                try {\n                    out.close();\n                } catch (throwable closeexception) {\n                   // evaluate possible precedence of flushexception over closeexception\n                   if ((flushexception instanceof threaddeath) &&\n                       !(closeexception instanceof threaddeath)) {\n                       flushexception.addsuppressed(closeexception);\n                       throw (threaddeath) flushexception;\n                   }\n\n                    if (flushexception != closeexception) {\n                        closeexception.addsuppressed(flushexception);\n                    }\n\n                    throw closeexception;\n                }\n            }\n        }\n    }\n}\n\n\n@pdai: 对比下jdk8中，close方法是没有加锁处理的。这种情况下你可以看jdk8源码中，直接利用java7的try with resources方式，优雅的调用flush方法后对out进行关闭。\n\npublic void close() throws ioexception {\n    try (outputstream ostream = out) {\n        flush();\n    }\n}\n\n\n\n# bytearrayoutputstream\n\nbytearrayoutputstream 源码如下\n\npublic class bytearrayoutputstream extends outputstream {\n\n    // 实际的byte数组\n    protected byte buf[];\n\n    // 数组中实际有效的byte的个数\n    protected int count;\n\n    // 初始化默认构造，初始化byte数组大小为32\n    public bytearrayoutputstream() {\n        this(32);\n    }\n\n    // 初始化byte的大小\n    public bytearrayoutputstream(int size) {\n        if (size < 0) {\n            throw new illegalargumentexception("negative initial size: "\n                                               + size);\n        }\n        buf = new byte[size];\n    }\n\n    // 扩容，确保它至少可以容纳由最小容量参数指定的元素数\n    private void ensurecapacity(int mincapacity) {\n        // overflow-conscious code\n        if (mincapacity - buf.length > 0)\n            grow(mincapacity);\n    }\n\n    // 分配的最大数组大小。\n    // 由于一些vm在数组中保留一些头字，所以尝试分配较大的阵列可能会导致outofmemoryerror（请求的阵列大小超过vm限制）\n    private static final int max_array_size = integer.max_value - 8;\n\n    // 扩容的实质方法，确保它至少可以容纳由最小容量参数指定的元素数\n    private void grow(int mincapacity) {\n        // overflow-conscious code\n        int oldcapacity = buf.length;\n        int newcapacity = oldcapacity << 1;\n        if (newcapacity - mincapacity < 0)\n            newcapacity = mincapacity;\n        if (newcapacity - max_array_size > 0)\n            newcapacity = hugecapacity(mincapacity);\n        buf = arrays.copyof(buf, newcapacity);\n    }\n\n    private static int hugecapacity(int mincapacity) {\n        if (mincapacity < 0) // overflow\n            throw new outofmemoryerror();\n        return (mincapacity > max_array_size) ?\n            integer.max_value :\n            max_array_size;\n    }\n\n    // 写入，写入前确保byte数据长度\n    public synchronized void write(int b) {\n        ensurecapacity(count + 1);\n        buf[count] = (byte) b;\n        count += 1;\n    }\n\n    \n    public synchronized void write(byte b[], int off, int len) {\n        objects.checkfromindexsize(off, len, b.length);\n        ensurecapacity(count + len);\n        system.arraycopy(b, off, buf, count, len);\n        count += len;\n    }\n\n    public void writebytes(byte b[]) {\n        write(b, 0, b.length);\n    }\n\n    public synchronized void writeto(outputstream out) throws ioexception {\n        out.write(buf, 0, count);\n    }\n\n    // 重置，显然将实际有效的byte数量置为0\n    public synchronized void reset() {\n        count = 0;\n    }\n\n    \n    public synchronized byte[] tobytearray() {\n        return arrays.copyof(buf, count);\n    }\n\n    // 长度，即count\n    public synchronized int size() {\n        return count;\n    }\n\n    // 转成string\n    public synchronized string tostring() {\n        return new string(buf, 0, count);\n    }\n\n    // 转成string，指定的字符集\n    public synchronized string tostring(string charsetname)\n        throws unsupportedencodingexception\n    {\n        return new string(buf, 0, count, charsetname);\n    }\n\n    public synchronized string tostring(charset charset) {\n        return new string(buf, 0, count, charset);\n    }\n\n    // 弃用\n    @deprecated\n    public synchronized string tostring(int hibyte) {\n        return new string(buf, hibyte, 0, count);\n    }\n\n    // 对byte 数组而言，close没啥实质意义，所以空实现\n    public void close() throws ioexception {\n    }\n\n}\n\n\n\n# bufferedoutputstream\n\nbufferedoutputstream 源码如下\n\npublic class bufferedoutputstream extends filteroutputstream {\n    \n    // buffered outputstream底层也是byte数组\n    protected byte buf[];\n\n    // 大小，buf[0]到buf[count-1]是实际存储的bytes\n    protected int count;\n\n    // 构造函数，被装饰的outputstream，以及默认buf大小是8192\n    public bufferedoutputstream(outputstream out) {\n        this(out, 8192);\n    }\n\n    public bufferedoutputstream(outputstream out, int size) {\n        super(out);\n        if (size <= 0) {\n            throw new illegalargumentexception("buffer size <= 0");\n        }\n        buf = new byte[size];\n    }\n\n    /** flush the internal buffer */\n    // 内部的flush方法，将buffer中的有效bytes(count是有效的bytes大小)通过被装饰的outputstream写入\n    private void flushbuffer() throws ioexception {\n        if (count > 0) {\n            out.write(buf, 0, count);\n            count = 0;\n        }\n    }\n\n    // 写入byte\n    @override\n    public synchronized void write(int b) throws ioexception {\n        // 当buffer满了以后，flush buffer\n        if (count >= buf.length) {\n            flushbuffer();\n        }\n        buf[count++] = (byte)b;\n    }\n\n    // 将 byte 数组从 off 位置开始，len 长度的字节写入\n    @override\n    public synchronized void write(byte b[], int off, int len) throws ioexception {\n        if (len >= buf.length) {\n            // 如果请求长度已经超过输出缓冲区的大小，直接刷新输出缓冲区，然后直接写入数据。\n            flushbuffer();\n            out.write(b, off, len);\n            return;\n        }\n        if (len > buf.length - count) {\n            flushbuffer();\n        }\n        system.arraycopy(b, off, buf, count, len);\n        count += len;\n    }\n\n    // flush方法，需要先将buffer中写入，最后在调用被装饰outputstream的flush方法\n    @override\n    public synchronized void flush() throws ioexception {\n        flushbuffer();\n        out.flush();\n    }\n}\n\n\n\n# 参考文章\n\n * jdk 11',charsets:{cjk:!0}},{title:"Java IO - 设计模式(装饰者模式)",frontmatter:{},regularPath:"/java/io/java-io-basic-design-pattern.html",relativePath:"java/io/java-io-basic-design-pattern.md",key:"v-e0f7392c",path:"/java/io/java-io-basic-design-pattern.html",headers:[{level:2,title:"Java IO - 设计模式(装饰者模式)",slug:"java-io-设计模式-装饰者模式",normalizedTitle:"java io - 设计模式(装饰者模式)",charIndex:2},{level:2,title:"装饰者模式",slug:"装饰者模式",normalizedTitle:"装饰者模式",charIndex:17},{level:2,title:"IO 装饰者模式",slug:"io-装饰者模式",normalizedTitle:"io 装饰者模式",charIndex:323}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java IO - 设计模式(装饰者模式) 装饰者模式 IO 装饰者模式",content:"# Java IO - 设计模式(装饰者模式)\n\n> Java I/O 使用了装饰者模式来实现。@pdai\n\n\n# 装饰者模式\n\n请参考装饰者模式详解\n\n装饰者(Decorator)和具体组件(ConcreteComponent)都继承自组件(Component)，具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。\n\n\n\n\n# IO 装饰者模式\n\n以 InputStream 为例，\n\n * InputStream 是抽象组件；\n * FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；\n * FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。\n\n\n\n实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。\n\nFileInputStream fileInputStream = new FileInputStream(filePath);\nBufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);\n\n\nDataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。",normalizedContent:"# java io - 设计模式(装饰者模式)\n\n> java i/o 使用了装饰者模式来实现。@pdai\n\n\n# 装饰者模式\n\n请参考装饰者模式详解\n\n装饰者(decorator)和具体组件(concretecomponent)都继承自组件(component)，具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。\n\n\n\n\n# io 装饰者模式\n\n以 inputstream 为例，\n\n * inputstream 是抽象组件；\n * fileinputstream 是 inputstream 的子类，属于具体组件，提供了字节流的输入操作；\n * filterinputstream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 bufferedinputstream 为 fileinputstream 提供缓存的功能。\n\n\n\n实例化一个具有缓存功能的字节流对象时，只需要在 fileinputstream 对象上再套一层 bufferedinputstream 对象即可。\n\nfileinputstream fileinputstream = new fileinputstream(filepath);\nbufferedinputstream bufferedinputstream = new bufferedinputstream(fileinputstream);\n\n\ndatainputstream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。",charsets:{cjk:!0}},{title:"Java IO - BIO 详解",frontmatter:{},regularPath:"/java/io/java-io-bio.html",relativePath:"java/io/java-io-bio.md",key:"v-8b849c24",path:"/java/io/java-io-bio.html",headers:[{level:2,title:"Java IO - BIO 详解",slug:"java-io-bio-详解",normalizedTitle:"java io - bio 详解",charIndex:2},{level:2,title:"几个重要概念",slug:"几个重要概念",normalizedTitle:"几个重要概念",charIndex:199},{level:2,title:"传统的BIO通信方式简介",slug:"传统的bio通信方式简介",normalizedTitle:"传统的bio通信方式简介",charIndex:211},{level:3,title:"传统的BIO的问题",slug:"传统的bio的问题",normalizedTitle:"传统的bio的问题",charIndex:231},{level:3,title:"多线程方式 - 伪异步方式",slug:"多线程方式-伪异步方式",normalizedTitle:"多线程方式 - 伪异步方式",charIndex:248},{level:2,title:"BIO通信方式深入分析",slug:"bio通信方式深入分析",normalizedTitle:"bio通信方式深入分析",charIndex:267},{level:3,title:"模拟20个客户端并发请求，服务器端使用单线程:",slug:"模拟20个客户端并发请求-服务器端使用单线程",normalizedTitle:"模拟20个客户端并发请求，服务器端使用单线程:",charIndex:286},{level:3,title:"多线程来优化服务器端",slug:"多线程来优化服务器端",normalizedTitle:"多线程来优化服务器端",charIndex:317},{level:3,title:"看看服务器端的执行效果",slug:"看看服务器端的执行效果",normalizedTitle:"看看服务器端的执行效果",charIndex:335},{level:3,title:"问题根源",slug:"问题根源",normalizedTitle:"问题根源",charIndex:354},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:364}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java IO - BIO 详解 几个重要概念 传统的BIO通信方式简介 传统的BIO的问题 多线程方式 - 伪异步方式 BIO通信方式深入分析 模拟20个客户端并发请求，服务器端使用单线程: 多线程来优化服务器端 看看服务器端的执行效果 问题根源 参考文章",content:'# Java IO - BIO 详解\n\n> BIO就是: blocking IO。最容易理解、最容易实现的IO工作方式，应用程序向操作系统请求网络IO操作，这时应用程序会一直等待；另一方面，操作系统收到请求后，也会等待，直到网络上有数据传到监听端口；操作系统在收集数据后，会把数据发送给应用程序；最后应用程序受到数据，并解除等待状态。@pdai\n\n * Java IO - BIO 详解\n   * 几个重要概念\n   * 传统的BIO通信方式简介\n     * 传统的BIO的问题\n     * 多线程方式 - 伪异步方式\n   * BIO通信方式深入分析\n     * 模拟20个客户端并发请求，服务器端使用单线程:\n     * 多线程来优化服务器端\n     * 看看服务器端的执行效果\n     * 问题根源\n   * 参考文章\n\n\n# 几个重要概念\n\n * 阻塞IO 和 非阻塞IO\n\n这两个概念是程序级别的。主要描述的是程序请求操作系统IO操作后，如果IO资源没有准备好，那么程序该如何处理的问题: 前者等待；后者继续执行(并且使用线程一直轮询，直到有IO资源准备好了)\n\n * 同步IO 和 非同步IO\n\n这两个概念是操作系统级别的。主要描述的是操作系统在收到程序请求IO操作后，如果IO资源没有准备好，该如何响应程序的问题: 前者不响应，直到IO资源准备好以后；后者返回一个标记(好让程序和自己知道以后的数据往哪里通知)，当IO资源准备好以后，再用事件机制返回给程序。\n\n\n# 传统的BIO通信方式简介\n\n以前大多数网络通信方式都是阻塞模式的，即:\n\n * 客户端向服务器端发出请求后，客户端会一直等待(不会再做其他事情)，直到服务器端返回结果或者网络出现问题。\n\n * 服务器端同样的，当在处理某个客户端A发来的请求时，另一个客户端B发来的请求会等待，直到服务器端的这个处理线程完成上一个处理。\n\n\n\n\n# 传统的BIO的问题\n\n * 同一时间，服务器只能接受来自于客户端A的请求信息；虽然客户端A和客户端B的请求是同时进行的，但客户端B发送的请求信息只能等到服务器接受完A的请求数据后，才能被接受。\n\n * 由于服务器一次只能处理一个客户端请求，当处理完成并返回后(或者异常时)，才能进行第二次请求的处理。很显然，这样的处理方式在高并发的情况下，是不能采用的。\n\n\n# 多线程方式 - 伪异步方式\n\n上面说的情况是服务器只有一个线程的情况，那么读者会直接提出我们可以使用多线程技术来解决这个问题:\n\n * 当服务器收到客户端X的请求后，(读取到所有请求数据后)将这个请求送入一个独立线程进行处理，然后主线程继续接受客户端Y的请求。\n\n * 客户端一侧，也可以使用一个子线程和服务器端进行通信。这样客户端主线程的其他工作就不受影响了，当服务器端有响应信息的时候再由这个子线程通过 监听模式/观察模式(等其他设计模式)通知主线程。\n\n如下图所示:\n\n\n\n但是使用线程来解决这个问题实际上是有局限性的:\n\n * 虽然在服务器端，请求的处理交给了一个独立线程进行，但是操作系统通知accept()的方式还是单个的。也就是，实际上是服务器接收到数据报文后的“业务处理过程”可以多线程，但是数据报文的接受还是需要一个一个的来(下文的示例代码和debug过程我们可以明确看到这一点)\n\n * 在linux系统中，可以创建的线程是有限的。我们可以通过cat /proc/sys/kernel/threads-max 命令查看可以创建的最大线程数。当然这个值是可以更改的，但是线程越多，CPU切换所需的时间也就越长，用来处理真正业务的需求也就越少。\n\n * 创建一个线程是有较大的资源消耗的。JVM创建一个线程的时候，即使这个线程不做任何的工作，JVM都会分配一个堆栈空间。这个空间的大小默认为128K，您可以通过-Xss参数进行调整。当然您还可以使用ThreadPoolExecutor线程池来缓解线程的创建问题，但是又会造成BlockingQueue积压任务的持续增加，同样消耗了大量资源。\n\n * 另外，如果您的应用程序大量使用长连接的话，线程是不会关闭的。这样系统资源的消耗更容易失控。 那么，如果你真想单纯使用线程解决阻塞的问题，那么您自己都可以算出来您一个服务器节点可以一次接受多大的并发了。看来，单纯使用线程解决这个问题不是最好的办法。\n\n\n# BIO通信方式深入分析\n\nBIO的问题关键不在于是否使用了多线程(包括线程池)处理这次请求，而在于accept()、read()的操作点都是被阻塞。要测试这个问题，也很简单。我们模拟了20个客户端(用20根线程模拟)，利用JAVA的同步计数器CountDownLatch，保证这20个客户都初始化完成后然后同时向服务器发送请求，然后我们来观察一下Server这边接受信息的情况。\n\n\n# 模拟20个客户端并发请求，服务器端使用单线程:\n\n客户端代码(SocketClientDaemon)\n\npackage testBSocket;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class SocketClientDaemon {\n    public static void main(String[] args) throws Exception {\n        Integer clientNumber = 20;\n        CountDownLatch countDownLatch = new CountDownLatch(clientNumber);\n\n        //分别开始启动这20个客户端\n        for(int index = 0 ; index < clientNumber ; index++ , countDownLatch.countDown()) {\n            SocketClientRequestThread client = new SocketClientRequestThread(countDownLatch, index);\n            new Thread(client).start();\n        }\n\n        //这个wait不涉及到具体的实验逻辑，只是为了保证守护线程在启动所有线程后，进入等待状态\n        synchronized (SocketClientDaemon.class) {\n            SocketClientDaemon.class.wait();\n        }\n    }\n}\n\n\n客户端代码(SocketClientRequestThread模拟请求)\n\npackage testBSocket;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.concurrent.CountDownLatch;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.log4j.BasicConfigurator;\n\n/**\n * 一个SocketClientRequestThread线程模拟一个客户端请求。\n * @author yinwenjie\n */\npublic class SocketClientRequestThread implements Runnable {\n\n    static {\n        BasicConfigurator.configure();\n    }\n\n    /**\n     * 日志\n     */\n    private static final Log LOGGER = LogFactory.getLog(SocketClientRequestThread.class);\n\n    private CountDownLatch countDownLatch;\n\n    /**\n     * 这个线层的编号\n     * @param countDownLatch\n     */\n    private Integer clientIndex;\n\n    /**\n     * countDownLatch是java提供的同步计数器。\n     * 当计数器数值减为0时，所有受其影响而等待的线程将会被激活。这样保证模拟并发请求的真实性\n     * @param countDownLatch\n     */\n    public SocketClientRequestThread(CountDownLatch countDownLatch , Integer clientIndex) {\n        this.countDownLatch = countDownLatch;\n        this.clientIndex = clientIndex;\n    }\n\n    @Override\n    public void run() {\n        Socket socket = null;\n        OutputStream clientRequest = null;\n        InputStream clientResponse = null;\n\n        try {\n            socket = new Socket("localhost",83);\n            clientRequest = socket.getOutputStream();\n            clientResponse = socket.getInputStream();\n\n            //等待，直到SocketClientDaemon完成所有线程的启动，然后所有线程一起发送请求\n            this.countDownLatch.await();\n\n            //发送请求信息\n            clientRequest.write(("这是第" + this.clientIndex + " 个客户端的请求。").getBytes());\n            clientRequest.flush();\n\n            //在这里等待，直到服务器返回信息\n            SocketClientRequestThread.LOGGER.info("第" + this.clientIndex + "个客户端的请求发送完成，等待服务器返回信息");\n            int maxLen = 1024;\n            byte[] contextBytes = new byte[maxLen];\n            int realLen;\n            String message = "";\n            //程序执行到这里，会一直等待服务器返回信息(注意，前提是in和out都不能close，如果close了就收不到服务器的反馈了)\n            while((realLen = clientResponse.read(contextBytes, 0, maxLen)) != -1) {\n                message += new String(contextBytes , 0 , realLen);\n            }\n            SocketClientRequestThread.LOGGER.info("接收到来自服务器的信息:" + message);\n        } catch (Exception e) {\n            SocketClientRequestThread.LOGGER.error(e.getMessage(), e);\n        } finally {\n            try {\n                if(clientRequest != null) {\n                    clientRequest.close();\n                }\n                if(clientResponse != null) {\n                    clientResponse.close();\n                }\n            } catch (IOException e) {\n                SocketClientRequestThread.LOGGER.error(e.getMessage(), e);\n            }\n        }\n    }\n}\n\n\n服务器端(SocketServer1)单个线程\n\npackage testBSocket;\n\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class SocketServer1 {\n\n    static {\n        BasicConfigurator.configure();\n    }\n\n    /**\n     * 日志\n     */\n    private static final Log LOGGER = LogFactory.getLog(SocketServer1.class);\n\n    public static void main(String[] args) throws Exception{\n        ServerSocket serverSocket = new ServerSocket(83);\n\n        try {\n            while(true) {\n                Socket socket = serverSocket.accept();\n\n                //下面我们收取信息\n                InputStream in = socket.getInputStream();\n                OutputStream out = socket.getOutputStream();\n                Integer sourcePort = socket.getPort();\n                int maxLen = 2048;\n                byte[] contextBytes = new byte[maxLen];\n                //这里也会被阻塞，直到有数据准备好\n                int realLen = in.read(contextBytes, 0, maxLen);\n                //读取信息\n                String message = new String(contextBytes , 0 , realLen);\n\n                //下面打印信息\n                SocketServer1.LOGGER.info("服务器收到来自于端口: " + sourcePort + "的信息: " + message);\n\n                //下面开始发送信息\n                out.write("回发响应信息！".getBytes());\n\n                //关闭\n                out.close();\n                in.close();\n                socket.close();\n            }\n        } catch(Exception e) {\n            SocketServer1.LOGGER.error(e.getMessage(), e);\n        } finally {\n            if(serverSocket != null) {\n                serverSocket.close();\n            }\n        }\n    }\n}\n\n\n\n# 多线程来优化服务器端\n\n客户端代码和上文一样，最主要是更改服务器端的代码:\n\npackage testBSocket;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class SocketServer2 {\n\n    static {\n        BasicConfigurator.configure();\n    }\n\n    private static final Log LOGGER = LogFactory.getLog(SocketServer2.class);\n\n    public static void main(String[] args) throws Exception{\n        ServerSocket serverSocket = new ServerSocket(83);\n\n        try {\n            while(true) {\n                Socket socket = serverSocket.accept();\n                //当然业务处理过程可以交给一个线程(这里可以使用线程池),并且线程的创建是很耗资源的。\n                //最终改变不了.accept()只能一个一个接受socket的情况,并且被阻塞的情况\n                SocketServerThread socketServerThread = new SocketServerThread(socket);\n                new Thread(socketServerThread).start();\n            }\n        } catch(Exception e) {\n            SocketServer2.LOGGER.error(e.getMessage(), e);\n        } finally {\n            if(serverSocket != null) {\n                serverSocket.close();\n            }\n        }\n    }\n}\n\n/**\n * 当然，接收到客户端的socket后，业务的处理过程可以交给一个线程来做。\n * 但还是改变不了socket被一个一个的做accept()的情况。\n * @author yinwenjie\n */\nclass SocketServerThread implements Runnable {\n\n    /**\n     * 日志\n     */\n    private static final Log LOGGER = LogFactory.getLog(SocketServerThread.class);\n\n    private Socket socket;\n\n    public SocketServerThread (Socket socket) {\n        this.socket = socket;\n    }\n\n    @Override\n    public void run() {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            //下面我们收取信息\n            in = socket.getInputStream();\n            out = socket.getOutputStream();\n            Integer sourcePort = socket.getPort();\n            int maxLen = 1024;\n            byte[] contextBytes = new byte[maxLen];\n            //使用线程，同样无法解决read方法的阻塞问题，\n            //也就是说read方法处同样会被阻塞，直到操作系统有数据准备好\n            int realLen = in.read(contextBytes, 0, maxLen);\n            //读取信息\n            String message = new String(contextBytes , 0 , realLen);\n\n            //下面打印信息\n            SocketServerThread.LOGGER.info("服务器收到来自于端口: " + sourcePort + "的信息: " + message);\n\n            //下面开始发送信息\n            out.write("回发响应信息！".getBytes());\n        } catch(Exception e) {\n            SocketServerThread.LOGGER.error(e.getMessage(), e);\n        } finally {\n            //试图关闭\n            try {\n                if(in != null) {\n                    in.close();\n                }\n                if(out != null) {\n                    out.close();\n                }\n                if(this.socket != null) {\n                    this.socket.close();\n                }\n            } catch (IOException e) {\n                SocketServerThread.LOGGER.error(e.getMessage(), e);\n            }\n        }\n    }\n}\n\n\n\n# 看看服务器端的执行效果\n\n我们主要看一看服务器使用多线程处理时的情况:\n\n\n\n\n# 问题根源\n\n那么重点的问题并不是“是否使用了多线程”，而是为什么accept()、read()方法会被阻塞。即: 异步IO模式 就是为了解决这样的并发性存在的。但是为了说清楚异步IO模式，在介绍IO模式的时候，我们就要首先了解清楚，什么是 阻塞式同步、非阻塞式同步、多路复用同步模式。\n\nAPI文档中对于 serverSocket.accept() 方法的使用描述:\n\n> Listens for a connection to be made to this socket and accepts it. The method blocks until a connection is made.\n\nserverSocket.accept()会被阻塞? 这里涉及到阻塞式同步IO的工作原理:\n\n * 服务器线程发起一个accept动作，询问操作系统 是否有新的socket套接字信息从端口X发送过来。\n\n\n\n * 注意，是询问操作系统。也就是说socket套接字的IO模式支持是基于操作系统的，那么自然同步IO/异步IO的支持就是需要操作系统级别的了。如下图:\n\n\n\n\n\n如果操作系统没有发现有套接字从指定的端口X来，那么操作系统就会等待。这样serverSocket.accept()方法就会一直等待。这就是为什么accept()方法为什么会阻塞: 它内部的实现是使用的操作系统级别的同步IO。\n\n\n# 参考文章\n\n * 文章主要来源于: 银文杰，笔名“说好不能打脸”，博客地址在新窗口打开。他的书《高性能服务系统构建与实战》。\n * https://blog.csdn.net/yinwenjie/article/details/48274255',normalizedContent:'# java io - bio 详解\n\n> bio就是: blocking io。最容易理解、最容易实现的io工作方式，应用程序向操作系统请求网络io操作，这时应用程序会一直等待；另一方面，操作系统收到请求后，也会等待，直到网络上有数据传到监听端口；操作系统在收集数据后，会把数据发送给应用程序；最后应用程序受到数据，并解除等待状态。@pdai\n\n * java io - bio 详解\n   * 几个重要概念\n   * 传统的bio通信方式简介\n     * 传统的bio的问题\n     * 多线程方式 - 伪异步方式\n   * bio通信方式深入分析\n     * 模拟20个客户端并发请求，服务器端使用单线程:\n     * 多线程来优化服务器端\n     * 看看服务器端的执行效果\n     * 问题根源\n   * 参考文章\n\n\n# 几个重要概念\n\n * 阻塞io 和 非阻塞io\n\n这两个概念是程序级别的。主要描述的是程序请求操作系统io操作后，如果io资源没有准备好，那么程序该如何处理的问题: 前者等待；后者继续执行(并且使用线程一直轮询，直到有io资源准备好了)\n\n * 同步io 和 非同步io\n\n这两个概念是操作系统级别的。主要描述的是操作系统在收到程序请求io操作后，如果io资源没有准备好，该如何响应程序的问题: 前者不响应，直到io资源准备好以后；后者返回一个标记(好让程序和自己知道以后的数据往哪里通知)，当io资源准备好以后，再用事件机制返回给程序。\n\n\n# 传统的bio通信方式简介\n\n以前大多数网络通信方式都是阻塞模式的，即:\n\n * 客户端向服务器端发出请求后，客户端会一直等待(不会再做其他事情)，直到服务器端返回结果或者网络出现问题。\n\n * 服务器端同样的，当在处理某个客户端a发来的请求时，另一个客户端b发来的请求会等待，直到服务器端的这个处理线程完成上一个处理。\n\n\n\n\n# 传统的bio的问题\n\n * 同一时间，服务器只能接受来自于客户端a的请求信息；虽然客户端a和客户端b的请求是同时进行的，但客户端b发送的请求信息只能等到服务器接受完a的请求数据后，才能被接受。\n\n * 由于服务器一次只能处理一个客户端请求，当处理完成并返回后(或者异常时)，才能进行第二次请求的处理。很显然，这样的处理方式在高并发的情况下，是不能采用的。\n\n\n# 多线程方式 - 伪异步方式\n\n上面说的情况是服务器只有一个线程的情况，那么读者会直接提出我们可以使用多线程技术来解决这个问题:\n\n * 当服务器收到客户端x的请求后，(读取到所有请求数据后)将这个请求送入一个独立线程进行处理，然后主线程继续接受客户端y的请求。\n\n * 客户端一侧，也可以使用一个子线程和服务器端进行通信。这样客户端主线程的其他工作就不受影响了，当服务器端有响应信息的时候再由这个子线程通过 监听模式/观察模式(等其他设计模式)通知主线程。\n\n如下图所示:\n\n\n\n但是使用线程来解决这个问题实际上是有局限性的:\n\n * 虽然在服务器端，请求的处理交给了一个独立线程进行，但是操作系统通知accept()的方式还是单个的。也就是，实际上是服务器接收到数据报文后的“业务处理过程”可以多线程，但是数据报文的接受还是需要一个一个的来(下文的示例代码和debug过程我们可以明确看到这一点)\n\n * 在linux系统中，可以创建的线程是有限的。我们可以通过cat /proc/sys/kernel/threads-max 命令查看可以创建的最大线程数。当然这个值是可以更改的，但是线程越多，cpu切换所需的时间也就越长，用来处理真正业务的需求也就越少。\n\n * 创建一个线程是有较大的资源消耗的。jvm创建一个线程的时候，即使这个线程不做任何的工作，jvm都会分配一个堆栈空间。这个空间的大小默认为128k，您可以通过-xss参数进行调整。当然您还可以使用threadpoolexecutor线程池来缓解线程的创建问题，但是又会造成blockingqueue积压任务的持续增加，同样消耗了大量资源。\n\n * 另外，如果您的应用程序大量使用长连接的话，线程是不会关闭的。这样系统资源的消耗更容易失控。 那么，如果你真想单纯使用线程解决阻塞的问题，那么您自己都可以算出来您一个服务器节点可以一次接受多大的并发了。看来，单纯使用线程解决这个问题不是最好的办法。\n\n\n# bio通信方式深入分析\n\nbio的问题关键不在于是否使用了多线程(包括线程池)处理这次请求，而在于accept()、read()的操作点都是被阻塞。要测试这个问题，也很简单。我们模拟了20个客户端(用20根线程模拟)，利用java的同步计数器countdownlatch，保证这20个客户都初始化完成后然后同时向服务器发送请求，然后我们来观察一下server这边接受信息的情况。\n\n\n# 模拟20个客户端并发请求，服务器端使用单线程:\n\n客户端代码(socketclientdaemon)\n\npackage testbsocket;\n\nimport java.util.concurrent.countdownlatch;\n\npublic class socketclientdaemon {\n    public static void main(string[] args) throws exception {\n        integer clientnumber = 20;\n        countdownlatch countdownlatch = new countdownlatch(clientnumber);\n\n        //分别开始启动这20个客户端\n        for(int index = 0 ; index < clientnumber ; index++ , countdownlatch.countdown()) {\n            socketclientrequestthread client = new socketclientrequestthread(countdownlatch, index);\n            new thread(client).start();\n        }\n\n        //这个wait不涉及到具体的实验逻辑，只是为了保证守护线程在启动所有线程后，进入等待状态\n        synchronized (socketclientdaemon.class) {\n            socketclientdaemon.class.wait();\n        }\n    }\n}\n\n\n客户端代码(socketclientrequestthread模拟请求)\n\npackage testbsocket;\n\nimport java.io.ioexception;\nimport java.io.inputstream;\nimport java.io.outputstream;\nimport java.net.socket;\nimport java.util.concurrent.countdownlatch;\n\nimport org.apache.commons.logging.log;\nimport org.apache.commons.logging.logfactory;\nimport org.apache.log4j.basicconfigurator;\n\n/**\n * 一个socketclientrequestthread线程模拟一个客户端请求。\n * @author yinwenjie\n */\npublic class socketclientrequestthread implements runnable {\n\n    static {\n        basicconfigurator.configure();\n    }\n\n    /**\n     * 日志\n     */\n    private static final log logger = logfactory.getlog(socketclientrequestthread.class);\n\n    private countdownlatch countdownlatch;\n\n    /**\n     * 这个线层的编号\n     * @param countdownlatch\n     */\n    private integer clientindex;\n\n    /**\n     * countdownlatch是java提供的同步计数器。\n     * 当计数器数值减为0时，所有受其影响而等待的线程将会被激活。这样保证模拟并发请求的真实性\n     * @param countdownlatch\n     */\n    public socketclientrequestthread(countdownlatch countdownlatch , integer clientindex) {\n        this.countdownlatch = countdownlatch;\n        this.clientindex = clientindex;\n    }\n\n    @override\n    public void run() {\n        socket socket = null;\n        outputstream clientrequest = null;\n        inputstream clientresponse = null;\n\n        try {\n            socket = new socket("localhost",83);\n            clientrequest = socket.getoutputstream();\n            clientresponse = socket.getinputstream();\n\n            //等待，直到socketclientdaemon完成所有线程的启动，然后所有线程一起发送请求\n            this.countdownlatch.await();\n\n            //发送请求信息\n            clientrequest.write(("这是第" + this.clientindex + " 个客户端的请求。").getbytes());\n            clientrequest.flush();\n\n            //在这里等待，直到服务器返回信息\n            socketclientrequestthread.logger.info("第" + this.clientindex + "个客户端的请求发送完成，等待服务器返回信息");\n            int maxlen = 1024;\n            byte[] contextbytes = new byte[maxlen];\n            int reallen;\n            string message = "";\n            //程序执行到这里，会一直等待服务器返回信息(注意，前提是in和out都不能close，如果close了就收不到服务器的反馈了)\n            while((reallen = clientresponse.read(contextbytes, 0, maxlen)) != -1) {\n                message += new string(contextbytes , 0 , reallen);\n            }\n            socketclientrequestthread.logger.info("接收到来自服务器的信息:" + message);\n        } catch (exception e) {\n            socketclientrequestthread.logger.error(e.getmessage(), e);\n        } finally {\n            try {\n                if(clientrequest != null) {\n                    clientrequest.close();\n                }\n                if(clientresponse != null) {\n                    clientresponse.close();\n                }\n            } catch (ioexception e) {\n                socketclientrequestthread.logger.error(e.getmessage(), e);\n            }\n        }\n    }\n}\n\n\n服务器端(socketserver1)单个线程\n\npackage testbsocket;\n\nimport java.io.inputstream;\nimport java.io.outputstream;\nimport java.net.serversocket;\nimport java.net.socket;\n\nimport org.apache.commons.logging.log;\nimport org.apache.commons.logging.logfactory;\nimport org.apache.log4j.basicconfigurator;\n\npublic class socketserver1 {\n\n    static {\n        basicconfigurator.configure();\n    }\n\n    /**\n     * 日志\n     */\n    private static final log logger = logfactory.getlog(socketserver1.class);\n\n    public static void main(string[] args) throws exception{\n        serversocket serversocket = new serversocket(83);\n\n        try {\n            while(true) {\n                socket socket = serversocket.accept();\n\n                //下面我们收取信息\n                inputstream in = socket.getinputstream();\n                outputstream out = socket.getoutputstream();\n                integer sourceport = socket.getport();\n                int maxlen = 2048;\n                byte[] contextbytes = new byte[maxlen];\n                //这里也会被阻塞，直到有数据准备好\n                int reallen = in.read(contextbytes, 0, maxlen);\n                //读取信息\n                string message = new string(contextbytes , 0 , reallen);\n\n                //下面打印信息\n                socketserver1.logger.info("服务器收到来自于端口: " + sourceport + "的信息: " + message);\n\n                //下面开始发送信息\n                out.write("回发响应信息！".getbytes());\n\n                //关闭\n                out.close();\n                in.close();\n                socket.close();\n            }\n        } catch(exception e) {\n            socketserver1.logger.error(e.getmessage(), e);\n        } finally {\n            if(serversocket != null) {\n                serversocket.close();\n            }\n        }\n    }\n}\n\n\n\n# 多线程来优化服务器端\n\n客户端代码和上文一样，最主要是更改服务器端的代码:\n\npackage testbsocket;\n\nimport java.io.ioexception;\nimport java.io.inputstream;\nimport java.io.outputstream;\nimport java.net.serversocket;\nimport java.net.socket;\n\nimport org.apache.commons.logging.log;\nimport org.apache.commons.logging.logfactory;\nimport org.apache.log4j.basicconfigurator;\n\npublic class socketserver2 {\n\n    static {\n        basicconfigurator.configure();\n    }\n\n    private static final log logger = logfactory.getlog(socketserver2.class);\n\n    public static void main(string[] args) throws exception{\n        serversocket serversocket = new serversocket(83);\n\n        try {\n            while(true) {\n                socket socket = serversocket.accept();\n                //当然业务处理过程可以交给一个线程(这里可以使用线程池),并且线程的创建是很耗资源的。\n                //最终改变不了.accept()只能一个一个接受socket的情况,并且被阻塞的情况\n                socketserverthread socketserverthread = new socketserverthread(socket);\n                new thread(socketserverthread).start();\n            }\n        } catch(exception e) {\n            socketserver2.logger.error(e.getmessage(), e);\n        } finally {\n            if(serversocket != null) {\n                serversocket.close();\n            }\n        }\n    }\n}\n\n/**\n * 当然，接收到客户端的socket后，业务的处理过程可以交给一个线程来做。\n * 但还是改变不了socket被一个一个的做accept()的情况。\n * @author yinwenjie\n */\nclass socketserverthread implements runnable {\n\n    /**\n     * 日志\n     */\n    private static final log logger = logfactory.getlog(socketserverthread.class);\n\n    private socket socket;\n\n    public socketserverthread (socket socket) {\n        this.socket = socket;\n    }\n\n    @override\n    public void run() {\n        inputstream in = null;\n        outputstream out = null;\n        try {\n            //下面我们收取信息\n            in = socket.getinputstream();\n            out = socket.getoutputstream();\n            integer sourceport = socket.getport();\n            int maxlen = 1024;\n            byte[] contextbytes = new byte[maxlen];\n            //使用线程，同样无法解决read方法的阻塞问题，\n            //也就是说read方法处同样会被阻塞，直到操作系统有数据准备好\n            int reallen = in.read(contextbytes, 0, maxlen);\n            //读取信息\n            string message = new string(contextbytes , 0 , reallen);\n\n            //下面打印信息\n            socketserverthread.logger.info("服务器收到来自于端口: " + sourceport + "的信息: " + message);\n\n            //下面开始发送信息\n            out.write("回发响应信息！".getbytes());\n        } catch(exception e) {\n            socketserverthread.logger.error(e.getmessage(), e);\n        } finally {\n            //试图关闭\n            try {\n                if(in != null) {\n                    in.close();\n                }\n                if(out != null) {\n                    out.close();\n                }\n                if(this.socket != null) {\n                    this.socket.close();\n                }\n            } catch (ioexception e) {\n                socketserverthread.logger.error(e.getmessage(), e);\n            }\n        }\n    }\n}\n\n\n\n# 看看服务器端的执行效果\n\n我们主要看一看服务器使用多线程处理时的情况:\n\n\n\n\n# 问题根源\n\n那么重点的问题并不是“是否使用了多线程”，而是为什么accept()、read()方法会被阻塞。即: 异步io模式 就是为了解决这样的并发性存在的。但是为了说清楚异步io模式，在介绍io模式的时候，我们就要首先了解清楚，什么是 阻塞式同步、非阻塞式同步、多路复用同步模式。\n\napi文档中对于 serversocket.accept() 方法的使用描述:\n\n> listens for a connection to be made to this socket and accepts it. the method blocks until a connection is made.\n\nserversocket.accept()会被阻塞? 这里涉及到阻塞式同步io的工作原理:\n\n * 服务器线程发起一个accept动作，询问操作系统 是否有新的socket套接字信息从端口x发送过来。\n\n\n\n * 注意，是询问操作系统。也就是说socket套接字的io模式支持是基于操作系统的，那么自然同步io/异步io的支持就是需要操作系统级别的了。如下图:\n\n\n\n\n\n如果操作系统没有发现有套接字从指定的端口x来，那么操作系统就会等待。这样serversocket.accept()方法就会一直等待。这就是为什么accept()方法为什么会阻塞: 它内部的实现是使用的操作系统级别的同步io。\n\n\n# 参考文章\n\n * 文章主要来源于: 银文杰，笔名“说好不能打脸”，博客地址在新窗口打开。他的书《高性能服务系统构建与实战》。\n * https://blog.csdn.net/yinwenjie/article/details/48274255',charsets:{cjk:!0}},{title:"Java IO - 常见类使用",frontmatter:{},regularPath:"/java/io/java-io-basic-usage.html",relativePath:"java/io/java-io-basic-usage.md",key:"v-3ff5c12e",path:"/java/io/java-io-basic-usage.html",headers:[{level:2,title:"Java IO - 常见类使用",slug:"java-io-常见类使用",normalizedTitle:"java io - 常见类使用",charIndex:2},{level:2,title:"IO常见类的使用",slug:"io常见类的使用",normalizedTitle:"io常见类的使用",charIndex:32},{level:3,title:"File相关",slug:"file相关",normalizedTitle:"file相关",charIndex:117},{level:3,title:"字节流相关",slug:"字节流相关",normalizedTitle:"字节流相关",charIndex:131},{level:3,title:"实现逐行输出文本文件的内容",slug:"实现逐行输出文本文件的内容",normalizedTitle:"实现逐行输出文本文件的内容",charIndex:144},{level:3,title:"序列化 & Serializable & transient",slug:"序列化-serializable-transient",normalizedTitle:"序列化 &amp; serializable &amp; transient",charIndex:null},{level:3,title:"Java 中的网络支持:",slug:"java-中的网络支持",normalizedTitle:"java 中的网络支持:",charIndex:203},{level:2,title:"常见问题",slug:"常见问题",normalizedTitle:"常见问题",charIndex:290},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:300}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java IO - 常见类使用 IO常见类的使用 File相关 字节流相关 实现逐行输出文本文件的内容 序列化 & Serializable & transient Java 中的网络支持: 常见问题 参考文章",content:'# Java IO - 常见类使用\n\n> 本文主要介绍Java IO常见类的使用，包括：磁盘操作，字节操作，字符操作，对象操作和网络操作。 @pdai\n\n * Java IO - 常见类使用\n   * IO常见类的使用\n     * File相关\n     * 字节流相关\n     * 实现逐行输出文本文件的内容\n     * 序列化 & Serializable & transient\n     * Java 中的网络支持:\n       * InetAddress\n       * URL\n       * Sockets\n       * Datagram\n   * 常见问题\n   * 参考文章\n\n\n# IO常见类的使用\n\nJava 的 I/O 大概可以分成以下几类:\n\n * 磁盘操作: File\n * 字节操作: InputStream 和 OutputStream\n * 字符操作: Reader 和 Writer\n * 对象操作: Serializable\n * 网络操作: Socket\n\n\n# File相关\n\nFile 类可以用于表示文件和目录的信息，但是它不表示文件的内容。\n\n递归地列出一个目录下所有文件:\n\npublic static void listAllFiles(File dir) {\n    if (dir == null || !dir.exists()) {\n        return;\n    }\n    if (dir.isFile()) {\n        System.out.println(dir.getName());\n        return;\n    }\n    for (File file : dir.listFiles()) {\n        listAllFiles(file);\n    }\n}\n\n\n\n# 字节流相关\n\npublic static void copyFile(String src, String dist) throws IOException {\n\n    FileInputStream in = new FileInputStream(src);\n    FileOutputStream out = new FileOutputStream(dist);\n    byte[] buffer = new byte[20 * 1024];\n\n    // read() 最多读取 buffer.length 个字节\n    // 返回的是实际读取的个数\n    // 返回 -1 的时候表示读到 eof，即文件尾\n    while (in.read(buffer, 0, buffer.length) != -1) {\n        out.write(buffer);\n    }\n\n    in.close();\n    out.close();\n}\n\n\n\n# 实现逐行输出文本文件的内容\n\npublic static void readFileContent(String filePath) throws IOException {\n\n    FileReader fileReader = new FileReader(filePath);\n    BufferedReader bufferedReader = new BufferedReader(fileReader);\n\n    String line;\n    while ((line = bufferedReader.readLine()) != null) {\n        System.out.println(line);\n    }\n\n    // 装饰者模式使得 BufferedReader 组合了一个 Reader 对象\n    // 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法\n    // 因此只要一个 close() 调用即可\n    bufferedReader.close();\n}\n\n\n\n# 序列化 & Serializable & transient\n\n序列化就是将一个对象转换成字节序列，方便存储和传输。\n\n * 序列化: ObjectOutputStream.writeObject()\n * 反序列化: ObjectInputStream.readObject()\n\n不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。\n\nSerializable\n\n序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。\n\npublic static void main(String[] args) throws IOException, ClassNotFoundException {\n    A a1 = new A(123, "abc");\n    String objectFile = "file/a1";\n    ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(objectFile));\n    objectOutputStream.writeObject(a1);\n    objectOutputStream.close();\n\n    ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(objectFile));\n    A a2 = (A) objectInputStream.readObject();\n    objectInputStream.close();\n    System.out.println(a2);\n}\n\nprivate static class A implements Serializable {\n    private int x;\n    private String y;\n\n    A(int x, String y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    @Override\n    public String toString() {\n        return "x = " + x + "  " + "y = " + y;\n    }\n}\n\n\ntransient\n\ntransient 关键字可以使一些属性不会被序列化。\n\nArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。\n\nprivate transient Object[] elementData;\n\n\n\n# Java 中的网络支持:\n\n * InetAddress: 用于表示网络上的硬件资源，即 IP 地址；\n * URL: 统一资源定位符；\n * Sockets: 使用 TCP 协议实现网络通信；\n * Datagram: 使用 UDP 协议实现网络通信。\n\n# InetAddress\n\n没有公有的构造函数，只能通过静态方法来创建实例。\n\nInetAddress.getByName(String host);\nInetAddress.getByAddress(byte[] address);\n\n\n# URL\n\n可以直接从 URL 中读取字节流数据。\n\npublic static void main(String[] args) throws IOException {\n\n    URL url = new URL("http://www.baidu.com");\n\n    /* 字节流 */\n    InputStream is = url.openStream();\n\n    /* 字符流 */\n    InputStreamReader isr = new InputStreamReader(is, "utf-8");\n\n    /* 提供缓存功能 */\n    BufferedReader br = new BufferedReader(isr);\n\n    String line;\n    while ((line = br.readLine()) != null) {\n        System.out.println(line);\n    }\n\n    br.close();\n}\n\n\n# Sockets\n\n * ServerSocket: 服务器端类\n * Socket: 客户端类\n * 服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。\n\n\n\n# Datagram\n\n * DatagramSocket: 通信类\n * DatagramPacket: 数据包类\n\n\n# 常见问题\n\n * Java 字节读取流的read方法返回int的原因\n\nhttps://blog.csdn.net/congwiny/article/details/18922847\n\n\n# 参考文章',normalizedContent:'# java io - 常见类使用\n\n> 本文主要介绍java io常见类的使用，包括：磁盘操作，字节操作，字符操作，对象操作和网络操作。 @pdai\n\n * java io - 常见类使用\n   * io常见类的使用\n     * file相关\n     * 字节流相关\n     * 实现逐行输出文本文件的内容\n     * 序列化 & serializable & transient\n     * java 中的网络支持:\n       * inetaddress\n       * url\n       * sockets\n       * datagram\n   * 常见问题\n   * 参考文章\n\n\n# io常见类的使用\n\njava 的 i/o 大概可以分成以下几类:\n\n * 磁盘操作: file\n * 字节操作: inputstream 和 outputstream\n * 字符操作: reader 和 writer\n * 对象操作: serializable\n * 网络操作: socket\n\n\n# file相关\n\nfile 类可以用于表示文件和目录的信息，但是它不表示文件的内容。\n\n递归地列出一个目录下所有文件:\n\npublic static void listallfiles(file dir) {\n    if (dir == null || !dir.exists()) {\n        return;\n    }\n    if (dir.isfile()) {\n        system.out.println(dir.getname());\n        return;\n    }\n    for (file file : dir.listfiles()) {\n        listallfiles(file);\n    }\n}\n\n\n\n# 字节流相关\n\npublic static void copyfile(string src, string dist) throws ioexception {\n\n    fileinputstream in = new fileinputstream(src);\n    fileoutputstream out = new fileoutputstream(dist);\n    byte[] buffer = new byte[20 * 1024];\n\n    // read() 最多读取 buffer.length 个字节\n    // 返回的是实际读取的个数\n    // 返回 -1 的时候表示读到 eof，即文件尾\n    while (in.read(buffer, 0, buffer.length) != -1) {\n        out.write(buffer);\n    }\n\n    in.close();\n    out.close();\n}\n\n\n\n# 实现逐行输出文本文件的内容\n\npublic static void readfilecontent(string filepath) throws ioexception {\n\n    filereader filereader = new filereader(filepath);\n    bufferedreader bufferedreader = new bufferedreader(filereader);\n\n    string line;\n    while ((line = bufferedreader.readline()) != null) {\n        system.out.println(line);\n    }\n\n    // 装饰者模式使得 bufferedreader 组合了一个 reader 对象\n    // 在调用 bufferedreader 的 close() 方法时会去调用 reader 的 close() 方法\n    // 因此只要一个 close() 调用即可\n    bufferedreader.close();\n}\n\n\n\n# 序列化 & serializable & transient\n\n序列化就是将一个对象转换成字节序列，方便存储和传输。\n\n * 序列化: objectoutputstream.writeobject()\n * 反序列化: objectinputstream.readobject()\n\n不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。\n\nserializable\n\n序列化的类需要实现 serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。\n\npublic static void main(string[] args) throws ioexception, classnotfoundexception {\n    a a1 = new a(123, "abc");\n    string objectfile = "file/a1";\n    objectoutputstream objectoutputstream = new objectoutputstream(new fileoutputstream(objectfile));\n    objectoutputstream.writeobject(a1);\n    objectoutputstream.close();\n\n    objectinputstream objectinputstream = new objectinputstream(new fileinputstream(objectfile));\n    a a2 = (a) objectinputstream.readobject();\n    objectinputstream.close();\n    system.out.println(a2);\n}\n\nprivate static class a implements serializable {\n    private int x;\n    private string y;\n\n    a(int x, string y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    @override\n    public string tostring() {\n        return "x = " + x + "  " + "y = " + y;\n    }\n}\n\n\ntransient\n\ntransient 关键字可以使一些属性不会被序列化。\n\narraylist 中存储数据的数组 elementdata 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。\n\nprivate transient object[] elementdata;\n\n\n\n# java 中的网络支持:\n\n * inetaddress: 用于表示网络上的硬件资源，即 ip 地址；\n * url: 统一资源定位符；\n * sockets: 使用 tcp 协议实现网络通信；\n * datagram: 使用 udp 协议实现网络通信。\n\n# inetaddress\n\n没有公有的构造函数，只能通过静态方法来创建实例。\n\ninetaddress.getbyname(string host);\ninetaddress.getbyaddress(byte[] address);\n\n\n# url\n\n可以直接从 url 中读取字节流数据。\n\npublic static void main(string[] args) throws ioexception {\n\n    url url = new url("http://www.baidu.com");\n\n    /* 字节流 */\n    inputstream is = url.openstream();\n\n    /* 字符流 */\n    inputstreamreader isr = new inputstreamreader(is, "utf-8");\n\n    /* 提供缓存功能 */\n    bufferedreader br = new bufferedreader(isr);\n\n    string line;\n    while ((line = br.readline()) != null) {\n        system.out.println(line);\n    }\n\n    br.close();\n}\n\n\n# sockets\n\n * serversocket: 服务器端类\n * socket: 客户端类\n * 服务器和客户端通过 inputstream 和 outputstream 进行输入输出。\n\n\n\n# datagram\n\n * datagramsocket: 通信类\n * datagrampacket: 数据包类\n\n\n# 常见问题\n\n * java 字节读取流的read方法返回int的原因\n\nhttps://blog.csdn.net/congwiny/article/details/18922847\n\n\n# 参考文章',charsets:{cjk:!0}},{title:"IO 模型 - Unix IO 模型",frontmatter:{},regularPath:"/java/io/java-io-model.html",relativePath:"java/io/java-io-model.md",key:"v-4b0b72ce",path:"/java/io/java-io-model.html",headers:[{level:2,title:"IO 模型 - Unix IO 模型",slug:"io-模型-unix-io-模型",normalizedTitle:"io 模型 - unix io 模型",charIndex:2},{level:2,title:"Unix IO 模型简介",slug:"unix-io-模型简介",normalizedTitle:"unix io 模型简介",charIndex:110},{level:3,title:"阻塞式 I/O",slug:"阻塞式-i-o",normalizedTitle:"阻塞式 i/o",charIndex:130},{level:3,title:"非阻塞式 I/O",slug:"非阻塞式-i-o",normalizedTitle:"非阻塞式 i/o",charIndex:145},{level:3,title:"I/O 复用",slug:"i-o-复用",normalizedTitle:"i/o 复用",charIndex:161},{level:3,title:"信号驱动 I/O",slug:"信号驱动-i-o",normalizedTitle:"信号驱动 i/o",charIndex:175},{level:3,title:"异步 I/O",slug:"异步-i-o",normalizedTitle:"异步 i/o",charIndex:191},{level:2,title:"I/O 模型比较",slug:"i-o-模型比较",normalizedTitle:"i/o 模型比较",charIndex:203},{level:3,title:"同步 I/O 与异步 I/O",slug:"同步-i-o-与异步-i-o",normalizedTitle:"同步 i/o 与异步 i/o",charIndex:219},{level:3,title:"五大 I/O 模型比较",slug:"五大-i-o-模型比较",normalizedTitle:"五大 i/o 模型比较",charIndex:241},{level:2,title:"IO多路复用",slug:"io多路复用",normalizedTitle:"io多路复用",charIndex:66},{level:3,title:"IO多路复用工作模式",slug:"io多路复用工作模式",normalizedTitle:"io多路复用工作模式",charIndex:272},{level:3,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:326},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:405}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"IO 模型 - Unix IO 模型 Unix IO 模型简介 阻塞式 I/O 非阻塞式 I/O I/O 复用 信号驱动 I/O 异步 I/O I/O 模型比较 同步 I/O 与异步 I/O 五大 I/O 模型比较 IO多路复用 IO多路复用工作模式 应用场景 参考资料",content:"# IO 模型 - Unix IO 模型\n\n> 本文主要简要介绍 Unix I/O 5种模型，并对5大模型比较，并重点为后续章节解释IO多路复用做铺垫。@pdai\n\n * IO 模型 - Unix IO 模型\n   * Unix IO 模型简介\n     * 阻塞式 I/O\n     * 非阻塞式 I/O\n     * I/O 复用\n     * 信号驱动 I/O\n     * 异步 I/O\n   * I/O 模型比较\n     * 同步 I/O 与异步 I/O\n     * 五大 I/O 模型比较\n   * IO多路复用\n     * IO多路复用工作模式\n       * 1. LT 模式\n       * 2. ET 模式\n     * 应用场景\n       * 1. select 应用场景\n       * 2. poll 应用场景\n       * 3. epoll 应用场景\n   * 参考资料\n\n\n# Unix IO 模型简介\n\n一个输入操作通常包括两个阶段:\n\n * 等待数据准备好\n * 从内核向进程复制数据\n\n对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。\n\nUnix 下有五种 I/O 模型:\n\n * 阻塞式 I/O\n * 非阻塞式 I/O\n * I/O 复用(select 和 poll)\n * 信号驱动式 I/O(SIGIO)\n * 异步 I/O(AIO)\n\n\n# 阻塞式 I/O\n\n应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回。\n\n应该注意到，在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，因此不消耗 CPU 时间，这种模型的执行效率会比较高。\n\n下图中，recvfrom 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。\n\nssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);\n\n\n\n\n或者网友提供的\n\n\n\n\n# 非阻塞式 I/O\n\n应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询(polling)。\n\n由于 CPU 要处理更多的系统调用，因此这种模型是比较低效的。\n\n\n\n或者网友提供的\n\n\n\n\n# I/O 复用\n\n使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用 recvfrom 把数据从内核复制到进程中。\n\n它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。\n\n如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。并且相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。\n\n\n\n或者网友提供的\n\n\n\n\n# 信号驱动 I/O\n\n应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。\n\n相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。\n\n\n\n或者网友提供的\n\n\n\n\n# 异步 I/O\n\n进行 aio_read 系统调用会立即返回，应用进程继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。\n\n异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。\n\n\n\n或者网友提供的\n\n\n\n\n# I/O 模型比较\n\n\n# 同步 I/O 与异步 I/O\n\n * 同步 I/O: 应用进程在调用 recvfrom 操作时会阻塞。\n * 异步 I/O: 不会阻塞。\n\n阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，虽然非阻塞式 I/O 和信号驱动 I/O 在等待数据阶段不会阻塞，但是在之后的将数据从内核复制到应用进程这个操作会阻塞。\n\n\n# 五大 I/O 模型比较\n\n前四种 I/O 模型的主要区别在于第一个阶段，而第二个阶段是一样的: 将数据从内核复制到应用进程过程中，应用进程会被阻塞。\n\n\n\n\n# IO多路复用\n\n> IO多路复用最为重要，后面的文章Java NIO - IO多路复用详解将对IO多路复用，Ractor模型以及Java NIO对其的支持作详解。\n\n这里主要概要性的理解: IO多路复用工作模式和应用。\n\n\n# IO多路复用工作模式\n\nepoll 的描述符事件有两种触发模式: LT(level trigger)和 ET(edge trigger)。\n\n# 1. LT 模式\n\n当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。\n\n# 2. ET 模式\n\n和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。\n\n很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。\n\n\n# 应用场景\n\n很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。\n\n# 1. select 应用场景\n\nselect 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时要求更高的场景，比如核反应堆的控制。\n\nselect 可移植性更好，几乎被所有主流平台所支持。\n\n# 2. poll 应用场景\n\npoll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。\n\n需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。\n\n需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且epoll 的描述符存储在内核，不容易调试。\n\n# 3. epoll 应用场景\n\n只需要运行在 Linux 平台上，并且有非常大量的描述符需要同时轮询，而且这些连接最好是长连接。\n\n\n# 参考资料\n\n * Stevens W R, Fenner B, Rudoff A M. UNIX network programming[M]. Addison-Wesley Professional, 2004.\n * Boost application performance using asynchronous I/O在新窗口打开\n * Synchronous and Asynchronous I/O在新窗口打开\n * Linux IO 模式及 select、poll、epoll 详解在新窗口打开\n * poll vs select vs event-based在新窗口打开\n * select / poll / epoll: practical difference for system architects在新窗口打开\n * Browse the source code of userspace/glibc/sysdeps/unix/sysv/linux/ online在新窗口打开",normalizedContent:"# io 模型 - unix io 模型\n\n> 本文主要简要介绍 unix i/o 5种模型，并对5大模型比较，并重点为后续章节解释io多路复用做铺垫。@pdai\n\n * io 模型 - unix io 模型\n   * unix io 模型简介\n     * 阻塞式 i/o\n     * 非阻塞式 i/o\n     * i/o 复用\n     * 信号驱动 i/o\n     * 异步 i/o\n   * i/o 模型比较\n     * 同步 i/o 与异步 i/o\n     * 五大 i/o 模型比较\n   * io多路复用\n     * io多路复用工作模式\n       * 1. lt 模式\n       * 2. et 模式\n     * 应用场景\n       * 1. select 应用场景\n       * 2. poll 应用场景\n       * 3. epoll 应用场景\n   * 参考资料\n\n\n# unix io 模型简介\n\n一个输入操作通常包括两个阶段:\n\n * 等待数据准备好\n * 从内核向进程复制数据\n\n对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。\n\nunix 下有五种 i/o 模型:\n\n * 阻塞式 i/o\n * 非阻塞式 i/o\n * i/o 复用(select 和 poll)\n * 信号驱动式 i/o(sigio)\n * 异步 i/o(aio)\n\n\n# 阻塞式 i/o\n\n应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回。\n\n应该注意到，在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，因此不消耗 cpu 时间，这种模型的执行效率会比较高。\n\n下图中，recvfrom 用于接收 socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。\n\nssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);\n\n\n\n\n或者网友提供的\n\n\n\n\n# 非阻塞式 i/o\n\n应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 i/o 是否完成，这种方式称为轮询(polling)。\n\n由于 cpu 要处理更多的系统调用，因此这种模型是比较低效的。\n\n\n\n或者网友提供的\n\n\n\n\n# i/o 复用\n\n使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用 recvfrom 把数据从内核复制到进程中。\n\n它可以让单个进程具有处理多个 i/o 事件的能力。又被称为 event driven i/o，即事件驱动 i/o。\n\n如果一个 web 服务器没有 i/o 复用，那么每一个 socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。并且相比于多进程和多线程技术，i/o 复用不需要进程线程创建和切换的开销，系统开销更小。\n\n\n\n或者网友提供的\n\n\n\n\n# 信号驱动 i/o\n\n应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 sigio 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。\n\n相比于非阻塞式 i/o 的轮询方式，信号驱动 i/o 的 cpu 利用率更高。\n\n\n\n或者网友提供的\n\n\n\n\n# 异步 i/o\n\n进行 aio_read 系统调用会立即返回，应用进程继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。\n\n异步 i/o 与信号驱动 i/o 的区别在于，异步 i/o 的信号是通知应用进程 i/o 完成，而信号驱动 i/o 的信号是通知应用进程可以开始 i/o。\n\n\n\n或者网友提供的\n\n\n\n\n# i/o 模型比较\n\n\n# 同步 i/o 与异步 i/o\n\n * 同步 i/o: 应用进程在调用 recvfrom 操作时会阻塞。\n * 异步 i/o: 不会阻塞。\n\n阻塞式 i/o、非阻塞式 i/o、i/o 复用和信号驱动 i/o 都是同步 i/o，虽然非阻塞式 i/o 和信号驱动 i/o 在等待数据阶段不会阻塞，但是在之后的将数据从内核复制到应用进程这个操作会阻塞。\n\n\n# 五大 i/o 模型比较\n\n前四种 i/o 模型的主要区别在于第一个阶段，而第二个阶段是一样的: 将数据从内核复制到应用进程过程中，应用进程会被阻塞。\n\n\n\n\n# io多路复用\n\n> io多路复用最为重要，后面的文章java nio - io多路复用详解将对io多路复用，ractor模型以及java nio对其的支持作详解。\n\n这里主要概要性的理解: io多路复用工作模式和应用。\n\n\n# io多路复用工作模式\n\nepoll 的描述符事件有两种触发模式: lt(level trigger)和 et(edge trigger)。\n\n# 1. lt 模式\n\n当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 blocking 和 no-blocking。\n\n# 2. et 模式\n\n和 lt 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。\n\n很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 lt 模式高。只支持 no-blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。\n\n\n# 应用场景\n\n很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。\n\n# 1. select 应用场景\n\nselect 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时要求更高的场景，比如核反应堆的控制。\n\nselect 可移植性更好，几乎被所有主流平台所支持。\n\n# 2. poll 应用场景\n\npoll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。\n\n需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。\n\n需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且epoll 的描述符存储在内核，不容易调试。\n\n# 3. epoll 应用场景\n\n只需要运行在 linux 平台上，并且有非常大量的描述符需要同时轮询，而且这些连接最好是长连接。\n\n\n# 参考资料\n\n * stevens w r, fenner b, rudoff a m. unix network programming[m]. addison-wesley professional, 2004.\n * boost application performance using asynchronous i/o在新窗口打开\n * synchronous and asynchronous i/o在新窗口打开\n * linux io 模式及 select、poll、epoll 详解在新窗口打开\n * poll vs select vs event-based在新窗口打开\n * select / poll / epoll: practical difference for system architects在新窗口打开\n * browse the source code of userspace/glibc/sysdeps/unix/sysv/linux/ online在新窗口打开",charsets:{cjk:!0}},{title:"Java NIO - 零拷贝实现",frontmatter:{},regularPath:"/java/io/java-io-nio-zerocopy.html",relativePath:"java/io/java-io-nio-zerocopy.md",key:"v-5391637e",path:"/java/io/java-io-nio-zerocopy.html",headers:[{level:2,title:"Java NIO - 零拷贝实现",slug:"java-nio-零拷贝实现",normalizedTitle:"java nio - 零拷贝实现",charIndex:2},{level:2,title:"Java NIO零拷贝",slug:"java-nio零拷贝",normalizedTitle:"java nio零拷贝",charIndex:270},{level:3,title:"MappedByteBuffer",slug:"mappedbytebuffer",normalizedTitle:"mappedbytebuffer",charIndex:124},{level:3,title:"DirectByteBuffer",slug:"directbytebuffer",normalizedTitle:"directbytebuffer",charIndex:313},{level:3,title:"FileChannel",slug:"filechannel",normalizedTitle:"filechannel",charIndex:159},{level:2,title:"其它的零拷贝实现",slug:"其它的零拷贝实现",normalizedTitle:"其它的零拷贝实现",charIndex:354},{level:3,title:"Netty零拷贝",slug:"netty零拷贝",normalizedTitle:"netty零拷贝",charIndex:370},{level:3,title:"RocketMQ和Kafka对比",slug:"rocketmq和kafka对比",normalizedTitle:"rocketmq和kafka对比",charIndex:386},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:408}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java NIO - 零拷贝实现 Java NIO零拷贝 MappedByteBuffer DirectByteBuffer FileChannel 其它的零拷贝实现 Netty零拷贝 RocketMQ和Kafka对比 参考文章",content:'# Java NIO - 零拷贝实现\n\n> 这里转一篇Java NIO 零拷贝的实现文章，在此之前建议先理解什么是Linux中零拷贝，可以先看这篇文章。本文从源码着手分析了 Java NIO 对零拷贝的实现，主要包括基于内存映射（mmap）方式的 MappedByteBuffer 以及基于 sendfile 方式的 FileChannel。最后在篇末简单的阐述了一下 Netty 中的零拷贝机制，以及 RocketMQ 和 Kafka 两种消息队列在零拷贝实现方式上的区别。@pdai\n\n * Java NIO - 零拷贝实现\n   * Java NIO零拷贝\n     * MappedByteBuffer\n     * DirectByteBuffer\n     * FileChannel\n   * 其它的零拷贝实现\n     * Netty零拷贝\n     * RocketMQ和Kafka对比\n   * 参考文章\n\n\n# Java NIO零拷贝\n\n在 Java NIO 中的通道（Channel）就相当于操作系统的内核空间（kernel space）的缓冲区，而缓冲区（Buffer）对应的相当于操作系统的用户空间（user space）中的用户缓冲区（user buffer）。\n\n * 通道（Channel）是全双工的（双向传输），它既可能是读缓冲区（read buffer），也可能是网络缓冲区（socket buffer）。\n * 缓冲区（Buffer）分为堆内存（HeapBuffer）和堆外内存（DirectBuffer），这是通过 malloc() 分配出来的用户态内存。\n\n堆外内存（DirectBuffer）在使用后需要应用程序手动回收，而堆内存（HeapBuffer）的数据在 GC 时可能会被自动回收。因此，在使用 HeapBuffer 读写数据时，为了避免缓冲区数据因为 GC 而丢失，NIO 会先把 HeapBuffer 内部的数据拷贝到一个临时的 DirectBuffer 中的本地内存（native memory），这个拷贝涉及到 sun.misc.Unsafe.copyMemory() 的调用，背后的实现原理与 memcpy() 类似。 最后，将临时生成的 DirectBuffer 内部的数据的内存地址传给 I/O 调用函数，这样就避免了再去访问 Java 对象处理 I/O 读写。\n\n\n# MappedByteBuffer\n\nMappedByteBuffer 是 NIO 基于**内存映射（mmap）**这种零拷贝方式的提供的一种实现，它继承自 ByteBuffer。FileChannel 定义了一个 map() 方法，它可以把一个文件从 position 位置开始的 size 大小的区域映射为内存映像文件。抽象方法 map() 方法在 FileChannel 中的定义如下：\n\npublic abstract MappedByteBuffer map(MapMode mode, long position, long size)\n        throws IOException;\n\n\n * mode：限定内存映射区域（MappedByteBuffer）对内存映像文件的访问模式，包括只可读（READ_ONLY）、可读可写（READ_WRITE）和写时拷贝（PRIVATE）三种模式。\n * position：文件映射的起始地址，对应内存映射区域（MappedByteBuffer）的首地址。\n * size：文件映射的字节长度，从 position 往后的字节数，对应内存映射区域（MappedByteBuffer）的大小。\n\nMappedByteBuffer 相比 ByteBuffer 新增了 fore()、load() 和 isLoad() 三个重要的方法：\n\n * fore()：对于处于 READ_WRITE 模式下的缓冲区，把对缓冲区内容的修改强制刷新到本地文件。\n * load()：将缓冲区的内容载入物理内存中，并返回这个缓冲区的引用。\n * isLoaded()：如果缓冲区的内容在物理内存中，则返回 true，否则返回 false。\n\n下面给出一个利用 MappedByteBuffer 对文件进行读写的使用示例：\n\nprivate final static String CONTENT = "Zero copy implemented by MappedByteBuffer";\nprivate final static String FILE_NAME = "/mmap.txt";\nprivate final static String CHARSET = "UTF-8";\n\n\n * 写文件数据：打开文件通道 fileChannel 并提供读权限、写权限和数据清空权限，通过 fileChannel 映射到一个可写的内存缓冲区 mappedByteBuffer，将目标数据写入 mappedByteBuffer，通过 force() 方法把缓冲区更改的内容强制写入本地文件。\n\n@Test\npublic void writeToFileByMappedByteBuffer() {\n    Path path = Paths.get(getClass().getResource(FILE_NAME).getPath());\n    byte[] bytes = CONTENT.getBytes(Charset.forName(CHARSET));\n    try (FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.READ,\n            StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING)) {\n        MappedByteBuffer mappedByteBuffer = fileChannel.map(READ_WRITE, 0, bytes.length);\n        if (mappedByteBuffer != null) {\n            mappedByteBuffer.put(bytes);\n            mappedByteBuffer.force();\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n\n\n * 读文件数据：打开文件通道 fileChannel 并提供只读权限，通过 fileChannel 映射到一个只可读的内存缓冲区 mappedByteBuffer，读取 mappedByteBuffer 中的字节数组即可得到文件数据。\n\n@Test\npublic void readFromFileByMappedByteBuffer() {\n    Path path = Paths.get(getClass().getResource(FILE_NAME).getPath());\n    int length = CONTENT.getBytes(Charset.forName(CHARSET)).length;\n    try (FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.READ)) {\n        MappedByteBuffer mappedByteBuffer = fileChannel.map(READ_ONLY, 0, length);\n        if (mappedByteBuffer != null) {\n            byte[] bytes = new byte[length];\n            mappedByteBuffer.get(bytes);\n            String content = new String(bytes, StandardCharsets.UTF_8);\n            assertEquals(content, "Zero copy implemented by MappedByteBuffer");\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n\n\n下面介绍 map() 方法的底层实现原理。map() 方法是 java.nio.channels.FileChannel 的抽象方法，由子类 sun.nio.ch.FileChannelImpl.java 实现，下面是和内存映射相关的核心代码：\n\npublic MappedByteBuffer map(MapMode mode, long position, long size) throws IOException {\n    int pagePosition = (int)(position % allocationGranularity);\n    long mapPosition = position - pagePosition;\n    long mapSize = size + pagePosition;\n    try {\n        addr = map0(imode, mapPosition, mapSize);\n    } catch (OutOfMemoryError x) {\n        System.gc();\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException y) {\n            Thread.currentThread().interrupt();\n        }\n        try {\n            addr = map0(imode, mapPosition, mapSize);\n        } catch (OutOfMemoryError y) {\n            throw new IOException("Map failed", y);\n        }\n    }\n\n    int isize = (int)size;\n    Unmapper um = new Unmapper(addr, mapSize, isize, mfd);\n    if ((!writable) || (imode == MAP_RO)) {\n        return Util.newMappedByteBufferR(isize, addr + pagePosition, mfd, um);\n    } else {\n        return Util.newMappedByteBuffer(isize, addr + pagePosition, mfd, um);\n    }\n}\n\n\nmap() 方法通过本地方法 map0() 为文件分配一块虚拟内存，作为它的内存映射区域，然后返回这块内存映射区域的起始地址。\n\n * 文件映射需要在 Java 堆中创建一个 MappedByteBuffer 的实例。如果第一次文件映射导致 OOM，则手动触发垃圾回收，休眠 100ms 后再尝试映射，如果失败则抛出异常。\n * 通过 Util 的 newMappedByteBuffer （可读可写）方法或者 newMappedByteBufferR（仅读） 方法方法反射创建一个 DirectByteBuffer 实例，其中 DirectByteBuffer 是 MappedByteBuffer 的子类。\n\nmap() 方法返回的是内存映射区域的起始地址，通过（起始地址 + 偏移量）就可以获取指定内存的数据。这样一定程度上替代了 read() 或 write() 方法，底层直接采用 sun.misc.Unsafe类的 getByte() 和 putByte() 方法对数据进行读写。\n\nprivate native long map0(int prot, long position, long mapSize) throws IOException;\n\n\n上面是本地方法（native method）map0 的定义，它通过 JNI（Java Native Interface）调用底层 C 的实现，这个 native 函数（Java_sun_nio_ch_FileChannelImpl_map0）的实现位于 JDK 源码包下的 native/sun/nio/ch/FileChannelImpl.c这个源文件里面。\n\nJNIEXPORT jlong JNICALL\nJava_sun_nio_ch_FileChannelImpl_map0(JNIEnv *env, jobject this,\n                                     jint prot, jlong off, jlong len)\n{\n    void *mapAddress = 0;\n    jobject fdo = (*env)->GetObjectField(env, this, chan_fd);\n    jint fd = fdval(env, fdo);\n    int protections = 0;\n    int flags = 0;\n\n    if (prot == sun_nio_ch_FileChannelImpl_MAP_RO) {\n        protections = PROT_READ;\n        flags = MAP_SHARED;\n    } else if (prot == sun_nio_ch_FileChannelImpl_MAP_RW) {\n        protections = PROT_WRITE | PROT_READ;\n        flags = MAP_SHARED;\n    } else if (prot == sun_nio_ch_FileChannelImpl_MAP_PV) {\n        protections =  PROT_WRITE | PROT_READ;\n        flags = MAP_PRIVATE;\n    }\n\n    mapAddress = mmap64(\n        0,                    /* Let OS decide location */\n        len,                  /* Number of bytes to map */\n        protections,          /* File permissions */\n        flags,                /* Changes are shared */\n        fd,                   /* File descriptor of mapped file */\n        off);                 /* Offset into file */\n\n    if (mapAddress == MAP_FAILED) {\n        if (errno == ENOMEM) {\n            JNU_ThrowOutOfMemoryError(env, "Map failed");\n            return IOS_THROWN;\n        }\n        return handle(env, -1, "Map failed");\n    }\n\n    return ((jlong) (unsigned long) mapAddress);\n}\n\n\n可以看出 map0() 函数最终是通过 mmap64() 这个函数对 Linux 底层内核发出内存映射的调用， mmap64() 函数的原型如下：\n\n#include <sys/mman.h>\n\nvoid *mmap64(void *addr, size_t len, int prot, int flags, int fd, off64_t offset);\n\n\n下面详细介绍一下 mmap64() 函数各个参数的含义以及参数可选值：\n\n * addr：文件在用户进程空间的内存映射区中的起始地址，是一个建议的参数，通常可设置为 0 或 NULL，此时由内核去决定真实的起始地址。当 + flags 为 MAP_FIXED 时，addr 就是一个必选的参数，即需要提供一个存在的地址。\n * len：文件需要进行内存映射的字节长度\n * prot：控制用户进程对内存映射区的访问权限\n   * PROT_READ：读权限\n   * PROT_WRITE：写权限\n   * PROT_EXEC：执行权限\n   * PROT_NONE：无权限\n * flags：控制内存映射区的修改是否被多个进程共享\n   * MAP_PRIVATE：对内存映射区数据的修改不会反映到真正的文件，数据修改发生时采用写时复制机制\n   * MAP_SHARED：对内存映射区的修改会同步到真正的文件，修改对共享此内存映射区的进程是可见的\n   * MAP_FIXED：不建议使用，这种模式下 addr 参数指定的必须的提供一个存在的 addr 参数\n * fd：文件描述符。每次 map 操作会导致文件的引用计数加 1，每次 unmap 操作或者结束进程会导致引用计数减 1\n * offset：文件偏移量。进行映射的文件位置，从文件起始地址向后的位移量\n\n下面总结一下 MappedByteBuffer 的特点和不足之处：\n\n * MappedByteBuffer 使用是堆外的虚拟内存，因此分配（map）的内存大小不受 JVM 的 -Xmx 参数限制，但是也是有大小限制的。 如果当文件超出 Integer.MAX_VALUE 字节限制时，可以通过 position 参数重新 map 文件后面的内容。\n * MappedByteBuffer 在处理大文件时性能的确很高，但也存内存占用、文件关闭不确定等问题，被其打开的文件只有在垃圾回收的才会被关闭，而且这个时间点是不确定的。\n * MappedByteBuffer 提供了文件映射内存的 mmap() 方法，也提供了释放映射内存的 unmap() 方法。然而 unmap() 是 FileChannelImpl 中的私有方法，无法直接显示调用。因此，用户程序需要通过 Java 反射的调用 sun.misc.Cleaner 类的 clean() 方法手动释放映射占用的内存区域。\n\npublic static void clean(final Object buffer) throws Exception {\n    AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n        try {\n            Method getCleanerMethod = buffer.getClass().getMethod("cleaner", new Class[0]);\n            getCleanerMethod.setAccessible(true);\n            Cleaner cleaner = (Cleaner) getCleanerMethod.invoke(buffer, new Object[0]);\n            cleaner.clean();\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    });\n}\n\n\n\n# DirectByteBuffer\n\nDirectByteBuffer 的对象引用位于 Java 内存模型的堆里面，JVM 可以对 DirectByteBuffer 的对象进行内存分配和回收管理，一般使用 DirectByteBuffer 的静态方法 allocateDirect() 创建 DirectByteBuffer 实例并分配内存。\n\npublic static ByteBuffer allocateDirect(int capacity) {\n    return new DirectByteBuffer(capacity);\n}\n\n\nDirectByteBuffer 内部的字节缓冲区位在于堆外的（用户态）直接内存，它是通过 Unsafe 的本地方法 allocateMemory() 进行内存分配，底层调用的是操作系统的 malloc() 函数。\n\nDirectByteBuffer(int cap) {\n    super(-1, 0, cap, cap);\n    boolean pa = VM.isDirectMemoryPageAligned();\n    int ps = Bits.pageSize();\n    long size = Math.max(1L, (long)cap + (pa ? ps : 0));\n    Bits.reserveMemory(size, cap);\n\n    long base = 0;\n    try {\n        base = unsafe.allocateMemory(size);\n    } catch (OutOfMemoryError x) {\n        Bits.unreserveMemory(size, cap);\n        throw x;\n    }\n    unsafe.setMemory(base, size, (byte) 0);\n    if (pa && (base % ps != 0)) {\n        address = base + ps - (base & (ps - 1));\n    } else {\n        address = base;\n    }\n    cleaner = Cleaner.create(this, new Deallocator(base, size, cap));\n    att = null;\n}\n\n\n除此之外，初始化 DirectByteBuffer 时还会创建一个 Deallocator 线程，并通过 Cleaner 的 freeMemory() 方法来对直接内存进行回收操作，freeMemory() 底层调用的是操作系统的 free() 函数。\n\nprivate static class Deallocator implements Runnable {\n    private static Unsafe unsafe = Unsafe.getUnsafe();\n\n    private long address;\n    private long size;\n    private int capacity;\n\n    private Deallocator(long address, long size, int capacity) {\n        assert (address != 0);\n        this.address = address;\n        this.size = size;\n        this.capacity = capacity;\n    }\n\n    public void run() {\n        if (address == 0) {\n            return;\n        }\n        unsafe.freeMemory(address);\n        address = 0;\n        Bits.unreserveMemory(size, capacity);\n    }\n}\n\n\n由于使用 DirectByteBuffer 分配的是系统本地的内存，不在 JVM 的管控范围之内，因此直接内存的回收和堆内存的回收不同，直接内存如果使用不当，很容易造成 OutOfMemoryError。\n\n说了这么多，那么 DirectByteBuffer 和零拷贝有什么关系？前面有提到在 MappedByteBuffer 进行内存映射时，它的 map() 方法会通过 Util.newMappedByteBuffer() 来创建一个缓冲区实例，初始化的代码如下：\n\nstatic MappedByteBuffer newMappedByteBuffer(int size, long addr, FileDescriptor fd,\n                                            Runnable unmapper) {\n    MappedByteBuffer dbb;\n    if (directByteBufferConstructor == null)\n        initDBBConstructor();\n    try {\n        dbb = (MappedByteBuffer)directByteBufferConstructor.newInstance(\n            new Object[] { new Integer(size), new Long(addr), fd, unmapper });\n    } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n        throw new InternalError(e);\n    }\n    return dbb;\n}\n\nprivate static void initDBBRConstructor() {\n    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n        public Void run() {\n            try {\n                Class<?> cl = Class.forName("java.nio.DirectByteBufferR");\n                Constructor<?> ctor = cl.getDeclaredConstructor(\n                    new Class<?>[] { int.class, long.class, FileDescriptor.class,\n                                    Runnable.class });\n                ctor.setAccessible(true);\n                directByteBufferRConstructor = ctor;\n            } catch (ClassNotFoundException | NoSuchMethodException |\n                     IllegalArgumentException | ClassCastException x) {\n                throw new InternalError(x);\n            }\n            return null;\n        }});\n}\n\n\nDirectByteBuffer 是 MappedByteBuffer 的具体实现类。实际上，Util.newMappedByteBuffer() 方法通过反射机制获取 DirectByteBuffer 的构造器，然后创建一个 DirectByteBuffer 的实例，对应的是一个单独用于内存映射的构造方法：\n\nprotected DirectByteBuffer(int cap, long addr, FileDescriptor fd, Runnable unmapper) {\n    super(-1, 0, cap, cap, fd);\n    address = addr;\n    cleaner = Cleaner.create(this, unmapper);\n    att = null;\n}\n\n\n因此，除了允许分配操作系统的直接内存以外，DirectByteBuffer 本身也具有文件内存映射的功能，这里不做过多说明。我们需要关注的是，DirectByteBuffer 在 MappedByteBuffer 的基础上提供了内存映像文件的随机读取 get() 和写入 write() 的操作。\n\n * 内存映像文件的随机读操作\n\npublic byte get() {\n    return ((unsafe.getByte(ix(nextGetIndex()))));\n}\n\npublic byte get(int i) {\n    return ((unsafe.getByte(ix(checkIndex(i)))));\n}\n\n\n * 内存映像文件的随机写操作\n\npublic ByteBuffer put(byte x) {\n    unsafe.putByte(ix(nextPutIndex()), ((x)));\n    return this;\n}\n\npublic ByteBuffer put(int i, byte x) {\n    unsafe.putByte(ix(checkIndex(i)), ((x)));\n    return this;\n}\n\n\n内存映像文件的随机读写都是借助 ix() 方法实现定位的， ix() 方法通过内存映射空间的内存首地址（address）和给定偏移量 i 计算出指针地址，然后由 unsafe 类的 get() 和 put() 方法和对指针指向的数据进行读取或写入。\n\nprivate long ix(int i) {\n    return address + ((long)i << 0);\n}\n\n\n\n# FileChannel\n\nFileChannel 是一个用于文件读写、映射和操作的通道，同时它在并发环境下是线程安全的，基于 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 getChannel() 方法可以创建并打开一个文件通道。FileChannel 定义了 transferFrom() 和 transferTo() 两个抽象方法，它通过在通道和通道之间建立连接实现数据传输的。\n\n * transferTo()：通过 FileChannel 把文件里面的源数据写入一个 WritableByteChannel 的目的通道。\n\npublic abstract long transferTo(long position, long count, WritableByteChannel target)\n        throws IOException;\n\n\n * transferFrom()：把一个源通道 ReadableByteChannel 中的数据读取到当前 FileChannel 的文件里面。\n\npublic abstract long transferFrom(ReadableByteChannel src, long position, long count)\n        throws IOException;\n\n\n下面给出 FileChannel 利用 transferTo() 和 transferFrom() 方法进行数据传输的使用示例：\n\nprivate static final String CONTENT = "Zero copy implemented by FileChannel";\nprivate static final String SOURCE_FILE = "/source.txt";\nprivate static final String TARGET_FILE = "/target.txt";\nprivate static final String CHARSET = "UTF-8";\n\n\n首先在类加载根路径下创建 source.txt 和 target.txt 两个文件，对源文件 source.txt 文件写入初始化数据。\n\n@Before\npublic void setup() {\n    Path source = Paths.get(getClassPath(SOURCE_FILE));\n    byte[] bytes = CONTENT.getBytes(Charset.forName(CHARSET));\n    try (FileChannel fromChannel = FileChannel.open(source, StandardOpenOption.READ,\n            StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING)) {\n        fromChannel.write(ByteBuffer.wrap(bytes));\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n\n\n对于 transferTo() 方法而言，目的通道 toChannel 可以是任意的单向字节写通道 WritableByteChannel；而对于 transferFrom() 方法而言，源通道 fromChannel 可以是任意的单向字节读通道 ReadableByteChannel。其中，FileChannel、SocketChannel 和 DatagramChannel 等通道实现了 WritableByteChannel 和 ReadableByteChannel 接口，都是同时支持读写的双向通道。为了方便测试，下面给出基于 FileChannel 完成 channel-to-channel 的数据传输示例。\n\n通过 transferTo() 将 fromChannel 中的数据拷贝到 toChannel\n\n@Test\npublic void transferTo() throws Exception {\n    try (FileChannel fromChannel = new RandomAccessFile(\n             getClassPath(SOURCE_FILE), "rw").getChannel();\n         FileChannel toChannel = new RandomAccessFile(\n             getClassPath(TARGET_FILE), "rw").getChannel()) {\n        long position = 0L;\n        long offset = fromChannel.size();\n        fromChannel.transferTo(position, offset, toChannel);\n    }\n}\n\n\n通过 transferFrom() 将 fromChannel 中的数据拷贝到 toChannel\n\n@Test\npublic void transferFrom() throws Exception {\n    try (FileChannel fromChannel = new RandomAccessFile(\n             getClassPath(SOURCE_FILE), "rw").getChannel();\n         FileChannel toChannel = new RandomAccessFile(\n             getClassPath(TARGET_FILE), "rw").getChannel()) {\n        long position = 0L;\n        long offset = fromChannel.size();\n        toChannel.transferFrom(fromChannel, position, offset);\n    }\n}\n\n\n下面介绍 transferTo() 和 transferFrom() 方法的底层实现原理，这两个方法也是 java.nio.channels.FileChannel 的抽象方法，由子类 sun.nio.ch.FileChannelImpl.java 实现。transferTo() 和 transferFrom() 底层都是基于 sendfile 实现数据传输的，其中 FileChannelImpl.java 定义了 3 个常量，用于标示当前操作系统的内核是否支持 sendfile 以及 sendfile 的相关特性。\n\nprivate static volatile boolean transferSupported = true;\nprivate static volatile boolean pipeSupported = true;\nprivate static volatile boolean fileSupported = true;\n\n\n * transferSupported：用于标记当前的系统内核是否支持 sendfile() 调用，默认为 true。\n * pipeSupported：用于标记当前的系统内核是否支持文件描述符（fd）基于管道（pipe）的 sendfile() 调用，默认为 true。\n * fileSupported：用于标记当前的系统内核是否支持文件描述符（fd）基于文件（file）的 sendfile() 调用，默认为 true。\n\n下面以 transferTo() 的源码实现为例。FileChannelImpl 首先执行 transferToDirectly() 方法，以 sendfile 的零拷贝方式尝试数据拷贝。如果系统内核不支持 sendfile，进一步执行 transferToTrustedChannel() 方法，以 mmap 的零拷贝方式进行内存映射，这种情况下目的通道必须是 FileChannelImpl 或者 SelChImpl 类型。如果以上两步都失败了，则执行 transferToArbitraryChannel() 方法，基于传统的 I/O 方式完成读写，具体步骤是初始化一个临时的 DirectBuffer，将源通道 FileChannel 的数据读取到 DirectBuffer，再写入目的通道 WritableByteChannel 里面。\n\npublic long transferTo(long position, long count, WritableByteChannel target)\n        throws IOException {\n    // 计算文件的大小\n    long sz = size();\n    // 校验起始位置\n    if (position > sz)\n        return 0;\n    int icount = (int)Math.min(count, Integer.MAX_VALUE);\n    // 校验偏移量\n    if ((sz - position) < icount)\n        icount = (int)(sz - position);\n\n    long n;\n\n    if ((n = transferToDirectly(position, icount, target)) >= 0)\n        return n;\n\n    if ((n = transferToTrustedChannel(position, icount, target)) >= 0)\n        return n;\n\n    return transferToArbitraryChannel(position, icount, target);\n}\n\n\n接下来重点分析一下 transferToDirectly() 方法的实现，也就是 transferTo() 通过 sendfile 实现零拷贝的精髓所在。可以看到，transferToDirectlyInternal() 方法先获取到目的通道 WritableByteChannel 的文件描述符 targetFD，获取同步锁然后执行 transferToDirectlyInternal() 方法。\n\nprivate long transferToDirectly(long position, int icount, WritableByteChannel target)\n        throws IOException {\n    // 省略从target获取targetFD的过程\n    if (nd.transferToDirectlyNeedsPositionLock()) {\n        synchronized (positionLock) {\n            long pos = position();\n            try {\n                return transferToDirectlyInternal(position, icount,\n                        target, targetFD);\n            } finally {\n                position(pos);\n            }\n        }\n    } else {\n        return transferToDirectlyInternal(position, icount, target, targetFD);\n    }\n}\n\n\n最终由 transferToDirectlyInternal() 调用本地方法 transferTo0() ，尝试以 sendfile 的方式进行数据传输。如果系统内核完全不支持 sendfile，比如 Windows 操作系统，则返回 UNSUPPORTED 并把 transferSupported 标识为 false。如果系统内核不支持 sendfile 的一些特性，比如说低版本的 Linux 内核不支持 DMA gather copy 操作，则返回 UNSUPPORTED_CASE 并把 pipeSupported 或者 fileSupported 标识为 false。\n\nprivate long transferToDirectlyInternal(long position, int icount,\n                                        WritableByteChannel target,\n                                        FileDescriptor targetFD) throws IOException {\n    assert !nd.transferToDirectlyNeedsPositionLock() ||\n            Thread.holdsLock(positionLock);\n\n    long n = -1;\n    int ti = -1;\n    try {\n        begin();\n        ti = threads.add();\n        if (!isOpen())\n            return -1;\n        do {\n            n = transferTo0(fd, position, icount, targetFD);\n        } while ((n == IOStatus.INTERRUPTED) && isOpen());\n        if (n == IOStatus.UNSUPPORTED_CASE) {\n            if (target instanceof SinkChannelImpl)\n                pipeSupported = false;\n            if (target instanceof FileChannelImpl)\n                fileSupported = false;\n            return IOStatus.UNSUPPORTED_CASE;\n        }\n        if (n == IOStatus.UNSUPPORTED) {\n            transferSupported = false;\n            return IOStatus.UNSUPPORTED;\n        }\n        return IOStatus.normalize(n);\n    } finally {\n        threads.remove(ti);\n        end (n > -1);\n    }\n}\n\n\n本地方法（native method）transferTo0() 通过 JNI（Java Native Interface）调用底层 C 的函数，这个 native 函数（Java_sun_nio_ch_FileChannelImpl_transferTo0）同样位于 JDK 源码包下的 native/sun/nio/ch/FileChannelImpl.c 源文件里面。JNI 函数 Java_sun_nio_ch_FileChannelImpl_transferTo0() 基于条件编译对不同的系统进行预编译，下面是 JDK 基于 Linux 系统内核对 transferTo() 提供的调用封装。\n\n#if defined(__linux__) || defined(__solaris__)\n#include <sys/sendfile.h>\n#elif defined(_AIX)\n#include <sys/socket.h>\n#elif defined(_ALLBSD_SOURCE)\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/uio.h>\n\n#define lseek64 lseek\n#define mmap64 mmap\n#endif\n\nJNIEXPORT jlong JNICALL\nJava_sun_nio_ch_FileChannelImpl_transferTo0(JNIEnv *env, jobject this,\n                                            jobject srcFDO,\n                                            jlong position, jlong count,\n                                            jobject dstFDO)\n{\n    jint srcFD = fdval(env, srcFDO);\n    jint dstFD = fdval(env, dstFDO);\n\n#if defined(__linux__)\n    off64_t offset = (off64_t)position;\n    jlong n = sendfile64(dstFD, srcFD, &offset, (size_t)count);\n    return n;\n#elif defined(__solaris__)\n    result = sendfilev64(dstFD, &sfv, 1, &numBytes);    \n    return result;\n#elif defined(__APPLE__)\n    result = sendfile(srcFD, dstFD, position, &numBytes, NULL, 0);\n    return result;\n#endif\n}\n\n\n对 Linux、Solaris 以及 Apple 系统而言，transferTo0() 函数底层会执行 sendfile64 这个系统调用完成零拷贝操作，sendfile64() 函数的原型如下：\n\n#include <sys/sendfile.h>\n\nssize_t sendfile64(int out_fd, int in_fd, off_t *offset, size_t count);\n\n\n下面简单介绍一下 sendfile64() 函数各个参数的含义：\n\n * out_fd：待写入的文件描述符\n * in_fd：待读取的文件描述符\n * offset：指定 in_fd 对应文件流的读取位置，如果为空，则默认从起始位置开始\n * count：指定在文件描述符 in_fd 和 out_fd 之间传输的字节数\n\n在 Linux 2.6.3 之前，out_fd 必须是一个 socket，而从 Linux 2.6.3 以后，out_fd 可以是任何文件。也就是说，sendfile64() 函数不仅可以进行网络文件传输，还可以对本地文件实现零拷贝操作。\n\n\n# 其它的零拷贝实现\n\n\n# Netty零拷贝\n\nNetty 中的零拷贝和上面提到的操作系统层面上的零拷贝不太一样, 我们所说的 Netty 零拷贝完全是基于（Java 层面）用户态的，它的更多的是偏向于数据操作优化这样的概念，具体表现在以下几个方面：\n\nNetty 通过 DefaultFileRegion 类对 java.nio.channels.FileChannel 的 tranferTo() 方法进行包装，在文件传输时可以将文件缓冲区的数据直接发送到目的通道（Channel）\n\nByteBuf 可以通过 wrap 操作把字节数组、ByteBuf、ByteBuffer 包装成一个 ByteBuf 对象, 进而避免了拷贝操作 ByteBuf 支持 slice 操作, 因此可以将 ByteBuf 分解为多个共享同一个存储区域的 ByteBuf，避免了内存的拷贝 Netty 提供了 CompositeByteBuf 类，它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免了各个 ByteBuf 之间的拷贝 其中第 1 条属于操作系统层面的零拷贝操作，后面 3 条只能算用户层面的数据操作优化。\n\n\n# RocketMQ和Kafka对比\n\nRocketMQ 选择了 mmap + write 这种零拷贝方式，适用于业务级消息这种小块文件的数据持久化和传输；而 Kafka 采用的是 sendfile 这种零拷贝方式，适用于系统日志消息这种高吞吐量的大块文件的数据持久化和传输。但是值得注意的一点是，Kafka 的索引文件使用的是 mmap + write 方式，数据文件使用的是 sendfile 方式。\n\n\n\n\n# 参考文章\n\n * 本文主要整理自 https://zhuanlan.zhihu.com/p/83398714\n * 作者：零壹技术栈',normalizedContent:'# java nio - 零拷贝实现\n\n> 这里转一篇java nio 零拷贝的实现文章，在此之前建议先理解什么是linux中零拷贝，可以先看这篇文章。本文从源码着手分析了 java nio 对零拷贝的实现，主要包括基于内存映射（mmap）方式的 mappedbytebuffer 以及基于 sendfile 方式的 filechannel。最后在篇末简单的阐述了一下 netty 中的零拷贝机制，以及 rocketmq 和 kafka 两种消息队列在零拷贝实现方式上的区别。@pdai\n\n * java nio - 零拷贝实现\n   * java nio零拷贝\n     * mappedbytebuffer\n     * directbytebuffer\n     * filechannel\n   * 其它的零拷贝实现\n     * netty零拷贝\n     * rocketmq和kafka对比\n   * 参考文章\n\n\n# java nio零拷贝\n\n在 java nio 中的通道（channel）就相当于操作系统的内核空间（kernel space）的缓冲区，而缓冲区（buffer）对应的相当于操作系统的用户空间（user space）中的用户缓冲区（user buffer）。\n\n * 通道（channel）是全双工的（双向传输），它既可能是读缓冲区（read buffer），也可能是网络缓冲区（socket buffer）。\n * 缓冲区（buffer）分为堆内存（heapbuffer）和堆外内存（directbuffer），这是通过 malloc() 分配出来的用户态内存。\n\n堆外内存（directbuffer）在使用后需要应用程序手动回收，而堆内存（heapbuffer）的数据在 gc 时可能会被自动回收。因此，在使用 heapbuffer 读写数据时，为了避免缓冲区数据因为 gc 而丢失，nio 会先把 heapbuffer 内部的数据拷贝到一个临时的 directbuffer 中的本地内存（native memory），这个拷贝涉及到 sun.misc.unsafe.copymemory() 的调用，背后的实现原理与 memcpy() 类似。 最后，将临时生成的 directbuffer 内部的数据的内存地址传给 i/o 调用函数，这样就避免了再去访问 java 对象处理 i/o 读写。\n\n\n# mappedbytebuffer\n\nmappedbytebuffer 是 nio 基于**内存映射（mmap）**这种零拷贝方式的提供的一种实现，它继承自 bytebuffer。filechannel 定义了一个 map() 方法，它可以把一个文件从 position 位置开始的 size 大小的区域映射为内存映像文件。抽象方法 map() 方法在 filechannel 中的定义如下：\n\npublic abstract mappedbytebuffer map(mapmode mode, long position, long size)\n        throws ioexception;\n\n\n * mode：限定内存映射区域（mappedbytebuffer）对内存映像文件的访问模式，包括只可读（read_only）、可读可写（read_write）和写时拷贝（private）三种模式。\n * position：文件映射的起始地址，对应内存映射区域（mappedbytebuffer）的首地址。\n * size：文件映射的字节长度，从 position 往后的字节数，对应内存映射区域（mappedbytebuffer）的大小。\n\nmappedbytebuffer 相比 bytebuffer 新增了 fore()、load() 和 isload() 三个重要的方法：\n\n * fore()：对于处于 read_write 模式下的缓冲区，把对缓冲区内容的修改强制刷新到本地文件。\n * load()：将缓冲区的内容载入物理内存中，并返回这个缓冲区的引用。\n * isloaded()：如果缓冲区的内容在物理内存中，则返回 true，否则返回 false。\n\n下面给出一个利用 mappedbytebuffer 对文件进行读写的使用示例：\n\nprivate final static string content = "zero copy implemented by mappedbytebuffer";\nprivate final static string file_name = "/mmap.txt";\nprivate final static string charset = "utf-8";\n\n\n * 写文件数据：打开文件通道 filechannel 并提供读权限、写权限和数据清空权限，通过 filechannel 映射到一个可写的内存缓冲区 mappedbytebuffer，将目标数据写入 mappedbytebuffer，通过 force() 方法把缓冲区更改的内容强制写入本地文件。\n\n@test\npublic void writetofilebymappedbytebuffer() {\n    path path = paths.get(getclass().getresource(file_name).getpath());\n    byte[] bytes = content.getbytes(charset.forname(charset));\n    try (filechannel filechannel = filechannel.open(path, standardopenoption.read,\n            standardopenoption.write, standardopenoption.truncate_existing)) {\n        mappedbytebuffer mappedbytebuffer = filechannel.map(read_write, 0, bytes.length);\n        if (mappedbytebuffer != null) {\n            mappedbytebuffer.put(bytes);\n            mappedbytebuffer.force();\n        }\n    } catch (ioexception e) {\n        e.printstacktrace();\n    }\n}\n\n\n * 读文件数据：打开文件通道 filechannel 并提供只读权限，通过 filechannel 映射到一个只可读的内存缓冲区 mappedbytebuffer，读取 mappedbytebuffer 中的字节数组即可得到文件数据。\n\n@test\npublic void readfromfilebymappedbytebuffer() {\n    path path = paths.get(getclass().getresource(file_name).getpath());\n    int length = content.getbytes(charset.forname(charset)).length;\n    try (filechannel filechannel = filechannel.open(path, standardopenoption.read)) {\n        mappedbytebuffer mappedbytebuffer = filechannel.map(read_only, 0, length);\n        if (mappedbytebuffer != null) {\n            byte[] bytes = new byte[length];\n            mappedbytebuffer.get(bytes);\n            string content = new string(bytes, standardcharsets.utf_8);\n            assertequals(content, "zero copy implemented by mappedbytebuffer");\n        }\n    } catch (ioexception e) {\n        e.printstacktrace();\n    }\n}\n\n\n下面介绍 map() 方法的底层实现原理。map() 方法是 java.nio.channels.filechannel 的抽象方法，由子类 sun.nio.ch.filechannelimpl.java 实现，下面是和内存映射相关的核心代码：\n\npublic mappedbytebuffer map(mapmode mode, long position, long size) throws ioexception {\n    int pageposition = (int)(position % allocationgranularity);\n    long mapposition = position - pageposition;\n    long mapsize = size + pageposition;\n    try {\n        addr = map0(imode, mapposition, mapsize);\n    } catch (outofmemoryerror x) {\n        system.gc();\n        try {\n            thread.sleep(100);\n        } catch (interruptedexception y) {\n            thread.currentthread().interrupt();\n        }\n        try {\n            addr = map0(imode, mapposition, mapsize);\n        } catch (outofmemoryerror y) {\n            throw new ioexception("map failed", y);\n        }\n    }\n\n    int isize = (int)size;\n    unmapper um = new unmapper(addr, mapsize, isize, mfd);\n    if ((!writable) || (imode == map_ro)) {\n        return util.newmappedbytebufferr(isize, addr + pageposition, mfd, um);\n    } else {\n        return util.newmappedbytebuffer(isize, addr + pageposition, mfd, um);\n    }\n}\n\n\nmap() 方法通过本地方法 map0() 为文件分配一块虚拟内存，作为它的内存映射区域，然后返回这块内存映射区域的起始地址。\n\n * 文件映射需要在 java 堆中创建一个 mappedbytebuffer 的实例。如果第一次文件映射导致 oom，则手动触发垃圾回收，休眠 100ms 后再尝试映射，如果失败则抛出异常。\n * 通过 util 的 newmappedbytebuffer （可读可写）方法或者 newmappedbytebufferr（仅读） 方法方法反射创建一个 directbytebuffer 实例，其中 directbytebuffer 是 mappedbytebuffer 的子类。\n\nmap() 方法返回的是内存映射区域的起始地址，通过（起始地址 + 偏移量）就可以获取指定内存的数据。这样一定程度上替代了 read() 或 write() 方法，底层直接采用 sun.misc.unsafe类的 getbyte() 和 putbyte() 方法对数据进行读写。\n\nprivate native long map0(int prot, long position, long mapsize) throws ioexception;\n\n\n上面是本地方法（native method）map0 的定义，它通过 jni（java native interface）调用底层 c 的实现，这个 native 函数（java_sun_nio_ch_filechannelimpl_map0）的实现位于 jdk 源码包下的 native/sun/nio/ch/filechannelimpl.c这个源文件里面。\n\njniexport jlong jnicall\njava_sun_nio_ch_filechannelimpl_map0(jnienv *env, jobject this,\n                                     jint prot, jlong off, jlong len)\n{\n    void *mapaddress = 0;\n    jobject fdo = (*env)->getobjectfield(env, this, chan_fd);\n    jint fd = fdval(env, fdo);\n    int protections = 0;\n    int flags = 0;\n\n    if (prot == sun_nio_ch_filechannelimpl_map_ro) {\n        protections = prot_read;\n        flags = map_shared;\n    } else if (prot == sun_nio_ch_filechannelimpl_map_rw) {\n        protections = prot_write | prot_read;\n        flags = map_shared;\n    } else if (prot == sun_nio_ch_filechannelimpl_map_pv) {\n        protections =  prot_write | prot_read;\n        flags = map_private;\n    }\n\n    mapaddress = mmap64(\n        0,                    /* let os decide location */\n        len,                  /* number of bytes to map */\n        protections,          /* file permissions */\n        flags,                /* changes are shared */\n        fd,                   /* file descriptor of mapped file */\n        off);                 /* offset into file */\n\n    if (mapaddress == map_failed) {\n        if (errno == enomem) {\n            jnu_throwoutofmemoryerror(env, "map failed");\n            return ios_thrown;\n        }\n        return handle(env, -1, "map failed");\n    }\n\n    return ((jlong) (unsigned long) mapaddress);\n}\n\n\n可以看出 map0() 函数最终是通过 mmap64() 这个函数对 linux 底层内核发出内存映射的调用， mmap64() 函数的原型如下：\n\n#include <sys/mman.h>\n\nvoid *mmap64(void *addr, size_t len, int prot, int flags, int fd, off64_t offset);\n\n\n下面详细介绍一下 mmap64() 函数各个参数的含义以及参数可选值：\n\n * addr：文件在用户进程空间的内存映射区中的起始地址，是一个建议的参数，通常可设置为 0 或 null，此时由内核去决定真实的起始地址。当 + flags 为 map_fixed 时，addr 就是一个必选的参数，即需要提供一个存在的地址。\n * len：文件需要进行内存映射的字节长度\n * prot：控制用户进程对内存映射区的访问权限\n   * prot_read：读权限\n   * prot_write：写权限\n   * prot_exec：执行权限\n   * prot_none：无权限\n * flags：控制内存映射区的修改是否被多个进程共享\n   * map_private：对内存映射区数据的修改不会反映到真正的文件，数据修改发生时采用写时复制机制\n   * map_shared：对内存映射区的修改会同步到真正的文件，修改对共享此内存映射区的进程是可见的\n   * map_fixed：不建议使用，这种模式下 addr 参数指定的必须的提供一个存在的 addr 参数\n * fd：文件描述符。每次 map 操作会导致文件的引用计数加 1，每次 unmap 操作或者结束进程会导致引用计数减 1\n * offset：文件偏移量。进行映射的文件位置，从文件起始地址向后的位移量\n\n下面总结一下 mappedbytebuffer 的特点和不足之处：\n\n * mappedbytebuffer 使用是堆外的虚拟内存，因此分配（map）的内存大小不受 jvm 的 -xmx 参数限制，但是也是有大小限制的。 如果当文件超出 integer.max_value 字节限制时，可以通过 position 参数重新 map 文件后面的内容。\n * mappedbytebuffer 在处理大文件时性能的确很高，但也存内存占用、文件关闭不确定等问题，被其打开的文件只有在垃圾回收的才会被关闭，而且这个时间点是不确定的。\n * mappedbytebuffer 提供了文件映射内存的 mmap() 方法，也提供了释放映射内存的 unmap() 方法。然而 unmap() 是 filechannelimpl 中的私有方法，无法直接显示调用。因此，用户程序需要通过 java 反射的调用 sun.misc.cleaner 类的 clean() 方法手动释放映射占用的内存区域。\n\npublic static void clean(final object buffer) throws exception {\n    accesscontroller.doprivileged((privilegedaction<void>) () -> {\n        try {\n            method getcleanermethod = buffer.getclass().getmethod("cleaner", new class[0]);\n            getcleanermethod.setaccessible(true);\n            cleaner cleaner = (cleaner) getcleanermethod.invoke(buffer, new object[0]);\n            cleaner.clean();\n        } catch(exception e) {\n            e.printstacktrace();\n        }\n    });\n}\n\n\n\n# directbytebuffer\n\ndirectbytebuffer 的对象引用位于 java 内存模型的堆里面，jvm 可以对 directbytebuffer 的对象进行内存分配和回收管理，一般使用 directbytebuffer 的静态方法 allocatedirect() 创建 directbytebuffer 实例并分配内存。\n\npublic static bytebuffer allocatedirect(int capacity) {\n    return new directbytebuffer(capacity);\n}\n\n\ndirectbytebuffer 内部的字节缓冲区位在于堆外的（用户态）直接内存，它是通过 unsafe 的本地方法 allocatememory() 进行内存分配，底层调用的是操作系统的 malloc() 函数。\n\ndirectbytebuffer(int cap) {\n    super(-1, 0, cap, cap);\n    boolean pa = vm.isdirectmemorypagealigned();\n    int ps = bits.pagesize();\n    long size = math.max(1l, (long)cap + (pa ? ps : 0));\n    bits.reservememory(size, cap);\n\n    long base = 0;\n    try {\n        base = unsafe.allocatememory(size);\n    } catch (outofmemoryerror x) {\n        bits.unreservememory(size, cap);\n        throw x;\n    }\n    unsafe.setmemory(base, size, (byte) 0);\n    if (pa && (base % ps != 0)) {\n        address = base + ps - (base & (ps - 1));\n    } else {\n        address = base;\n    }\n    cleaner = cleaner.create(this, new deallocator(base, size, cap));\n    att = null;\n}\n\n\n除此之外，初始化 directbytebuffer 时还会创建一个 deallocator 线程，并通过 cleaner 的 freememory() 方法来对直接内存进行回收操作，freememory() 底层调用的是操作系统的 free() 函数。\n\nprivate static class deallocator implements runnable {\n    private static unsafe unsafe = unsafe.getunsafe();\n\n    private long address;\n    private long size;\n    private int capacity;\n\n    private deallocator(long address, long size, int capacity) {\n        assert (address != 0);\n        this.address = address;\n        this.size = size;\n        this.capacity = capacity;\n    }\n\n    public void run() {\n        if (address == 0) {\n            return;\n        }\n        unsafe.freememory(address);\n        address = 0;\n        bits.unreservememory(size, capacity);\n    }\n}\n\n\n由于使用 directbytebuffer 分配的是系统本地的内存，不在 jvm 的管控范围之内，因此直接内存的回收和堆内存的回收不同，直接内存如果使用不当，很容易造成 outofmemoryerror。\n\n说了这么多，那么 directbytebuffer 和零拷贝有什么关系？前面有提到在 mappedbytebuffer 进行内存映射时，它的 map() 方法会通过 util.newmappedbytebuffer() 来创建一个缓冲区实例，初始化的代码如下：\n\nstatic mappedbytebuffer newmappedbytebuffer(int size, long addr, filedescriptor fd,\n                                            runnable unmapper) {\n    mappedbytebuffer dbb;\n    if (directbytebufferconstructor == null)\n        initdbbconstructor();\n    try {\n        dbb = (mappedbytebuffer)directbytebufferconstructor.newinstance(\n            new object[] { new integer(size), new long(addr), fd, unmapper });\n    } catch (instantiationexception | illegalaccessexception | invocationtargetexception e) {\n        throw new internalerror(e);\n    }\n    return dbb;\n}\n\nprivate static void initdbbrconstructor() {\n    accesscontroller.doprivileged(new privilegedaction<void>() {\n        public void run() {\n            try {\n                class<?> cl = class.forname("java.nio.directbytebufferr");\n                constructor<?> ctor = cl.getdeclaredconstructor(\n                    new class<?>[] { int.class, long.class, filedescriptor.class,\n                                    runnable.class });\n                ctor.setaccessible(true);\n                directbytebufferrconstructor = ctor;\n            } catch (classnotfoundexception | nosuchmethodexception |\n                     illegalargumentexception | classcastexception x) {\n                throw new internalerror(x);\n            }\n            return null;\n        }});\n}\n\n\ndirectbytebuffer 是 mappedbytebuffer 的具体实现类。实际上，util.newmappedbytebuffer() 方法通过反射机制获取 directbytebuffer 的构造器，然后创建一个 directbytebuffer 的实例，对应的是一个单独用于内存映射的构造方法：\n\nprotected directbytebuffer(int cap, long addr, filedescriptor fd, runnable unmapper) {\n    super(-1, 0, cap, cap, fd);\n    address = addr;\n    cleaner = cleaner.create(this, unmapper);\n    att = null;\n}\n\n\n因此，除了允许分配操作系统的直接内存以外，directbytebuffer 本身也具有文件内存映射的功能，这里不做过多说明。我们需要关注的是，directbytebuffer 在 mappedbytebuffer 的基础上提供了内存映像文件的随机读取 get() 和写入 write() 的操作。\n\n * 内存映像文件的随机读操作\n\npublic byte get() {\n    return ((unsafe.getbyte(ix(nextgetindex()))));\n}\n\npublic byte get(int i) {\n    return ((unsafe.getbyte(ix(checkindex(i)))));\n}\n\n\n * 内存映像文件的随机写操作\n\npublic bytebuffer put(byte x) {\n    unsafe.putbyte(ix(nextputindex()), ((x)));\n    return this;\n}\n\npublic bytebuffer put(int i, byte x) {\n    unsafe.putbyte(ix(checkindex(i)), ((x)));\n    return this;\n}\n\n\n内存映像文件的随机读写都是借助 ix() 方法实现定位的， ix() 方法通过内存映射空间的内存首地址（address）和给定偏移量 i 计算出指针地址，然后由 unsafe 类的 get() 和 put() 方法和对指针指向的数据进行读取或写入。\n\nprivate long ix(int i) {\n    return address + ((long)i << 0);\n}\n\n\n\n# filechannel\n\nfilechannel 是一个用于文件读写、映射和操作的通道，同时它在并发环境下是线程安全的，基于 fileinputstream、fileoutputstream 或者 randomaccessfile 的 getchannel() 方法可以创建并打开一个文件通道。filechannel 定义了 transferfrom() 和 transferto() 两个抽象方法，它通过在通道和通道之间建立连接实现数据传输的。\n\n * transferto()：通过 filechannel 把文件里面的源数据写入一个 writablebytechannel 的目的通道。\n\npublic abstract long transferto(long position, long count, writablebytechannel target)\n        throws ioexception;\n\n\n * transferfrom()：把一个源通道 readablebytechannel 中的数据读取到当前 filechannel 的文件里面。\n\npublic abstract long transferfrom(readablebytechannel src, long position, long count)\n        throws ioexception;\n\n\n下面给出 filechannel 利用 transferto() 和 transferfrom() 方法进行数据传输的使用示例：\n\nprivate static final string content = "zero copy implemented by filechannel";\nprivate static final string source_file = "/source.txt";\nprivate static final string target_file = "/target.txt";\nprivate static final string charset = "utf-8";\n\n\n首先在类加载根路径下创建 source.txt 和 target.txt 两个文件，对源文件 source.txt 文件写入初始化数据。\n\n@before\npublic void setup() {\n    path source = paths.get(getclasspath(source_file));\n    byte[] bytes = content.getbytes(charset.forname(charset));\n    try (filechannel fromchannel = filechannel.open(source, standardopenoption.read,\n            standardopenoption.write, standardopenoption.truncate_existing)) {\n        fromchannel.write(bytebuffer.wrap(bytes));\n    } catch (ioexception e) {\n        e.printstacktrace();\n    }\n}\n\n\n对于 transferto() 方法而言，目的通道 tochannel 可以是任意的单向字节写通道 writablebytechannel；而对于 transferfrom() 方法而言，源通道 fromchannel 可以是任意的单向字节读通道 readablebytechannel。其中，filechannel、socketchannel 和 datagramchannel 等通道实现了 writablebytechannel 和 readablebytechannel 接口，都是同时支持读写的双向通道。为了方便测试，下面给出基于 filechannel 完成 channel-to-channel 的数据传输示例。\n\n通过 transferto() 将 fromchannel 中的数据拷贝到 tochannel\n\n@test\npublic void transferto() throws exception {\n    try (filechannel fromchannel = new randomaccessfile(\n             getclasspath(source_file), "rw").getchannel();\n         filechannel tochannel = new randomaccessfile(\n             getclasspath(target_file), "rw").getchannel()) {\n        long position = 0l;\n        long offset = fromchannel.size();\n        fromchannel.transferto(position, offset, tochannel);\n    }\n}\n\n\n通过 transferfrom() 将 fromchannel 中的数据拷贝到 tochannel\n\n@test\npublic void transferfrom() throws exception {\n    try (filechannel fromchannel = new randomaccessfile(\n             getclasspath(source_file), "rw").getchannel();\n         filechannel tochannel = new randomaccessfile(\n             getclasspath(target_file), "rw").getchannel()) {\n        long position = 0l;\n        long offset = fromchannel.size();\n        tochannel.transferfrom(fromchannel, position, offset);\n    }\n}\n\n\n下面介绍 transferto() 和 transferfrom() 方法的底层实现原理，这两个方法也是 java.nio.channels.filechannel 的抽象方法，由子类 sun.nio.ch.filechannelimpl.java 实现。transferto() 和 transferfrom() 底层都是基于 sendfile 实现数据传输的，其中 filechannelimpl.java 定义了 3 个常量，用于标示当前操作系统的内核是否支持 sendfile 以及 sendfile 的相关特性。\n\nprivate static volatile boolean transfersupported = true;\nprivate static volatile boolean pipesupported = true;\nprivate static volatile boolean filesupported = true;\n\n\n * transfersupported：用于标记当前的系统内核是否支持 sendfile() 调用，默认为 true。\n * pipesupported：用于标记当前的系统内核是否支持文件描述符（fd）基于管道（pipe）的 sendfile() 调用，默认为 true。\n * filesupported：用于标记当前的系统内核是否支持文件描述符（fd）基于文件（file）的 sendfile() 调用，默认为 true。\n\n下面以 transferto() 的源码实现为例。filechannelimpl 首先执行 transfertodirectly() 方法，以 sendfile 的零拷贝方式尝试数据拷贝。如果系统内核不支持 sendfile，进一步执行 transfertotrustedchannel() 方法，以 mmap 的零拷贝方式进行内存映射，这种情况下目的通道必须是 filechannelimpl 或者 selchimpl 类型。如果以上两步都失败了，则执行 transfertoarbitrarychannel() 方法，基于传统的 i/o 方式完成读写，具体步骤是初始化一个临时的 directbuffer，将源通道 filechannel 的数据读取到 directbuffer，再写入目的通道 writablebytechannel 里面。\n\npublic long transferto(long position, long count, writablebytechannel target)\n        throws ioexception {\n    // 计算文件的大小\n    long sz = size();\n    // 校验起始位置\n    if (position > sz)\n        return 0;\n    int icount = (int)math.min(count, integer.max_value);\n    // 校验偏移量\n    if ((sz - position) < icount)\n        icount = (int)(sz - position);\n\n    long n;\n\n    if ((n = transfertodirectly(position, icount, target)) >= 0)\n        return n;\n\n    if ((n = transfertotrustedchannel(position, icount, target)) >= 0)\n        return n;\n\n    return transfertoarbitrarychannel(position, icount, target);\n}\n\n\n接下来重点分析一下 transfertodirectly() 方法的实现，也就是 transferto() 通过 sendfile 实现零拷贝的精髓所在。可以看到，transfertodirectlyinternal() 方法先获取到目的通道 writablebytechannel 的文件描述符 targetfd，获取同步锁然后执行 transfertodirectlyinternal() 方法。\n\nprivate long transfertodirectly(long position, int icount, writablebytechannel target)\n        throws ioexception {\n    // 省略从target获取targetfd的过程\n    if (nd.transfertodirectlyneedspositionlock()) {\n        synchronized (positionlock) {\n            long pos = position();\n            try {\n                return transfertodirectlyinternal(position, icount,\n                        target, targetfd);\n            } finally {\n                position(pos);\n            }\n        }\n    } else {\n        return transfertodirectlyinternal(position, icount, target, targetfd);\n    }\n}\n\n\n最终由 transfertodirectlyinternal() 调用本地方法 transferto0() ，尝试以 sendfile 的方式进行数据传输。如果系统内核完全不支持 sendfile，比如 windows 操作系统，则返回 unsupported 并把 transfersupported 标识为 false。如果系统内核不支持 sendfile 的一些特性，比如说低版本的 linux 内核不支持 dma gather copy 操作，则返回 unsupported_case 并把 pipesupported 或者 filesupported 标识为 false。\n\nprivate long transfertodirectlyinternal(long position, int icount,\n                                        writablebytechannel target,\n                                        filedescriptor targetfd) throws ioexception {\n    assert !nd.transfertodirectlyneedspositionlock() ||\n            thread.holdslock(positionlock);\n\n    long n = -1;\n    int ti = -1;\n    try {\n        begin();\n        ti = threads.add();\n        if (!isopen())\n            return -1;\n        do {\n            n = transferto0(fd, position, icount, targetfd);\n        } while ((n == iostatus.interrupted) && isopen());\n        if (n == iostatus.unsupported_case) {\n            if (target instanceof sinkchannelimpl)\n                pipesupported = false;\n            if (target instanceof filechannelimpl)\n                filesupported = false;\n            return iostatus.unsupported_case;\n        }\n        if (n == iostatus.unsupported) {\n            transfersupported = false;\n            return iostatus.unsupported;\n        }\n        return iostatus.normalize(n);\n    } finally {\n        threads.remove(ti);\n        end (n > -1);\n    }\n}\n\n\n本地方法（native method）transferto0() 通过 jni（java native interface）调用底层 c 的函数，这个 native 函数（java_sun_nio_ch_filechannelimpl_transferto0）同样位于 jdk 源码包下的 native/sun/nio/ch/filechannelimpl.c 源文件里面。jni 函数 java_sun_nio_ch_filechannelimpl_transferto0() 基于条件编译对不同的系统进行预编译，下面是 jdk 基于 linux 系统内核对 transferto() 提供的调用封装。\n\n#if defined(__linux__) || defined(__solaris__)\n#include <sys/sendfile.h>\n#elif defined(_aix)\n#include <sys/socket.h>\n#elif defined(_allbsd_source)\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/uio.h>\n\n#define lseek64 lseek\n#define mmap64 mmap\n#endif\n\njniexport jlong jnicall\njava_sun_nio_ch_filechannelimpl_transferto0(jnienv *env, jobject this,\n                                            jobject srcfdo,\n                                            jlong position, jlong count,\n                                            jobject dstfdo)\n{\n    jint srcfd = fdval(env, srcfdo);\n    jint dstfd = fdval(env, dstfdo);\n\n#if defined(__linux__)\n    off64_t offset = (off64_t)position;\n    jlong n = sendfile64(dstfd, srcfd, &offset, (size_t)count);\n    return n;\n#elif defined(__solaris__)\n    result = sendfilev64(dstfd, &sfv, 1, &numbytes);    \n    return result;\n#elif defined(__apple__)\n    result = sendfile(srcfd, dstfd, position, &numbytes, null, 0);\n    return result;\n#endif\n}\n\n\n对 linux、solaris 以及 apple 系统而言，transferto0() 函数底层会执行 sendfile64 这个系统调用完成零拷贝操作，sendfile64() 函数的原型如下：\n\n#include <sys/sendfile.h>\n\nssize_t sendfile64(int out_fd, int in_fd, off_t *offset, size_t count);\n\n\n下面简单介绍一下 sendfile64() 函数各个参数的含义：\n\n * out_fd：待写入的文件描述符\n * in_fd：待读取的文件描述符\n * offset：指定 in_fd 对应文件流的读取位置，如果为空，则默认从起始位置开始\n * count：指定在文件描述符 in_fd 和 out_fd 之间传输的字节数\n\n在 linux 2.6.3 之前，out_fd 必须是一个 socket，而从 linux 2.6.3 以后，out_fd 可以是任何文件。也就是说，sendfile64() 函数不仅可以进行网络文件传输，还可以对本地文件实现零拷贝操作。\n\n\n# 其它的零拷贝实现\n\n\n# netty零拷贝\n\nnetty 中的零拷贝和上面提到的操作系统层面上的零拷贝不太一样, 我们所说的 netty 零拷贝完全是基于（java 层面）用户态的，它的更多的是偏向于数据操作优化这样的概念，具体表现在以下几个方面：\n\nnetty 通过 defaultfileregion 类对 java.nio.channels.filechannel 的 tranferto() 方法进行包装，在文件传输时可以将文件缓冲区的数据直接发送到目的通道（channel）\n\nbytebuf 可以通过 wrap 操作把字节数组、bytebuf、bytebuffer 包装成一个 bytebuf 对象, 进而避免了拷贝操作 bytebuf 支持 slice 操作, 因此可以将 bytebuf 分解为多个共享同一个存储区域的 bytebuf，避免了内存的拷贝 netty 提供了 compositebytebuf 类，它可以将多个 bytebuf 合并为一个逻辑上的 bytebuf，避免了各个 bytebuf 之间的拷贝 其中第 1 条属于操作系统层面的零拷贝操作，后面 3 条只能算用户层面的数据操作优化。\n\n\n# rocketmq和kafka对比\n\nrocketmq 选择了 mmap + write 这种零拷贝方式，适用于业务级消息这种小块文件的数据持久化和传输；而 kafka 采用的是 sendfile 这种零拷贝方式，适用于系统日志消息这种高吞吐量的大块文件的数据持久化和传输。但是值得注意的一点是，kafka 的索引文件使用的是 mmap + write 方式，数据文件使用的是 sendfile 方式。\n\n\n\n\n# 参考文章\n\n * 本文主要整理自 https://zhuanlan.zhihu.com/p/83398714\n * 作者：零壹技术栈',charsets:{cjk:!0}},{title:"Java NIO - 基础详解",frontmatter:{},regularPath:"/java/io/java-io-nio.html",relativePath:"java/io/java-io-nio.md",key:"v-d895a124",path:"/java/io/java-io-nio.html",headers:[{level:2,title:"Java NIO - 基础详解",slug:"java-nio-基础详解",normalizedTitle:"java nio - 基础详解",charIndex:2},{level:2,title:"流与块",slug:"流与块",normalizedTitle:"流与块",charIndex:114},{level:2,title:"通道与缓冲区",slug:"通道与缓冲区",normalizedTitle:"通道与缓冲区",charIndex:123},{level:3,title:"1\\. 通道",slug:"_1-通道",normalizedTitle:"1. 通道",charIndex:137},{level:3,title:"2\\. 缓冲区",slug:"_2-缓冲区",normalizedTitle:"2. 缓冲区",charIndex:150},{level:2,title:"缓冲区状态变量",slug:"缓冲区状态变量",normalizedTitle:"缓冲区状态变量",charIndex:162},{level:2,title:"文件 NIO 实例",slug:"文件-nio-实例",normalizedTitle:"文件 nio 实例",charIndex:175},{level:2,title:"选择器",slug:"选择器",normalizedTitle:"选择器",charIndex:190},{level:3,title:"1\\. 创建选择器",slug:"_1-创建选择器",normalizedTitle:"1. 创建选择器",charIndex:201},{level:3,title:"2\\. 将通道注册到选择器上",slug:"_2-将通道注册到选择器上",normalizedTitle:"2. 将通道注册到选择器上",charIndex:217},{level:3,title:"3\\. 监听事件",slug:"_3-监听事件",normalizedTitle:"3. 监听事件",charIndex:238},{level:3,title:"4\\. 获取到达的事件",slug:"_4-获取到达的事件",normalizedTitle:"4. 获取到达的事件",charIndex:253},{level:3,title:"5\\. 事件循环",slug:"_5-事件循环",normalizedTitle:"5. 事件循环",charIndex:271},{level:2,title:"套接字 NIO 实例",slug:"套接字-nio-实例",normalizedTitle:"套接字 nio 实例",charIndex:284},{level:2,title:"内存映射文件",slug:"内存映射文件",normalizedTitle:"内存映射文件",charIndex:300},{level:2,title:"对比",slug:"对比",normalizedTitle:"对比",charIndex:312},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:320}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java NIO - 基础详解 流与块 通道与缓冲区 1\\. 通道 2\\. 缓冲区 缓冲区状态变量 文件 NIO 实例 选择器 1\\. 创建选择器 2\\. 将通道注册到选择器上 3\\. 监听事件 4\\. 获取到达的事件 5\\. 事件循环 套接字 NIO 实例 内存映射文件 对比 参考文章",content:'# Java NIO - 基础详解\n\n> 新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。@pdai\n\n * Java NIO - 基础详解\n   * 流与块\n   * 通道与缓冲区\n     * 1. 通道\n     * 2. 缓冲区\n   * 缓冲区状态变量\n   * 文件 NIO 实例\n   * 选择器\n     * 1. 创建选择器\n     * 2. 将通道注册到选择器上\n     * 3. 监听事件\n     * 4. 获取到达的事件\n     * 5. 事件循环\n   * 套接字 NIO 实例\n   * 内存映射文件\n   * 对比\n   * 参考文章\n\nStandard IO是对字节流的读写，在进行IO之前，首先创建一个流对象，流对象进行读写操作都是按字节 ，一个字节一个字节的来读或写。而NIO把IO抽象成块，类似磁盘的读写，每次IO操作的单位都是一个块，块被读入内存之后就是一个byte[]，NIO一次可以读或写多个字节。\n\n\n# 流与块\n\nI/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。\n\n面向流的 I/O 一次处理一个字节数据: 一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。\n\n面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。\n\nI/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。\n\n\n# 通道与缓冲区\n\n\n# 1. 通道\n\n通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。\n\n通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。\n\n通道包括以下类型:\n\n * FileChannel: 从文件中读写数据；\n * DatagramChannel: 通过 UDP 读写网络中数据；\n * SocketChannel: 通过 TCP 读写网络中数据；\n * ServerSocketChannel: 可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。\n\n\n# 2. 缓冲区\n\n发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。\n\n缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。\n\n缓冲区包括以下类型:\n\n * ByteBuffer\n * CharBuffer\n * ShortBuffer\n * IntBuffer\n * LongBuffer\n * FloatBuffer\n * DoubleBuffer\n\n\n# 缓冲区状态变量\n\n * capacity: 最大容量；\n * position: 当前已经读写的字节数；\n * limit: 还可以读写的字节数。\n\n状态变量的改变过程举例:\n\n① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。\n\n\n\n② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 移动设置为 5，limit 保持不变。\n\n\n\n③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。\n\n\n\n④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。\n\n\n\n⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。\n\n\n\n\n# 文件 NIO 实例\n\n以下展示了使用 NIO 快速复制文件的实例:\n\npublic static void fastCopy(String src, String dist) throws IOException {\n\n    /* 获得源文件的输入字节流 */\n    FileInputStream fin = new FileInputStream(src);\n\n    /* 获取输入字节流的文件通道 */\n    FileChannel fcin = fin.getChannel();\n\n    /* 获取目标文件的输出字节流 */\n    FileOutputStream fout = new FileOutputStream(dist);\n\n    /* 获取输出字节流的通道 */\n    FileChannel fcout = fout.getChannel();\n\n    /* 为缓冲区分配 1024 个字节 */\n    ByteBuffer buffer = ByteBuffer.allocateDirect(1024);\n\n    while (true) {\n\n        /* 从输入通道中读取数据到缓冲区中 */\n        int r = fcin.read(buffer);\n\n        /* read() 返回 -1 表示 EOF */\n        if (r == -1) {\n            break;\n        }\n\n        /* 切换读写 */\n        buffer.flip();\n\n        /* 把缓冲区的内容写入输出文件中 */\n        fcout.write(buffer);\n        \n        /* 清空缓冲区 */\n        buffer.clear();\n    }\n}\n\n\n\n# 选择器\n\nNIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。\n\nNIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。\n\n通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。\n\n因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件具有更好的性能。\n\n应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。\n\n\n\n\n# 1. 创建选择器\n\nSelector selector = Selector.open();\n\n\n\n# 2. 将通道注册到选择器上\n\nServerSocketChannel ssChannel = ServerSocketChannel.open();\nssChannel.configureBlocking(false);\nssChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n\n通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。\n\n在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类:\n\n * SelectionKey.OP_CONNECT\n * SelectionKey.OP_ACCEPT\n * SelectionKey.OP_READ\n * SelectionKey.OP_WRITE\n\n它们在 SelectionKey 的定义如下:\n\npublic static final int OP_READ = 1 << 0;\npublic static final int OP_WRITE = 1 << 2;\npublic static final int OP_CONNECT = 1 << 3;\npublic static final int OP_ACCEPT = 1 << 4;\n\n\n可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如:\n\nint interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;\n\n\n\n# 3. 监听事件\n\nint num = selector.select();\n\n\n使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。\n\n\n# 4. 获取到达的事件\n\nSet<SelectionKey> keys = selector.selectedKeys();\nIterator<SelectionKey> keyIterator = keys.iterator();\nwhile (keyIterator.hasNext()) {\n    SelectionKey key = keyIterator.next();\n    if (key.isAcceptable()) {\n        // ...\n    } else if (key.isReadable()) {\n        // ...\n    }\n    keyIterator.remove();\n}\n\n\n\n# 5. 事件循环\n\n因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。\n\nwhile (true) {\n    int num = selector.select();\n    Set<SelectionKey> keys = selector.selectedKeys();\n    Iterator<SelectionKey> keyIterator = keys.iterator();\n    while (keyIterator.hasNext()) {\n        SelectionKey key = keyIterator.next();\n        if (key.isAcceptable()) {\n            // ...\n        } else if (key.isReadable()) {\n            // ...\n        }\n        keyIterator.remove();\n    }\n}\n\n\n\n# 套接字 NIO 实例\n\npublic class NIOServer {\n\n    public static void main(String[] args) throws IOException {\n\n        Selector selector = Selector.open();\n\n        ServerSocketChannel ssChannel = ServerSocketChannel.open();\n        ssChannel.configureBlocking(false);\n        ssChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        ServerSocket serverSocket = ssChannel.socket();\n        InetSocketAddress address = new InetSocketAddress("127.0.0.1", 8888);\n        serverSocket.bind(address);\n\n        while (true) {\n\n            selector.select();\n            Set<SelectionKey> keys = selector.selectedKeys();\n            Iterator<SelectionKey> keyIterator = keys.iterator();\n\n            while (keyIterator.hasNext()) {\n\n                SelectionKey key = keyIterator.next();\n\n                if (key.isAcceptable()) {\n\n                    ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel();\n\n                    // 服务器会为每个新连接创建一个 SocketChannel\n                    SocketChannel sChannel = ssChannel1.accept();\n                    sChannel.configureBlocking(false);\n\n                    // 这个新连接主要用于从客户端读取数据\n                    sChannel.register(selector, SelectionKey.OP_READ);\n\n                } else if (key.isReadable()) {\n\n                    SocketChannel sChannel = (SocketChannel) key.channel();\n                    System.out.println(readDataFromSocketChannel(sChannel));\n                    sChannel.close();\n                }\n\n                keyIterator.remove();\n            }\n        }\n    }\n\n    private static String readDataFromSocketChannel(SocketChannel sChannel) throws IOException {\n\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        StringBuilder data = new StringBuilder();\n\n        while (true) {\n\n            buffer.clear();\n            int n = sChannel.read(buffer);\n            if (n == -1) {\n                break;\n            }\n            buffer.flip();\n            int limit = buffer.limit();\n            char[] dst = new char[limit];\n            for (int i = 0; i < limit; i++) {\n                dst[i] = (char) buffer.get(i);\n            }\n            data.append(dst);\n            buffer.clear();\n        }\n        return data.toString();\n    }\n}\n\n\npublic class NIOClient {\n\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket("127.0.0.1", 8888);\n        OutputStream out = socket.getOutputStream();\n        String s = "hello world";\n        out.write(s.getBytes());\n        out.close();\n    }\n}\n\n\n\n# 内存映射文件\n\n内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。\n\n向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。\n\n下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。\n\nMappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, 0, 1024);\n\n\n\n# 对比\n\nNIO 与普通 I/O 的区别主要有以下两点:\n\n * NIO 是非阻塞的\n * NIO 面向块，I/O 面向流\n\n\n# 参考文章\n\n * Java NIO Tutorial在新窗口打开\n * Java NIO 浅析在新窗口打开\n * IBM: NIO 入门在新窗口打开\n * Eckel B, 埃克尔, 昊鹏, 等. Java 编程思想 [M]. 机械工业出版社, 2002.\n * IBM: NIO 入门在新窗口打开\n * IBM: 深入分析 Java I/O 的工作机制在新窗口打开\n * IBM: 深入分析 Java 中的中文编码问题在新窗口打开\n * IBM: Java 序列化的高级认识在新窗口打开\n * NIO 与传统 IO 的区别在新窗口打开\n * Decorator Design Pattern在新窗口打开\n * Socket Multicast在新窗口打开',normalizedContent:'# java nio - 基础详解\n\n> 新的输入/输出 (nio) 库是在 jdk 1.4 中引入的，弥补了原来的 i/o 的不足，提供了高速的、面向块的 i/o。@pdai\n\n * java nio - 基础详解\n   * 流与块\n   * 通道与缓冲区\n     * 1. 通道\n     * 2. 缓冲区\n   * 缓冲区状态变量\n   * 文件 nio 实例\n   * 选择器\n     * 1. 创建选择器\n     * 2. 将通道注册到选择器上\n     * 3. 监听事件\n     * 4. 获取到达的事件\n     * 5. 事件循环\n   * 套接字 nio 实例\n   * 内存映射文件\n   * 对比\n   * 参考文章\n\nstandard io是对字节流的读写，在进行io之前，首先创建一个流对象，流对象进行读写操作都是按字节 ，一个字节一个字节的来读或写。而nio把io抽象成块，类似磁盘的读写，每次io操作的单位都是一个块，块被读入内存之后就是一个byte[]，nio一次可以读或写多个字节。\n\n\n# 流与块\n\ni/o 与 nio 最重要的区别是数据打包和传输的方式，i/o 以流的方式处理数据，而 nio 以块的方式处理数据。\n\n面向流的 i/o 一次处理一个字节数据: 一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 i/o 通常相当慢。\n\n面向块的 i/o 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 i/o 缺少一些面向流的 i/o 所具有的优雅性和简单性。\n\ni/o 包和 nio 已经很好地集成了，java.io.* 已经以 nio 为基础重新实现了，所以现在它可以利用 nio 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。\n\n\n# 通道与缓冲区\n\n\n# 1. 通道\n\n通道 channel 是对原 i/o 包中的流的模拟，可以通过它读取和写入数据。\n\n通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 inputstream 或者 outputstream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。\n\n通道包括以下类型:\n\n * filechannel: 从文件中读写数据；\n * datagramchannel: 通过 udp 读写网络中数据；\n * socketchannel: 通过 tcp 读写网络中数据；\n * serversocketchannel: 可以监听新进来的 tcp 连接，对每一个新进来的连接都会创建一个 socketchannel。\n\n\n# 2. 缓冲区\n\n发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。\n\n缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。\n\n缓冲区包括以下类型:\n\n * bytebuffer\n * charbuffer\n * shortbuffer\n * intbuffer\n * longbuffer\n * floatbuffer\n * doublebuffer\n\n\n# 缓冲区状态变量\n\n * capacity: 最大容量；\n * position: 当前已经读写的字节数；\n * limit: 还可以读写的字节数。\n\n状态变量的改变过程举例:\n\n① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。\n\n\n\n② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 移动设置为 5，limit 保持不变。\n\n\n\n③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。\n\n\n\n④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。\n\n\n\n⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。\n\n\n\n\n# 文件 nio 实例\n\n以下展示了使用 nio 快速复制文件的实例:\n\npublic static void fastcopy(string src, string dist) throws ioexception {\n\n    /* 获得源文件的输入字节流 */\n    fileinputstream fin = new fileinputstream(src);\n\n    /* 获取输入字节流的文件通道 */\n    filechannel fcin = fin.getchannel();\n\n    /* 获取目标文件的输出字节流 */\n    fileoutputstream fout = new fileoutputstream(dist);\n\n    /* 获取输出字节流的通道 */\n    filechannel fcout = fout.getchannel();\n\n    /* 为缓冲区分配 1024 个字节 */\n    bytebuffer buffer = bytebuffer.allocatedirect(1024);\n\n    while (true) {\n\n        /* 从输入通道中读取数据到缓冲区中 */\n        int r = fcin.read(buffer);\n\n        /* read() 返回 -1 表示 eof */\n        if (r == -1) {\n            break;\n        }\n\n        /* 切换读写 */\n        buffer.flip();\n\n        /* 把缓冲区的内容写入输出文件中 */\n        fcout.write(buffer);\n        \n        /* 清空缓冲区 */\n        buffer.clear();\n    }\n}\n\n\n\n# 选择器\n\nnio 常常被叫做非阻塞 io，主要是因为 nio 在网络通信中的非阻塞特性被广泛使用。\n\nnio 实现了 io 多路复用中的 reactor 模型，一个线程 thread 使用一个选择器 selector 通过轮询的方式去监听多个通道 channel 上的事件，从而让一个线程就可以处理多个事件。\n\n通过配置监听的通道 channel 为非阻塞，那么当 channel 上的 io 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 channel，找到 io 事件已经到达的 channel 执行。\n\n因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件具有更好的性能。\n\n应该注意的是，只有套接字 channel 才能配置为非阻塞，而 filechannel 不能，为 filechannel 配置非阻塞也没有意义。\n\n\n\n\n# 1. 创建选择器\n\nselector selector = selector.open();\n\n\n\n# 2. 将通道注册到选择器上\n\nserversocketchannel sschannel = serversocketchannel.open();\nsschannel.configureblocking(false);\nsschannel.register(selector, selectionkey.op_accept);\n\n\n通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。\n\n在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类:\n\n * selectionkey.op_connect\n * selectionkey.op_accept\n * selectionkey.op_read\n * selectionkey.op_write\n\n它们在 selectionkey 的定义如下:\n\npublic static final int op_read = 1 << 0;\npublic static final int op_write = 1 << 2;\npublic static final int op_connect = 1 << 3;\npublic static final int op_accept = 1 << 4;\n\n\n可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如:\n\nint interestset = selectionkey.op_read | selectionkey.op_write;\n\n\n\n# 3. 监听事件\n\nint num = selector.select();\n\n\n使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。\n\n\n# 4. 获取到达的事件\n\nset<selectionkey> keys = selector.selectedkeys();\niterator<selectionkey> keyiterator = keys.iterator();\nwhile (keyiterator.hasnext()) {\n    selectionkey key = keyiterator.next();\n    if (key.isacceptable()) {\n        // ...\n    } else if (key.isreadable()) {\n        // ...\n    }\n    keyiterator.remove();\n}\n\n\n\n# 5. 事件循环\n\n因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。\n\nwhile (true) {\n    int num = selector.select();\n    set<selectionkey> keys = selector.selectedkeys();\n    iterator<selectionkey> keyiterator = keys.iterator();\n    while (keyiterator.hasnext()) {\n        selectionkey key = keyiterator.next();\n        if (key.isacceptable()) {\n            // ...\n        } else if (key.isreadable()) {\n            // ...\n        }\n        keyiterator.remove();\n    }\n}\n\n\n\n# 套接字 nio 实例\n\npublic class nioserver {\n\n    public static void main(string[] args) throws ioexception {\n\n        selector selector = selector.open();\n\n        serversocketchannel sschannel = serversocketchannel.open();\n        sschannel.configureblocking(false);\n        sschannel.register(selector, selectionkey.op_accept);\n\n        serversocket serversocket = sschannel.socket();\n        inetsocketaddress address = new inetsocketaddress("127.0.0.1", 8888);\n        serversocket.bind(address);\n\n        while (true) {\n\n            selector.select();\n            set<selectionkey> keys = selector.selectedkeys();\n            iterator<selectionkey> keyiterator = keys.iterator();\n\n            while (keyiterator.hasnext()) {\n\n                selectionkey key = keyiterator.next();\n\n                if (key.isacceptable()) {\n\n                    serversocketchannel sschannel1 = (serversocketchannel) key.channel();\n\n                    // 服务器会为每个新连接创建一个 socketchannel\n                    socketchannel schannel = sschannel1.accept();\n                    schannel.configureblocking(false);\n\n                    // 这个新连接主要用于从客户端读取数据\n                    schannel.register(selector, selectionkey.op_read);\n\n                } else if (key.isreadable()) {\n\n                    socketchannel schannel = (socketchannel) key.channel();\n                    system.out.println(readdatafromsocketchannel(schannel));\n                    schannel.close();\n                }\n\n                keyiterator.remove();\n            }\n        }\n    }\n\n    private static string readdatafromsocketchannel(socketchannel schannel) throws ioexception {\n\n        bytebuffer buffer = bytebuffer.allocate(1024);\n        stringbuilder data = new stringbuilder();\n\n        while (true) {\n\n            buffer.clear();\n            int n = schannel.read(buffer);\n            if (n == -1) {\n                break;\n            }\n            buffer.flip();\n            int limit = buffer.limit();\n            char[] dst = new char[limit];\n            for (int i = 0; i < limit; i++) {\n                dst[i] = (char) buffer.get(i);\n            }\n            data.append(dst);\n            buffer.clear();\n        }\n        return data.tostring();\n    }\n}\n\n\npublic class nioclient {\n\n    public static void main(string[] args) throws ioexception {\n        socket socket = new socket("127.0.0.1", 8888);\n        outputstream out = socket.getoutputstream();\n        string s = "hello world";\n        out.write(s.getbytes());\n        out.close();\n    }\n}\n\n\n\n# 内存映射文件\n\n内存映射文件 i/o 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 i/o 快得多。\n\n向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。\n\n下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 mappedbytebuffer，它是 bytebuffer 的子类。因此，可以像使用其他任何 bytebuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。\n\nmappedbytebuffer mbb = fc.map(filechannel.mapmode.read_write, 0, 1024);\n\n\n\n# 对比\n\nnio 与普通 i/o 的区别主要有以下两点:\n\n * nio 是非阻塞的\n * nio 面向块，i/o 面向流\n\n\n# 参考文章\n\n * java nio tutorial在新窗口打开\n * java nio 浅析在新窗口打开\n * ibm: nio 入门在新窗口打开\n * eckel b, 埃克尔, 昊鹏, 等. java 编程思想 [m]. 机械工业出版社, 2002.\n * ibm: nio 入门在新窗口打开\n * ibm: 深入分析 java i/o 的工作机制在新窗口打开\n * ibm: 深入分析 java 中的中文编码问题在新窗口打开\n * ibm: java 序列化的高级认识在新窗口打开\n * nio 与传统 io 的区别在新窗口打开\n * decorator design pattern在新窗口打开\n * socket multicast在新窗口打开',charsets:{cjk:!0}},{title:"Java N(A)IO - 框架: Netty",frontmatter:{},regularPath:"/java/io/java-io-nio-netty.html",relativePath:"java/io/java-io-nio-netty.md",key:"v-bf576b64",path:"/java/io/java-io-nio-netty.html",headers:[{level:2,title:"Java N(A)IO - 框架: Netty",slug:"java-n-a-io-框架-netty",normalizedTitle:"java n(a)io - 框架: netty",charIndex:2},{level:2,title:"NIO框架",slug:"nio框架",normalizedTitle:"nio框架",charIndex:48},{level:2,title:"比较好的基于NIO的开源框架(Netty)",slug:"比较好的基于nio的开源框架-netty",normalizedTitle:"比较好的基于nio的开源框架(netty)",charIndex:221},{level:3,title:"优点",slug:"优点",normalizedTitle:"优点",charIndex:250},{level:3,title:"例子",slug:"例子",normalizedTitle:"例子",charIndex:260},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:268}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java N(A)IO - 框架: Netty NIO框架 比较好的基于NIO的开源框架(Netty) 优点 例子 参考文章",content:'# Java N(A)IO - 框架: Netty\n\n> Netty是一个高性能、异步事件驱动的NIO框架，提供了对TCP、UDP和文件传输的支持。作为当前最流行的NIO框架，Netty在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，一些业界著名的开源组件也基于Netty构建，比如RPC框架、zookeeper等。@pdai\n\n * Java N(A)IO - 框架: Netty\n   * NIO框架\n   * 比较好的基于NIO的开源框架(Netty)\n     * 优点\n     * 例子\n   * 参考文章\n\n\n# NIO框架\n\n目前流行的NIO框架非常的多。在论坛上、互联网上大家讨论和使用最多的有以下几种:\n\n * 原生JAVA NIO框架:\n\nJAVA NIO通信框架基于多路复用IO原理，我们将详细讲解它的工作原理。\n\n * APACHE MINA 2:\n\n是一个网络应用程序框架，用来帮助用户简单地开发高性能和高可扩展性的网络应用程序。它提供了一个通过Java NIO在不同的传输例如TCP/IP和UDP/IP上抽象的事件驱动的异步API。\n\n * NETTY 4/5:\n\nNetty是由JBOSS提供的一个java开源框架。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。我们将讲解NETTY 4 的工作原理。另外说一句: MINA和NETTY的主要作者是同一人Trustin Lee。\n\n * Grizzly:\n\nGrizzly是一种应用程序框架，专门解决编写成千上万用户访问服务器时候产生的各种问题。使用JAVA NIO作为基础，并隐藏其编程的复杂性。\n\n\n# 比较好的基于NIO的开源框架(Netty)\n\n\n# 优点\n\n * api简单，开发门槛低\n * 功能强大，内置了多种编码、解码功能\n * 与其它业界主流的NIO框架对比，netty的综合性能最优\n * 社区活跃，使用广泛，经历过很多商业应用项目的考验\n * 定制能力强，可以对框架进行灵活的扩展\n\n\n# 例子\n\n<dependency>\n     <groupId>org.jboss.netty</groupId>\n     <artifactId>netty</artifactId>\n     <version>3.2.5.Final</version>\n</dependency>\n\n\n * 服务端。接收客户端请求并将内容打印出来，同时发送一个消息收到回执。\n\npublic class NettyServer {\n\n    private static int HEADER_LENGTH = 4;\n\n    public void bind(int port) throws Exception {\n\n        ServerBootstrap b = new ServerBootstrap(new NioServerSocketChannelFactory(Executors.newCachedThreadPool(),\n                                                                                  Executors.newCachedThreadPool()));\n\n        // 构造对应的pipeline\n        b.setPipelineFactory(new ChannelPipelineFactory() {\n\n            public ChannelPipeline getPipeline() throws Exception {\n                ChannelPipeline pipelines = Channels.pipeline();\n                pipelines.addLast(MessageHandler.class.getName(), new MessageHandler());\n                return pipelines;\n            }\n        });\n        // 监听端口号\n        b.bind(new InetSocketAddress(port));\n    }\n\n    // 处理消息\n    static class MessageHandler extends SimpleChannelHandler {\n\n        public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n            // 接收客户端请求\n            ChannelBuffer buffer = (ChannelBuffer) e.getMessage();\n            String message = new String(buffer.readBytes(buffer.readableBytes()).array(), "UTF-8");\n            System.out.println("<服务端>收到内容=" + message);\n\n            // 给客户端发送回执\n            byte[] body = "服务端已收到".getBytes();\n            byte[] header = ByteBuffer.allocate(HEADER_LENGTH).order(ByteOrder.BIG_ENDIAN).putInt(body.length).array();\n            Channels.write(ctx.getChannel(), ChannelBuffers.wrappedBuffer(header, body));\n            System.out.println("<服务端>发送回执,time=" + System.currentTimeMillis());\n\n        }\n    }\n\n    public static void main(String[] args) {\n        try {\n            new NettyServer().bind(1088);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        ;\n    }\n}\n\n\n * 客户端。向服务端发送一个请求，然后打印服务端响应的内容。\n\npublic class NettyClient {\n\n    private final ByteBuffer readHeader  = ByteBuffer.allocate(4).order(ByteOrder.BIG_ENDIAN);\n    private final ByteBuffer writeHeader = ByteBuffer.allocate(4).order(ByteOrder.BIG_ENDIAN);\n    private SocketChannel    channel;\n\n    public void sendMessage(byte[] body) throws Exception {\n        // 创建客户端通道\n        channel = SocketChannel.open();\n        channel.socket().setSoTimeout(60000);\n        channel.connect(new InetSocketAddress(AddressUtils.getHostIp(), 1088));\n\n        // 客户端发请求\n        writeWithHeader(channel, body);\n\n        // 接收服务端响应的信息\n        readHeader.clear();\n        read(channel, readHeader);\n        int bodyLen = readHeader.getInt(0);\n        ByteBuffer bodyBuf = ByteBuffer.allocate(bodyLen).order(ByteOrder.BIG_ENDIAN);\n        read(channel, bodyBuf);\n        System.out.println("<客户端>收到响应内容: " + new String(bodyBuf.array(), "UTF-8") + ",长度:" + bodyLen);\n    }\n\n    private void writeWithHeader(SocketChannel channel, byte[] body) throws IOException {\n        writeHeader.clear();\n        writeHeader.putInt(body.length);\n        writeHeader.flip();\n        // channel.write(writeHeader);\n        channel.write(ByteBuffer.wrap(body));\n    }\n\n    private void read(SocketChannel channel, ByteBuffer buffer) throws IOException {\n        while (buffer.hasRemaining()) {\n            int r = channel.read(buffer);\n            if (r == -1) {\n                throw new IOException("end of stream when reading header");\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        String body = "客户发的测试请求！";\n        try {\n            new NettyClient().sendMessage(body.getBytes());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\n\n\n# 参考文章\n\n * https://blog.csdn.net/yinwenjie/article/details/48829419\n * https://blog.csdn.net/yinwenjie/article/details/48969853\n * Netty入门简介在新窗口打开',normalizedContent:'# java n(a)io - 框架: netty\n\n> netty是一个高性能、异步事件驱动的nio框架，提供了对tcp、udp和文件传输的支持。作为当前最流行的nio框架，netty在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，一些业界著名的开源组件也基于netty构建，比如rpc框架、zookeeper等。@pdai\n\n * java n(a)io - 框架: netty\n   * nio框架\n   * 比较好的基于nio的开源框架(netty)\n     * 优点\n     * 例子\n   * 参考文章\n\n\n# nio框架\n\n目前流行的nio框架非常的多。在论坛上、互联网上大家讨论和使用最多的有以下几种:\n\n * 原生java nio框架:\n\njava nio通信框架基于多路复用io原理，我们将详细讲解它的工作原理。\n\n * apache mina 2:\n\n是一个网络应用程序框架，用来帮助用户简单地开发高性能和高可扩展性的网络应用程序。它提供了一个通过java nio在不同的传输例如tcp/ip和udp/ip上抽象的事件驱动的异步api。\n\n * netty 4/5:\n\nnetty是由jboss提供的一个java开源框架。netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。我们将讲解netty 4 的工作原理。另外说一句: mina和netty的主要作者是同一人trustin lee。\n\n * grizzly:\n\ngrizzly是一种应用程序框架，专门解决编写成千上万用户访问服务器时候产生的各种问题。使用java nio作为基础，并隐藏其编程的复杂性。\n\n\n# 比较好的基于nio的开源框架(netty)\n\n\n# 优点\n\n * api简单，开发门槛低\n * 功能强大，内置了多种编码、解码功能\n * 与其它业界主流的nio框架对比，netty的综合性能最优\n * 社区活跃，使用广泛，经历过很多商业应用项目的考验\n * 定制能力强，可以对框架进行灵活的扩展\n\n\n# 例子\n\n<dependency>\n     <groupid>org.jboss.netty</groupid>\n     <artifactid>netty</artifactid>\n     <version>3.2.5.final</version>\n</dependency>\n\n\n * 服务端。接收客户端请求并将内容打印出来，同时发送一个消息收到回执。\n\npublic class nettyserver {\n\n    private static int header_length = 4;\n\n    public void bind(int port) throws exception {\n\n        serverbootstrap b = new serverbootstrap(new nioserversocketchannelfactory(executors.newcachedthreadpool(),\n                                                                                  executors.newcachedthreadpool()));\n\n        // 构造对应的pipeline\n        b.setpipelinefactory(new channelpipelinefactory() {\n\n            public channelpipeline getpipeline() throws exception {\n                channelpipeline pipelines = channels.pipeline();\n                pipelines.addlast(messagehandler.class.getname(), new messagehandler());\n                return pipelines;\n            }\n        });\n        // 监听端口号\n        b.bind(new inetsocketaddress(port));\n    }\n\n    // 处理消息\n    static class messagehandler extends simplechannelhandler {\n\n        public void messagereceived(channelhandlercontext ctx, messageevent e) throws exception {\n            // 接收客户端请求\n            channelbuffer buffer = (channelbuffer) e.getmessage();\n            string message = new string(buffer.readbytes(buffer.readablebytes()).array(), "utf-8");\n            system.out.println("<服务端>收到内容=" + message);\n\n            // 给客户端发送回执\n            byte[] body = "服务端已收到".getbytes();\n            byte[] header = bytebuffer.allocate(header_length).order(byteorder.big_endian).putint(body.length).array();\n            channels.write(ctx.getchannel(), channelbuffers.wrappedbuffer(header, body));\n            system.out.println("<服务端>发送回执,time=" + system.currenttimemillis());\n\n        }\n    }\n\n    public static void main(string[] args) {\n        try {\n            new nettyserver().bind(1088);\n        } catch (exception e) {\n            e.printstacktrace();\n        }\n        ;\n    }\n}\n\n\n * 客户端。向服务端发送一个请求，然后打印服务端响应的内容。\n\npublic class nettyclient {\n\n    private final bytebuffer readheader  = bytebuffer.allocate(4).order(byteorder.big_endian);\n    private final bytebuffer writeheader = bytebuffer.allocate(4).order(byteorder.big_endian);\n    private socketchannel    channel;\n\n    public void sendmessage(byte[] body) throws exception {\n        // 创建客户端通道\n        channel = socketchannel.open();\n        channel.socket().setsotimeout(60000);\n        channel.connect(new inetsocketaddress(addressutils.gethostip(), 1088));\n\n        // 客户端发请求\n        writewithheader(channel, body);\n\n        // 接收服务端响应的信息\n        readheader.clear();\n        read(channel, readheader);\n        int bodylen = readheader.getint(0);\n        bytebuffer bodybuf = bytebuffer.allocate(bodylen).order(byteorder.big_endian);\n        read(channel, bodybuf);\n        system.out.println("<客户端>收到响应内容: " + new string(bodybuf.array(), "utf-8") + ",长度:" + bodylen);\n    }\n\n    private void writewithheader(socketchannel channel, byte[] body) throws ioexception {\n        writeheader.clear();\n        writeheader.putint(body.length);\n        writeheader.flip();\n        // channel.write(writeheader);\n        channel.write(bytebuffer.wrap(body));\n    }\n\n    private void read(socketchannel channel, bytebuffer buffer) throws ioexception {\n        while (buffer.hasremaining()) {\n            int r = channel.read(buffer);\n            if (r == -1) {\n                throw new ioexception("end of stream when reading header");\n            }\n        }\n    }\n\n    public static void main(string[] args) {\n        string body = "客户发的测试请求！";\n        try {\n            new nettyclient().sendmessage(body.getbytes());\n        } catch (exception e) {\n            e.printstacktrace();\n        }\n    }\n}\n\n\n\n\n# 参考文章\n\n * https://blog.csdn.net/yinwenjie/article/details/48829419\n * https://blog.csdn.net/yinwenjie/article/details/48969853\n * netty入门简介在新窗口打开',charsets:{cjk:!0}},{title:"Java NIO - IO多路复用详解",frontmatter:{},regularPath:"/java/io/java-io-nio-select-epoll.html",relativePath:"java/io/java-io-nio-select-epoll.md",key:"v-2d139d12",path:"/java/io/java-io-nio-select-epoll.html",headers:[{level:2,title:"Java NIO - IO多路复用详解",slug:"java-nio-io多路复用详解",normalizedTitle:"java nio - io多路复用详解",charIndex:2},{level:2,title:"现实场景",slug:"现实场景",normalizedTitle:"现实场景",charIndex:96},{level:2,title:"典型的多路复用IO实现",slug:"典型的多路复用io实现",normalizedTitle:"典型的多路复用io实现",charIndex:106},{level:2,title:"Reactor模型和Proactor模型",slug:"reactor模型和proactor模型",normalizedTitle:"reactor模型和proactor模型",charIndex:123},{level:3,title:"传统IO模型",slug:"传统io模型",normalizedTitle:"传统io模型",charIndex:151},{level:3,title:"Reactor事件驱动模型",slug:"reactor事件驱动模型",normalizedTitle:"reactor事件驱动模型",charIndex:165},{level:3,title:"Reactor模型----业务处理与IO分离",slug:"reactor模型-业务处理与io分离",normalizedTitle:"reactor模型----业务处理与io分离",charIndex:186},{level:3,title:"Reactor模型----并发读写",slug:"reactor模型-并发读写",normalizedTitle:"reactor模型----并发读写",charIndex:216},{level:3,title:"Reactor模型示例",slug:"reactor模型示例",normalizedTitle:"reactor模型示例",charIndex:241},{level:2,title:"JAVA对多路复用IO的支持",slug:"java对多路复用io的支持",normalizedTitle:"java对多路复用io的支持",charIndex:258},{level:3,title:"重要概念: Channel",slug:"重要概念-channel",normalizedTitle:"重要概念: channel",charIndex:280},{level:3,title:"重要概念: Buffer",slug:"重要概念-buffer",normalizedTitle:"重要概念: buffer",charIndex:301},{level:3,title:"重要概念: Selector",slug:"重要概念-selector",normalizedTitle:"重要概念: selector",charIndex:321},{level:3,title:"JAVA NIO 框架简要设计分析",slug:"java-nio-框架简要设计分析",normalizedTitle:"java nio 框架简要设计分析",charIndex:343},{level:3,title:"JAVA实例",slug:"java实例",normalizedTitle:"java实例",charIndex:368},{level:3,title:"JAVA实例改进",slug:"java实例改进",normalizedTitle:"java实例改进",charIndex:382},{level:2,title:"多路复用IO的优缺点",slug:"多路复用io的优缺点",normalizedTitle:"多路复用io的优缺点",charIndex:396},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:412}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java NIO - IO多路复用详解 现实场景 典型的多路复用IO实现 Reactor模型和Proactor模型 传统IO模型 Reactor事件驱动模型 Reactor模型----业务处理与IO分离 Reactor模型----并发读写 Reactor模型示例 JAVA对多路复用IO的支持 重要概念: Channel 重要概念: Buffer 重要概念: Selector JAVA NIO 框架简要设计分析 JAVA实例 JAVA实例改进 多路复用IO的优缺点 参考文章",content:'# Java NIO - IO多路复用详解\n\n> 本文主要对IO多路复用，Ractor模型以及Java NIO对其的支持。@pdai\n\n * Java NIO - IO多路复用详解\n   * 现实场景\n   * 典型的多路复用IO实现\n   * Reactor模型和Proactor模型\n     * 传统IO模型\n     * Reactor事件驱动模型\n     * Reactor模型----业务处理与IO分离\n     * Reactor模型----并发读写\n     * Reactor模型示例\n   * JAVA对多路复用IO的支持\n     * 重要概念: Channel\n     * 重要概念: Buffer\n     * 重要概念: Selector\n     * JAVA NIO 框架简要设计分析\n     * JAVA实例\n     * JAVA实例改进\n   * 多路复用IO的优缺点\n   * 参考文章\n\n\n# 现实场景\n\n我们试想一下这样的现实场景:\n\n一个餐厅同时有100位客人到店，当然到店后第一件要做的事情就是点菜。但是问题来了，餐厅老板为了节约人力成本目前只有一位大堂服务员拿着唯一的一本菜单等待客人进行服务。\n\n * 那么最笨(但是最简单)的方法是(方法A)，无论有多少客人等待点餐，服务员都把仅有的一份菜单递给其中一位客人，然后站在客人身旁等待这个客人完成点菜过程。在记录客人点菜内容后，把点菜记录交给后堂厨师。然后是第二位客人。。。。然后是第三位客人。很明显，只有脑袋被门夹过的老板，才会这样设置服务流程。因为随后的80位客人，再等待超时后就会离店(还会给差评)。\n\n * 于是还有一种办法(方法B)，老板马上新雇佣99名服务员，同时印制99本新的菜单。每一名服务员手持一本菜单负责一位客人(关键不只在于服务员，还在于菜单。因为没有菜单客人也无法点菜)。在客人点完菜后，记录点菜内容交给后堂厨师(当然为了更高效，后堂厨师最好也有100名)。这样每一位客人享受的就是VIP服务咯，当然客人不会走，但是人力成本可是一个大头哦(亏死你)。\n\n * 另外一种办法(方法C)，就是改进点菜的方式，当客人到店后，自己申请一本菜单。想好自己要点的才后，就呼叫服务员。服务员站在自己身边后记录客人的菜单内容。将菜单递给厨师的过程也要进行改进，并不是每一份菜单记录好以后，都要交给后堂厨师。服务员可以记录号多份菜单后，同时交给厨师就行了。那么这种方式，对于老板来说人力成本是最低的；对于客人来说，虽然不再享受VIP服务并且要进行一定的等待，但是这些都是可接受的；对于服务员来说，基本上她的时间都没有浪费，基本上被老板压杆了最后一滴油水。\n\n如果您是老板，您会采用哪种方式呢?\n\n到店情况: 并发量。到店情况不理想时，一个服务员一本菜单，当然是足够了。所以不同的老板在不同的场合下，将会灵活选择服务员和菜单的配置。\n\n * 客人: 客户端请求\n * 点餐内容: 客户端发送的实际数据\n * 老板: 操作系统\n * 人力成本: 系统资源\n * 菜单: 文件状态描述符。操作系统对于一个进程能够同时持有的文件状态描述符的个数是有限制的，在linux系统中$ulimit -n查看这个限制值，当然也是可以(并且应该)进行内核参数调整的。\n * 服务员: 操作系统内核用于IO操作的线程(内核线程)\n * 厨师: 应用程序线程(当然厨房就是应用程序进程咯)\n * 餐单传递方式: 包括了阻塞式和非阻塞式两种。\n   * 方法A: 阻塞式/非阻塞式 同步IO\n   * 方法B: 使用线程进行处理的 阻塞式/非阻塞式 同步IO\n   * 方法C: 阻塞式/非阻塞式 多路复用IO\n\n\n# 典型的多路复用IO实现\n\n目前流程的多路复用IO实现主要包括四种: select、poll、epoll、kqueue。下表是他们的一些重要特性的比较:\n\nIO模型     相对性能   关键思路               操作系统            JAVA支持情况\nselect   较高     Reactor            windows/Linux   支持,Reactor模式(反应器设计模式)。Linux操作系统的 kernels\n                                                   2.4内核版本之前，默认使用select；而目前windows下对同步IO的支持，都是select模型\npoll     较高     Reactor            Linux           Linux下的JAVA NIO框架，Linux kernels\n                                                   2.6内核版本之前使用poll进行支持。也是使用的Reactor模式\nepoll    高      Reactor/Proactor   Linux           Linux kernels 2.6内核版本及以后使用epoll进行支持；Linux kernels\n                                                   2.6内核版本之前使用poll进行支持；另外一定注意，由于Linux下没有Windows下的IOCP技术提供真正的\n                                                   异步IO 支持，所以Linux下使用epoll模拟异步IO\nkqueue   高      Proactor           Linux           目前JAVA的版本不支持\n\n多路复用IO技术最适用的是“高并发”场景，所谓高并发是指1毫秒内至少同时有上千个连接请求准备好。其他情况下多路复用IO技术发挥不出来它的优势。另一方面，使用JAVA NIO进行功能实现，相对于传统的Socket套接字实现要复杂一些，所以实际应用中，需要根据自己的业务需求进行技术选择。\n\n\n# Reactor模型和Proactor模型\n\n\n# 传统IO模型\n\n对于传统IO模型，其主要是一个Server对接N个客户端，在客户端连接之后，为每个客户端都分配一个执行线程。如下图是该模型的一个演示：\n\n\n\n从图中可以看出，传统IO的特点在于：\n\n * 每个客户端连接到达之后，服务端会分配一个线程给该客户端，该线程会处理包括读取数据，解码，业务计算，编码，以及发送数据整个过程；\n * 同一时刻，服务端的吞吐量与服务器所提供的线程数量是呈线性关系的。\n\n这种设计模式在客户端连接不多，并发量不大的情况下是可以运行得很好的，但是在海量并发的情况下，这种模式就显得力不从心了。这种模式主要存在的问题有如下几点：\n\n * 服务器的并发量对服务端能够创建的线程数有很大的依赖关系，但是服务器线程却是不能无限增长的；\n * 服务端每个线程不仅要进行IO读写操作，而且还需要进行业务计算；\n * 服务端在获取客户端连接，读取数据，以及写入数据的过程都是阻塞类型的，在网络状况不好的情况下，这将极大的降低服务器每个线程的利用率，从而降低服务器吞吐量。\n\n\n# Reactor事件驱动模型\n\n在传统IO模型中，由于线程在等待连接以及进行IO操作时都会阻塞当前线程，这部分损耗是非常大的。因而jdk 1.4中就提供了一套非阻塞IO的API。该API本质上是以事件驱动来处理网络事件的，而Reactor是基于该API提出的一套IO模型。如下是Reactor事件驱动模型的示意图：\n\n\n\n从图中可以看出，在Reactor模型中，主要有四个角色：客户端连接，Reactor，Acceptor和Handler。这里Acceptor会不断地接收客户端的连接，然后将接收到的连接交由Reactor进行分发，最后有具体的Handler进行处理。改进后的Reactor模型相对于传统的IO模型主要有如下优点：\n\n * 从模型上来讲，如果仅仅还是只使用一个线程池来处理客户端连接的网络读写，以及业务计算，那么Reactor模型与传统IO模型在效率上并没有什么提升。但是Reactor模型是以事件进行驱动的，其能够将接收客户端连接，+ 网络读和网络写，以及业务计算进行拆分，从而极大的提升处理效率；\n * Reactor模型是异步非阻塞模型，工作线程在没有网络事件时可以处理其他的任务，而不用像传统IO那样必须阻塞等待。\n\n\n# Reactor模型----业务处理与IO分离\n\n在上面的Reactor模型中，由于网络读写和业务操作都在同一个线程中，在高并发情况下，这里的系统瓶颈主要在两方面：\n\n * 高频率的网络读写事件处理；\n * 大量的业务操作处理；\n\n基于上述两个问题，这里在单线程Reactor模型的基础上提出了使用线程池的方式处理业务操作的模型。如下是该模型的示意图：\n\n\n\n从图中可以看出，在多线程进行业务操作的模型下，该模式主要具有如下特点：\n\n * 使用一个线程进行客户端连接的接收以及网络读写事件的处理；\n * 在接收到客户端连接之后，将该连接交由线程池进行数据的编解码以及业务计算。\n\n这种模式相较于前面的模式性能有了很大的提升，主要在于在进行网络读写的同时，也进行了业务计算，从而大大提升了系统的吞吐量。但是这种模式也有其不足，主要在于：\n\n * 网络读写是一个比较消耗CPU的操作，在高并发的情况下，将会有大量的客户端数据需要进行网络读写，此时一个线程将不足以处理这么多请求。\n\n\n# Reactor模型----并发读写\n\n对于使用线程池处理业务操作的模型，由于网络读写在高并发情况下会成为系统的一个瓶颈，因而针对该模型这里提出了一种改进后的模型，即使用线程池进行网络读写，而仅仅只使用一个线程专门接收客户端连接。如下是该模型的示意图：\n\n\n\n可以看到，改进后的Reactor模型将Reactor拆分为了mainReactor和subReactor。这里mainReactor主要进行客户端连接的处理，处理完成之后将该连接交由subReactor以处理客户端的网络读写。这里的subReactor则是使用一个线程池来支撑的，其读写能力将会随着线程数的增多而大大增加。对于业务操作，这里也是使用一个线程池，而每个业务请求都只需要进行编解码和业务计算。通过这种方式，服务器的性能将会大大提升，在可见情况下，其基本上可以支持百万连接。\n\n\n# Reactor模型示例\n\n对于上述Reactor模型，服务端主要有三个角色：Reactor，Acceptor和Handler。这里基于Doug Lea的文档对其进行了实现，如下是Reactor的实现代码：\n\npublic class Reactor implements Runnable {\n  private final Selector selector;\n  private final ServerSocketChannel serverSocket;\n\n  public Reactor(int port) throws IOException {\n    serverSocket = ServerSocketChannel.open();  // 创建服务端的ServerSocketChannel\n    serverSocket.configureBlocking(false);  // 设置为非阻塞模式\n    selector = Selector.open();  // 创建一个Selector多路复用器\n    SelectionKey key = serverSocket.register(selector, SelectionKey.OP_ACCEPT);\n    serverSocket.bind(new InetSocketAddress(port));  // 绑定服务端端口\n    key.attach(new Acceptor(serverSocket));  // 为服务端Channel绑定一个Acceptor\n  }\n\n  @Override\n  public void run() {\n    try {\n      while (!Thread.interrupted()) {\n        selector.select();  // 服务端使用一个线程不断等待客户端的连接到达\n        Set<SelectionKey> keys = selector.selectedKeys();\n        Iterator<SelectionKey> iterator = keys.iterator();\n        while (iterator.hasNext()) {\n          dispatch(iterator.next());  // 监听到客户端连接事件后将其分发给Acceptor\n          iterator.remove();\n        }\n\n        selector.selectNow();\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n\n  private void dispatch(SelectionKey key) throws IOException {\n    // 这里的attachement也即前面为服务端Channel绑定的Acceptor，调用其run()方法进行\n    // 客户端连接的获取，并且进行分发\n    Runnable attachment = (Runnable) key.attachment();\n    attachment.run();\n  }\n}\n\n\n这里Reactor首先开启了一个ServerSocketChannel，然后将其绑定到指定的端口，并且注册到了一个多路复用器上。接着在一个线程中，其会在多路复用器上等待客户端连接。当有客户端连接到达后，Reactor就会将其派发给一个Acceptor，由该Acceptor专门进行客户端连接的获取。下面我们继续看一下Acceptor的代码：\n\npublic class Acceptor implements Runnable {\n  private final ExecutorService executor = Executors.newFixedThreadPool(20);\n\n  private final ServerSocketChannel serverSocket;\n\n  public Acceptor(ServerSocketChannel serverSocket) {\n    this.serverSocket = serverSocket;\n  }\n\n  @Override\n  public void run() {\n    try {\n      SocketChannel channel = serverSocket.accept();  // 获取客户端连接\n      if (null != channel) {\n        executor.execute(new Handler(channel));  // 将客户端连接交由线程池处理\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\n\n\n这里可以看到，在Acceptor获取到客户端连接之后，其就将其交由线程池进行网络读写了，而这里的主线程只是不断监听客户端连接事件。下面我们看看Handler的具体逻辑：\n\npublic class Handler implements Runnable {\n  private volatile static Selector selector;\n  private final SocketChannel channel;\n  private SelectionKey key;\n  private volatile ByteBuffer input = ByteBuffer.allocate(1024);\n  private volatile ByteBuffer output = ByteBuffer.allocate(1024);\n\n  public Handler(SocketChannel channel) throws IOException {\n    this.channel = channel;\n    channel.configureBlocking(false);  // 设置客户端连接为非阻塞模式\n    selector = Selector.open();  // 为客户端创建一个新的多路复用器\n    key = channel.register(selector, SelectionKey.OP_READ);  // 注册客户端Channel的读事件\n  }\n\n  @Override\n  public void run() {\n    try {\n      while (selector.isOpen() && channel.isOpen()) {\n        Set<SelectionKey> keys = select();  // 等待客户端事件发生\n        Iterator<SelectionKey> iterator = keys.iterator();\n        while (iterator.hasNext()) {\n          SelectionKey key = iterator.next();\n          iterator.remove();\n\n          // 如果当前是读事件，则读取数据\n          if (key.isReadable()) {\n            read(key);\n          } else if (key.isWritable()) {\n           // 如果当前是写事件，则写入数据\n            write(key);\n          }\n        }\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n\n  // 这里处理的主要目的是处理Jdk的一个bug，该bug会导致Selector被意外触发，但是实际上没有任何事件到达，\n  // 此时的处理方式是新建一个Selector，然后重新将当前Channel注册到该Selector上\n  private Set<SelectionKey> select() throws IOException {\n    selector.select();\n    Set<SelectionKey> keys = selector.selectedKeys();\n    if (keys.isEmpty()) {\n      int interestOps = key.interestOps();\n      selector = Selector.open();\n      key = channel.register(selector, interestOps);\n      return select();\n    }\n\n    return keys;\n  }\n\n  // 读取客户端发送的数据\n  private void read(SelectionKey key) throws IOException {\n    channel.read(input);\n    if (input.position() == 0) {\n      return;\n    }\n\n    input.flip();\n    process();  // 对读取的数据进行业务处理\n    input.clear();\n    key.interestOps(SelectionKey.OP_WRITE);  // 读取完成后监听写入事件\n  }\n\n  private void write(SelectionKey key) throws IOException {\n    output.flip();\n    if (channel.isOpen()) {\n      channel.write(output);  // 当有写入事件时，将业务处理的结果写入到客户端Channel中\n      key.channel();\n      channel.close();\n      output.clear();\n    }\n  }\n    \n  // 进行业务处理，并且获取处理结果。本质上，基于Reactor模型，如果这里成为处理瓶颈，\n  // 则直接将其处理过程放入线程池即可，并且使用一个Future获取处理结果，最后写入客户端Channel\n  private void process() {\n    byte[] bytes = new byte[input.remaining()];\n    input.get(bytes);\n    String message = new String(bytes, CharsetUtil.UTF_8);\n    System.out.println("receive message from client: \\n" + message);\n\n    output.put("hello client".getBytes());\n  }\n}\n\n\n在Handler中，主要进行的就是为每一个客户端Channel创建一个Selector，并且监听该Channel的网络读写事件。当有事件到达时，进行数据的读写，而业务操作这交由具体的业务线程池处理。\n\n\n# JAVA对多路复用IO的支持\n\n\n\n\n# 重要概念: Channel\n\n通道，被建立的一个应用程序和操作系统交互事件、传递内容的渠道(注意是连接到操作系统)。一个通道会有一个专属的文件状态描述符。那么既然是和操作系统进行内容的传递，那么说明应用程序可以通过通道读取数据，也可以通过通道向操作系统写数据。\n\nJDK API中的Channel的描述是:\n\n> A channel represents an open connection to an entity such as a hardware device, a file, a network socket, or a program component that is capable of performing one or more distinct I/O operations, for example reading or writing.\n\n> A channel is either open or closed. A channel is open upon creation, and once closed it remains closed. Once a channel is closed, any attempt to invoke an I/O operation upon it will cause a ClosedChannelException to be thrown. Whether or not a channel is open may be tested by invoking its isOpen method.\n\nJAVA NIO 框架中，自有的Channel通道包括:\n\n\n\n所有被Selector(选择器)注册的通道，只能是继承了SelectableChannel类的子类。如上图所示\n\n * ServerSocketChannel: 应用服务器程序的监听通道。只有通过这个通道，应用程序才能向操作系统注册支持“多路复用IO”的端口监听。同时支持UDP协议和TCP协议。\n\n * ScoketChannel: TCP Socket套接字的监听通道，一个Socket套接字对应了一个客户端IP: 端口 到 服务器IP: 端口的通信连接。\n\n * DatagramChannel: UDP 数据报文的监听通道。\n\n\n# 重要概念: Buffer\n\n数据缓存区: 在JAVA NIO 框架中，为了保证每个通道的数据读写速度JAVA NIO 框架为每一种需要支持数据读写的通道集成了Buffer的支持。\n\n这句话怎么理解呢? 例如ServerSocketChannel通道它只支持对OP_ACCEPT事件的监听，所以它是不能直接进行网络数据内容的读写的。所以ServerSocketChannel是没有集成Buffer的。\n\nBuffer有两种工作模式: 写模式和读模式。在读模式下，应用程序只能从Buffer中读取数据，不能进行写操作。但是在写模式下，应用程序是可以进行读操作的，这就表示可能会出现脏读的情况。所以一旦您决定要从Buffer中读取数据，一定要将Buffer的状态改为读模式。\n\n如下图:\n\n\n\n * position: 缓存区目前这在操作的数据块位置\n * limit: 缓存区最大可以进行操作的位置。缓存区的读写状态正式由这个属性控制的。\n * capacity: 缓存区的最大容量。这个容量是在缓存区创建时进行指定的。由于高并发时通道数量往往会很庞大，所以每一个缓存区的容量最好不要过大。\n\n在下文JAVA NIO框架的代码实例中，我们将进行Buffer缓存区操作的演示。\n\n\n# 重要概念: Selector\n\nSelector的英文含义是“选择器”，不过根据我们详细介绍的Selector的岗位职责，您可以把它称之为“轮询代理器”、“事件订阅器”、“channel容器管理机”都行。\n\n * 事件订阅和Channel管理\n\n应用程序将向Selector对象注册需要它关注的Channel，以及具体的某一个Channel会对哪些IO事件感兴趣。Selector中也会维护一个“已经注册的Channel”的容器。以下代码来自WindowsSelectorImpl实现类中，对已经注册的Channel的管理容器:\n\n// Initial capacity of the poll array\nprivate final int INIT_CAP = 8;\n// Maximum number of sockets for select().\n// Should be INIT_CAP times a power of 2\nprivate final static int MAX_SELECTABLE_FDS = 1024;\n\n// The list of SelectableChannels serviced by this Selector. Every mod\n// MAX_SELECTABLE_FDS entry is bogus, to align this array with the poll\n// array,  where the corresponding entry is occupied by the wakeupSocket\nprivate SelectionKeyImpl[] channelArray = new SelectionKeyImpl[INIT_CAP];\n\n\n * 轮询代理\n\n应用层不再通过阻塞模式或者非阻塞模式直接询问操作系统“事件有没有发生”，而是由Selector代其询问。\n\n * 实现不同操作系统的支持\n\n之前已经提到过，多路复用IO技术 是需要操作系统进行支持的，其特点就是操作系统可以同时扫描同一个端口上不同网络连接的事件。所以作为上层的JVM，必须要为 不同操作系统的多路复用IO实现 编写不同的代码。同样我使用的测试环境是Windows，它对应的实现类是sun.nio.ch.WindowsSelectorImpl:\n\n\n\n\n# JAVA NIO 框架简要设计分析\n\n通过上文的描述，我们知道了多路复用IO技术是操作系统的内核实现。在不同的操作系统，甚至同一系列操作系统的版本中所实现的多路复用IO技术都是不一样的。那么作为跨平台的JAVA JVM来说如何适应多种多样的多路复用IO技术实现呢? 面向对象的威力就显现出来了: 无论使用哪种实现方式，他们都会有“选择器”、“通道”、“缓存”这几个操作要素，那么可以为不同的多路复用IO技术创建一个统一的抽象组，并且为不同的操作系统进行具体的实现。JAVA NIO中对各种多路复用IO的支持，主要的基础是java.nio.channels.spi.SelectorProvider抽象类，其中的几个主要抽象方法包括:\n\n * public abstract DatagramChannel openDatagramChannel(): 创建和这个操作系统匹配的UDP 通道实现。\n\n * public abstract AbstractSelector openSelector(): 创建和这个操作系统匹配的NIO选择器，就像上文所述，不同的操作系统，不同的版本所默认支持的NIO模型是不一样的。\n\n * public abstract ServerSocketChannel openServerSocketChannel(): 创建和这个NIO模型匹配的服务器端通道。\n\n * public abstract SocketChannel openSocketChannel(): 创建和这个NIO模型匹配的TCP Socket套接字通道(用来反映客户端的TCP连接)\n\n由于JAVA NIO框架的整个设计是很大的，所以我们只能还原一部分我们关心的问题。这里我们以JAVA NIO框架中对于不同多路复用IO技术的选择器 进行实例化创建的方式作为例子，以点窥豹观全局:\n\n\n\n很明显，不同的SelectorProvider实现对应了不同的 选择器。由具体的SelectorProvider实现进行创建。另外说明一下，实际上netty底层也是通过这个设计获得具体使用的NIO模型，我们后文讲解Netty时，会讲到这个问题。以下代码是Netty 4.0中NioServerSocketChannel进行实例化时的核心代码片段:\n\nprivate static ServerSocketChannel newSocket(SelectorProvider provider) {\n    try {\n        /**\n            *  Use the {@link SelectorProvider} to open {@link SocketChannel} and so remove condition in\n            *  {@link SelectorProvider#provider()} which is called by each ServerSocketChannel.open() otherwise.\n            *\n            *  See <a href="See https://github.com/netty/netty/issues/2308">#2308</a>.\n            */\n        return provider.openServerSocketChannel();\n    } catch (IOException e) {\n        throw new ChannelException(\n                "Failed to open a server socket.", e);\n    }\n}\n\n\n\n# JAVA实例\n\n下面，我们使用JAVA NIO框架，实现一个支持多路复用IO的服务器端(实际上客户端是否使用多路复用IO技术，对整个系统架构的性能提升相关性不大):\n\npackage testNSocket;\n\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.URLDecoder;\nimport java.net.URLEncoder;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectableChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class SocketServer1 {\n\n    static {\n        BasicConfigurator.configure();\n    }\n\n    /**\n     * 日志\n     */\n    private static final Log LOGGER = LogFactory.getLog(SocketServer1.class);\n\n    public static void main(String[] args) throws Exception {\n        ServerSocketChannel serverChannel = ServerSocketChannel.open();\n        serverChannel.configureBlocking(false);\n        ServerSocket serverSocket = serverChannel.socket();\n        serverSocket.setReuseAddress(true);\n        serverSocket.bind(new InetSocketAddress(83));\n\n        Selector selector = Selector.open();\n        //注意、服务器通道只能注册SelectionKey.OP_ACCEPT事件\n        serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        try {\n            while(true) {\n                //如果条件成立，说明本次询问selector，并没有获取到任何准备好的、感兴趣的事件\n                //java程序对多路复用IO的支持也包括了阻塞模式 和非阻塞模式两种。\n                if(selector.select(100) == 0) {\n                    //================================================\n                    //      这里视业务情况，可以做一些然并卵的事情\n                    //================================================\n                    continue;\n                }\n                //这里就是本次询问操作系统，所获取到的“所关心的事件”的事件类型(每一个通道都是独立的)\n                Iterator<SelectionKey> selecionKeys = selector.selectedKeys().iterator();\n\n                while(selecionKeys.hasNext()) {\n                    SelectionKey readyKey = selecionKeys.next();\n                    //这个已经处理的readyKey一定要移除。如果不移除，就会一直存在在selector.selectedKeys集合中\n                    //待到下一次selector.select() > 0时，这个readyKey又会被处理一次\n                    selecionKeys.remove();\n\n                    SelectableChannel selectableChannel = readyKey.channel();\n                    if(readyKey.isValid() && readyKey.isAcceptable()) {\n                        SocketServer1.LOGGER.info("======channel通道已经准备好=======");\n                        /*\n                         * 当server socket channel通道已经准备好，就可以从server socket channel中获取socketchannel了\n                         * 拿到socket channel后，要做的事情就是马上到selector注册这个socket channel感兴趣的事情。\n                         * 否则无法监听到这个socket channel到达的数据\n                         * */\n                        ServerSocketChannel serverSocketChannel = (ServerSocketChannel)selectableChannel;\n                        SocketChannel socketChannel = serverSocketChannel.accept();\n                        registerSocketChannel(socketChannel , selector);\n\n                    } else if(readyKey.isValid() && readyKey.isConnectable()) {\n                        SocketServer1.LOGGER.info("======socket channel 建立连接=======");\n                    } else if(readyKey.isValid() && readyKey.isReadable()) {\n                        SocketServer1.LOGGER.info("======socket channel 数据准备完成，可以去读==读取=======");\n                        readSocketChannel(readyKey);\n                    }\n                }\n            }\n        } catch(Exception e) {\n            SocketServer1.LOGGER.error(e.getMessage() , e);\n        } finally {\n            serverSocket.close();\n        }\n    }\n\n    /**\n     * 在server socket channel接收到/准备好 一个新的 TCP连接后。\n     * 就会向程序返回一个新的socketChannel。<br>\n     * 但是这个新的socket channel并没有在selector“选择器/代理器”中注册，\n     * 所以程序还没法通过selector通知这个socket channel的事件。\n     * 于是我们拿到新的socket channel后，要做的第一个事情就是到selector“选择器/代理器”中注册这个\n     * socket channel感兴趣的事件\n     * @param socketChannel 新的socket channel\n     * @param selector selector“选择器/代理器”\n     * @throws Exception\n     */\n    private static void registerSocketChannel(SocketChannel socketChannel , Selector selector) throws Exception {\n        socketChannel.configureBlocking(false);\n        //socket通道可以且只可以注册三种事件SelectionKey.OP_READ | SelectionKey.OP_WRITE | SelectionKey.OP_CONNECT\n        socketChannel.register(selector, SelectionKey.OP_READ , ByteBuffer.allocate(2048));\n    }\n\n    /**\n     * 这个方法用于读取从客户端传来的信息。\n     * 并且观察从客户端过来的socket channel在经过多次传输后，是否完成传输。\n     * 如果传输完成，则返回一个true的标记。\n     * @param socketChannel\n     * @throws Exception\n     */\n    private static void readSocketChannel(SelectionKey readyKey) throws Exception {\n        SocketChannel clientSocketChannel = (SocketChannel)readyKey.channel();\n        //获取客户端使用的端口\n        InetSocketAddress sourceSocketAddress = (InetSocketAddress)clientSocketChannel.getRemoteAddress();\n        Integer resoucePort = sourceSocketAddress.getPort();\n\n        //拿到这个socket channel使用的缓存区，准备读取数据\n        //在后文，将详细讲解缓存区的用法概念，实际上重要的就是三个元素capacity,position和limit。\n        ByteBuffer contextBytes = (ByteBuffer)readyKey.attachment();\n        //将通道的数据写入到缓存区，注意是写入到缓存区。\n        //由于之前设置了ByteBuffer的大小为2048 byte，所以可以存在写入不完的情况\n        //没关系，我们后面来调整代码。这里我们暂时理解为一次接受可以完成\n        int realLen = -1;\n        try {\n            realLen = clientSocketChannel.read(contextBytes);\n        } catch(Exception e) {\n            //这里抛出了异常，一般就是客户端因为某种原因终止了。所以关闭channel就行了\n            SocketServer1.LOGGER.error(e.getMessage());\n            clientSocketChannel.close();\n            return;\n        }\n\n        //如果缓存区中没有任何数据(但实际上这个不太可能，否则就不会触发OP_READ事件了)\n        if(realLen == -1) {\n            SocketServer1.LOGGER.warn("====缓存区没有数据? ====");\n            return;\n        }\n\n        //将缓存区从写状态切换为读状态(实际上这个方法是读写模式互切换)。\n        //这是java nio框架中的这个socket channel的写请求将全部等待。\n        contextBytes.flip();\n        //注意中文乱码的问题，我个人喜好是使用URLDecoder/URLEncoder，进行解编码。\n        //当然java nio框架本身也提供编解码方式，看个人咯\n        byte[] messageBytes = contextBytes.array();\n        String messageEncode = new String(messageBytes , "UTF-8");\n        String message = URLDecoder.decode(messageEncode, "UTF-8");\n\n        //如果收到了“over”关键字，才会清空buffer，并回发数据；\n        //否则不清空缓存，还要还原buffer的“写状态”\n        if(message.indexOf("over") != -1) {\n            //清空已经读取的缓存，并从新切换为写状态(这里要注意clear()和capacity()两个方法的区别)\n            contextBytes.clear();\n            SocketServer1.LOGGER.info("端口:" + resoucePort + "客户端发来的信息======message : " + message);\n\n            //======================================================\n            //          当然接受完成后，可以在这里正式处理业务了        \n            //======================================================\n\n            //回发数据，并关闭channel\n            ByteBuffer sendBuffer = ByteBuffer.wrap(URLEncoder.encode("回发处理结果", "UTF-8").getBytes());\n            clientSocketChannel.write(sendBuffer);\n            clientSocketChannel.close();\n        } else {\n            SocketServer1.LOGGER.info("端口:" + resoucePort + "客户端信息还未接受完，继续接受======message : " + message);\n            //这是，limit和capacity的值一致，position的位置是realLen的位置\n            contextBytes.position(realLen);\n            contextBytes.limit(contextBytes.capacity());\n        }\n    }\n}\n\n\n代码中的注释是比较清楚的，但是还是要对几个关键点进行一下讲解:\n\n * serverChannel.register(Selector sel, int ops, Object att): 实际上register(Selector sel, int ops, Object att)方法是ServerSocketChannel类的父类AbstractSelectableChannel提供的一个方法，表示只要继承了AbstractSelectableChannel类的子类都可以注册到选择器中。通过观察整个AbstractSelectableChannel继承关系，下图中的这些类可以被注册到选择器中:\n\n\n\n * SelectionKey.OP_ACCEPT: 不同的Channel对象可以注册的“我关心的事件”是不一样的。例如ServerSocketChannel除了能够被允许关注OP_ACCEPT事件外，不允许再关心其他事件了(否则运行时会抛出异常)。以下梳理了常使用的AbstractSelectableChannel子类可以注册的事件列表:\n\n通道类                   通道作用      可关注的事件\nServerSocketChannel   服务器端通道    SelectionKey.OP_ACCEPT\nDatagramChannel       UDP协议通道   SelectionKey.OP_READ、SelectionKey.OP_WRITE\nSocketChannel         TCP协议通道   SelectionKey.OP_READ、SelectionKey.OP_WRITE、SelectionKey.OP_CONNECT\n\n实际上通过每一个AbstractSelectableChannel子类所实现的public final int validOps()方法，就可以查看这个通道“可以关心的IO事件”。\n\nselector.selectedKeys().iterator(): 当选择器Selector收到操作系统的IO操作事件后，它的selectedKeys将在下一次轮询操作中，收到这些事件的关键描述字(不同的channel，就算关键字一样，也会存储成两个对象)。但是每一个“事件关键字”被处理后都必须移除，否则下一次轮询时，这个事件会被重复处理。\n\n> Returns this selector’s selected-key set. Keys may be removed from, but not directly added to, the selected-key set. Any attempt to add an object to the key set will cause an UnsupportedOperationException to be thrown. The selected-key set is not thread-safe.\n\n\n# JAVA实例改进\n\n上面的代码中，我们为了讲解selector的使用，在缓存使用上就进行了简化。实际的应用中，为了节约内存资源，我们一般不会为一个通道分配那么多的缓存空间。下面的代码我们主要对其中的缓存操作进行了优化:\n\npackage testNSocket;\n\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.URLDecoder;\nimport java.net.URLEncoder;\n\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectableChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\n\nimport java.util.Iterator;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.log4j.BasicConfigurator;\n\npublic class SocketServer2 {\n\n    static {\n        BasicConfigurator.configure();\n    }\n\n    /**\n     * 日志\n     */\n    private static final Log LOGGER = LogFactory.getLog(SocketServer2.class);\n\n    /**\n     * 改进的java nio server的代码中，由于buffer的大小设置的比较小。\n     * 我们不再把一个client通过socket channel多次传给服务器的信息保存在beff中了(因为根本存不下)<br>\n     * 我们使用socketchanel的hashcode作为key(当然您也可以自己确定一个id)，信息的stringbuffer作为value，存储到服务器端的一个内存区域MESSAGEHASHCONTEXT。\n     * \n     * 如果您不清楚ConcurrentHashMap的作用和工作原理，请自行百度/Google\n     */\n    private static final ConcurrentMap<Integer, StringBuffer> MESSAGEHASHCONTEXT = new ConcurrentHashMap<Integer , StringBuffer>();\n\n    public static void main(String[] args) throws Exception {\n        ServerSocketChannel serverChannel = ServerSocketChannel.open();\n        serverChannel.configureBlocking(false);\n        ServerSocket serverSocket = serverChannel.socket();\n        serverSocket.setReuseAddress(true);\n        serverSocket.bind(new InetSocketAddress(83));\n\n        Selector selector = Selector.open();\n        //注意、服务器通道只能注册SelectionKey.OP_ACCEPT事件\n        serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        try {\n            while(true) {\n                //如果条件成立，说明本次询问selector，并没有获取到任何准备好的、感兴趣的事件\n                //java程序对多路复用IO的支持也包括了阻塞模式 和非阻塞模式两种。\n                if(selector.select(100) == 0) {\n                    //================================================\n                    //      这里视业务情况，可以做一些然并卵的事情\n                    //================================================\n                    continue;\n                }\n                //这里就是本次询问操作系统，所获取到的“所关心的事件”的事件类型(每一个通道都是独立的)\n                Iterator<SelectionKey> selecionKeys = selector.selectedKeys().iterator();\n\n                while(selecionKeys.hasNext()) {\n                    SelectionKey readyKey = selecionKeys.next();\n                    //这个已经处理的readyKey一定要移除。如果不移除，就会一直存在在selector.selectedKeys集合中\n                    //待到下一次selector.select() > 0时，这个readyKey又会被处理一次\n                    selecionKeys.remove();\n\n                    SelectableChannel selectableChannel = readyKey.channel();\n                    if(readyKey.isValid() && readyKey.isAcceptable()) {\n                        SocketServer2.LOGGER.info("======channel通道已经准备好=======");\n                        /*\n                         * 当server socket channel通道已经准备好，就可以从server socket channel中获取socketchannel了\n                         * 拿到socket channel后，要做的事情就是马上到selector注册这个socket channel感兴趣的事情。\n                         * 否则无法监听到这个socket channel到达的数据\n                         * */\n                        ServerSocketChannel serverSocketChannel = (ServerSocketChannel)selectableChannel;\n                        SocketChannel socketChannel = serverSocketChannel.accept();\n                        registerSocketChannel(socketChannel , selector);\n\n                    } else if(readyKey.isValid() && readyKey.isConnectable()) {\n                        SocketServer2.LOGGER.info("======socket channel 建立连接=======");\n                    } else if(readyKey.isValid() && readyKey.isReadable()) {\n                        SocketServer2.LOGGER.info("======socket channel 数据准备完成，可以去读==读取=======");\n                        readSocketChannel(readyKey);\n                    }\n                }\n            }\n        } catch(Exception e) {\n            SocketServer2.LOGGER.error(e.getMessage() , e);\n        } finally {\n            serverSocket.close();\n        }\n    }\n\n    /**\n     * 在server socket channel接收到/准备好 一个新的 TCP连接后。\n     * 就会向程序返回一个新的socketChannel。<br>\n     * 但是这个新的socket channel并没有在selector“选择器/代理器”中注册，\n     * 所以程序还没法通过selector通知这个socket channel的事件。\n     * 于是我们拿到新的socket channel后，要做的第一个事情就是到selector“选择器/代理器”中注册这个\n     * socket channel感兴趣的事件\n     * @param socketChannel 新的socket channel\n     * @param selector selector“选择器/代理器”\n     * @throws Exception\n     */\n    private static void registerSocketChannel(SocketChannel socketChannel , Selector selector) throws Exception {\n        socketChannel.configureBlocking(false);\n        //socket通道可以且只可以注册三种事件SelectionKey.OP_READ | SelectionKey.OP_WRITE | SelectionKey.OP_CONNECT\n        //最后一个参数视为 为这个socketchanne分配的缓存区\n        socketChannel.register(selector, SelectionKey.OP_READ , ByteBuffer.allocate(50));\n    }\n\n    /**\n     * 这个方法用于读取从客户端传来的信息。\n     * 并且观察从客户端过来的socket channel在经过多次传输后，是否完成传输。\n     * 如果传输完成，则返回一个true的标记。\n     * @param socketChannel\n     * @throws Exception\n     */\n    private static void readSocketChannel(SelectionKey readyKey) throws Exception {\n        SocketChannel clientSocketChannel = (SocketChannel)readyKey.channel();\n        //获取客户端使用的端口\n        InetSocketAddress sourceSocketAddress = (InetSocketAddress)clientSocketChannel.getRemoteAddress();\n        Integer resoucePort = sourceSocketAddress.getPort();\n\n        //拿到这个socket channel使用的缓存区，准备读取数据\n        //在后文，将详细讲解缓存区的用法概念，实际上重要的就是三个元素capacity,position和limit。\n        ByteBuffer contextBytes = (ByteBuffer)readyKey.attachment();\n        //将通道的数据写入到缓存区，注意是写入到缓存区。\n        //这次，为了演示buff的使用方式，我们故意缩小了buff的容量大小到50byte，\n        //以便演示channel对buff的多次读写操作\n        int realLen = 0;\n        StringBuffer message = new StringBuffer();\n        //这句话的意思是，将目前通道中的数据写入到缓存区\n        //最大可写入的数据量就是buff的容量\n        while((realLen = clientSocketChannel.read(contextBytes)) != 0) {\n\n            //一定要把buffer切换成“读”模式，否则由于limit = capacity\n            //在read没有写满的情况下，就会导致多读\n            contextBytes.flip();\n            int position = contextBytes.position();\n            int capacity = contextBytes.capacity();\n            byte[] messageBytes = new byte[capacity];\n            contextBytes.get(messageBytes, position, realLen);\n\n            //这种方式也是可以读取数据的，而且不用关心position的位置。\n            //因为是目前contextBytes所有的数据全部转出为一个byte数组。\n            //使用这种方式时，一定要自己控制好读取的最终位置(realLen很重要)\n            //byte[] messageBytes = contextBytes.array();\n\n            //注意中文乱码的问题，我个人喜好是使用URLDecoder/URLEncoder，进行解编码。\n            //当然java nio框架本身也提供编解码方式，看个人咯\n            String messageEncode = new String(messageBytes , 0 , realLen , "UTF-8");\n            message.append(messageEncode);\n\n            //再切换成“写”模式，直接情况缓存的方式，最快捷\n            contextBytes.clear();\n        }\n\n        //如果发现本次接收的信息中有over关键字，说明信息接收完了\n        if(URLDecoder.decode(message.toString(), "UTF-8").indexOf("over") != -1) {\n            //则从messageHashContext中，取出之前已经收到的信息，组合成完整的信息\n            Integer channelUUID = clientSocketChannel.hashCode();\n            SocketServer2.LOGGER.info("端口:" + resoucePort + "客户端发来的信息======message : " + message);\n            StringBuffer completeMessage;\n            //清空MESSAGEHASHCONTEXT中的历史记录\n            StringBuffer historyMessage = MESSAGEHASHCONTEXT.remove(channelUUID);\n            if(historyMessage == null) {\n                completeMessage = message;\n            } else {\n                completeMessage = historyMessage.append(message);\n            }\n            SocketServer2.LOGGER.info("端口:" + resoucePort + "客户端发来的完整信息======completeMessage : " + URLDecoder.decode(completeMessage.toString(), "UTF-8"));\n\n            //======================================================\n            //          当然接受完成后，可以在这里正式处理业务了        \n            //======================================================\n\n            //回发数据，并关闭channel\n            ByteBuffer sendBuffer = ByteBuffer.wrap(URLEncoder.encode("回发处理结果", "UTF-8").getBytes());\n            clientSocketChannel.write(sendBuffer);\n            clientSocketChannel.close();\n        } else {\n            //如果没有发现有“over”关键字，说明还没有接受完，则将本次接受到的信息存入messageHashContext\n            SocketServer2.LOGGER.info("端口:" + resoucePort + "客户端信息还未接受完，继续接受======message : " + URLDecoder.decode(message.toString(), "UTF-8"));\n            //每一个channel对象都是独立的，所以可以使用对象的hash值，作为唯一标示\n            Integer channelUUID = clientSocketChannel.hashCode();\n\n            //然后获取这个channel下以前已经达到的message信息\n            StringBuffer historyMessage = MESSAGEHASHCONTEXT.get(channelUUID);\n            if(historyMessage == null) {\n                historyMessage = new StringBuffer();\n                MESSAGEHASHCONTEXT.put(channelUUID, historyMessage.append(message));\n            }\n        }\n    }\n}\n\n\n以上代码应该没有过多需要讲解的了。当然，您还是可以加入线程池技术，进行具体的业务处理。注意，一定是线程池，因为这样可以保证线程规模的可控性。\n\n\n# 多路复用IO的优缺点\n\n * 不用再使用多线程来进行IO处理了(包括操作系统内核IO管理模块和应用程序进程而言)。当然实际业务的处理中，应用程序进程还是可以引入线程池技术的\n\n * 同一个端口可以处理多种协议，例如，使用ServerSocketChannel测测的服务器端口监听，既可以处理TCP协议又可以处理UDP协议。\n\n * 操作系统级别的优化: 多路复用IO技术可以是操作系统级别在一个端口上能够同时接受多个客户端的IO事件。同时具有之前我们讲到的阻塞式同步IO和非阻塞式同步IO的所有特点。Selector的一部分作用更相当于“轮询代理器”。\n\n * 都是同步IO: 目前我们介绍的 阻塞式IO、非阻塞式IO甚至包括多路复用IO，这些都是基于操作系统级别对“同步IO”的实现。我们一直在说“同步IO”，一直都没有详细说，什么叫做“同步IO”。实际上一句话就可以说清楚: 只有上层(包括上层的某种代理机制)系统询问我是否有某个事件发生了，否则我不会主动告诉上层系统事件发生了:\n\n\n# 参考文章\n\n * 文章主要来源于: 银文杰，笔名“说好不能打脸”，博客地址在新窗口打开。他的书《高性能服务系统构建与实战》。\n * https://blog.csdn.net/yinwenjie/article/details/48522403',normalizedContent:'# java nio - io多路复用详解\n\n> 本文主要对io多路复用，ractor模型以及java nio对其的支持。@pdai\n\n * java nio - io多路复用详解\n   * 现实场景\n   * 典型的多路复用io实现\n   * reactor模型和proactor模型\n     * 传统io模型\n     * reactor事件驱动模型\n     * reactor模型----业务处理与io分离\n     * reactor模型----并发读写\n     * reactor模型示例\n   * java对多路复用io的支持\n     * 重要概念: channel\n     * 重要概念: buffer\n     * 重要概念: selector\n     * java nio 框架简要设计分析\n     * java实例\n     * java实例改进\n   * 多路复用io的优缺点\n   * 参考文章\n\n\n# 现实场景\n\n我们试想一下这样的现实场景:\n\n一个餐厅同时有100位客人到店，当然到店后第一件要做的事情就是点菜。但是问题来了，餐厅老板为了节约人力成本目前只有一位大堂服务员拿着唯一的一本菜单等待客人进行服务。\n\n * 那么最笨(但是最简单)的方法是(方法a)，无论有多少客人等待点餐，服务员都把仅有的一份菜单递给其中一位客人，然后站在客人身旁等待这个客人完成点菜过程。在记录客人点菜内容后，把点菜记录交给后堂厨师。然后是第二位客人。。。。然后是第三位客人。很明显，只有脑袋被门夹过的老板，才会这样设置服务流程。因为随后的80位客人，再等待超时后就会离店(还会给差评)。\n\n * 于是还有一种办法(方法b)，老板马上新雇佣99名服务员，同时印制99本新的菜单。每一名服务员手持一本菜单负责一位客人(关键不只在于服务员，还在于菜单。因为没有菜单客人也无法点菜)。在客人点完菜后，记录点菜内容交给后堂厨师(当然为了更高效，后堂厨师最好也有100名)。这样每一位客人享受的就是vip服务咯，当然客人不会走，但是人力成本可是一个大头哦(亏死你)。\n\n * 另外一种办法(方法c)，就是改进点菜的方式，当客人到店后，自己申请一本菜单。想好自己要点的才后，就呼叫服务员。服务员站在自己身边后记录客人的菜单内容。将菜单递给厨师的过程也要进行改进，并不是每一份菜单记录好以后，都要交给后堂厨师。服务员可以记录号多份菜单后，同时交给厨师就行了。那么这种方式，对于老板来说人力成本是最低的；对于客人来说，虽然不再享受vip服务并且要进行一定的等待，但是这些都是可接受的；对于服务员来说，基本上她的时间都没有浪费，基本上被老板压杆了最后一滴油水。\n\n如果您是老板，您会采用哪种方式呢?\n\n到店情况: 并发量。到店情况不理想时，一个服务员一本菜单，当然是足够了。所以不同的老板在不同的场合下，将会灵活选择服务员和菜单的配置。\n\n * 客人: 客户端请求\n * 点餐内容: 客户端发送的实际数据\n * 老板: 操作系统\n * 人力成本: 系统资源\n * 菜单: 文件状态描述符。操作系统对于一个进程能够同时持有的文件状态描述符的个数是有限制的，在linux系统中$ulimit -n查看这个限制值，当然也是可以(并且应该)进行内核参数调整的。\n * 服务员: 操作系统内核用于io操作的线程(内核线程)\n * 厨师: 应用程序线程(当然厨房就是应用程序进程咯)\n * 餐单传递方式: 包括了阻塞式和非阻塞式两种。\n   * 方法a: 阻塞式/非阻塞式 同步io\n   * 方法b: 使用线程进行处理的 阻塞式/非阻塞式 同步io\n   * 方法c: 阻塞式/非阻塞式 多路复用io\n\n\n# 典型的多路复用io实现\n\n目前流程的多路复用io实现主要包括四种: select、poll、epoll、kqueue。下表是他们的一些重要特性的比较:\n\nio模型     相对性能   关键思路               操作系统            java支持情况\nselect   较高     reactor            windows/linux   支持,reactor模式(反应器设计模式)。linux操作系统的 kernels\n                                                   2.4内核版本之前，默认使用select；而目前windows下对同步io的支持，都是select模型\npoll     较高     reactor            linux           linux下的java nio框架，linux kernels\n                                                   2.6内核版本之前使用poll进行支持。也是使用的reactor模式\nepoll    高      reactor/proactor   linux           linux kernels 2.6内核版本及以后使用epoll进行支持；linux kernels\n                                                   2.6内核版本之前使用poll进行支持；另外一定注意，由于linux下没有windows下的iocp技术提供真正的\n                                                   异步io 支持，所以linux下使用epoll模拟异步io\nkqueue   高      proactor           linux           目前java的版本不支持\n\n多路复用io技术最适用的是“高并发”场景，所谓高并发是指1毫秒内至少同时有上千个连接请求准备好。其他情况下多路复用io技术发挥不出来它的优势。另一方面，使用java nio进行功能实现，相对于传统的socket套接字实现要复杂一些，所以实际应用中，需要根据自己的业务需求进行技术选择。\n\n\n# reactor模型和proactor模型\n\n\n# 传统io模型\n\n对于传统io模型，其主要是一个server对接n个客户端，在客户端连接之后，为每个客户端都分配一个执行线程。如下图是该模型的一个演示：\n\n\n\n从图中可以看出，传统io的特点在于：\n\n * 每个客户端连接到达之后，服务端会分配一个线程给该客户端，该线程会处理包括读取数据，解码，业务计算，编码，以及发送数据整个过程；\n * 同一时刻，服务端的吞吐量与服务器所提供的线程数量是呈线性关系的。\n\n这种设计模式在客户端连接不多，并发量不大的情况下是可以运行得很好的，但是在海量并发的情况下，这种模式就显得力不从心了。这种模式主要存在的问题有如下几点：\n\n * 服务器的并发量对服务端能够创建的线程数有很大的依赖关系，但是服务器线程却是不能无限增长的；\n * 服务端每个线程不仅要进行io读写操作，而且还需要进行业务计算；\n * 服务端在获取客户端连接，读取数据，以及写入数据的过程都是阻塞类型的，在网络状况不好的情况下，这将极大的降低服务器每个线程的利用率，从而降低服务器吞吐量。\n\n\n# reactor事件驱动模型\n\n在传统io模型中，由于线程在等待连接以及进行io操作时都会阻塞当前线程，这部分损耗是非常大的。因而jdk 1.4中就提供了一套非阻塞io的api。该api本质上是以事件驱动来处理网络事件的，而reactor是基于该api提出的一套io模型。如下是reactor事件驱动模型的示意图：\n\n\n\n从图中可以看出，在reactor模型中，主要有四个角色：客户端连接，reactor，acceptor和handler。这里acceptor会不断地接收客户端的连接，然后将接收到的连接交由reactor进行分发，最后有具体的handler进行处理。改进后的reactor模型相对于传统的io模型主要有如下优点：\n\n * 从模型上来讲，如果仅仅还是只使用一个线程池来处理客户端连接的网络读写，以及业务计算，那么reactor模型与传统io模型在效率上并没有什么提升。但是reactor模型是以事件进行驱动的，其能够将接收客户端连接，+ 网络读和网络写，以及业务计算进行拆分，从而极大的提升处理效率；\n * reactor模型是异步非阻塞模型，工作线程在没有网络事件时可以处理其他的任务，而不用像传统io那样必须阻塞等待。\n\n\n# reactor模型----业务处理与io分离\n\n在上面的reactor模型中，由于网络读写和业务操作都在同一个线程中，在高并发情况下，这里的系统瓶颈主要在两方面：\n\n * 高频率的网络读写事件处理；\n * 大量的业务操作处理；\n\n基于上述两个问题，这里在单线程reactor模型的基础上提出了使用线程池的方式处理业务操作的模型。如下是该模型的示意图：\n\n\n\n从图中可以看出，在多线程进行业务操作的模型下，该模式主要具有如下特点：\n\n * 使用一个线程进行客户端连接的接收以及网络读写事件的处理；\n * 在接收到客户端连接之后，将该连接交由线程池进行数据的编解码以及业务计算。\n\n这种模式相较于前面的模式性能有了很大的提升，主要在于在进行网络读写的同时，也进行了业务计算，从而大大提升了系统的吞吐量。但是这种模式也有其不足，主要在于：\n\n * 网络读写是一个比较消耗cpu的操作，在高并发的情况下，将会有大量的客户端数据需要进行网络读写，此时一个线程将不足以处理这么多请求。\n\n\n# reactor模型----并发读写\n\n对于使用线程池处理业务操作的模型，由于网络读写在高并发情况下会成为系统的一个瓶颈，因而针对该模型这里提出了一种改进后的模型，即使用线程池进行网络读写，而仅仅只使用一个线程专门接收客户端连接。如下是该模型的示意图：\n\n\n\n可以看到，改进后的reactor模型将reactor拆分为了mainreactor和subreactor。这里mainreactor主要进行客户端连接的处理，处理完成之后将该连接交由subreactor以处理客户端的网络读写。这里的subreactor则是使用一个线程池来支撑的，其读写能力将会随着线程数的增多而大大增加。对于业务操作，这里也是使用一个线程池，而每个业务请求都只需要进行编解码和业务计算。通过这种方式，服务器的性能将会大大提升，在可见情况下，其基本上可以支持百万连接。\n\n\n# reactor模型示例\n\n对于上述reactor模型，服务端主要有三个角色：reactor，acceptor和handler。这里基于doug lea的文档对其进行了实现，如下是reactor的实现代码：\n\npublic class reactor implements runnable {\n  private final selector selector;\n  private final serversocketchannel serversocket;\n\n  public reactor(int port) throws ioexception {\n    serversocket = serversocketchannel.open();  // 创建服务端的serversocketchannel\n    serversocket.configureblocking(false);  // 设置为非阻塞模式\n    selector = selector.open();  // 创建一个selector多路复用器\n    selectionkey key = serversocket.register(selector, selectionkey.op_accept);\n    serversocket.bind(new inetsocketaddress(port));  // 绑定服务端端口\n    key.attach(new acceptor(serversocket));  // 为服务端channel绑定一个acceptor\n  }\n\n  @override\n  public void run() {\n    try {\n      while (!thread.interrupted()) {\n        selector.select();  // 服务端使用一个线程不断等待客户端的连接到达\n        set<selectionkey> keys = selector.selectedkeys();\n        iterator<selectionkey> iterator = keys.iterator();\n        while (iterator.hasnext()) {\n          dispatch(iterator.next());  // 监听到客户端连接事件后将其分发给acceptor\n          iterator.remove();\n        }\n\n        selector.selectnow();\n      }\n    } catch (ioexception e) {\n      e.printstacktrace();\n    }\n  }\n\n  private void dispatch(selectionkey key) throws ioexception {\n    // 这里的attachement也即前面为服务端channel绑定的acceptor，调用其run()方法进行\n    // 客户端连接的获取，并且进行分发\n    runnable attachment = (runnable) key.attachment();\n    attachment.run();\n  }\n}\n\n\n这里reactor首先开启了一个serversocketchannel，然后将其绑定到指定的端口，并且注册到了一个多路复用器上。接着在一个线程中，其会在多路复用器上等待客户端连接。当有客户端连接到达后，reactor就会将其派发给一个acceptor，由该acceptor专门进行客户端连接的获取。下面我们继续看一下acceptor的代码：\n\npublic class acceptor implements runnable {\n  private final executorservice executor = executors.newfixedthreadpool(20);\n\n  private final serversocketchannel serversocket;\n\n  public acceptor(serversocketchannel serversocket) {\n    this.serversocket = serversocket;\n  }\n\n  @override\n  public void run() {\n    try {\n      socketchannel channel = serversocket.accept();  // 获取客户端连接\n      if (null != channel) {\n        executor.execute(new handler(channel));  // 将客户端连接交由线程池处理\n      }\n    } catch (ioexception e) {\n      e.printstacktrace();\n    }\n  }\n}\n\n\n这里可以看到，在acceptor获取到客户端连接之后，其就将其交由线程池进行网络读写了，而这里的主线程只是不断监听客户端连接事件。下面我们看看handler的具体逻辑：\n\npublic class handler implements runnable {\n  private volatile static selector selector;\n  private final socketchannel channel;\n  private selectionkey key;\n  private volatile bytebuffer input = bytebuffer.allocate(1024);\n  private volatile bytebuffer output = bytebuffer.allocate(1024);\n\n  public handler(socketchannel channel) throws ioexception {\n    this.channel = channel;\n    channel.configureblocking(false);  // 设置客户端连接为非阻塞模式\n    selector = selector.open();  // 为客户端创建一个新的多路复用器\n    key = channel.register(selector, selectionkey.op_read);  // 注册客户端channel的读事件\n  }\n\n  @override\n  public void run() {\n    try {\n      while (selector.isopen() && channel.isopen()) {\n        set<selectionkey> keys = select();  // 等待客户端事件发生\n        iterator<selectionkey> iterator = keys.iterator();\n        while (iterator.hasnext()) {\n          selectionkey key = iterator.next();\n          iterator.remove();\n\n          // 如果当前是读事件，则读取数据\n          if (key.isreadable()) {\n            read(key);\n          } else if (key.iswritable()) {\n           // 如果当前是写事件，则写入数据\n            write(key);\n          }\n        }\n      }\n    } catch (exception e) {\n      e.printstacktrace();\n    }\n  }\n\n  // 这里处理的主要目的是处理jdk的一个bug，该bug会导致selector被意外触发，但是实际上没有任何事件到达，\n  // 此时的处理方式是新建一个selector，然后重新将当前channel注册到该selector上\n  private set<selectionkey> select() throws ioexception {\n    selector.select();\n    set<selectionkey> keys = selector.selectedkeys();\n    if (keys.isempty()) {\n      int interestops = key.interestops();\n      selector = selector.open();\n      key = channel.register(selector, interestops);\n      return select();\n    }\n\n    return keys;\n  }\n\n  // 读取客户端发送的数据\n  private void read(selectionkey key) throws ioexception {\n    channel.read(input);\n    if (input.position() == 0) {\n      return;\n    }\n\n    input.flip();\n    process();  // 对读取的数据进行业务处理\n    input.clear();\n    key.interestops(selectionkey.op_write);  // 读取完成后监听写入事件\n  }\n\n  private void write(selectionkey key) throws ioexception {\n    output.flip();\n    if (channel.isopen()) {\n      channel.write(output);  // 当有写入事件时，将业务处理的结果写入到客户端channel中\n      key.channel();\n      channel.close();\n      output.clear();\n    }\n  }\n    \n  // 进行业务处理，并且获取处理结果。本质上，基于reactor模型，如果这里成为处理瓶颈，\n  // 则直接将其处理过程放入线程池即可，并且使用一个future获取处理结果，最后写入客户端channel\n  private void process() {\n    byte[] bytes = new byte[input.remaining()];\n    input.get(bytes);\n    string message = new string(bytes, charsetutil.utf_8);\n    system.out.println("receive message from client: \\n" + message);\n\n    output.put("hello client".getbytes());\n  }\n}\n\n\n在handler中，主要进行的就是为每一个客户端channel创建一个selector，并且监听该channel的网络读写事件。当有事件到达时，进行数据的读写，而业务操作这交由具体的业务线程池处理。\n\n\n# java对多路复用io的支持\n\n\n\n\n# 重要概念: channel\n\n通道，被建立的一个应用程序和操作系统交互事件、传递内容的渠道(注意是连接到操作系统)。一个通道会有一个专属的文件状态描述符。那么既然是和操作系统进行内容的传递，那么说明应用程序可以通过通道读取数据，也可以通过通道向操作系统写数据。\n\njdk api中的channel的描述是:\n\n> a channel represents an open connection to an entity such as a hardware device, a file, a network socket, or a program component that is capable of performing one or more distinct i/o operations, for example reading or writing.\n\n> a channel is either open or closed. a channel is open upon creation, and once closed it remains closed. once a channel is closed, any attempt to invoke an i/o operation upon it will cause a closedchannelexception to be thrown. whether or not a channel is open may be tested by invoking its isopen method.\n\njava nio 框架中，自有的channel通道包括:\n\n\n\n所有被selector(选择器)注册的通道，只能是继承了selectablechannel类的子类。如上图所示\n\n * serversocketchannel: 应用服务器程序的监听通道。只有通过这个通道，应用程序才能向操作系统注册支持“多路复用io”的端口监听。同时支持udp协议和tcp协议。\n\n * scoketchannel: tcp socket套接字的监听通道，一个socket套接字对应了一个客户端ip: 端口 到 服务器ip: 端口的通信连接。\n\n * datagramchannel: udp 数据报文的监听通道。\n\n\n# 重要概念: buffer\n\n数据缓存区: 在java nio 框架中，为了保证每个通道的数据读写速度java nio 框架为每一种需要支持数据读写的通道集成了buffer的支持。\n\n这句话怎么理解呢? 例如serversocketchannel通道它只支持对op_accept事件的监听，所以它是不能直接进行网络数据内容的读写的。所以serversocketchannel是没有集成buffer的。\n\nbuffer有两种工作模式: 写模式和读模式。在读模式下，应用程序只能从buffer中读取数据，不能进行写操作。但是在写模式下，应用程序是可以进行读操作的，这就表示可能会出现脏读的情况。所以一旦您决定要从buffer中读取数据，一定要将buffer的状态改为读模式。\n\n如下图:\n\n\n\n * position: 缓存区目前这在操作的数据块位置\n * limit: 缓存区最大可以进行操作的位置。缓存区的读写状态正式由这个属性控制的。\n * capacity: 缓存区的最大容量。这个容量是在缓存区创建时进行指定的。由于高并发时通道数量往往会很庞大，所以每一个缓存区的容量最好不要过大。\n\n在下文java nio框架的代码实例中，我们将进行buffer缓存区操作的演示。\n\n\n# 重要概念: selector\n\nselector的英文含义是“选择器”，不过根据我们详细介绍的selector的岗位职责，您可以把它称之为“轮询代理器”、“事件订阅器”、“channel容器管理机”都行。\n\n * 事件订阅和channel管理\n\n应用程序将向selector对象注册需要它关注的channel，以及具体的某一个channel会对哪些io事件感兴趣。selector中也会维护一个“已经注册的channel”的容器。以下代码来自windowsselectorimpl实现类中，对已经注册的channel的管理容器:\n\n// initial capacity of the poll array\nprivate final int init_cap = 8;\n// maximum number of sockets for select().\n// should be init_cap times a power of 2\nprivate final static int max_selectable_fds = 1024;\n\n// the list of selectablechannels serviced by this selector. every mod\n// max_selectable_fds entry is bogus, to align this array with the poll\n// array,  where the corresponding entry is occupied by the wakeupsocket\nprivate selectionkeyimpl[] channelarray = new selectionkeyimpl[init_cap];\n\n\n * 轮询代理\n\n应用层不再通过阻塞模式或者非阻塞模式直接询问操作系统“事件有没有发生”，而是由selector代其询问。\n\n * 实现不同操作系统的支持\n\n之前已经提到过，多路复用io技术 是需要操作系统进行支持的，其特点就是操作系统可以同时扫描同一个端口上不同网络连接的事件。所以作为上层的jvm，必须要为 不同操作系统的多路复用io实现 编写不同的代码。同样我使用的测试环境是windows，它对应的实现类是sun.nio.ch.windowsselectorimpl:\n\n\n\n\n# java nio 框架简要设计分析\n\n通过上文的描述，我们知道了多路复用io技术是操作系统的内核实现。在不同的操作系统，甚至同一系列操作系统的版本中所实现的多路复用io技术都是不一样的。那么作为跨平台的java jvm来说如何适应多种多样的多路复用io技术实现呢? 面向对象的威力就显现出来了: 无论使用哪种实现方式，他们都会有“选择器”、“通道”、“缓存”这几个操作要素，那么可以为不同的多路复用io技术创建一个统一的抽象组，并且为不同的操作系统进行具体的实现。java nio中对各种多路复用io的支持，主要的基础是java.nio.channels.spi.selectorprovider抽象类，其中的几个主要抽象方法包括:\n\n * public abstract datagramchannel opendatagramchannel(): 创建和这个操作系统匹配的udp 通道实现。\n\n * public abstract abstractselector openselector(): 创建和这个操作系统匹配的nio选择器，就像上文所述，不同的操作系统，不同的版本所默认支持的nio模型是不一样的。\n\n * public abstract serversocketchannel openserversocketchannel(): 创建和这个nio模型匹配的服务器端通道。\n\n * public abstract socketchannel opensocketchannel(): 创建和这个nio模型匹配的tcp socket套接字通道(用来反映客户端的tcp连接)\n\n由于java nio框架的整个设计是很大的，所以我们只能还原一部分我们关心的问题。这里我们以java nio框架中对于不同多路复用io技术的选择器 进行实例化创建的方式作为例子，以点窥豹观全局:\n\n\n\n很明显，不同的selectorprovider实现对应了不同的 选择器。由具体的selectorprovider实现进行创建。另外说明一下，实际上netty底层也是通过这个设计获得具体使用的nio模型，我们后文讲解netty时，会讲到这个问题。以下代码是netty 4.0中nioserversocketchannel进行实例化时的核心代码片段:\n\nprivate static serversocketchannel newsocket(selectorprovider provider) {\n    try {\n        /**\n            *  use the {@link selectorprovider} to open {@link socketchannel} and so remove condition in\n            *  {@link selectorprovider#provider()} which is called by each serversocketchannel.open() otherwise.\n            *\n            *  see <a href="see https://github.com/netty/netty/issues/2308">#2308</a>.\n            */\n        return provider.openserversocketchannel();\n    } catch (ioexception e) {\n        throw new channelexception(\n                "failed to open a server socket.", e);\n    }\n}\n\n\n\n# java实例\n\n下面，我们使用java nio框架，实现一个支持多路复用io的服务器端(实际上客户端是否使用多路复用io技术，对整个系统架构的性能提升相关性不大):\n\npackage testnsocket;\n\nimport java.net.inetsocketaddress;\nimport java.net.serversocket;\nimport java.net.urldecoder;\nimport java.net.urlencoder;\nimport java.nio.bytebuffer;\nimport java.nio.channels.selectablechannel;\nimport java.nio.channels.selectionkey;\nimport java.nio.channels.selector;\nimport java.nio.channels.serversocketchannel;\nimport java.nio.channels.socketchannel;\nimport java.util.iterator;\n\nimport org.apache.commons.logging.log;\nimport org.apache.commons.logging.logfactory;\nimport org.apache.log4j.basicconfigurator;\n\npublic class socketserver1 {\n\n    static {\n        basicconfigurator.configure();\n    }\n\n    /**\n     * 日志\n     */\n    private static final log logger = logfactory.getlog(socketserver1.class);\n\n    public static void main(string[] args) throws exception {\n        serversocketchannel serverchannel = serversocketchannel.open();\n        serverchannel.configureblocking(false);\n        serversocket serversocket = serverchannel.socket();\n        serversocket.setreuseaddress(true);\n        serversocket.bind(new inetsocketaddress(83));\n\n        selector selector = selector.open();\n        //注意、服务器通道只能注册selectionkey.op_accept事件\n        serverchannel.register(selector, selectionkey.op_accept);\n\n        try {\n            while(true) {\n                //如果条件成立，说明本次询问selector，并没有获取到任何准备好的、感兴趣的事件\n                //java程序对多路复用io的支持也包括了阻塞模式 和非阻塞模式两种。\n                if(selector.select(100) == 0) {\n                    //================================================\n                    //      这里视业务情况，可以做一些然并卵的事情\n                    //================================================\n                    continue;\n                }\n                //这里就是本次询问操作系统，所获取到的“所关心的事件”的事件类型(每一个通道都是独立的)\n                iterator<selectionkey> selecionkeys = selector.selectedkeys().iterator();\n\n                while(selecionkeys.hasnext()) {\n                    selectionkey readykey = selecionkeys.next();\n                    //这个已经处理的readykey一定要移除。如果不移除，就会一直存在在selector.selectedkeys集合中\n                    //待到下一次selector.select() > 0时，这个readykey又会被处理一次\n                    selecionkeys.remove();\n\n                    selectablechannel selectablechannel = readykey.channel();\n                    if(readykey.isvalid() && readykey.isacceptable()) {\n                        socketserver1.logger.info("======channel通道已经准备好=======");\n                        /*\n                         * 当server socket channel通道已经准备好，就可以从server socket channel中获取socketchannel了\n                         * 拿到socket channel后，要做的事情就是马上到selector注册这个socket channel感兴趣的事情。\n                         * 否则无法监听到这个socket channel到达的数据\n                         * */\n                        serversocketchannel serversocketchannel = (serversocketchannel)selectablechannel;\n                        socketchannel socketchannel = serversocketchannel.accept();\n                        registersocketchannel(socketchannel , selector);\n\n                    } else if(readykey.isvalid() && readykey.isconnectable()) {\n                        socketserver1.logger.info("======socket channel 建立连接=======");\n                    } else if(readykey.isvalid() && readykey.isreadable()) {\n                        socketserver1.logger.info("======socket channel 数据准备完成，可以去读==读取=======");\n                        readsocketchannel(readykey);\n                    }\n                }\n            }\n        } catch(exception e) {\n            socketserver1.logger.error(e.getmessage() , e);\n        } finally {\n            serversocket.close();\n        }\n    }\n\n    /**\n     * 在server socket channel接收到/准备好 一个新的 tcp连接后。\n     * 就会向程序返回一个新的socketchannel。<br>\n     * 但是这个新的socket channel并没有在selector“选择器/代理器”中注册，\n     * 所以程序还没法通过selector通知这个socket channel的事件。\n     * 于是我们拿到新的socket channel后，要做的第一个事情就是到selector“选择器/代理器”中注册这个\n     * socket channel感兴趣的事件\n     * @param socketchannel 新的socket channel\n     * @param selector selector“选择器/代理器”\n     * @throws exception\n     */\n    private static void registersocketchannel(socketchannel socketchannel , selector selector) throws exception {\n        socketchannel.configureblocking(false);\n        //socket通道可以且只可以注册三种事件selectionkey.op_read | selectionkey.op_write | selectionkey.op_connect\n        socketchannel.register(selector, selectionkey.op_read , bytebuffer.allocate(2048));\n    }\n\n    /**\n     * 这个方法用于读取从客户端传来的信息。\n     * 并且观察从客户端过来的socket channel在经过多次传输后，是否完成传输。\n     * 如果传输完成，则返回一个true的标记。\n     * @param socketchannel\n     * @throws exception\n     */\n    private static void readsocketchannel(selectionkey readykey) throws exception {\n        socketchannel clientsocketchannel = (socketchannel)readykey.channel();\n        //获取客户端使用的端口\n        inetsocketaddress sourcesocketaddress = (inetsocketaddress)clientsocketchannel.getremoteaddress();\n        integer resouceport = sourcesocketaddress.getport();\n\n        //拿到这个socket channel使用的缓存区，准备读取数据\n        //在后文，将详细讲解缓存区的用法概念，实际上重要的就是三个元素capacity,position和limit。\n        bytebuffer contextbytes = (bytebuffer)readykey.attachment();\n        //将通道的数据写入到缓存区，注意是写入到缓存区。\n        //由于之前设置了bytebuffer的大小为2048 byte，所以可以存在写入不完的情况\n        //没关系，我们后面来调整代码。这里我们暂时理解为一次接受可以完成\n        int reallen = -1;\n        try {\n            reallen = clientsocketchannel.read(contextbytes);\n        } catch(exception e) {\n            //这里抛出了异常，一般就是客户端因为某种原因终止了。所以关闭channel就行了\n            socketserver1.logger.error(e.getmessage());\n            clientsocketchannel.close();\n            return;\n        }\n\n        //如果缓存区中没有任何数据(但实际上这个不太可能，否则就不会触发op_read事件了)\n        if(reallen == -1) {\n            socketserver1.logger.warn("====缓存区没有数据? ====");\n            return;\n        }\n\n        //将缓存区从写状态切换为读状态(实际上这个方法是读写模式互切换)。\n        //这是java nio框架中的这个socket channel的写请求将全部等待。\n        contextbytes.flip();\n        //注意中文乱码的问题，我个人喜好是使用urldecoder/urlencoder，进行解编码。\n        //当然java nio框架本身也提供编解码方式，看个人咯\n        byte[] messagebytes = contextbytes.array();\n        string messageencode = new string(messagebytes , "utf-8");\n        string message = urldecoder.decode(messageencode, "utf-8");\n\n        //如果收到了“over”关键字，才会清空buffer，并回发数据；\n        //否则不清空缓存，还要还原buffer的“写状态”\n        if(message.indexof("over") != -1) {\n            //清空已经读取的缓存，并从新切换为写状态(这里要注意clear()和capacity()两个方法的区别)\n            contextbytes.clear();\n            socketserver1.logger.info("端口:" + resouceport + "客户端发来的信息======message : " + message);\n\n            //======================================================\n            //          当然接受完成后，可以在这里正式处理业务了        \n            //======================================================\n\n            //回发数据，并关闭channel\n            bytebuffer sendbuffer = bytebuffer.wrap(urlencoder.encode("回发处理结果", "utf-8").getbytes());\n            clientsocketchannel.write(sendbuffer);\n            clientsocketchannel.close();\n        } else {\n            socketserver1.logger.info("端口:" + resouceport + "客户端信息还未接受完，继续接受======message : " + message);\n            //这是，limit和capacity的值一致，position的位置是reallen的位置\n            contextbytes.position(reallen);\n            contextbytes.limit(contextbytes.capacity());\n        }\n    }\n}\n\n\n代码中的注释是比较清楚的，但是还是要对几个关键点进行一下讲解:\n\n * serverchannel.register(selector sel, int ops, object att): 实际上register(selector sel, int ops, object att)方法是serversocketchannel类的父类abstractselectablechannel提供的一个方法，表示只要继承了abstractselectablechannel类的子类都可以注册到选择器中。通过观察整个abstractselectablechannel继承关系，下图中的这些类可以被注册到选择器中:\n\n\n\n * selectionkey.op_accept: 不同的channel对象可以注册的“我关心的事件”是不一样的。例如serversocketchannel除了能够被允许关注op_accept事件外，不允许再关心其他事件了(否则运行时会抛出异常)。以下梳理了常使用的abstractselectablechannel子类可以注册的事件列表:\n\n通道类                   通道作用      可关注的事件\nserversocketchannel   服务器端通道    selectionkey.op_accept\ndatagramchannel       udp协议通道   selectionkey.op_read、selectionkey.op_write\nsocketchannel         tcp协议通道   selectionkey.op_read、selectionkey.op_write、selectionkey.op_connect\n\n实际上通过每一个abstractselectablechannel子类所实现的public final int validops()方法，就可以查看这个通道“可以关心的io事件”。\n\nselector.selectedkeys().iterator(): 当选择器selector收到操作系统的io操作事件后，它的selectedkeys将在下一次轮询操作中，收到这些事件的关键描述字(不同的channel，就算关键字一样，也会存储成两个对象)。但是每一个“事件关键字”被处理后都必须移除，否则下一次轮询时，这个事件会被重复处理。\n\n> returns this selector’s selected-key set. keys may be removed from, but not directly added to, the selected-key set. any attempt to add an object to the key set will cause an unsupportedoperationexception to be thrown. the selected-key set is not thread-safe.\n\n\n# java实例改进\n\n上面的代码中，我们为了讲解selector的使用，在缓存使用上就进行了简化。实际的应用中，为了节约内存资源，我们一般不会为一个通道分配那么多的缓存空间。下面的代码我们主要对其中的缓存操作进行了优化:\n\npackage testnsocket;\n\nimport java.net.inetsocketaddress;\nimport java.net.serversocket;\nimport java.net.urldecoder;\nimport java.net.urlencoder;\n\nimport java.nio.bytebuffer;\nimport java.nio.channels.selectablechannel;\nimport java.nio.channels.selectionkey;\nimport java.nio.channels.selector;\nimport java.nio.channels.serversocketchannel;\nimport java.nio.channels.socketchannel;\n\nimport java.util.iterator;\nimport java.util.concurrent.concurrenthashmap;\nimport java.util.concurrent.concurrentmap;\n\nimport org.apache.commons.logging.log;\nimport org.apache.commons.logging.logfactory;\nimport org.apache.log4j.basicconfigurator;\n\npublic class socketserver2 {\n\n    static {\n        basicconfigurator.configure();\n    }\n\n    /**\n     * 日志\n     */\n    private static final log logger = logfactory.getlog(socketserver2.class);\n\n    /**\n     * 改进的java nio server的代码中，由于buffer的大小设置的比较小。\n     * 我们不再把一个client通过socket channel多次传给服务器的信息保存在beff中了(因为根本存不下)<br>\n     * 我们使用socketchanel的hashcode作为key(当然您也可以自己确定一个id)，信息的stringbuffer作为value，存储到服务器端的一个内存区域messagehashcontext。\n     * \n     * 如果您不清楚concurrenthashmap的作用和工作原理，请自行百度/google\n     */\n    private static final concurrentmap<integer, stringbuffer> messagehashcontext = new concurrenthashmap<integer , stringbuffer>();\n\n    public static void main(string[] args) throws exception {\n        serversocketchannel serverchannel = serversocketchannel.open();\n        serverchannel.configureblocking(false);\n        serversocket serversocket = serverchannel.socket();\n        serversocket.setreuseaddress(true);\n        serversocket.bind(new inetsocketaddress(83));\n\n        selector selector = selector.open();\n        //注意、服务器通道只能注册selectionkey.op_accept事件\n        serverchannel.register(selector, selectionkey.op_accept);\n\n        try {\n            while(true) {\n                //如果条件成立，说明本次询问selector，并没有获取到任何准备好的、感兴趣的事件\n                //java程序对多路复用io的支持也包括了阻塞模式 和非阻塞模式两种。\n                if(selector.select(100) == 0) {\n                    //================================================\n                    //      这里视业务情况，可以做一些然并卵的事情\n                    //================================================\n                    continue;\n                }\n                //这里就是本次询问操作系统，所获取到的“所关心的事件”的事件类型(每一个通道都是独立的)\n                iterator<selectionkey> selecionkeys = selector.selectedkeys().iterator();\n\n                while(selecionkeys.hasnext()) {\n                    selectionkey readykey = selecionkeys.next();\n                    //这个已经处理的readykey一定要移除。如果不移除，就会一直存在在selector.selectedkeys集合中\n                    //待到下一次selector.select() > 0时，这个readykey又会被处理一次\n                    selecionkeys.remove();\n\n                    selectablechannel selectablechannel = readykey.channel();\n                    if(readykey.isvalid() && readykey.isacceptable()) {\n                        socketserver2.logger.info("======channel通道已经准备好=======");\n                        /*\n                         * 当server socket channel通道已经准备好，就可以从server socket channel中获取socketchannel了\n                         * 拿到socket channel后，要做的事情就是马上到selector注册这个socket channel感兴趣的事情。\n                         * 否则无法监听到这个socket channel到达的数据\n                         * */\n                        serversocketchannel serversocketchannel = (serversocketchannel)selectablechannel;\n                        socketchannel socketchannel = serversocketchannel.accept();\n                        registersocketchannel(socketchannel , selector);\n\n                    } else if(readykey.isvalid() && readykey.isconnectable()) {\n                        socketserver2.logger.info("======socket channel 建立连接=======");\n                    } else if(readykey.isvalid() && readykey.isreadable()) {\n                        socketserver2.logger.info("======socket channel 数据准备完成，可以去读==读取=======");\n                        readsocketchannel(readykey);\n                    }\n                }\n            }\n        } catch(exception e) {\n            socketserver2.logger.error(e.getmessage() , e);\n        } finally {\n            serversocket.close();\n        }\n    }\n\n    /**\n     * 在server socket channel接收到/准备好 一个新的 tcp连接后。\n     * 就会向程序返回一个新的socketchannel。<br>\n     * 但是这个新的socket channel并没有在selector“选择器/代理器”中注册，\n     * 所以程序还没法通过selector通知这个socket channel的事件。\n     * 于是我们拿到新的socket channel后，要做的第一个事情就是到selector“选择器/代理器”中注册这个\n     * socket channel感兴趣的事件\n     * @param socketchannel 新的socket channel\n     * @param selector selector“选择器/代理器”\n     * @throws exception\n     */\n    private static void registersocketchannel(socketchannel socketchannel , selector selector) throws exception {\n        socketchannel.configureblocking(false);\n        //socket通道可以且只可以注册三种事件selectionkey.op_read | selectionkey.op_write | selectionkey.op_connect\n        //最后一个参数视为 为这个socketchanne分配的缓存区\n        socketchannel.register(selector, selectionkey.op_read , bytebuffer.allocate(50));\n    }\n\n    /**\n     * 这个方法用于读取从客户端传来的信息。\n     * 并且观察从客户端过来的socket channel在经过多次传输后，是否完成传输。\n     * 如果传输完成，则返回一个true的标记。\n     * @param socketchannel\n     * @throws exception\n     */\n    private static void readsocketchannel(selectionkey readykey) throws exception {\n        socketchannel clientsocketchannel = (socketchannel)readykey.channel();\n        //获取客户端使用的端口\n        inetsocketaddress sourcesocketaddress = (inetsocketaddress)clientsocketchannel.getremoteaddress();\n        integer resouceport = sourcesocketaddress.getport();\n\n        //拿到这个socket channel使用的缓存区，准备读取数据\n        //在后文，将详细讲解缓存区的用法概念，实际上重要的就是三个元素capacity,position和limit。\n        bytebuffer contextbytes = (bytebuffer)readykey.attachment();\n        //将通道的数据写入到缓存区，注意是写入到缓存区。\n        //这次，为了演示buff的使用方式，我们故意缩小了buff的容量大小到50byte，\n        //以便演示channel对buff的多次读写操作\n        int reallen = 0;\n        stringbuffer message = new stringbuffer();\n        //这句话的意思是，将目前通道中的数据写入到缓存区\n        //最大可写入的数据量就是buff的容量\n        while((reallen = clientsocketchannel.read(contextbytes)) != 0) {\n\n            //一定要把buffer切换成“读”模式，否则由于limit = capacity\n            //在read没有写满的情况下，就会导致多读\n            contextbytes.flip();\n            int position = contextbytes.position();\n            int capacity = contextbytes.capacity();\n            byte[] messagebytes = new byte[capacity];\n            contextbytes.get(messagebytes, position, reallen);\n\n            //这种方式也是可以读取数据的，而且不用关心position的位置。\n            //因为是目前contextbytes所有的数据全部转出为一个byte数组。\n            //使用这种方式时，一定要自己控制好读取的最终位置(reallen很重要)\n            //byte[] messagebytes = contextbytes.array();\n\n            //注意中文乱码的问题，我个人喜好是使用urldecoder/urlencoder，进行解编码。\n            //当然java nio框架本身也提供编解码方式，看个人咯\n            string messageencode = new string(messagebytes , 0 , reallen , "utf-8");\n            message.append(messageencode);\n\n            //再切换成“写”模式，直接情况缓存的方式，最快捷\n            contextbytes.clear();\n        }\n\n        //如果发现本次接收的信息中有over关键字，说明信息接收完了\n        if(urldecoder.decode(message.tostring(), "utf-8").indexof("over") != -1) {\n            //则从messagehashcontext中，取出之前已经收到的信息，组合成完整的信息\n            integer channeluuid = clientsocketchannel.hashcode();\n            socketserver2.logger.info("端口:" + resouceport + "客户端发来的信息======message : " + message);\n            stringbuffer completemessage;\n            //清空messagehashcontext中的历史记录\n            stringbuffer historymessage = messagehashcontext.remove(channeluuid);\n            if(historymessage == null) {\n                completemessage = message;\n            } else {\n                completemessage = historymessage.append(message);\n            }\n            socketserver2.logger.info("端口:" + resouceport + "客户端发来的完整信息======completemessage : " + urldecoder.decode(completemessage.tostring(), "utf-8"));\n\n            //======================================================\n            //          当然接受完成后，可以在这里正式处理业务了        \n            //======================================================\n\n            //回发数据，并关闭channel\n            bytebuffer sendbuffer = bytebuffer.wrap(urlencoder.encode("回发处理结果", "utf-8").getbytes());\n            clientsocketchannel.write(sendbuffer);\n            clientsocketchannel.close();\n        } else {\n            //如果没有发现有“over”关键字，说明还没有接受完，则将本次接受到的信息存入messagehashcontext\n            socketserver2.logger.info("端口:" + resouceport + "客户端信息还未接受完，继续接受======message : " + urldecoder.decode(message.tostring(), "utf-8"));\n            //每一个channel对象都是独立的，所以可以使用对象的hash值，作为唯一标示\n            integer channeluuid = clientsocketchannel.hashcode();\n\n            //然后获取这个channel下以前已经达到的message信息\n            stringbuffer historymessage = messagehashcontext.get(channeluuid);\n            if(historymessage == null) {\n                historymessage = new stringbuffer();\n                messagehashcontext.put(channeluuid, historymessage.append(message));\n            }\n        }\n    }\n}\n\n\n以上代码应该没有过多需要讲解的了。当然，您还是可以加入线程池技术，进行具体的业务处理。注意，一定是线程池，因为这样可以保证线程规模的可控性。\n\n\n# 多路复用io的优缺点\n\n * 不用再使用多线程来进行io处理了(包括操作系统内核io管理模块和应用程序进程而言)。当然实际业务的处理中，应用程序进程还是可以引入线程池技术的\n\n * 同一个端口可以处理多种协议，例如，使用serversocketchannel测测的服务器端口监听，既可以处理tcp协议又可以处理udp协议。\n\n * 操作系统级别的优化: 多路复用io技术可以是操作系统级别在一个端口上能够同时接受多个客户端的io事件。同时具有之前我们讲到的阻塞式同步io和非阻塞式同步io的所有特点。selector的一部分作用更相当于“轮询代理器”。\n\n * 都是同步io: 目前我们介绍的 阻塞式io、非阻塞式io甚至包括多路复用io，这些都是基于操作系统级别对“同步io”的实现。我们一直在说“同步io”，一直都没有详细说，什么叫做“同步io”。实际上一句话就可以说清楚: 只有上层(包括上层的某种代理机制)系统询问我是否有某个事件发生了，否则我不会主动告诉上层系统事件发生了:\n\n\n# 参考文章\n\n * 文章主要来源于: 银文杰，笔名“说好不能打脸”，博客地址在新窗口打开。他的书《高性能服务系统构建与实战》。\n * https://blog.csdn.net/yinwenjie/article/details/48522403',charsets:{cjk:!0}},{title:"♥Java IO知识体系详解♥",frontmatter:{},regularPath:"/java/io/java-io-overview.html",relativePath:"java/io/java-io-overview.md",key:"v-2c08e938",path:"/java/io/java-io-overview.html",headers:[{level:2,title:"♥Java IO知识体系详解♥",slug:"♥java-io知识体系详解♥",normalizedTitle:"♥java io知识体系详解♥",charIndex:2},{level:2,title:"知识体系",slug:"知识体系",normalizedTitle:"知识体系",charIndex:10},{level:2,title:"相关文章",slug:"相关文章",normalizedTitle:"相关文章",charIndex:89},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:99}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"♥Java IO知识体系详解♥ 知识体系 相关文章 参考文章",content:"# ♥Java IO知识体系详解♥\n\n> 本文主要梳理Java IO/NIO/AIO的知识体系。@pdai\n\n * ♥Java IO知识体系详解♥\n   * 知识体系\n   * 相关文章\n   * 参考文章\n\n\n# 知识体系\n\n\n\n\n# 相关文章\n\n> A. Java进阶 - IO框架之知识体系：首先了解下Java IO框架包含什么，同时推荐下如何学习IO框架。@pdai\n\n * Java IO/NIO/AIO - Overview\n   * 本文主要梳理Java IO/NIO/AIO的知识体系\n\n> B. Java进阶 - IO框架之基础IO：其次对Java基础IO框架进行梳理，包括其分类，使用和源码详解。@pdai\n\n * Java IO - 分类(传输，操作)\n   * 本文主要从传输方式和数据操作两个方面分析Java IO的分类\n * Java IO - 设计模式(装饰者模式)\n   * Java I/O 使用了装饰者模式来实现\n * Java IO - 源码: InputStream\n   * 本文主要从JDK源码角度分析InputStream\n * Java IO - 源码: OutputStream\n   * 本文主要从JDK源码角度分析 OutputStream\n * Java IO - 常见类使用\n   * 本文主要介绍Java IO常见类的使用，包括：磁盘操作，字节操作，字符操作，对象操作和网络操作\n\n> C. Java进阶 - IO框架之NIO/AIO等：然后再对Unix IO模型学习，引入到Java BIO/NIO/AIO相关知识详解。@pdai\n\n * IO 模型 - Unix IO 模型\n   * 本文主要简要介绍 Unix I/O 5种模型，并对5大模型比较，并重点为后续章节解释IO多路复用做铺垫\n * Java IO - BIO 详解\n   * BIO就是: blocking IO。最容易理解、最容易实现的IO工作方式，应用程序向操作系统请求网络IO操作，这时应用程序会一直等待；另一方面，操作系统收到请求后，也会等待，直到网络上有数据传到监听端口；操作系统在收集数据后，会把数据发送给应用程序；最后应用程序受到数据，并解除等待状态\n * Java NIO - 基础详解\n   * 新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O\n * Java NIO - IO多路复用详解\n   * 本文主要对IO多路复用，Ractor模型以及Java NIO对其的支持\n * Java AIO - 异步IO详解\n   * 本文主要对异步IO和Java中对AIO的支持详解。@pdai\n\n> D. Java进阶 - IO框架之开源框架：最后再对常用的开源框架进行分析和详解。@pdai\n\n * Java NIO - 零拷贝实现这里转一篇Java NIO 零拷贝的实现文章，在此之前建议先理解什么是Linux中零拷贝，可以先看这篇文章。本文从源码着手分析了 Java NIO 对零拷贝的实现，主要包括基于内存映射（mmap）方式的 MappedByteBuffer 以及基于 sendfile 方式的 FileChannel。最后在篇末简单的阐述了一下 Netty 中的零拷贝机制，以及 RocketMQ 和 Kafka 两种消息队列在零拷贝实现方式上的区别。\n\n * Java N(A)IO - 框架: Netty\n   \n   * Netty是一个高性能、异步事件驱动的NIO框架，提供了对TCP、UDP和文件传输的支持。作为当前最流行的NIO框架，Netty在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，一些业界著名的开源组件也基于Netty构建，比如RPC框架、zookeeper等\n\n\n# 参考文章\n\n * Java 基础IO源码 https://blog.csdn.net/panweiwei1994/article/details/78046000\n * Linux 网络 I/O 模型简介(图文)https://blog.csdn.net/anxpp/article/details/51503329\n * Java 网络IO编程总结(BIO、NIO、AIO均含完整实例代码) https://blog.csdn.net/anxpp/article/details/51512200\n * Java 编程思想(八)BIO/NIO/AIO的具体实现 https://blog.csdn.net/KingCat666/article/details/77689627\n\nJava IO\n\n * 架构设计: 系统间通信(1)——概述从“聊天”开始上篇 https://blog.csdn.net/yinwenjie/article/list/6?\n * https://blog.csdn.net/yinwenjie/article/details/48274255\n * https://blog.csdn.net/yinwenjie/article/details/48344989\n * https://blog.csdn.net/yinwenjie/article/details/48472237\n * https://blog.csdn.net/yinwenjie/article/details/48522403\n * https://blog.csdn.net/yinwenjie/article/details/48784375\n\nNetty\n\n * https://blog.csdn.net/yinwenjie/article/details/48829419\n * https://blog.csdn.net/yinwenjie/article/details/48969853\n * https://blog.csdn.net/woaixiaopangniu521/article/details/70279143",normalizedContent:"# ♥java io知识体系详解♥\n\n> 本文主要梳理java io/nio/aio的知识体系。@pdai\n\n * ♥java io知识体系详解♥\n   * 知识体系\n   * 相关文章\n   * 参考文章\n\n\n# 知识体系\n\n\n\n\n# 相关文章\n\n> a. java进阶 - io框架之知识体系：首先了解下java io框架包含什么，同时推荐下如何学习io框架。@pdai\n\n * java io/nio/aio - overview\n   * 本文主要梳理java io/nio/aio的知识体系\n\n> b. java进阶 - io框架之基础io：其次对java基础io框架进行梳理，包括其分类，使用和源码详解。@pdai\n\n * java io - 分类(传输，操作)\n   * 本文主要从传输方式和数据操作两个方面分析java io的分类\n * java io - 设计模式(装饰者模式)\n   * java i/o 使用了装饰者模式来实现\n * java io - 源码: inputstream\n   * 本文主要从jdk源码角度分析inputstream\n * java io - 源码: outputstream\n   * 本文主要从jdk源码角度分析 outputstream\n * java io - 常见类使用\n   * 本文主要介绍java io常见类的使用，包括：磁盘操作，字节操作，字符操作，对象操作和网络操作\n\n> c. java进阶 - io框架之nio/aio等：然后再对unix io模型学习，引入到java bio/nio/aio相关知识详解。@pdai\n\n * io 模型 - unix io 模型\n   * 本文主要简要介绍 unix i/o 5种模型，并对5大模型比较，并重点为后续章节解释io多路复用做铺垫\n * java io - bio 详解\n   * bio就是: blocking io。最容易理解、最容易实现的io工作方式，应用程序向操作系统请求网络io操作，这时应用程序会一直等待；另一方面，操作系统收到请求后，也会等待，直到网络上有数据传到监听端口；操作系统在收集数据后，会把数据发送给应用程序；最后应用程序受到数据，并解除等待状态\n * java nio - 基础详解\n   * 新的输入/输出 (nio) 库是在 jdk 1.4 中引入的，弥补了原来的 i/o 的不足，提供了高速的、面向块的 i/o\n * java nio - io多路复用详解\n   * 本文主要对io多路复用，ractor模型以及java nio对其的支持\n * java aio - 异步io详解\n   * 本文主要对异步io和java中对aio的支持详解。@pdai\n\n> d. java进阶 - io框架之开源框架：最后再对常用的开源框架进行分析和详解。@pdai\n\n * java nio - 零拷贝实现这里转一篇java nio 零拷贝的实现文章，在此之前建议先理解什么是linux中零拷贝，可以先看这篇文章。本文从源码着手分析了 java nio 对零拷贝的实现，主要包括基于内存映射（mmap）方式的 mappedbytebuffer 以及基于 sendfile 方式的 filechannel。最后在篇末简单的阐述了一下 netty 中的零拷贝机制，以及 rocketmq 和 kafka 两种消息队列在零拷贝实现方式上的区别。\n\n * java n(a)io - 框架: netty\n   \n   * netty是一个高性能、异步事件驱动的nio框架，提供了对tcp、udp和文件传输的支持。作为当前最流行的nio框架，netty在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，一些业界著名的开源组件也基于netty构建，比如rpc框架、zookeeper等\n\n\n# 参考文章\n\n * java 基础io源码 https://blog.csdn.net/panweiwei1994/article/details/78046000\n * linux 网络 i/o 模型简介(图文)https://blog.csdn.net/anxpp/article/details/51503329\n * java 网络io编程总结(bio、nio、aio均含完整实例代码) https://blog.csdn.net/anxpp/article/details/51512200\n * java 编程思想(八)bio/nio/aio的具体实现 https://blog.csdn.net/kingcat666/article/details/77689627\n\njava io\n\n * 架构设计: 系统间通信(1)——概述从“聊天”开始上篇 https://blog.csdn.net/yinwenjie/article/list/6?\n * https://blog.csdn.net/yinwenjie/article/details/48274255\n * https://blog.csdn.net/yinwenjie/article/details/48344989\n * https://blog.csdn.net/yinwenjie/article/details/48472237\n * https://blog.csdn.net/yinwenjie/article/details/48522403\n * https://blog.csdn.net/yinwenjie/article/details/48784375\n\nnetty\n\n * https://blog.csdn.net/yinwenjie/article/details/48829419\n * https://blog.csdn.net/yinwenjie/article/details/48969853\n * https://blog.csdn.net/woaixiaopangniu521/article/details/70279143",charsets:{cjk:!0}},{title:"Java 8 - 重复注解",frontmatter:{},regularPath:"/java/java8/java8-anno-repeat.html",relativePath:"java/java8/java8-anno-repeat.md",key:"v-681ae11a",path:"/java/java8/java8-anno-repeat.html",headers:[{level:2,title:"Java 8 - 重复注解",slug:"java-8-重复注解",normalizedTitle:"java 8 - 重复注解",charIndex:2},{level:2,title:"什么是重复注解",slug:"什么是重复注解",normalizedTitle:"什么是重复注解",charIndex:119},{level:3,title:"JDK8之前",slug:"jdk8之前",normalizedTitle:"jdk8之前",charIndex:134},{level:3,title:"Jdk8重复注解",slug:"jdk8重复注解",normalizedTitle:"jdk8重复注解",charIndex:148},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:162}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java 8 - 重复注解 什么是重复注解 JDK8之前 Jdk8重复注解 总结",content:'# Java 8 - 重复注解\n\n> 理解Java 8 重复注解需理解几个问题: @pdai\n> \n>  * Jdk8之前对重复注解是怎么做的?\n>  * Jdk8对重复注解添加了什么支持?\n\n * Java 8 - 重复注解\n   * 什么是重复注解\n     * JDK8之前\n     * Jdk8重复注解\n   * 总结\n\n\n# 什么是重复注解\n\n允许在同一申明类型(类，属性，或方法)的多次使用同一个注解\n\n\n# JDK8之前\n\njava 8之前也有重复使用注解的解决方案，但可读性不是很好，比如下面的代码:\n\npublic @interface Authority {\n     String role();\n}\n\npublic @interface Authorities {\n    Authority[] value();\n}\n\npublic class RepeatAnnotationUseOldVersion {\n\n    @Authorities({@Authority(role="Admin"),@Authority(role="Manager")})\n    public void doSomeThing(){\n    }\n}\n\n\n由另一个注解来存储重复注解，在使用时候，用存储注解Authorities来扩展重复注解。\n\n\n# Jdk8重复注解\n\n我们再来看看java 8里面的做法:\n\n@Repeatable(Authorities.class)\npublic @interface Authority {\n     String role();\n}\n\npublic @interface Authorities {\n    Authority[] value();\n}\n\npublic class RepeatAnnotationUseNewVersion {\n    @Authority(role="Admin")\n    @Authority(role="Manager")\n    public void doSomeThing(){ }\n}\n\n\n不同的地方是，创建重复注解Authority时，加上@Repeatable,指向存储注解Authorities，在使用时候，直接可以重复使用Authority注解。从上面例子看出，java 8里面做法更适合常规的思维，可读性强一点\n\n\n# 总结\n\nJEP120没有太多内容，是一个小特性，仅仅是为了提高代码可读性。这次java 8对注解做了2个方面的改进(JEP 104,JEP120)，相信注解会比以前使用得更加频繁了。',normalizedContent:'# java 8 - 重复注解\n\n> 理解java 8 重复注解需理解几个问题: @pdai\n> \n>  * jdk8之前对重复注解是怎么做的?\n>  * jdk8对重复注解添加了什么支持?\n\n * java 8 - 重复注解\n   * 什么是重复注解\n     * jdk8之前\n     * jdk8重复注解\n   * 总结\n\n\n# 什么是重复注解\n\n允许在同一申明类型(类，属性，或方法)的多次使用同一个注解\n\n\n# jdk8之前\n\njava 8之前也有重复使用注解的解决方案，但可读性不是很好，比如下面的代码:\n\npublic @interface authority {\n     string role();\n}\n\npublic @interface authorities {\n    authority[] value();\n}\n\npublic class repeatannotationuseoldversion {\n\n    @authorities({@authority(role="admin"),@authority(role="manager")})\n    public void dosomething(){\n    }\n}\n\n\n由另一个注解来存储重复注解，在使用时候，用存储注解authorities来扩展重复注解。\n\n\n# jdk8重复注解\n\n我们再来看看java 8里面的做法:\n\n@repeatable(authorities.class)\npublic @interface authority {\n     string role();\n}\n\npublic @interface authorities {\n    authority[] value();\n}\n\npublic class repeatannotationusenewversion {\n    @authority(role="admin")\n    @authority(role="manager")\n    public void dosomething(){ }\n}\n\n\n不同的地方是，创建重复注解authority时，加上@repeatable,指向存储注解authorities，在使用时候，直接可以重复使用authority注解。从上面例子看出，java 8里面做法更适合常规的思维，可读性强一点\n\n\n# 总结\n\njep120没有太多内容，是一个小特性，仅仅是为了提高代码可读性。这次java 8对注解做了2个方面的改进(jep 104,jep120)，相信注解会比以前使用得更加频繁了。',charsets:{cjk:!0}},{title:"Java 8 - 默认方法",frontmatter:{},regularPath:"/java/java8/java8-default.html",relativePath:"java/java8/java8-default.md",key:"v-79b9f78c",path:"/java/java8/java8-default.html",headers:[{level:2,title:"Java 8 - 默认方法",slug:"java-8-默认方法",normalizedTitle:"java 8 - 默认方法",charIndex:2},{level:2,title:"什么是默认方法，为什么要有默认方法",slug:"什么是默认方法-为什么要有默认方法",normalizedTitle:"什么是默认方法，为什么要有默认方法",charIndex:148},{level:3,title:"先上例子",slug:"先上例子",normalizedTitle:"先上例子",charIndex:173},{level:3,title:"什么是默认方法",slug:"什么是默认方法",normalizedTitle:"什么是默认方法",charIndex:148},{level:3,title:"为什么出现默认方法",slug:"为什么出现默认方法",normalizedTitle:"为什么出现默认方法",charIndex:200},{level:2,title:"java 8抽象类与接口对比",slug:"java-8抽象类与接口对比",normalizedTitle:"java 8抽象类与接口对比",charIndex:215},{level:2,title:"多重继承的冲突",slug:"多重继承的冲突",normalizedTitle:"多重继承的冲突",charIndex:235},{level:3,title:"举例子",slug:"举例子",normalizedTitle:"举例子",charIndex:250},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:259}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java 8 - 默认方法 什么是默认方法，为什么要有默认方法 先上例子 什么是默认方法 为什么出现默认方法 java 8抽象类与接口对比 多重继承的冲突 举例子 总结",content:'# Java 8 - 默认方法\n\n> 理解Java 8 默认方法需理解几个问题: @pdai\n> \n>  * 为什么会出现默认方法?\n>  * 接口中出现默认方法，且类可以实现多接口的，那和抽象类有啥区别?\n>  * 多重实现的默认方法冲突怎么办?\n\n * Java 8 - 默认方法\n   * 什么是默认方法，为什么要有默认方法\n     * 先上例子\n     * 什么是默认方法\n     * 为什么出现默认方法\n   * java 8抽象类与接口对比\n   * 多重继承的冲突\n     * 举例子\n   * 总结\n\n\n# 什么是默认方法，为什么要有默认方法\n\n\n# 先上例子\n\n一个接口A，Clazz类实现了接口A。\n\npublic interface A {\n    default void foo(){\n       System.out.println("Calling A.foo()");\n    }\n}\n\npublic class Clazz implements A {\n    public static void main(String[] args){\n       Clazz clazz = new Clazz();\n       clazz.foo();//调用A.foo()\n    }\n}\n\n\n代码是可以编译的，即使Clazz类并没有实现foo()方法。在接口A中提供了foo()方法的默认实现。\n\n\n# 什么是默认方法\n\n简单说，就是接口可以有实现方法，而且不需要实现类去实现其方法。只需在方法名前面加个default关键字即可。\n\n\n# 为什么出现默认方法\n\n为什么要有这个特性? 首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的java 8之前的集合框架没有foreach方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了解决接口的修改与现有的实现不兼容的问题。\n\n\n# java 8抽象类与接口对比\n\n这一个功能特性出来后，很多同学都反应了，java 8的接口都有实现方法了，跟抽象类还有什么区别? 其实还是有的，请看下表对比。。\n\n相同点                                              不同点\n都是抽象类型                                           抽象类不可以多重继承，接口可以(无论是多重类型继承还是多重行为继承)\n都可以有实现方法(以前接口不行)                                 抽象类和接口所反映出的设计理念不同。其实抽象类表示的是”is-a”关系，接口表示的是”like-a”关系\n都可以不需要实现类或者继承者去实现所有方法，(以前不行，现在接口中默认方法不需要实现者实现)   接口中定义的变量默认是public static final\n                                                 型，且必须给其初值，所以实现类中不能改变其值；抽象类中的变量默认是 friendly\n                                                 型，其值可以在子类中重新定义，也可以重新赋值。\n\n\n# 多重继承的冲突\n\n由于同一个方法可以从不同接口引入，自然而然的会有冲突的现象，默认方法判断冲突的规则如下:\n\n1.一个声明在类里面的方法优先于任何默认方法(classes always win)\n\n2.否则，则会优先选取路径最短的。\n\n\n# 举例子\n\n * Case 1\n\npublic interface A{\n\tdefault void aa() {\n\t\tSystem.out.println("A\'s aa");\n\t}\n}\npublic interface B{\n\tdefault void aa() {\n\t\tSystem.out.println("B\'s aa");\n\t}\n}\npublic static class D implements A,B{\n\t\n}\n\n\n报错 Duplicate default methods named aa with the parameters () and () are inherited from the types DocApplication.B and DocApplication.A\n\n如果一定要这么写呢，同时实现A,B并且使用A中aa? 可以这么写:\n\npublic static class D implements A,B{\n    @Override\n    public void aa(){\n        A.super.aa();\n    }\n}\n\n\n * Case 2\n\npublic interface A{\n\tdefault void aa() {\n\t\tSystem.out.println("A\'s aa");\n\t}\n}\npublic interface B{\n\tdefault void aa() {\n\t\tSystem.out.println("B\'s aa");\n\t}\n}\npublic interface C extends A, B{\n\tdefault void aa() {\n\t\tSystem.out.println("C\'s aa");\n\t}\n}\npublic static class D implements A,B,C{\n\t\n}\n\n\n输出 C\'s aa\n\n * Case 3\n\npublic interface A{\n\tdefault void aa() {\n\t\tSystem.out.println("A\'s aa");\n\t}\n}\npublic interface C extends A{\n\tdefault void aa() {\n\t\tSystem.out.println("C\'s aa");\n\t}\n}\npublic static class D implements C{\n\t\n}\n\n\n输出 C\'s aa\n\n> 通过Case1-3可以知道它是找唯一的最短路径的default，如果是多个那么报错。\n\n * Case 4 如果想调用A的默认函数，则用到新语法X.super.m(…),下面修改C类，实现A接口，重写一个hello方法，如下所示:\n\npublic interface A{\n\tdefault void aa() {\n\t\tSystem.out.println("A\'s aa");\n\t}\n}\npublic class X implements A{\n    @Override\n    public void aa(){\n        A.super.aa();\n    }\n}\n\n\n输出: A\'s aa\n\n * Case 5\n\npublic interface A{\n\tdefault void aa() {\n\t\tSystem.out.println("A\'s aa");\n\t}\n}\npublic interface B{\n\tdefault void aa() {\n\t\tSystem.out.println("B\'s aa");\n\t}\n}\npublic interface C extends A,B{\n\tdefault void aa() {\n\t\tSystem.out.println("C\'s aa");\n\t}\n}\npublic static class D implements C{\n\t@Override\n    public void aa(){\n        C.super.aa();\n    }\n}\n\n\n输出 C\'s aa 可见C.super表示的是C接口，同时D无法访问A,B的aa\n\n> 通过Case 5也可以看出，C虽然有同一个两个最短路径的aa, 但是它自己有一个更高优先级的aa，所以不会报错; case 6 会报错\n\n * Case 6\n\npublic interface A{\n\tdefault void aa() {\n\t\tSystem.out.println("A\'s aa");\n\t}\n}\npublic interface B{\n\tdefault void aa() {\n\t\tSystem.out.println("B\'s aa");\n\t}\n}\npublic interface C extends A,B{\n}\n\n\n报错\n\n\n# 总结\n\n默认方法给予我们修改接口而不破坏原来的实现类的结构提供了便利，目前java 8的集合框架已经大量使用了默认方法来改进了，当我们最终开始使用Java 8的lambdas表达式时，提供给我们一个平滑的过渡体验。也许将来我们会在API设计中看到更多的默认方法的应用。',normalizedContent:'# java 8 - 默认方法\n\n> 理解java 8 默认方法需理解几个问题: @pdai\n> \n>  * 为什么会出现默认方法?\n>  * 接口中出现默认方法，且类可以实现多接口的，那和抽象类有啥区别?\n>  * 多重实现的默认方法冲突怎么办?\n\n * java 8 - 默认方法\n   * 什么是默认方法，为什么要有默认方法\n     * 先上例子\n     * 什么是默认方法\n     * 为什么出现默认方法\n   * java 8抽象类与接口对比\n   * 多重继承的冲突\n     * 举例子\n   * 总结\n\n\n# 什么是默认方法，为什么要有默认方法\n\n\n# 先上例子\n\n一个接口a，clazz类实现了接口a。\n\npublic interface a {\n    default void foo(){\n       system.out.println("calling a.foo()");\n    }\n}\n\npublic class clazz implements a {\n    public static void main(string[] args){\n       clazz clazz = new clazz();\n       clazz.foo();//调用a.foo()\n    }\n}\n\n\n代码是可以编译的，即使clazz类并没有实现foo()方法。在接口a中提供了foo()方法的默认实现。\n\n\n# 什么是默认方法\n\n简单说，就是接口可以有实现方法，而且不需要实现类去实现其方法。只需在方法名前面加个default关键字即可。\n\n\n# 为什么出现默认方法\n\n为什么要有这个特性? 首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的java 8之前的集合框架没有foreach方法，通常能想到的解决办法是在jdk里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了解决接口的修改与现有的实现不兼容的问题。\n\n\n# java 8抽象类与接口对比\n\n这一个功能特性出来后，很多同学都反应了，java 8的接口都有实现方法了，跟抽象类还有什么区别? 其实还是有的，请看下表对比。。\n\n相同点                                              不同点\n都是抽象类型                                           抽象类不可以多重继承，接口可以(无论是多重类型继承还是多重行为继承)\n都可以有实现方法(以前接口不行)                                 抽象类和接口所反映出的设计理念不同。其实抽象类表示的是”is-a”关系，接口表示的是”like-a”关系\n都可以不需要实现类或者继承者去实现所有方法，(以前不行，现在接口中默认方法不需要实现者实现)   接口中定义的变量默认是public static final\n                                                 型，且必须给其初值，所以实现类中不能改变其值；抽象类中的变量默认是 friendly\n                                                 型，其值可以在子类中重新定义，也可以重新赋值。\n\n\n# 多重继承的冲突\n\n由于同一个方法可以从不同接口引入，自然而然的会有冲突的现象，默认方法判断冲突的规则如下:\n\n1.一个声明在类里面的方法优先于任何默认方法(classes always win)\n\n2.否则，则会优先选取路径最短的。\n\n\n# 举例子\n\n * case 1\n\npublic interface a{\n\tdefault void aa() {\n\t\tsystem.out.println("a\'s aa");\n\t}\n}\npublic interface b{\n\tdefault void aa() {\n\t\tsystem.out.println("b\'s aa");\n\t}\n}\npublic static class d implements a,b{\n\t\n}\n\n\n报错 duplicate default methods named aa with the parameters () and () are inherited from the types docapplication.b and docapplication.a\n\n如果一定要这么写呢，同时实现a,b并且使用a中aa? 可以这么写:\n\npublic static class d implements a,b{\n    @override\n    public void aa(){\n        a.super.aa();\n    }\n}\n\n\n * case 2\n\npublic interface a{\n\tdefault void aa() {\n\t\tsystem.out.println("a\'s aa");\n\t}\n}\npublic interface b{\n\tdefault void aa() {\n\t\tsystem.out.println("b\'s aa");\n\t}\n}\npublic interface c extends a, b{\n\tdefault void aa() {\n\t\tsystem.out.println("c\'s aa");\n\t}\n}\npublic static class d implements a,b,c{\n\t\n}\n\n\n输出 c\'s aa\n\n * case 3\n\npublic interface a{\n\tdefault void aa() {\n\t\tsystem.out.println("a\'s aa");\n\t}\n}\npublic interface c extends a{\n\tdefault void aa() {\n\t\tsystem.out.println("c\'s aa");\n\t}\n}\npublic static class d implements c{\n\t\n}\n\n\n输出 c\'s aa\n\n> 通过case1-3可以知道它是找唯一的最短路径的default，如果是多个那么报错。\n\n * case 4 如果想调用a的默认函数，则用到新语法x.super.m(…),下面修改c类，实现a接口，重写一个hello方法，如下所示:\n\npublic interface a{\n\tdefault void aa() {\n\t\tsystem.out.println("a\'s aa");\n\t}\n}\npublic class x implements a{\n    @override\n    public void aa(){\n        a.super.aa();\n    }\n}\n\n\n输出: a\'s aa\n\n * case 5\n\npublic interface a{\n\tdefault void aa() {\n\t\tsystem.out.println("a\'s aa");\n\t}\n}\npublic interface b{\n\tdefault void aa() {\n\t\tsystem.out.println("b\'s aa");\n\t}\n}\npublic interface c extends a,b{\n\tdefault void aa() {\n\t\tsystem.out.println("c\'s aa");\n\t}\n}\npublic static class d implements c{\n\t@override\n    public void aa(){\n        c.super.aa();\n    }\n}\n\n\n输出 c\'s aa 可见c.super表示的是c接口，同时d无法访问a,b的aa\n\n> 通过case 5也可以看出，c虽然有同一个两个最短路径的aa, 但是它自己有一个更高优先级的aa，所以不会报错; case 6 会报错\n\n * case 6\n\npublic interface a{\n\tdefault void aa() {\n\t\tsystem.out.println("a\'s aa");\n\t}\n}\npublic interface b{\n\tdefault void aa() {\n\t\tsystem.out.println("b\'s aa");\n\t}\n}\npublic interface c extends a,b{\n}\n\n\n报错\n\n\n# 总结\n\n默认方法给予我们修改接口而不破坏原来的实现类的结构提供了便利，目前java 8的集合框架已经大量使用了默认方法来改进了，当我们最终开始使用java 8的lambdas表达式时，提供给我们一个平滑的过渡体验。也许将来我们会在api设计中看到更多的默认方法的应用。',charsets:{cjk:!0}},{title:"Java 8 - JavaFx 2.0",frontmatter:{},regularPath:"/java/java8/java8-javafx.html",relativePath:"java/java8/java8-javafx.md",key:"v-428b51f0",path:"/java/java8/java8-javafx.html",headers:[{level:2,title:"Java 8 - JavaFx 2.0",slug:"java-8-javafx-2-0",normalizedTitle:"java 8 - javafx 2.0",charIndex:2},{level:2,title:"JavaFX历史",slug:"javafx历史",normalizedTitle:"javafx历史",charIndex:215},{level:2,title:"JavaFx8的新特性",slug:"javafx8的新特性",normalizedTitle:"javafx8的新特性",charIndex:229},{level:2,title:"JavaFX 8开发2048游戏",slug:"javafx-8开发2048游戏",normalizedTitle:"javafx 8开发2048游戏",charIndex:415},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:437},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:445}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java 8 - JavaFx 2.0 JavaFX历史 JavaFx8的新特性 JavaFX 8开发2048游戏 总结 参考",content:"# Java 8 - JavaFx 2.0\n\n> JavaFX主要致力于富客户端开发，以弥补swing的缺陷，主要提供图形库与media库，支持audio,video,graphics,animation,3D等，同时采用现代化的css方式支持界面设计。同时又采用XUI方式以XML方式设计UI界面，达到显示与逻辑的分离。与android这方面确实有点相似性。@pdai\n\n * Java 8 - JavaFx 2.0\n   * JavaFX历史\n   * JavaFx8的新特性\n     * 全新现代主题: Modena\n     * JavaFX 3D\n     * 富文本\n     * TreeTableView\n     * 日期控件DatePicker\n     * 用于 CSS 结构的公共 API\n     * WebView 增强功能\n     * JavaFX Scene Builder 2.0\n   * JavaFX 8开发2048游戏\n   * 总结\n   * 参考\n\n\n# JavaFX历史\n\n跟java在服务器端和web端成绩相比，桌面一直是java的软肋，于是Sun公司在2008年推出JavaFX，弥补桌面软件的缺陷，请看下图JavaFX一路走过来的改进\n\n\n\n从上图看出，一开始推出时候，开发者需使用一种名为JavaFX Script的静态的、声明式的编程语言来开发JavaFX应用程序。因为JavaFX Script将会被编译为Java bytecode，程序员可以使用Java代码代替。\n\nJavaFX 2.0之后的版本摒弃了JavaFX Script语言，而作为一个Java API来使用。因此使用JavaFX平台实现的应用程序将直接通过标准Java代码来实现。\n\nJavaFX 2.0 包含非常丰富的 UI 控件、图形和多媒体特性用于简化可视化应用的开发，WebView可直接在应用中嵌入网页；另外 2.0 版本允许使用 FXML 进行 UI 定义，这是一个脚本化基于 XML 的标识语言。\n\n从JDK 7u6开始，JavaFx就与JDK捆绑在一起了，JavaFX团队称，下一个版本将是8.0，目前所有的工作都已经围绕8.0库进行。这是因为JavaFX将捆绑在Java 8中，因此该团队决定跳过几个版本号，迎头赶上Java 8。\n\n\n# JavaFx8的新特性\n\n# 全新现代主题: Modena\n\n新的Modena主题来替换原来的Caspian主题。不过在Application的start()方法中，可以通过setUserAgentStylesheet(STYLESHEET_CASPIAN)来继续使用Caspian主题。\n\n参考http://fxexperience.com/2013/03/modena-theme-update/\n\n# JavaFX 3D\n\n在JavaFX8中提供了3D图像处理API，包括Shape3D (Box, Cylinder, MeshView, Sphere子类),SubScene, Material, PickResult, LightBase (AmbientLight 和PointLight子类),SceneAntialiasing等。Camera类也得到了更新。从JavaDoc中可以找到更多信息。\n\n# 富文本\n\n强化了富文本的支持\n\n# TreeTableView\n\n# 日期控件DatePicker\n\n增加日期控件\n\n# 用于 CSS 结构的公共 API\n\nCSS 样式设置是 JavaFX 的一项主要特性\nCSS 已专门在私有 API 中实现(com.sun.javafx.css 软件包)\n多种工具(例如 Scene Builder)需要 CSS 公共 API\n开发人员将能够定义自定义 CSS 样式\n\n\n# WebView 增强功能\n\n * Nashorn JavaScript 引擎 https://blogs.oracle.com/nashorn/entry/open_for_business\n * WebSocket http://javafx-jira.kenai.com/browse/RT-14947\n * Web Workers http://javafx-jira.kenai.com/browse/RT-9782\n\n# JavaFX Scene Builder 2.0\n\n可视化工具，加速JavaFX图形界面的开发，下载地址\n\nJavaFX Scene Builder如同NetBeans一般，通过拖拽的方式配置界面，待完成界面之後，保存为FXML格式文件，此文件以XML描述物件配置，再交由JavaFX程式处理，因此可減少直接以JavaFX编写界面的困難度。\n\nJavaFX Scene Builder 2.0新增JavaFX Theme预览功能，菜单「Preview」→「JavaFX Theme」选择不同的主題，包括:\n\nModena (FX8).\nModena Touch (FX8).\nModena High Contrast – Black on White (FX8).\nModena High Contrast – White on Black (FX8).\nModena High Contrast – Yellow on Black (FX8).\nCaspian (FX2).\nCaspian Embedded (FX2).\nCaspian Embedded QVGA (FX2).\n\n\n\n# JavaFX 8开发2048游戏\n\n2048虽然不像前段时间那么火了，但个人还是非常喜欢玩2048，空闲时间都忍不住来一发，感谢 Gabriele Cirulli 发明了这了不起 (并且会上瘾)的2048游戏，因为是用MIT协议开源出来，各种语言版本的2048游戏横空出世，下图是用JavaFX 8来开发的一款2048。\n\n所用到的技术\n\nLambda expressions\nStream API\nJavaFX 8\nJavaFX CSS basics\nJavaFX animationsfx2048相关类的说明\nGame2048,游戏主类\nGameManager,包含游戏界面布局(Board)以及Grid的操作(GridOperator)\nBoard,包含labels ，分数，grid ，Tile\nTile,游戏中的数字块\nGridOperator,Grid操作类\nLocation,Direction 位置帮助类\nRecordManager，SessionManager，纪录游戏分数，会话类\n\n\n这里是源码地址，大家感兴趣的可以去学习下git.oschina.net/benhail/javase8-sample/tree/master/src/main/java/javase8sample/chapter13/javafx8/fx2048\n\n\n# 总结\n\n比起AWT和SWING，JavaFX的优势很明显，各大主流IDE已经支持JavaFX的开发了，最佳的工具莫过于NetBeans，且随着lambda带来的好处，JavaFX的事件处理简洁了不少，以前需要写匿名函数类。另外JavaFX开源以来，JavaFX的生态环境也越来越活跃了，包括各种教程，嵌入式尝试，还有一些开源项目，比如: ControlsFX，JRebirth，DataFX Flow，mvvmFX，TestFX 等等。还有JavaFX是可以运行在Android和ios上面，这个很赞！\n\n好了，总结到这里也差不多了，在RIA平台上面，有HTML5、Flex和微软的Sliverlight，JavaFX能否表现优秀，在于大家的各位，只要我们多用JavaFX，那么JavaFX也会越来越优秀，任何语言都是这样, THE END .\n\n\n# 参考\n\n * https://github.com/oimchat/oim-fx\n\n * https://github.com/goxr3plus/FX-BorderlessScene\n\n * https://github.com/topics/material-ui\n\n * https://github.com/in-sideFX/Undecorator\n\n * https://github.com/brunoborges/webfx\n\n * https://blog.csdn.net/loongshawn/article/details/52805751\n\n * https://docs.oracle.com/javafx/2/ui_controls/overview.htm#BABJACHC\n\n * https://www.oracle.com/technetwork/cn/articles/java/layoutfx-1536156-zhs.html",normalizedContent:"# java 8 - javafx 2.0\n\n> javafx主要致力于富客户端开发，以弥补swing的缺陷，主要提供图形库与media库，支持audio,video,graphics,animation,3d等，同时采用现代化的css方式支持界面设计。同时又采用xui方式以xml方式设计ui界面，达到显示与逻辑的分离。与android这方面确实有点相似性。@pdai\n\n * java 8 - javafx 2.0\n   * javafx历史\n   * javafx8的新特性\n     * 全新现代主题: modena\n     * javafx 3d\n     * 富文本\n     * treetableview\n     * 日期控件datepicker\n     * 用于 css 结构的公共 api\n     * webview 增强功能\n     * javafx scene builder 2.0\n   * javafx 8开发2048游戏\n   * 总结\n   * 参考\n\n\n# javafx历史\n\n跟java在服务器端和web端成绩相比，桌面一直是java的软肋，于是sun公司在2008年推出javafx，弥补桌面软件的缺陷，请看下图javafx一路走过来的改进\n\n\n\n从上图看出，一开始推出时候，开发者需使用一种名为javafx script的静态的、声明式的编程语言来开发javafx应用程序。因为javafx script将会被编译为java bytecode，程序员可以使用java代码代替。\n\njavafx 2.0之后的版本摒弃了javafx script语言，而作为一个java api来使用。因此使用javafx平台实现的应用程序将直接通过标准java代码来实现。\n\njavafx 2.0 包含非常丰富的 ui 控件、图形和多媒体特性用于简化可视化应用的开发，webview可直接在应用中嵌入网页；另外 2.0 版本允许使用 fxml 进行 ui 定义，这是一个脚本化基于 xml 的标识语言。\n\n从jdk 7u6开始，javafx就与jdk捆绑在一起了，javafx团队称，下一个版本将是8.0，目前所有的工作都已经围绕8.0库进行。这是因为javafx将捆绑在java 8中，因此该团队决定跳过几个版本号，迎头赶上java 8。\n\n\n# javafx8的新特性\n\n# 全新现代主题: modena\n\n新的modena主题来替换原来的caspian主题。不过在application的start()方法中，可以通过setuseragentstylesheet(stylesheet_caspian)来继续使用caspian主题。\n\n参考http://fxexperience.com/2013/03/modena-theme-update/\n\n# javafx 3d\n\n在javafx8中提供了3d图像处理api，包括shape3d (box, cylinder, meshview, sphere子类),subscene, material, pickresult, lightbase (ambientlight 和pointlight子类),sceneantialiasing等。camera类也得到了更新。从javadoc中可以找到更多信息。\n\n# 富文本\n\n强化了富文本的支持\n\n# treetableview\n\n# 日期控件datepicker\n\n增加日期控件\n\n# 用于 css 结构的公共 api\n\ncss 样式设置是 javafx 的一项主要特性\ncss 已专门在私有 api 中实现(com.sun.javafx.css 软件包)\n多种工具(例如 scene builder)需要 css 公共 api\n开发人员将能够定义自定义 css 样式\n\n\n# webview 增强功能\n\n * nashorn javascript 引擎 https://blogs.oracle.com/nashorn/entry/open_for_business\n * websocket http://javafx-jira.kenai.com/browse/rt-14947\n * web workers http://javafx-jira.kenai.com/browse/rt-9782\n\n# javafx scene builder 2.0\n\n可视化工具，加速javafx图形界面的开发，下载地址\n\njavafx scene builder如同netbeans一般，通过拖拽的方式配置界面，待完成界面之後，保存为fxml格式文件，此文件以xml描述物件配置，再交由javafx程式处理，因此可減少直接以javafx编写界面的困難度。\n\njavafx scene builder 2.0新增javafx theme预览功能，菜单「preview」→「javafx theme」选择不同的主題，包括:\n\nmodena (fx8).\nmodena touch (fx8).\nmodena high contrast – black on white (fx8).\nmodena high contrast – white on black (fx8).\nmodena high contrast – yellow on black (fx8).\ncaspian (fx2).\ncaspian embedded (fx2).\ncaspian embedded qvga (fx2).\n\n\n\n# javafx 8开发2048游戏\n\n2048虽然不像前段时间那么火了，但个人还是非常喜欢玩2048，空闲时间都忍不住来一发，感谢 gabriele cirulli 发明了这了不起 (并且会上瘾)的2048游戏，因为是用mit协议开源出来，各种语言版本的2048游戏横空出世，下图是用javafx 8来开发的一款2048。\n\n所用到的技术\n\nlambda expressions\nstream api\njavafx 8\njavafx css basics\njavafx animationsfx2048相关类的说明\ngame2048,游戏主类\ngamemanager,包含游戏界面布局(board)以及grid的操作(gridoperator)\nboard,包含labels ，分数，grid ，tile\ntile,游戏中的数字块\ngridoperator,grid操作类\nlocation,direction 位置帮助类\nrecordmanager，sessionmanager，纪录游戏分数，会话类\n\n\n这里是源码地址，大家感兴趣的可以去学习下git.oschina.net/benhail/javase8-sample/tree/master/src/main/java/javase8sample/chapter13/javafx8/fx2048\n\n\n# 总结\n\n比起awt和swing，javafx的优势很明显，各大主流ide已经支持javafx的开发了，最佳的工具莫过于netbeans，且随着lambda带来的好处，javafx的事件处理简洁了不少，以前需要写匿名函数类。另外javafx开源以来，javafx的生态环境也越来越活跃了，包括各种教程，嵌入式尝试，还有一些开源项目，比如: controlsfx，jrebirth，datafx flow，mvvmfx，testfx 等等。还有javafx是可以运行在android和ios上面，这个很赞！\n\n好了，总结到这里也差不多了，在ria平台上面，有html5、flex和微软的sliverlight，javafx能否表现优秀，在于大家的各位，只要我们多用javafx，那么javafx也会越来越优秀，任何语言都是这样, the end .\n\n\n# 参考\n\n * https://github.com/oimchat/oim-fx\n\n * https://github.com/goxr3plus/fx-borderlessscene\n\n * https://github.com/topics/material-ui\n\n * https://github.com/in-sidefx/undecorator\n\n * https://github.com/brunoborges/webfx\n\n * https://blog.csdn.net/loongshawn/article/details/52805751\n\n * https://docs.oracle.com/javafx/2/ui_controls/overview.htm#babjachc\n\n * https://www.oracle.com/technetwork/cn/articles/java/layoutfx-1536156-zhs.html",charsets:{cjk:!0}},{title:"Java 8 - JRE精简",frontmatter:{},regularPath:"/java/java8/java8-jre.html",relativePath:"java/java8/java8-jre.md",key:"v-46722458",path:"/java/java8/java8-jre.html",headers:[{level:2,title:"Java 8 - JRE精简",slug:"java-8-jre精简",normalizedTitle:"java 8 - jre精简",charIndex:2},{level:2,title:"JRE精简好处",slug:"jre精简好处",normalizedTitle:"jre精简好处",charIndex:120},{level:2,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:133},{level:2,title:"使用工具开发的效果",slug:"使用工具开发的效果",normalizedTitle:"使用工具开发的效果",charIndex:141},{level:3,title:"JDEPS工具使用",slug:"jdeps工具使用",normalizedTitle:"jdeps工具使用",charIndex:158},{level:3,title:"在linux上构建profile",slug:"在linux上构建profile",normalizedTitle:"在linux上构建profile",charIndex:175},{level:3,title:"编译后compact大致的占用空间",slug:"编译后compact大致的占用空间",normalizedTitle:"编译后compact大致的占用空间",charIndex:199},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:222}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java 8 - JRE精简 JRE精简好处 概念 使用工具开发的效果 JDEPS工具使用 在linux上构建profile 编译后compact大致的占用空间 总结",content:"# Java 8 - JRE精简\n\n> 理解Java8 JRE精简需理解几个问题: @pdai\n> \n>  * 为什么精简Java8 JRE，及好处是啥?\n>  * 在不同平台上如何编译等?\n\n * Java 8 - JRE精简\n   * JRE精简好处\n   * 概念\n   * 使用工具开发的效果\n     * JDEPS工具使用\n     * 在linux上构建profile\n     * 编译后compact大致的占用空间\n   * 总结\n\nOracle公司如期发布了Java 8正式版！没有让广大javaer失望。对于一个人来说，18岁是人生的转折点，从稚嫩走向成熟，法律意味着你是完全民事行为能力人，不再收益于未成年人保护法，到今年为止，java也走过了18年，java8是一个新的里程碑，带来了前所未有的诸多特性，lambda表达式，Stream API，新的Date time api，多核并发支持，重大安全问题改进等，相信java会越来越好，丰富的类库以及庞大的开源生态环境是其他语言所不具备的，说起丰富的类库，很多同学就吐槽了，java该减肥了，确实是该减肥，java8有个很好的特性，即JEP161(http://openjdk.java.net/jeps/161 ),该特性定义了Java SE平台规范的一些子集，使java应用程序不需要整个JRE平台即可部署和运行在小型设备上。开发人员可以基于目标硬件的可用资源选择一个合适的JRE运行环境。\n\n\n# JRE精简好处\n\n * 更小的Java环境需要更少的计算资源。\n * 一个较小的运行时环境可以更好的优化性能和启动时间。\n * 消除未使用的代码从安全的角度总是好的。\n * 这些打包的应用程序可以下载速度更快。\n\n\n# 概念\n\n紧凑的JRE分3种，分别是compact1、compact2、compact3，他们的关系是compact1<compact2<compact3,他们包含的API如下图所示\n\n使用javac根据profile编译应用程序\n\njavac –bootclasspath, or javac –profile\n\n\n如果不符合compact的api，则报错。\n\n$ javac -profile compact2 Test.java\nTest.java:7: error: ThreadMXBean is not available in profile 'compact2'\n ThreadMXBean bean = ManagementFactory.getThreadMXBean();\n ^\nTest.java:7: error: ManagementFactory is not available in profile 'compact2'\n ThreadMXBean bean = ManagementFactory.getThreadMXBean();\n                     ^\n2 errors\n\n\n\n\n\n# 使用工具开发的效果\n\n\n\n\n# JDEPS工具使用\n\njava8新增一个工具，用来分析应用程序所依赖的profile，有三个参数比较常用 -p，-v，-r\n\nimport java.util.Set;\nimport java.util.HashSet;\n\npublic class Deps {\n  public static void main(String[] args) {\n    System.out.println(Math.random());\n    Set<String> set = new HashSet<>();\n  }\n}\n\n\n************** PROFILE ********************\njdeps -P Deps.class \nDeps.class -> /Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home/jre/lib/rt.jar\n   <unnamed> (Deps.class)\n      -> java.io                                            compact1\n      -> java.lang                                          compact1\n      -> java.util                                          compact1\n\n************** VERBOSE ********************\njdeps -v Deps.class \nDeps.class -> /Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home/jre/lib/rt.jar\n   Deps (Deps.class)\n      -> java.io.PrintStream                                \n      -> java.lang.Math                                     \n      -> java.lang.Object                                   \n      -> java.lang.String                                   \n      -> java.lang.System                                   \n      -> java.util.HashSet  \n\n************** RECURSIVE ********************\njdeps -R Deps.class \nDeps.class -> /Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home/jre/lib/rt.jar\n   <unnamed> (Deps.class)\n      -> java.io                                            \n      -> java.lang                                          \n      -> java.util                                          \n/Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home/jre/lib/jce.jar -> /Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home/jre/lib/rt.jar\n   javax.crypto (jce.jar)\n      -> java.io                                            \n      -> java.lang                                          \n      -> java.lang.reflect                                  \n      -> java.net                                           \n      -> java.nio                                           \n      -> java.security                                      \n      -> java.security.cert                                 \n      -> java.security.spec                                 \n      -> java.util                                          \n      -> java.util.concurrent                               \n      -> java.util.jar                                      \n      -> java.util.regex                                    \n      -> java.util.zip                                      \n      -> javax.security.auth                                \n      -> sun.security.jca                                   JDK internal API (rt.jar)\n      -> sun.security.util                                  JDK internal API (rt.jar)\n      -> sun.security.validator                             JDK internal API (rt.jar)\n   javax.crypto.interfaces (jce.jar)\n      -> java.lang                                          \n      -> java.math                                          \n      -> java.security                                      \n   javax.crypto.spec (jce.jar)\n      -> java.lang                                          \n      -> java.math                                          \n      -> java.security.spec                                 \n      -> java.util                                          \n/Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home/jre/lib/rt.jar -> /Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home/jre/lib/jce.jar\n   java.security (rt.jar)\n      -> javax.crypto                                       JDK internal API (jce.jar)\n   sun.security.util (rt.jar)\n      -> javax.crypto                                       JDK internal API (jce.jar)\n      -> javax.crypto.interfaces                            JDK internal API (jce.jar)\n      -> javax.crypto.spec                                  JDK internal API (jce.jar)\n\n\n\n# 在linux上构建profile\n\n$ hg clone http://hg.openjdk.java.net/jdk8/jdk8/\n$ cd jdk8\n$ make images profiles : \n# Finished profiles (build time 00:00:27)\n----- Build times -------\nStart 2013-03-17 14:47:35\nEnd 2013-03-17 14:58:26\n00:00:25 corba\n00:00:15 demos\n00:01:50 hotspot\n00:00:24 images\n00:00:21 jaxp\n00:00:31 jaxws\n00:05:37 jdk\n00:00:43 langtools\n00:00:18 nashorn\n00:00:27 profiles\n00:10:51 TOTAL\n-------------------------\nFinished building Java(TM) for target 'images profiles'\n$ cd images\n$ ls -d *image\nj2re-compact1-image j2re-compact2-image j2re-compact3-image j2re-image j2sdk-image\n\n\n\n# 编译后compact大致的占用空间\n\n\n\n\n# 总结\n\n如今，物联网正风行一时。我们看到大量不同的设备在市场上出现，每一种的更新速度都越来越快。java需要一个占用资源少的JRE运行环境，紧凑的JRE特性的出现，希望能带来以后的物联网的发展，甚至还是会有大量的java应用程序出现在物联网上面。目前oracle也发布了针对raspberry pi的JRE了。\n\n另外该特性也是为java9的模块化项目做准备，模块化特性是javaer所期待的特性。他是解决业务系统复杂度的一个利器，当然OSGI也是相当的出色。但osgi对于新学者来说未免太复杂了。",normalizedContent:"# java 8 - jre精简\n\n> 理解java8 jre精简需理解几个问题: @pdai\n> \n>  * 为什么精简java8 jre，及好处是啥?\n>  * 在不同平台上如何编译等?\n\n * java 8 - jre精简\n   * jre精简好处\n   * 概念\n   * 使用工具开发的效果\n     * jdeps工具使用\n     * 在linux上构建profile\n     * 编译后compact大致的占用空间\n   * 总结\n\noracle公司如期发布了java 8正式版！没有让广大javaer失望。对于一个人来说，18岁是人生的转折点，从稚嫩走向成熟，法律意味着你是完全民事行为能力人，不再收益于未成年人保护法，到今年为止，java也走过了18年，java8是一个新的里程碑，带来了前所未有的诸多特性，lambda表达式，stream api，新的date time api，多核并发支持，重大安全问题改进等，相信java会越来越好，丰富的类库以及庞大的开源生态环境是其他语言所不具备的，说起丰富的类库，很多同学就吐槽了，java该减肥了，确实是该减肥，java8有个很好的特性，即jep161(http://openjdk.java.net/jeps/161 ),该特性定义了java se平台规范的一些子集，使java应用程序不需要整个jre平台即可部署和运行在小型设备上。开发人员可以基于目标硬件的可用资源选择一个合适的jre运行环境。\n\n\n# jre精简好处\n\n * 更小的java环境需要更少的计算资源。\n * 一个较小的运行时环境可以更好的优化性能和启动时间。\n * 消除未使用的代码从安全的角度总是好的。\n * 这些打包的应用程序可以下载速度更快。\n\n\n# 概念\n\n紧凑的jre分3种，分别是compact1、compact2、compact3，他们的关系是compact1<compact2<compact3,他们包含的api如下图所示\n\n使用javac根据profile编译应用程序\n\njavac –bootclasspath, or javac –profile\n\n\n如果不符合compact的api，则报错。\n\n$ javac -profile compact2 test.java\ntest.java:7: error: threadmxbean is not available in profile 'compact2'\n threadmxbean bean = managementfactory.getthreadmxbean();\n ^\ntest.java:7: error: managementfactory is not available in profile 'compact2'\n threadmxbean bean = managementfactory.getthreadmxbean();\n                     ^\n2 errors\n\n\n\n\n\n# 使用工具开发的效果\n\n\n\n\n# jdeps工具使用\n\njava8新增一个工具，用来分析应用程序所依赖的profile，有三个参数比较常用 -p，-v，-r\n\nimport java.util.set;\nimport java.util.hashset;\n\npublic class deps {\n  public static void main(string[] args) {\n    system.out.println(math.random());\n    set<string> set = new hashset<>();\n  }\n}\n\n\n************** profile ********************\njdeps -p deps.class \ndeps.class -> /library/java/javavirtualmachines/jdk1.8.0.jdk/contents/home/jre/lib/rt.jar\n   <unnamed> (deps.class)\n      -> java.io                                            compact1\n      -> java.lang                                          compact1\n      -> java.util                                          compact1\n\n************** verbose ********************\njdeps -v deps.class \ndeps.class -> /library/java/javavirtualmachines/jdk1.8.0.jdk/contents/home/jre/lib/rt.jar\n   deps (deps.class)\n      -> java.io.printstream                                \n      -> java.lang.math                                     \n      -> java.lang.object                                   \n      -> java.lang.string                                   \n      -> java.lang.system                                   \n      -> java.util.hashset  \n\n************** recursive ********************\njdeps -r deps.class \ndeps.class -> /library/java/javavirtualmachines/jdk1.8.0.jdk/contents/home/jre/lib/rt.jar\n   <unnamed> (deps.class)\n      -> java.io                                            \n      -> java.lang                                          \n      -> java.util                                          \n/library/java/javavirtualmachines/jdk1.8.0.jdk/contents/home/jre/lib/jce.jar -> /library/java/javavirtualmachines/jdk1.8.0.jdk/contents/home/jre/lib/rt.jar\n   javax.crypto (jce.jar)\n      -> java.io                                            \n      -> java.lang                                          \n      -> java.lang.reflect                                  \n      -> java.net                                           \n      -> java.nio                                           \n      -> java.security                                      \n      -> java.security.cert                                 \n      -> java.security.spec                                 \n      -> java.util                                          \n      -> java.util.concurrent                               \n      -> java.util.jar                                      \n      -> java.util.regex                                    \n      -> java.util.zip                                      \n      -> javax.security.auth                                \n      -> sun.security.jca                                   jdk internal api (rt.jar)\n      -> sun.security.util                                  jdk internal api (rt.jar)\n      -> sun.security.validator                             jdk internal api (rt.jar)\n   javax.crypto.interfaces (jce.jar)\n      -> java.lang                                          \n      -> java.math                                          \n      -> java.security                                      \n   javax.crypto.spec (jce.jar)\n      -> java.lang                                          \n      -> java.math                                          \n      -> java.security.spec                                 \n      -> java.util                                          \n/library/java/javavirtualmachines/jdk1.8.0.jdk/contents/home/jre/lib/rt.jar -> /library/java/javavirtualmachines/jdk1.8.0.jdk/contents/home/jre/lib/jce.jar\n   java.security (rt.jar)\n      -> javax.crypto                                       jdk internal api (jce.jar)\n   sun.security.util (rt.jar)\n      -> javax.crypto                                       jdk internal api (jce.jar)\n      -> javax.crypto.interfaces                            jdk internal api (jce.jar)\n      -> javax.crypto.spec                                  jdk internal api (jce.jar)\n\n\n\n# 在linux上构建profile\n\n$ hg clone http://hg.openjdk.java.net/jdk8/jdk8/\n$ cd jdk8\n$ make images profiles : \n# finished profiles (build time 00:00:27)\n----- build times -------\nstart 2013-03-17 14:47:35\nend 2013-03-17 14:58:26\n00:00:25 corba\n00:00:15 demos\n00:01:50 hotspot\n00:00:24 images\n00:00:21 jaxp\n00:00:31 jaxws\n00:05:37 jdk\n00:00:43 langtools\n00:00:18 nashorn\n00:00:27 profiles\n00:10:51 total\n-------------------------\nfinished building java(tm) for target 'images profiles'\n$ cd images\n$ ls -d *image\nj2re-compact1-image j2re-compact2-image j2re-compact3-image j2re-image j2sdk-image\n\n\n\n# 编译后compact大致的占用空间\n\n\n\n\n# 总结\n\n如今，物联网正风行一时。我们看到大量不同的设备在市场上出现，每一种的更新速度都越来越快。java需要一个占用资源少的jre运行环境，紧凑的jre特性的出现，希望能带来以后的物联网的发展，甚至还是会有大量的java应用程序出现在物联网上面。目前oracle也发布了针对raspberry pi的jre了。\n\n另外该特性也是为java9的模块化项目做准备，模块化特性是javaer所期待的特性。他是解决业务系统复杂度的一个利器，当然osgi也是相当的出色。但osgi对于新学者来说未免太复杂了。",charsets:{cjk:!0}},{title:"Java 8 - LocalDate/LocalDateTime",frontmatter:{},regularPath:"/java/java8/java8-localdatetime.html",relativePath:"java/java8/java8-localdatetime.md",key:"v-c5de697c",path:"/java/java8/java8-localdatetime.html",headers:[{level:2,title:"Java 8 - LocalDate/LocalDateTime",slug:"java-8-localdate-localdatetime",normalizedTitle:"java 8 - localdate/localdatetime",charIndex:2},{level:2,title:"Java8之前的Date有哪些槽点",slug:"java8之前的date有哪些槽点",normalizedTitle:"java8之前的date有哪些槽点",charIndex:70},{level:2,title:"Java8时间和日期",slug:"java8时间和日期",normalizedTitle:"java8时间和日期",charIndex:282},{level:3,title:"类概览",slug:"类概览",normalizedTitle:"类概览",charIndex:300},{level:3,title:"方法概览",slug:"方法概览",normalizedTitle:"方法概览",charIndex:311},{level:2,title:"一些例子",slug:"一些例子",normalizedTitle:"一些例子",charIndex:321},{level:2,title:"其它语言时间",slug:"其它语言时间",normalizedTitle:"其它语言时间",charIndex:164},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:343}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java 8 - LocalDate/LocalDateTime Java8之前的Date有哪些槽点 Java8时间和日期 类概览 方法概览 一些例子 其它语言时间 总结",content:'# Java 8 - LocalDate/LocalDateTime\n\n> 理解时间和日期库需要理解如下问题: @pdai\n> \n>  * Java8之前的Date有哪些槽点?\n>  * Java8之前使用哪些常用的第三方时间库?\n>  * Java8关于时间和日期有哪些类和方法，变比Java8之前它的特点是什么?\n>  * 其它语言时间库?\n\n * Java 8 - LocalDate/LocalDateTime\n   * Java8之前的Date有哪些槽点\n     * 槽点一\n     * 槽点二\n     * 槽点三\n     * 槽点四\n   * Java8时间和日期\n     * 类概览\n     * 方法概览\n   * 一些例子\n   * 其它语言时间\n   * 总结\n\n\n# Java8之前的Date有哪些槽点\n\n> Tiago Fernandez做过一次投票，选举最烂的JAVA API，排第一的EJB2.X，第二的就是日期API。\n\n# 槽点一\n\n最开始的时候，Date既要承载日期信息，又要做日期之间的转换，还要做不同日期格式的显示，职责较繁杂(不懂单一职责，你妈妈知道吗? 纯属恶搞~哈哈)\n\n后来从JDK 1.1 开始，这三项职责分开了:\n\n使用Calendar类实现日期和时间字段之间转换；\n使用DateFormat类来格式化和分析日期字符串；\n而Date只用来承载日期和时间信息。\n\n\n原有Date中的相应方法已废弃。不过，无论是Date，还是Calendar，都用着太不方便了，这是API没有设计好的地方。\n\n# 槽点二\n\n坑爹的year和month\n\nDate date = new Date(2012,1,1);\nSystem.out.println(date);\n输出Thu Feb 01 00:00:00 CST 3912\n\n\n观察输出结果，year是2012+1900，而month，月份参数我不是给了1吗? 怎么输出二月(Feb)了?\n\n应该曾有人告诉你，如果你要设置日期，应该使用 java.util.Calendar，像这样…\n\nCalendar calendar = Calendar.getInstance();\ncalendar.set(2013, 8, 2);\n\n\n这样写又不对了，calendar的month也是从0开始的，表达8月份应该用7这个数字，要么就干脆用枚举\n\ncalendar.set(2013, Calendar.AUGUST, 2);\n\n\n注意上面的代码，Calendar年份的传值不需要减去1900(当然月份的定义和Date还是一样)，这种不一致真是让人抓狂！\n\n有些人可能知道，Calendar相关的API是IBM捐出去的，所以才导致不一致。\n\n# 槽点三\n\njava.util.Date与java.util.Calendar中的所有属性都是可变的\n\n下面的代码，计算两个日期之间的天数….\n\npublic static void main(String[] args) {\n    Calendar birth = Calendar.getInstance();\n    birth.set(1975, Calendar.MAY, 26);\n    Calendar now = Calendar.getInstance();\n    System.out.println(daysBetween(birth, now));\n    System.out.println(daysBetween(birth, now)); // 显示 0? \n }  \n\npublic static long daysBetween(Calendar begin, Calendar end) {\n    long daysBetween = 0;\n    while(begin.before(end)) {\n        begin.add(Calendar.DAY_OF_MONTH, 1);\n        daysBetween++;\n    }\n    return daysBetween;\n}\n\n\ndaysBetween有点问题，如果连续计算两个Date实例的话，第二次会取得0，因为Calendar状态是可变的，考虑到重复计算的场合，最好复制一个新的Calendar\n\npublic static long daysBetween(Calendar begin, Calendar end) {\n    Calendar calendar = (Calendar) begin.clone(); // 复制\n    long daysBetween = 0;\n    while(calendar.before(end)) {\n        calendar.add(Calendar.DAY_OF_MONTH, 1);\n        daysBetween++;\n    }\n    return daysBetween;\n}\n\n\n# 槽点四\n\nSimpleDateTimeFormat是非线程安全的。\n\n\n# Java8时间和日期\n\n\n# 类概览\n\nJava 8仍然延用了ISO的日历体系，并且与它的前辈们不同，java.time包中的类是不可变且线程安全的。新的时间及日期API位于java.time包中，下面是里面的一些关键的类:\n\n * Instant——它代表的是时间戳\n * LocalDate——不包含具体时间的日期，比如2014-01-14。它可以用来存储生日，周年纪念日，入职日期等。\n * LocalTime——它代表的是不含日期的时间\n * LocalDateTime——它包含了日期及时间，不过还是没有偏移信息或者说时区。\n * ZonedDateTime——这是一个包含时区的完整的日期时间，偏移量是以UTC/格林威治时间为基准的。\n\n新的库还增加了ZoneOffset及Zoned，可以为时区提供更好的支持。有了新的DateTimeFormatter之后日期的解析及格式化也变得焕然一新了。\n\n\n# 方法概览\n\n该包的API提供了大量相关的方法，这些方法一般有一致的方法前缀:\n\n * of: 静态工厂方法。\n * parse: 静态工厂方法，关注于解析。\n * get: 获取某些东西的值。\n * is: 检查某些东西的是否是true。\n * with: 不可变的setter等价物。\n * plus: 加一些量到某个对象。\n * minus: 从某个对象减去一些量。\n * to: 转换到另一个类型。\n * at: 把这个对象与另一个对象组合起来，例如: date.atTime(time)。\n\n\n# 一些例子\n\npublic class TimeIntroduction {\n    public static void testClock() throws InterruptedException {\n        //时钟提供给我们用于访问某个特定 时区的 瞬时时间、日期 和 时间的。  \n        Clock c1 = Clock.systemUTC(); //系统默认UTC时钟(当前瞬时时间 System.currentTimeMillis())  \n        System.out.println(c1.millis()); //每次调用将返回当前瞬时时间(UTC)  \n        Clock c2 = Clock.systemDefaultZone(); //系统默认时区时钟(当前瞬时时间)  \n        Clock c31 = Clock.system(ZoneId.of("Europe/Paris")); //巴黎时区  \n        System.out.println(c31.millis()); //每次调用将返回当前瞬时时间(UTC)  \n        Clock c32 = Clock.system(ZoneId.of("Asia/Shanghai"));//上海时区  \n        System.out.println(c32.millis());//每次调用将返回当前瞬时时间(UTC)  \n        Clock c4 = Clock.fixed(Instant.now(), ZoneId.of("Asia/Shanghai"));//固定上海时区时钟  \n        System.out.println(c4.millis());\n        Thread.sleep(1000);\n        System.out.println(c4.millis()); //不变 即时钟时钟在那一个点不动  \n        Clock c5 = Clock.offset(c1, Duration.ofSeconds(2)); //相对于系统默认时钟两秒的时钟  \n        System.out.println(c1.millis());\n        System.out.println(c5.millis());\n    }\n    public static void testInstant() {\n        //瞬时时间 相当于以前的System.currentTimeMillis()  \n        Instant instant1 = Instant.now();\n        System.out.println(instant1.getEpochSecond());//精确到秒 得到相对于1970-01-01 00:00:00 UTC的一个时间  \n        System.out.println(instant1.toEpochMilli()); //精确到毫秒  \n        Clock clock1 = Clock.systemUTC(); //获取系统UTC默认时钟  \n        Instant instant2 = Instant.now(clock1);//得到时钟的瞬时时间  \n        System.out.println(instant2.toEpochMilli());\n        Clock clock2 = Clock.fixed(instant1, ZoneId.systemDefault()); //固定瞬时时间时钟  \n        Instant instant3 = Instant.now(clock2);//得到时钟的瞬时时间  \n        System.out.println(instant3.toEpochMilli());//equals instant1  \n    }\n    public static void testLocalDateTime() {\n        //使用默认时区时钟瞬时时间创建 Clock.systemDefaultZone() --\x3e即相对于 ZoneId.systemDefault()默认时区  \n        LocalDateTime now = LocalDateTime.now();\n        System.out.println(now);\n\t\t//自定义时区  \n        LocalDateTime now2 = LocalDateTime.now(ZoneId.of("Europe/Paris"));\n        System.out.println(now2);//会以相应的时区显示日期  \n\t\t//自定义时钟  \n        Clock clock = Clock.system(ZoneId.of("Asia/Dhaka"));\n        LocalDateTime now3 = LocalDateTime.now(clock);\n        System.out.println(now3);//会以相应的时区显示日期  \n\t\t//不需要写什么相对时间 如java.util.Date 年是相对于1900 月是从0开始  \n\t\t//2013-12-31 23:59  \n\t\t\n        LocalDateTime d1 = LocalDateTime.of(2013, 12, 31, 23, 59);\n\t\t//年月日 时分秒 纳秒  \n        LocalDateTime d2 = LocalDateTime.of(2013, 12, 31, 23, 59, 59, 11);\n\t\t//使用瞬时时间 + 时区  \n        Instant instant = Instant.now();\n        LocalDateTime d3 = LocalDateTime.ofInstant(Instant.now(), ZoneId.systemDefault());\n        System.out.println(d3);\n        \n\t\t//解析String---\x3eLocalDateTime  \n        LocalDateTime d4 = LocalDateTime.parse("2013-12-31T23:59");\n        System.out.println(d4);\n        LocalDateTime d5 = LocalDateTime.parse("2013-12-31T23:59:59.999");//999毫秒 等价于999000000纳秒  \n        System.out.println(d5);\n        \n\t\t//使用DateTimeFormatter API 解析 和 格式化  \n        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");\n        LocalDateTime d6 = LocalDateTime.parse("2013/12/31 23:59:59", formatter);\n        System.out.println(formatter.format(d6));\n        \n\t\t//时间获取  \n        System.out.println(d6.getYear());\n        System.out.println(d6.getMonth());\n        System.out.println(d6.getDayOfYear());\n        System.out.println(d6.getDayOfMonth());\n        System.out.println(d6.getDayOfWeek());\n        System.out.println(d6.getHour());\n        System.out.println(d6.getMinute());\n        System.out.println(d6.getSecond());\n        System.out.println(d6.getNano());\n        \n\t\t//时间增减  \n        LocalDateTime d7 = d6.minusDays(1);\n        LocalDateTime d8 = d7.plus(1, IsoFields.QUARTER_YEARS);\n\t\t//LocalDate 即年月日 无时分秒  \n\t\t//LocalTime即时分秒 无年月日  \n\t\t//API和LocalDateTime类似就不演示了  \n\t\t\n\t\t// 两个日期是否相等\n\t\tSystem.out.println(d1.equals(d2));\n\t\t\n\t\t// MonthDay - 用来检查生日\n\t\tLocalDate dateOfBirth = LocalDate.of(2010, 01, 14); \n\t\tMonthDay birthday = MonthDay.of(dateOfBirth.getMonth(), dateOfBirth.getDayOfMonth()); \n\t\tMonthDay currentMonthDay = MonthDay.from(today); \n\t\tSystem.out.println(currentMonthDay.equals(birthday));\n\t\t\n\t\t// YearMonth - 用来检查信用卡过期\n\t\tYearMonth currentYearMonth = YearMonth.now(); System.out.printf("Days in month year %s: %d%n", currentYearMonth, currentYearMonth.lengthOfMonth()); \n\t\tYearMonth creditCardExpiry = YearMonth.of(2018, Month.FEBRUARY); \n\t\tSystem.out.printf("Your credit card expires on %s %n", creditCardExpiry); \n\t\t\n\t\t// 判断闰年 - LocalDate类有一个isLeapYear()的方法\n\t\tSystem.out.println(dateOfBirth.isLeapYear());\n    }\n    public static void testZonedDateTime() {\n        //即带有时区的date-time 存储纳秒、时区和时差(避免与本地date-time歧义)。  \n\t\t//API和LocalDateTime类似，只是多了时差(如2013-12-20T10:35:50.711+08:00[Asia/Shanghai])  \n        ZonedDateTime now = ZonedDateTime.now();\n        System.out.println(now);\n        ZonedDateTime now2 = ZonedDateTime.now(ZoneId.of("Europe/Paris"));\n        System.out.println(now2);\n\t\t//其他的用法也是类似的 就不介绍了  \n        ZonedDateTime z1 = ZonedDateTime.parse("2013-12-31T23:59:59Z[Europe/Paris]");\n        System.out.println(z1);\n    }\n    public static void testDuration() {\n        //表示两个瞬时时间的时间段  \n        Duration d1 = Duration.between(Instant.ofEpochMilli(System.currentTimeMillis() - 12323123), Instant.now());\n\t\t//得到相应的时差  \n        System.out.println(d1.toDays());\n        System.out.println(d1.toHours());\n        System.out.println(d1.toMinutes());\n        System.out.println(d1.toMillis());\n        System.out.println(d1.toNanos());\n\t\t//1天时差 类似的还有如ofHours()  \n        Duration d2 = Duration.ofDays(1);\n        System.out.println(d2.toDays());\n    }\n    public static void testChronology() {\n        //提供对java.util.Calendar的替换，提供对年历系统的支持  \n        Chronology c = HijrahChronology.INSTANCE;\n        ChronoLocalDateTime d = c.localDateTime(LocalDateTime.now());\n        System.out.println(d);\n    }\n    /**\n     * 新旧日期转换\n     */\n    public static void testNewOldDateConversion(){\n        Instant instant=new Date().toInstant();\n        Date date=Date.from(instant);\n        System.out.println(instant);\n        System.out.println(date);\n    }\n    public static void main(String[] args) throws InterruptedException {\n        testClock();\n        testInstant();\n        testLocalDateTime();\n        testZonedDateTime();\n        testDuration();\n        testChronology();\n        testNewOldDateConversion();\n    }\n}\n\n\n\n# 其它语言时间\n\n日期与时间处理API，在各种语言中，可能都只是个不起眼的API，如果你没有较复杂的时间处理需求，可能只是利用日期与时间处理API取得系统时间，简单做些显示罢了，然而如果认真看待日期与时间，其复杂程度可能会远超过你的想象，天文、地理、历史、政治、文化等因素，都会影响到你对时间的处理。所以在处理时间上，最好选用JSR310(如果你用java8的话就实现310了)，或者Joda-Time。\n\n不止是java面临时间处理的尴尬，其他语言同样也遇到过类似的问题，比如\n\nArrow: Python 中更好的日期与时间处理库\n\nMoment.js: JavaScript 中的日期库\n\nNoda-Time: .NET 阵营的 Joda-Time 的复制\n\n\n# 总结\n\n看完了这些例子后，我相信你已经对Java 8这套新的时间日期API有了一定的了解了。现在我们来回顾下关于这个新的API的一些关键的要素。\n\n * 它提供了javax.time.ZoneId用来处理时区。\n\n * 它提供了LocalDate与LocalTime类 Java 8中新的时间与日期API中的所有类都是不可变且线程安全的，这与之前的Date与Calendar API中的恰好相反，那里面像java.util.Date以及SimpleDateFormat这些关键的类都不是线程安全的。\n\n * 新的时间与日期API中很重要的一点是它定义清楚了基本的时间与日期的概念，比方说，瞬时时间，持续时间，日期，时间，时区以及时间段。它们都是基于ISO日历体系的。\n\n * 每个Java开发人员都应该至少了解这套新的API中的这五个类: Instant 它代表的是时间戳，比如2014-01-14T02:20:13.592Z，这可以从java.time.Clock类中获取，像这样: Instant current = Clock.system(ZoneId.of(“Asia/Tokyo”)).instant(); LocalDate 它表示的是不带时间的日期，比如2014-01-14。它可以用来存储生日，周年纪念日，入职日期等。 LocalTime – 它表示的是不带日期的时间 LocalDateTime – 它包含了时间与日期，不过没有带时区的偏移量 ZonedDateTime – 这是一个带时区的完整时间，它根据UTC/格林威治时间来进行时区调整\n\n * 这个库的主包是java.time，里面包含了代表日期，时间，瞬时以及持续时间的类。它有两个子package，一个是java.time.foramt，这个是什么用途就很明显了，还有一个是java.time.temporal，它能从更低层面对各个字段进行访问。\n\n * 时区指的是地球上共享同一标准时间的地区。每个时区都有一个唯一标识符，同时还有一个地区/城市(Asia/Tokyo)的格式以及从格林威治时间开始的一个偏移时间。比如说，东京的偏移时间就是+09:00。 OffsetDateTime类实际上包含了LocalDateTime与ZoneOffset。它用来表示一个包含格林威治时间偏移量(+/-小时: 分，比如+06:00或者 -08: 00)的完整的日期(年月日)及时间(时分秒，纳秒)。 DateTimeFormatter类用于在Java中进行日期的格式化与解析。与SimpleDateFormat不同，它是不可变且线程安全的，如果需要的话，可以赋值给一个静态变量。DateTimeFormatter类提供了许多预定义的格式器，你也可以自定义自己想要的格式。当然了，根据约定，它还有一个parse()方法是用于将字符串转换成日期的，如果转换期间出现任何错误，它会抛出DateTimeParseException异常。类似的，DateFormatter类也有一个用于格式化日期的format()方法，它出错的话则会抛出DateTimeException异常。\n\n * 再说一句，“MMM d yyyy”与“MMm dd yyyy”这两个日期格式也略有不同，前者能识别出”Jan 2 2014″与”Jan 14 2014″这两个串，而后者如果传进来的是”Jan 2 2014″则会报错，因为它期望月份处传进来的是两个字符。为了解决这个问题，在天为个位数的情况下，你得在前面补0，比如”Jan 2 2014″应该改为”Jan 02 2014″。',normalizedContent:'# java 8 - localdate/localdatetime\n\n> 理解时间和日期库需要理解如下问题: @pdai\n> \n>  * java8之前的date有哪些槽点?\n>  * java8之前使用哪些常用的第三方时间库?\n>  * java8关于时间和日期有哪些类和方法，变比java8之前它的特点是什么?\n>  * 其它语言时间库?\n\n * java 8 - localdate/localdatetime\n   * java8之前的date有哪些槽点\n     * 槽点一\n     * 槽点二\n     * 槽点三\n     * 槽点四\n   * java8时间和日期\n     * 类概览\n     * 方法概览\n   * 一些例子\n   * 其它语言时间\n   * 总结\n\n\n# java8之前的date有哪些槽点\n\n> tiago fernandez做过一次投票，选举最烂的java api，排第一的ejb2.x，第二的就是日期api。\n\n# 槽点一\n\n最开始的时候，date既要承载日期信息，又要做日期之间的转换，还要做不同日期格式的显示，职责较繁杂(不懂单一职责，你妈妈知道吗? 纯属恶搞~哈哈)\n\n后来从jdk 1.1 开始，这三项职责分开了:\n\n使用calendar类实现日期和时间字段之间转换；\n使用dateformat类来格式化和分析日期字符串；\n而date只用来承载日期和时间信息。\n\n\n原有date中的相应方法已废弃。不过，无论是date，还是calendar，都用着太不方便了，这是api没有设计好的地方。\n\n# 槽点二\n\n坑爹的year和month\n\ndate date = new date(2012,1,1);\nsystem.out.println(date);\n输出thu feb 01 00:00:00 cst 3912\n\n\n观察输出结果，year是2012+1900，而month，月份参数我不是给了1吗? 怎么输出二月(feb)了?\n\n应该曾有人告诉你，如果你要设置日期，应该使用 java.util.calendar，像这样…\n\ncalendar calendar = calendar.getinstance();\ncalendar.set(2013, 8, 2);\n\n\n这样写又不对了，calendar的month也是从0开始的，表达8月份应该用7这个数字，要么就干脆用枚举\n\ncalendar.set(2013, calendar.august, 2);\n\n\n注意上面的代码，calendar年份的传值不需要减去1900(当然月份的定义和date还是一样)，这种不一致真是让人抓狂！\n\n有些人可能知道，calendar相关的api是ibm捐出去的，所以才导致不一致。\n\n# 槽点三\n\njava.util.date与java.util.calendar中的所有属性都是可变的\n\n下面的代码，计算两个日期之间的天数….\n\npublic static void main(string[] args) {\n    calendar birth = calendar.getinstance();\n    birth.set(1975, calendar.may, 26);\n    calendar now = calendar.getinstance();\n    system.out.println(daysbetween(birth, now));\n    system.out.println(daysbetween(birth, now)); // 显示 0? \n }  \n\npublic static long daysbetween(calendar begin, calendar end) {\n    long daysbetween = 0;\n    while(begin.before(end)) {\n        begin.add(calendar.day_of_month, 1);\n        daysbetween++;\n    }\n    return daysbetween;\n}\n\n\ndaysbetween有点问题，如果连续计算两个date实例的话，第二次会取得0，因为calendar状态是可变的，考虑到重复计算的场合，最好复制一个新的calendar\n\npublic static long daysbetween(calendar begin, calendar end) {\n    calendar calendar = (calendar) begin.clone(); // 复制\n    long daysbetween = 0;\n    while(calendar.before(end)) {\n        calendar.add(calendar.day_of_month, 1);\n        daysbetween++;\n    }\n    return daysbetween;\n}\n\n\n# 槽点四\n\nsimpledatetimeformat是非线程安全的。\n\n\n# java8时间和日期\n\n\n# 类概览\n\njava 8仍然延用了iso的日历体系，并且与它的前辈们不同，java.time包中的类是不可变且线程安全的。新的时间及日期api位于java.time包中，下面是里面的一些关键的类:\n\n * instant——它代表的是时间戳\n * localdate——不包含具体时间的日期，比如2014-01-14。它可以用来存储生日，周年纪念日，入职日期等。\n * localtime——它代表的是不含日期的时间\n * localdatetime——它包含了日期及时间，不过还是没有偏移信息或者说时区。\n * zoneddatetime——这是一个包含时区的完整的日期时间，偏移量是以utc/格林威治时间为基准的。\n\n新的库还增加了zoneoffset及zoned，可以为时区提供更好的支持。有了新的datetimeformatter之后日期的解析及格式化也变得焕然一新了。\n\n\n# 方法概览\n\n该包的api提供了大量相关的方法，这些方法一般有一致的方法前缀:\n\n * of: 静态工厂方法。\n * parse: 静态工厂方法，关注于解析。\n * get: 获取某些东西的值。\n * is: 检查某些东西的是否是true。\n * with: 不可变的setter等价物。\n * plus: 加一些量到某个对象。\n * minus: 从某个对象减去一些量。\n * to: 转换到另一个类型。\n * at: 把这个对象与另一个对象组合起来，例如: date.attime(time)。\n\n\n# 一些例子\n\npublic class timeintroduction {\n    public static void testclock() throws interruptedexception {\n        //时钟提供给我们用于访问某个特定 时区的 瞬时时间、日期 和 时间的。  \n        clock c1 = clock.systemutc(); //系统默认utc时钟(当前瞬时时间 system.currenttimemillis())  \n        system.out.println(c1.millis()); //每次调用将返回当前瞬时时间(utc)  \n        clock c2 = clock.systemdefaultzone(); //系统默认时区时钟(当前瞬时时间)  \n        clock c31 = clock.system(zoneid.of("europe/paris")); //巴黎时区  \n        system.out.println(c31.millis()); //每次调用将返回当前瞬时时间(utc)  \n        clock c32 = clock.system(zoneid.of("asia/shanghai"));//上海时区  \n        system.out.println(c32.millis());//每次调用将返回当前瞬时时间(utc)  \n        clock c4 = clock.fixed(instant.now(), zoneid.of("asia/shanghai"));//固定上海时区时钟  \n        system.out.println(c4.millis());\n        thread.sleep(1000);\n        system.out.println(c4.millis()); //不变 即时钟时钟在那一个点不动  \n        clock c5 = clock.offset(c1, duration.ofseconds(2)); //相对于系统默认时钟两秒的时钟  \n        system.out.println(c1.millis());\n        system.out.println(c5.millis());\n    }\n    public static void testinstant() {\n        //瞬时时间 相当于以前的system.currenttimemillis()  \n        instant instant1 = instant.now();\n        system.out.println(instant1.getepochsecond());//精确到秒 得到相对于1970-01-01 00:00:00 utc的一个时间  \n        system.out.println(instant1.toepochmilli()); //精确到毫秒  \n        clock clock1 = clock.systemutc(); //获取系统utc默认时钟  \n        instant instant2 = instant.now(clock1);//得到时钟的瞬时时间  \n        system.out.println(instant2.toepochmilli());\n        clock clock2 = clock.fixed(instant1, zoneid.systemdefault()); //固定瞬时时间时钟  \n        instant instant3 = instant.now(clock2);//得到时钟的瞬时时间  \n        system.out.println(instant3.toepochmilli());//equals instant1  \n    }\n    public static void testlocaldatetime() {\n        //使用默认时区时钟瞬时时间创建 clock.systemdefaultzone() --\x3e即相对于 zoneid.systemdefault()默认时区  \n        localdatetime now = localdatetime.now();\n        system.out.println(now);\n\t\t//自定义时区  \n        localdatetime now2 = localdatetime.now(zoneid.of("europe/paris"));\n        system.out.println(now2);//会以相应的时区显示日期  \n\t\t//自定义时钟  \n        clock clock = clock.system(zoneid.of("asia/dhaka"));\n        localdatetime now3 = localdatetime.now(clock);\n        system.out.println(now3);//会以相应的时区显示日期  \n\t\t//不需要写什么相对时间 如java.util.date 年是相对于1900 月是从0开始  \n\t\t//2013-12-31 23:59  \n\t\t\n        localdatetime d1 = localdatetime.of(2013, 12, 31, 23, 59);\n\t\t//年月日 时分秒 纳秒  \n        localdatetime d2 = localdatetime.of(2013, 12, 31, 23, 59, 59, 11);\n\t\t//使用瞬时时间 + 时区  \n        instant instant = instant.now();\n        localdatetime d3 = localdatetime.ofinstant(instant.now(), zoneid.systemdefault());\n        system.out.println(d3);\n        \n\t\t//解析string---\x3elocaldatetime  \n        localdatetime d4 = localdatetime.parse("2013-12-31t23:59");\n        system.out.println(d4);\n        localdatetime d5 = localdatetime.parse("2013-12-31t23:59:59.999");//999毫秒 等价于999000000纳秒  \n        system.out.println(d5);\n        \n\t\t//使用datetimeformatter api 解析 和 格式化  \n        datetimeformatter formatter = datetimeformatter.ofpattern("yyyy/mm/dd hh:mm:ss");\n        localdatetime d6 = localdatetime.parse("2013/12/31 23:59:59", formatter);\n        system.out.println(formatter.format(d6));\n        \n\t\t//时间获取  \n        system.out.println(d6.getyear());\n        system.out.println(d6.getmonth());\n        system.out.println(d6.getdayofyear());\n        system.out.println(d6.getdayofmonth());\n        system.out.println(d6.getdayofweek());\n        system.out.println(d6.gethour());\n        system.out.println(d6.getminute());\n        system.out.println(d6.getsecond());\n        system.out.println(d6.getnano());\n        \n\t\t//时间增减  \n        localdatetime d7 = d6.minusdays(1);\n        localdatetime d8 = d7.plus(1, isofields.quarter_years);\n\t\t//localdate 即年月日 无时分秒  \n\t\t//localtime即时分秒 无年月日  \n\t\t//api和localdatetime类似就不演示了  \n\t\t\n\t\t// 两个日期是否相等\n\t\tsystem.out.println(d1.equals(d2));\n\t\t\n\t\t// monthday - 用来检查生日\n\t\tlocaldate dateofbirth = localdate.of(2010, 01, 14); \n\t\tmonthday birthday = monthday.of(dateofbirth.getmonth(), dateofbirth.getdayofmonth()); \n\t\tmonthday currentmonthday = monthday.from(today); \n\t\tsystem.out.println(currentmonthday.equals(birthday));\n\t\t\n\t\t// yearmonth - 用来检查信用卡过期\n\t\tyearmonth currentyearmonth = yearmonth.now(); system.out.printf("days in month year %s: %d%n", currentyearmonth, currentyearmonth.lengthofmonth()); \n\t\tyearmonth creditcardexpiry = yearmonth.of(2018, month.february); \n\t\tsystem.out.printf("your credit card expires on %s %n", creditcardexpiry); \n\t\t\n\t\t// 判断闰年 - localdate类有一个isleapyear()的方法\n\t\tsystem.out.println(dateofbirth.isleapyear());\n    }\n    public static void testzoneddatetime() {\n        //即带有时区的date-time 存储纳秒、时区和时差(避免与本地date-time歧义)。  \n\t\t//api和localdatetime类似，只是多了时差(如2013-12-20t10:35:50.711+08:00[asia/shanghai])  \n        zoneddatetime now = zoneddatetime.now();\n        system.out.println(now);\n        zoneddatetime now2 = zoneddatetime.now(zoneid.of("europe/paris"));\n        system.out.println(now2);\n\t\t//其他的用法也是类似的 就不介绍了  \n        zoneddatetime z1 = zoneddatetime.parse("2013-12-31t23:59:59z[europe/paris]");\n        system.out.println(z1);\n    }\n    public static void testduration() {\n        //表示两个瞬时时间的时间段  \n        duration d1 = duration.between(instant.ofepochmilli(system.currenttimemillis() - 12323123), instant.now());\n\t\t//得到相应的时差  \n        system.out.println(d1.todays());\n        system.out.println(d1.tohours());\n        system.out.println(d1.tominutes());\n        system.out.println(d1.tomillis());\n        system.out.println(d1.tonanos());\n\t\t//1天时差 类似的还有如ofhours()  \n        duration d2 = duration.ofdays(1);\n        system.out.println(d2.todays());\n    }\n    public static void testchronology() {\n        //提供对java.util.calendar的替换，提供对年历系统的支持  \n        chronology c = hijrahchronology.instance;\n        chronolocaldatetime d = c.localdatetime(localdatetime.now());\n        system.out.println(d);\n    }\n    /**\n     * 新旧日期转换\n     */\n    public static void testnewolddateconversion(){\n        instant instant=new date().toinstant();\n        date date=date.from(instant);\n        system.out.println(instant);\n        system.out.println(date);\n    }\n    public static void main(string[] args) throws interruptedexception {\n        testclock();\n        testinstant();\n        testlocaldatetime();\n        testzoneddatetime();\n        testduration();\n        testchronology();\n        testnewolddateconversion();\n    }\n}\n\n\n\n# 其它语言时间\n\n日期与时间处理api，在各种语言中，可能都只是个不起眼的api，如果你没有较复杂的时间处理需求，可能只是利用日期与时间处理api取得系统时间，简单做些显示罢了，然而如果认真看待日期与时间，其复杂程度可能会远超过你的想象，天文、地理、历史、政治、文化等因素，都会影响到你对时间的处理。所以在处理时间上，最好选用jsr310(如果你用java8的话就实现310了)，或者joda-time。\n\n不止是java面临时间处理的尴尬，其他语言同样也遇到过类似的问题，比如\n\narrow: python 中更好的日期与时间处理库\n\nmoment.js: javascript 中的日期库\n\nnoda-time: .net 阵营的 joda-time 的复制\n\n\n# 总结\n\n看完了这些例子后，我相信你已经对java 8这套新的时间日期api有了一定的了解了。现在我们来回顾下关于这个新的api的一些关键的要素。\n\n * 它提供了javax.time.zoneid用来处理时区。\n\n * 它提供了localdate与localtime类 java 8中新的时间与日期api中的所有类都是不可变且线程安全的，这与之前的date与calendar api中的恰好相反，那里面像java.util.date以及simpledateformat这些关键的类都不是线程安全的。\n\n * 新的时间与日期api中很重要的一点是它定义清楚了基本的时间与日期的概念，比方说，瞬时时间，持续时间，日期，时间，时区以及时间段。它们都是基于iso日历体系的。\n\n * 每个java开发人员都应该至少了解这套新的api中的这五个类: instant 它代表的是时间戳，比如2014-01-14t02:20:13.592z，这可以从java.time.clock类中获取，像这样: instant current = clock.system(zoneid.of(“asia/tokyo”)).instant(); localdate 它表示的是不带时间的日期，比如2014-01-14。它可以用来存储生日，周年纪念日，入职日期等。 localtime – 它表示的是不带日期的时间 localdatetime – 它包含了时间与日期，不过没有带时区的偏移量 zoneddatetime – 这是一个带时区的完整时间，它根据utc/格林威治时间来进行时区调整\n\n * 这个库的主包是java.time，里面包含了代表日期，时间，瞬时以及持续时间的类。它有两个子package，一个是java.time.foramt，这个是什么用途就很明显了，还有一个是java.time.temporal，它能从更低层面对各个字段进行访问。\n\n * 时区指的是地球上共享同一标准时间的地区。每个时区都有一个唯一标识符，同时还有一个地区/城市(asia/tokyo)的格式以及从格林威治时间开始的一个偏移时间。比如说，东京的偏移时间就是+09:00。 offsetdatetime类实际上包含了localdatetime与zoneoffset。它用来表示一个包含格林威治时间偏移量(+/-小时: 分，比如+06:00或者 -08: 00)的完整的日期(年月日)及时间(时分秒，纳秒)。 datetimeformatter类用于在java中进行日期的格式化与解析。与simpledateformat不同，它是不可变且线程安全的，如果需要的话，可以赋值给一个静态变量。datetimeformatter类提供了许多预定义的格式器，你也可以自定义自己想要的格式。当然了，根据约定，它还有一个parse()方法是用于将字符串转换成日期的，如果转换期间出现任何错误，它会抛出datetimeparseexception异常。类似的，dateformatter类也有一个用于格式化日期的format()方法，它出错的话则会抛出datetimeexception异常。\n\n * 再说一句，“mmm d yyyy”与“mmm dd yyyy”这两个日期格式也略有不同，前者能识别出”jan 2 2014″与”jan 14 2014″这两个串，而后者如果传进来的是”jan 2 2014″则会报错，因为它期望月份处传进来的是两个字符。为了解决这个问题，在天为个位数的情况下，你得在前面补0，比如”jan 2 2014″应该改为”jan 02 2014″。',charsets:{cjk:!0}},{title:"Java 8 - Optional类深度解析",frontmatter:{},regularPath:"/java/java8/java8-optional.html",relativePath:"java/java8/java8-optional.md",key:"v-57df1a48",path:"/java/java8/java8-optional.html",headers:[{level:2,title:"Java 8 - Optional类深度解析",slug:"java-8-optional类深度解析",normalizedTitle:"java 8 - optional类深度解析",charIndex:2},{level:2,title:"Optional类包含的方法",slug:"optional类包含的方法",normalizedTitle:"optional类包含的方法",charIndex:91},{level:3,title:"of",slug:"of",normalizedTitle:"of",charIndex:113},{level:3,title:"ofNullable",slug:"ofnullable",normalizedTitle:"ofnullable",charIndex:123},{level:3,title:"isPresent",slug:"ispresent",normalizedTitle:"ispresent",charIndex:141},{level:3,title:"get",slug:"get",normalizedTitle:"get",charIndex:158},{level:3,title:"ifPresent",slug:"ifpresent",normalizedTitle:"ifpresent",charIndex:169},{level:3,title:"orElse",slug:"orelse",normalizedTitle:"orelse",charIndex:186},{level:3,title:"orElseGet",slug:"orelseget",normalizedTitle:"orelseget",charIndex:200},{level:3,title:"orElseThrow",slug:"orelsethrow",normalizedTitle:"orelsethrow",charIndex:217},{level:3,title:"map",slug:"map",normalizedTitle:"map",charIndex:236},{level:3,title:"flatMap",slug:"flatmap",normalizedTitle:"flatmap",charIndex:247},{level:3,title:"filter",slug:"filter",normalizedTitle:"filter",charIndex:262},{level:2,title:"一些例子",slug:"一些例子",normalizedTitle:"一些例子",charIndex:274},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:284}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java 8 - Optional类深度解析 Optional类包含的方法 of ofNullable isPresent get ifPresent orElse orElseGet orElseThrow map flatMap filter 一些例子 参考",content:'# Java 8 - Optional类深度解析\n\n> 对Java 8 Optional类进行深度解析。 @pdai\n\n * Java 8 - Optional类深度解析\n   * Optional类包含的方法\n     * of\n     * ofNullable\n     * isPresent\n     * get\n     * ifPresent\n     * orElse\n     * orElseGet\n     * orElseThrow\n     * map\n     * flatMap\n     * filter\n   * 一些例子\n   * 参考\n\n> 身为一名Java程序员，大家可能都有这样的经历: 调用一个方法得到了返回值却不能直接将返回值作为参数去调用别的方法。我们首先要判断这个返回值是否为null，只有在非空的前提下才能将其作为其他方法的参数。这正是一些类似Guava的外部API试图解决的问题。一些JVM编程语言比如Scala、Ceylon等已经将对在核心API中解决了这个问题。在我的前一篇文章中，介绍了Scala是如何解决了这个问题。\n\n新版本的Java，比如Java 8引入了一个新的Optional类。Optional类的Javadoc描述如下:\n\n> 这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。\n\n\n# Optional类包含的方法\n\n\n# of\n\n> 为非null的值创建一个Optional。\n\nof方法通过工厂方法创建Optional类。需要注意的是，创建对象时传入的参数不能为null。如果传入参数为null，则抛出NullPointerException 。\n\n//调用工厂方法创建Optional实例\nOptional<String> name = Optional.of("Sanaulla");\n//传入参数为null，抛出NullPointerException.\nOptional<String> someNull = Optional.of(null);\n\n\n\n# ofNullable\n\n> 为指定的值创建一个Optional，如果指定的值为null，则返回一个空的Optional。\n\nofNullable与of方法相似，唯一的区别是可以接受参数为null的情况。示例如下:\n\n//下面创建了一个不包含任何值的Optional实例\n//例如，值为\'null\'\nOptional empty = Optional.ofNullable(null);\n\n\n\n# isPresent\n\n非常容易理解\n\n> 如果值存在返回true，否则返回false。\n\n类似下面的代码:\n\n//isPresent方法用来检查Optional实例中是否包含值\nif (name.isPresent()) {\n  //在Optional实例内调用get()返回已存在的值\n  System.out.println(name.get());//输出Sanaulla\n}\n\n\n\n# get\n\n> 如果Optional有值则将其返回，否则抛出NoSuchElementException。\n\n上面的示例中，get方法用来得到Optional实例中的值。下面我们看一个抛出NoSuchElementException的例子:\n\n//执行下面的代码会输出: No value present \ntry {\n  //在空的Optional实例上调用get()，抛出NoSuchElementException\n  System.out.println(empty.get());\n} catch (NoSuchElementException ex) {\n  System.out.println(ex.getMessage());\n}\n\n\n\n# ifPresent\n\n> 如果Optional实例有值则为其调用consumer，否则不做处理\n\n要理解ifPresent方法，首先需要了解Consumer类。简答地说，Consumer类包含一个抽象方法。该抽象方法对传入的值进行处理，但没有返回值。Java8支持不用接口直接通过lambda表达式传入参数。\n\n如果Optional实例有值，调用ifPresent()可以接受接口段或lambda表达式。类似下面的代码:\n\n//ifPresent方法接受lambda表达式作为参数。\n//lambda表达式对Optional的值调用consumer进行处理。\nname.ifPresent((value) -> {\n  System.out.println("The length of the value is: " + value.length());\n});\n\n\n\n# orElse\n\n> 如果有值则将其返回，否则返回指定的其它值。\n\n如果Optional实例有值则将其返回，否则返回orElse方法传入的参数。示例如下:\n\n//如果值不为null，orElse方法返回Optional实例的值。\n//如果为null，返回传入的消息。\n//输出: There is no value present!\nSystem.out.println(empty.orElse("There is no value present!"));\n//输出: Sanaulla\nSystem.out.println(name.orElse("There is some value!"));\n\n\n\n# orElseGet\n\n> orElseGet与orElse方法类似，区别在于得到的默认值。orElse方法将传入的字符串作为默认值，orElseGet方法可以接受Supplier接口的实现用来生成默认值。示例如下:\n\n//orElseGet与orElse方法类似，区别在于orElse传入的是默认值，\n//orElseGet可以接受一个lambda表达式生成默认值。\n//输出: Default Value\nSystem.out.println(empty.orElseGet(() -> "Default Value"));\n//输出: Sanaulla\nSystem.out.println(name.orElseGet(() -> "Default Value"));\n\n\n\n# orElseThrow\n\n> 如果有值则将其返回，否则抛出supplier接口创建的异常。\n\n在orElseGet方法中，我们传入一个Supplier接口。然而，在orElseThrow中我们可以传入一个lambda表达式或方法，如果值不存在来抛出异常。示例如下:\n\ntry {\n  //orElseThrow与orElse方法类似。与返回默认值不同，\n  //orElseThrow会抛出lambda表达式或方法生成的异常 \n\n  empty.orElseThrow(ValueAbsentException::new);\n} catch (Throwable ex) {\n  //输出: No value present in the Optional instance\n  System.out.println(ex.getMessage());\n}\n\n\nValueAbsentException定义如下:\n\nclass ValueAbsentException extends Throwable {\n\n  public ValueAbsentException() {\n    super();\n  }\n\n  public ValueAbsentException(String msg) {\n    super(msg);\n  }\n\n  @Override\n  public String getMessage() {\n    return "No value present in the Optional instance";\n  }\n}\n\n\n\n# map\n\nmap方法文档说明如下:\n\n> 如果有值，则对其执行调用mapping函数得到返回值。如果返回值不为null，则创建包含mapping返回值的Optional作为map方法返回值，否则返回空Optional。\n\nmap方法用来对Optional实例的值执行一系列操作。通过一组实现了Function接口的lambda表达式传入操作。如果你不熟悉Function接口，可以参考我的这篇博客。map方法示例如下:\n\n//map方法执行传入的lambda表达式参数对Optional实例的值进行修改。\n//为lambda表达式的返回值创建新的Optional实例作为map方法的返回值。\nOptional<String> upperName = name.map((value) -> value.toUpperCase());\nSystem.out.println(upperName.orElse("No value found"));\n\n\n\n# flatMap\n\n> 如果有值，为其执行mapping函数返回Optional类型返回值，否则返回空Optional。flatMap与map(Funtion)方法类似，区别在于flatMap中的mapper返回值必须是Optional。调用结束时，flatMap不会对结果用Optional封装。\n\nflatMap方法与map方法类似，区别在于mapping函数的返回值不同。map方法的mapping函数返回值可以是任何类型T，而flatMap方法的mapping函数必须是Optional。\n\n参照map函数，使用flatMap重写的示例如下:\n\n//flatMap与map(Function)非常类似，区别在于传入方法的lambda表达式的返回类型。\n//map方法中的lambda表达式返回值可以是任意类型，在map函数返回之前会包装为Optional。 \n//但flatMap方法中的lambda表达式返回值必须是Optionl实例。 \nupperName = name.flatMap((value) -> Optional.of(value.toUpperCase()));\nSystem.out.println(upperName.orElse("No value found"));//输出SANAULLA\n\n\n\n# filter\n\nfilter个方法通过传入限定条件对Optional实例的值进行过滤。文档描述如下:\n\n> 如果有值并且满足断言条件返回包含该值的Optional，否则返回空Optional。\n\n读到这里，可能你已经知道如何为filter方法传入一段代码。是的，这里可以传入一个lambda表达式。对于filter函数我们应该传入实现了Predicate接口的lambda表达式。如果你不熟悉Predicate接口，可以参考这篇文章。\n\n现在我来看看filter的各种用法，下面的示例介绍了满足限定条件和不满足两种情况:\n\n//filter方法检查给定的Option值是否满足某些条件。\n//如果满足则返回同一个Option实例，否则返回空Optional。\nOptional<String> longName = name.filter((value) -> value.length() > 6);\nSystem.out.println(longName.orElse("The name is less than 6 characters"));//输出Sanaulla\n\n//另一个例子是Optional值不满足filter指定的条件。\nOptional<String> anotherName = Optional.of("Sana");\nOptional<String> shortName = anotherName.filter((value) -> value.length() > 6);\n//输出: name长度不足6字符\nSystem.out.println(shortName.orElse("The name is less than 6 characters"));\n\n\n\n# 一些例子\n\n * 一个综合例子\n\npublic class OptionalDemo {\n\n  public static void main(String[] args) {\n    //创建Optional实例，也可以通过方法返回值得到。\n    Optional<String> name = Optional.of("Sanaulla");\n\n    //创建没有值的Optional实例，例如值为\'null\'\n    Optional empty = Optional.ofNullable(null);\n\n    //isPresent方法用来检查Optional实例是否有值。\n    if (name.isPresent()) {\n      //调用get()返回Optional值。\n      System.out.println(name.get());\n    }\n\n    try {\n      //在Optional实例上调用get()抛出NoSuchElementException。\n      System.out.println(empty.get());\n    } catch (NoSuchElementException ex) {\n      System.out.println(ex.getMessage());\n    }\n\n    //ifPresent方法接受lambda表达式参数。\n    //如果Optional值不为空，lambda表达式会处理并在其上执行操作。\n    name.ifPresent((value) -> {\n      System.out.println("The length of the value is: " + value.length());\n    });\n\n    //如果有值orElse方法会返回Optional实例，否则返回传入的错误信息。\n    System.out.println(empty.orElse("There is no value present!"));\n    System.out.println(name.orElse("There is some value!"));\n\n    //orElseGet与orElse类似，区别在于传入的默认值。\n    //orElseGet接受lambda表达式生成默认值。\n    System.out.println(empty.orElseGet(() -> "Default Value"));\n    System.out.println(name.orElseGet(() -> "Default Value"));\n\n    try {\n      //orElseThrow与orElse方法类似，区别在于返回值。\n      //orElseThrow抛出由传入的lambda表达式/方法生成异常。\n      empty.orElseThrow(ValueAbsentException::new);\n    } catch (Throwable ex) {\n      System.out.println(ex.getMessage());\n    }\n\n    //map方法通过传入的lambda表达式修改Optonal实例默认值。 \n    //lambda表达式返回值会包装为Optional实例。\n    Optional<String> upperName = name.map((value) -> value.toUpperCase());\n    System.out.println(upperName.orElse("No value found"));\n\n    //flatMap与map(Funtion)非常相似，区别在于lambda表达式的返回值。\n    //map方法的lambda表达式返回值可以是任何类型，但是返回值会包装成Optional实例。\n    //但是flatMap方法的lambda返回值总是Optional类型。\n    upperName = name.flatMap((value) -> Optional.of(value.toUpperCase()));\n    System.out.println(upperName.orElse("No value found"));\n\n    //filter方法检查Optiona值是否满足给定条件。\n    //如果满足返回Optional实例值，否则返回空Optional。\n    Optional<String> longName = name.filter((value) -> value.length() > 6);\n    System.out.println(longName.orElse("The name is less than 6 characters"));\n\n    //另一个示例，Optional值不满足给定条件。\n    Optional<String> anotherName = Optional.of("Sana");\n    Optional<String> shortName = anotherName.filter((value) -> value.length() > 6);\n    System.out.println(shortName.orElse("The name is less than 6 characters"));\n\n  }\n}\n\n\n上述代码输出如下:\n\nSanaulla\nNo value present\nThe length of the value is: 8\nThere is no value present!\nSanaulla\nDefault Value\nSanaulla\nNo value present in the Optional instance\nSANAULLA\nSANAULLA\nSanaulla\nThe name is less than 6 characters\n\n\n * 在 Java 8 中提高 Null 的安全性\n\n假设我们有一个像这样的类层次结构:\n\nclass Outer {\n    Nested nested;\n    Nested getNested() {\n        return nested;\n    }\n}\nclass Nested {\n    Inner inner;\n    Inner getInner() {\n        return inner;\n    }\n}\nclass Inner {\n    String foo;\n    String getFoo() {\n        return foo;\n    }\n}\n\n\n解决这种结构的深层嵌套路径是有点麻烦的。我们必须编写一堆 null 检查来确保不会导致一个 NullPointerException:\n\nOuter outer = new Outer();\nif (outer != null && outer.nested != null && outer.nested.inner != null) {\n    System.out.println(outer.nested.inner.foo);\n}\n\n\n我们可以通过利用 Java 8 的 Optional 类型来摆脱所有这些 null 检查。map 方法接收一个 Function 类型的 lambda 表达式，并自动将每个 function 的结果包装成一个 Optional 对象。这使我们能够在一行中进行多个 map 操作。Null 检查是在底层自动处理的。\n\nOptional.of(new Outer())\n    .map(Outer::getNested)\n    .map(Nested::getInner)\n    .map(Inner::getFoo)\n    .ifPresent(System.out::println);\n\n\n还有一种实现相同作用的方式就是通过利用一个 supplier 函数来解决嵌套路径的问题:\n\nOuter obj = new Outer();\nresolve(() -> obj.getNested().getInner().getFoo())\n    .ifPresent(System.out::println);\n\n\n调用 obj.getNested().getInner().getFoo()) 可能会抛出一个 NullPointerException 异常。在这种情况下，该异常将会被捕获，而该方法会返回 Optional.empty()。\n\npublic static <T> Optional<T> resolve(Supplier<T> resolver) {\n    try {\n        T result = resolver.get();\n        return Optional.ofNullable(result);\n    }\n    catch (NullPointerException e) {\n        return Optional.empty();\n    }\n}\n\n\n请记住，这两个解决方案可能没有传统 null 检查那么高的性能。不过在大多数情况下不会有太大问题。\n\n\n# 参考\n\n原文链接: javacodegeeks\n\n翻译: ImportNew.com - 高俊阳\n\n译文链接: http://www.importnew.com/6675.html\n\n转载请保留原文出处、译者和译文链接。',normalizedContent:'# java 8 - optional类深度解析\n\n> 对java 8 optional类进行深度解析。 @pdai\n\n * java 8 - optional类深度解析\n   * optional类包含的方法\n     * of\n     * ofnullable\n     * ispresent\n     * get\n     * ifpresent\n     * orelse\n     * orelseget\n     * orelsethrow\n     * map\n     * flatmap\n     * filter\n   * 一些例子\n   * 参考\n\n> 身为一名java程序员，大家可能都有这样的经历: 调用一个方法得到了返回值却不能直接将返回值作为参数去调用别的方法。我们首先要判断这个返回值是否为null，只有在非空的前提下才能将其作为其他方法的参数。这正是一些类似guava的外部api试图解决的问题。一些jvm编程语言比如scala、ceylon等已经将对在核心api中解决了这个问题。在我的前一篇文章中，介绍了scala是如何解决了这个问题。\n\n新版本的java，比如java 8引入了一个新的optional类。optional类的javadoc描述如下:\n\n> 这是一个可以为null的容器对象。如果值存在则ispresent()方法会返回true，调用get()方法会返回该对象。\n\n\n# optional类包含的方法\n\n\n# of\n\n> 为非null的值创建一个optional。\n\nof方法通过工厂方法创建optional类。需要注意的是，创建对象时传入的参数不能为null。如果传入参数为null，则抛出nullpointerexception 。\n\n//调用工厂方法创建optional实例\noptional<string> name = optional.of("sanaulla");\n//传入参数为null，抛出nullpointerexception.\noptional<string> somenull = optional.of(null);\n\n\n\n# ofnullable\n\n> 为指定的值创建一个optional，如果指定的值为null，则返回一个空的optional。\n\nofnullable与of方法相似，唯一的区别是可以接受参数为null的情况。示例如下:\n\n//下面创建了一个不包含任何值的optional实例\n//例如，值为\'null\'\noptional empty = optional.ofnullable(null);\n\n\n\n# ispresent\n\n非常容易理解\n\n> 如果值存在返回true，否则返回false。\n\n类似下面的代码:\n\n//ispresent方法用来检查optional实例中是否包含值\nif (name.ispresent()) {\n  //在optional实例内调用get()返回已存在的值\n  system.out.println(name.get());//输出sanaulla\n}\n\n\n\n# get\n\n> 如果optional有值则将其返回，否则抛出nosuchelementexception。\n\n上面的示例中，get方法用来得到optional实例中的值。下面我们看一个抛出nosuchelementexception的例子:\n\n//执行下面的代码会输出: no value present \ntry {\n  //在空的optional实例上调用get()，抛出nosuchelementexception\n  system.out.println(empty.get());\n} catch (nosuchelementexception ex) {\n  system.out.println(ex.getmessage());\n}\n\n\n\n# ifpresent\n\n> 如果optional实例有值则为其调用consumer，否则不做处理\n\n要理解ifpresent方法，首先需要了解consumer类。简答地说，consumer类包含一个抽象方法。该抽象方法对传入的值进行处理，但没有返回值。java8支持不用接口直接通过lambda表达式传入参数。\n\n如果optional实例有值，调用ifpresent()可以接受接口段或lambda表达式。类似下面的代码:\n\n//ifpresent方法接受lambda表达式作为参数。\n//lambda表达式对optional的值调用consumer进行处理。\nname.ifpresent((value) -> {\n  system.out.println("the length of the value is: " + value.length());\n});\n\n\n\n# orelse\n\n> 如果有值则将其返回，否则返回指定的其它值。\n\n如果optional实例有值则将其返回，否则返回orelse方法传入的参数。示例如下:\n\n//如果值不为null，orelse方法返回optional实例的值。\n//如果为null，返回传入的消息。\n//输出: there is no value present!\nsystem.out.println(empty.orelse("there is no value present!"));\n//输出: sanaulla\nsystem.out.println(name.orelse("there is some value!"));\n\n\n\n# orelseget\n\n> orelseget与orelse方法类似，区别在于得到的默认值。orelse方法将传入的字符串作为默认值，orelseget方法可以接受supplier接口的实现用来生成默认值。示例如下:\n\n//orelseget与orelse方法类似，区别在于orelse传入的是默认值，\n//orelseget可以接受一个lambda表达式生成默认值。\n//输出: default value\nsystem.out.println(empty.orelseget(() -> "default value"));\n//输出: sanaulla\nsystem.out.println(name.orelseget(() -> "default value"));\n\n\n\n# orelsethrow\n\n> 如果有值则将其返回，否则抛出supplier接口创建的异常。\n\n在orelseget方法中，我们传入一个supplier接口。然而，在orelsethrow中我们可以传入一个lambda表达式或方法，如果值不存在来抛出异常。示例如下:\n\ntry {\n  //orelsethrow与orelse方法类似。与返回默认值不同，\n  //orelsethrow会抛出lambda表达式或方法生成的异常 \n\n  empty.orelsethrow(valueabsentexception::new);\n} catch (throwable ex) {\n  //输出: no value present in the optional instance\n  system.out.println(ex.getmessage());\n}\n\n\nvalueabsentexception定义如下:\n\nclass valueabsentexception extends throwable {\n\n  public valueabsentexception() {\n    super();\n  }\n\n  public valueabsentexception(string msg) {\n    super(msg);\n  }\n\n  @override\n  public string getmessage() {\n    return "no value present in the optional instance";\n  }\n}\n\n\n\n# map\n\nmap方法文档说明如下:\n\n> 如果有值，则对其执行调用mapping函数得到返回值。如果返回值不为null，则创建包含mapping返回值的optional作为map方法返回值，否则返回空optional。\n\nmap方法用来对optional实例的值执行一系列操作。通过一组实现了function接口的lambda表达式传入操作。如果你不熟悉function接口，可以参考我的这篇博客。map方法示例如下:\n\n//map方法执行传入的lambda表达式参数对optional实例的值进行修改。\n//为lambda表达式的返回值创建新的optional实例作为map方法的返回值。\noptional<string> uppername = name.map((value) -> value.touppercase());\nsystem.out.println(uppername.orelse("no value found"));\n\n\n\n# flatmap\n\n> 如果有值，为其执行mapping函数返回optional类型返回值，否则返回空optional。flatmap与map(funtion)方法类似，区别在于flatmap中的mapper返回值必须是optional。调用结束时，flatmap不会对结果用optional封装。\n\nflatmap方法与map方法类似，区别在于mapping函数的返回值不同。map方法的mapping函数返回值可以是任何类型t，而flatmap方法的mapping函数必须是optional。\n\n参照map函数，使用flatmap重写的示例如下:\n\n//flatmap与map(function)非常类似，区别在于传入方法的lambda表达式的返回类型。\n//map方法中的lambda表达式返回值可以是任意类型，在map函数返回之前会包装为optional。 \n//但flatmap方法中的lambda表达式返回值必须是optionl实例。 \nuppername = name.flatmap((value) -> optional.of(value.touppercase()));\nsystem.out.println(uppername.orelse("no value found"));//输出sanaulla\n\n\n\n# filter\n\nfilter个方法通过传入限定条件对optional实例的值进行过滤。文档描述如下:\n\n> 如果有值并且满足断言条件返回包含该值的optional，否则返回空optional。\n\n读到这里，可能你已经知道如何为filter方法传入一段代码。是的，这里可以传入一个lambda表达式。对于filter函数我们应该传入实现了predicate接口的lambda表达式。如果你不熟悉predicate接口，可以参考这篇文章。\n\n现在我来看看filter的各种用法，下面的示例介绍了满足限定条件和不满足两种情况:\n\n//filter方法检查给定的option值是否满足某些条件。\n//如果满足则返回同一个option实例，否则返回空optional。\noptional<string> longname = name.filter((value) -> value.length() > 6);\nsystem.out.println(longname.orelse("the name is less than 6 characters"));//输出sanaulla\n\n//另一个例子是optional值不满足filter指定的条件。\noptional<string> anothername = optional.of("sana");\noptional<string> shortname = anothername.filter((value) -> value.length() > 6);\n//输出: name长度不足6字符\nsystem.out.println(shortname.orelse("the name is less than 6 characters"));\n\n\n\n# 一些例子\n\n * 一个综合例子\n\npublic class optionaldemo {\n\n  public static void main(string[] args) {\n    //创建optional实例，也可以通过方法返回值得到。\n    optional<string> name = optional.of("sanaulla");\n\n    //创建没有值的optional实例，例如值为\'null\'\n    optional empty = optional.ofnullable(null);\n\n    //ispresent方法用来检查optional实例是否有值。\n    if (name.ispresent()) {\n      //调用get()返回optional值。\n      system.out.println(name.get());\n    }\n\n    try {\n      //在optional实例上调用get()抛出nosuchelementexception。\n      system.out.println(empty.get());\n    } catch (nosuchelementexception ex) {\n      system.out.println(ex.getmessage());\n    }\n\n    //ifpresent方法接受lambda表达式参数。\n    //如果optional值不为空，lambda表达式会处理并在其上执行操作。\n    name.ifpresent((value) -> {\n      system.out.println("the length of the value is: " + value.length());\n    });\n\n    //如果有值orelse方法会返回optional实例，否则返回传入的错误信息。\n    system.out.println(empty.orelse("there is no value present!"));\n    system.out.println(name.orelse("there is some value!"));\n\n    //orelseget与orelse类似，区别在于传入的默认值。\n    //orelseget接受lambda表达式生成默认值。\n    system.out.println(empty.orelseget(() -> "default value"));\n    system.out.println(name.orelseget(() -> "default value"));\n\n    try {\n      //orelsethrow与orelse方法类似，区别在于返回值。\n      //orelsethrow抛出由传入的lambda表达式/方法生成异常。\n      empty.orelsethrow(valueabsentexception::new);\n    } catch (throwable ex) {\n      system.out.println(ex.getmessage());\n    }\n\n    //map方法通过传入的lambda表达式修改optonal实例默认值。 \n    //lambda表达式返回值会包装为optional实例。\n    optional<string> uppername = name.map((value) -> value.touppercase());\n    system.out.println(uppername.orelse("no value found"));\n\n    //flatmap与map(funtion)非常相似，区别在于lambda表达式的返回值。\n    //map方法的lambda表达式返回值可以是任何类型，但是返回值会包装成optional实例。\n    //但是flatmap方法的lambda返回值总是optional类型。\n    uppername = name.flatmap((value) -> optional.of(value.touppercase()));\n    system.out.println(uppername.orelse("no value found"));\n\n    //filter方法检查optiona值是否满足给定条件。\n    //如果满足返回optional实例值，否则返回空optional。\n    optional<string> longname = name.filter((value) -> value.length() > 6);\n    system.out.println(longname.orelse("the name is less than 6 characters"));\n\n    //另一个示例，optional值不满足给定条件。\n    optional<string> anothername = optional.of("sana");\n    optional<string> shortname = anothername.filter((value) -> value.length() > 6);\n    system.out.println(shortname.orelse("the name is less than 6 characters"));\n\n  }\n}\n\n\n上述代码输出如下:\n\nsanaulla\nno value present\nthe length of the value is: 8\nthere is no value present!\nsanaulla\ndefault value\nsanaulla\nno value present in the optional instance\nsanaulla\nsanaulla\nsanaulla\nthe name is less than 6 characters\n\n\n * 在 java 8 中提高 null 的安全性\n\n假设我们有一个像这样的类层次结构:\n\nclass outer {\n    nested nested;\n    nested getnested() {\n        return nested;\n    }\n}\nclass nested {\n    inner inner;\n    inner getinner() {\n        return inner;\n    }\n}\nclass inner {\n    string foo;\n    string getfoo() {\n        return foo;\n    }\n}\n\n\n解决这种结构的深层嵌套路径是有点麻烦的。我们必须编写一堆 null 检查来确保不会导致一个 nullpointerexception:\n\nouter outer = new outer();\nif (outer != null && outer.nested != null && outer.nested.inner != null) {\n    system.out.println(outer.nested.inner.foo);\n}\n\n\n我们可以通过利用 java 8 的 optional 类型来摆脱所有这些 null 检查。map 方法接收一个 function 类型的 lambda 表达式，并自动将每个 function 的结果包装成一个 optional 对象。这使我们能够在一行中进行多个 map 操作。null 检查是在底层自动处理的。\n\noptional.of(new outer())\n    .map(outer::getnested)\n    .map(nested::getinner)\n    .map(inner::getfoo)\n    .ifpresent(system.out::println);\n\n\n还有一种实现相同作用的方式就是通过利用一个 supplier 函数来解决嵌套路径的问题:\n\nouter obj = new outer();\nresolve(() -> obj.getnested().getinner().getfoo())\n    .ifpresent(system.out::println);\n\n\n调用 obj.getnested().getinner().getfoo()) 可能会抛出一个 nullpointerexception 异常。在这种情况下，该异常将会被捕获，而该方法会返回 optional.empty()。\n\npublic static <t> optional<t> resolve(supplier<t> resolver) {\n    try {\n        t result = resolver.get();\n        return optional.ofnullable(result);\n    }\n    catch (nullpointerexception e) {\n        return optional.empty();\n    }\n}\n\n\n请记住，这两个解决方案可能没有传统 null 检查那么高的性能。不过在大多数情况下不会有太大问题。\n\n\n# 参考\n\n原文链接: javacodegeeks\n\n翻译: importnew.com - 高俊阳\n\n译文链接: http://www.importnew.com/6675.html\n\n转载请保留原文出处、译者和译文链接。',charsets:{cjk:!0}},{title:"Java 8 - 移除Permgen",frontmatter:{},regularPath:"/java/java8/java8-permgen.html",relativePath:"java/java8/java8-permgen.md",key:"v-08deb28e",path:"/java/java8/java8-permgen.html",headers:[{level:2,title:"Java 8 - 移除Permgen",slug:"java-8-移除permgen",normalizedTitle:"java 8 - 移除permgen",charIndex:2},{level:2,title:"PermGen space简单介绍",slug:"permgen-space简单介绍",normalizedTitle:"permgen space简单介绍",charIndex:98},{level:2,title:"元空间(MetaSpace)一种新的内存空间诞生",slug:"元空间-metaspace-一种新的内存空间诞生",normalizedTitle:"元空间(metaspace)一种新的内存空间诞生",charIndex:121},{level:2,title:"PermGen vs. Metaspace 运行时比较",slug:"permgen-vs-metaspace-运行时比较",normalizedTitle:"permgen vs. metaspace 运行时比较",charIndex:151},{level:3,title:"JDK 1.7 @64-bit – PermGen 耗尽测试",slug:"jdk-1-7-64-bit-permgen-耗尽测试",normalizedTitle:"jdk 1.7 @64-bit – permgen 耗尽测试",charIndex:186},{level:3,title:"JDK 1.8 @64-bit – Metaspace大小动态调整测试",slug:"jdk-1-8-64-bit-metaspace大小动态调整测试",normalizedTitle:"jdk 1.8 @64-bit – metaspace大小动态调整测试",charIndex:224},{level:3,title:"JDK 1.8 @64-bit – Metaspace 受限测试",slug:"jdk-1-8-64-bit-metaspace-受限测试",normalizedTitle:"jdk 1.8 @64-bit – metaspace 受限测试",charIndex:267},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:305},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:313}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java 8 - 移除Permgen PermGen space简单介绍 元空间(MetaSpace)一种新的内存空间诞生 PermGen vs. Metaspace 运行时比较 JDK 1.7 @64-bit – PermGen 耗尽测试 JDK 1.8 @64-bit – Metaspace大小动态调整测试 JDK 1.8 @64-bit – Metaspace 受限测试 总结 参考文章",content:'# Java 8 - 移除Permgen\n\n> 本文主要介绍PermGen space，及Java 8 - 移除Permgen。@pdai\n\n * Java 8 - 移除Permgen\n   * PermGen space简单介绍\n   * 元空间(MetaSpace)一种新的内存空间诞生\n   * PermGen vs. Metaspace 运行时比较\n     * JDK 1.7 @64-bit – PermGen 耗尽测试\n     * JDK 1.8 @64-bit – Metaspace大小动态调整测试\n     * JDK 1.8 @64-bit – Metaspace 受限测试\n   * 总结\n   * 参考文章\n\n> 很多开发者都在其系统中见过“java.lang.OutOfMemoryError: PermGen space”这一问题。这往往是由类加载器相关的内存泄漏以及新类加载器的创建导致的，通常出现于代码热部署时。相对于正式产品，该问题在开发机上出现的频率更高，在产品中最常见的“问题”是默认值太低了。常用的解决方法是将其设置为256MB或更高。\n\n\n# PermGen space简单介绍\n\nPermGen space的全称是Permanent Generation space,是指内存的永久保存区域，说说为什么会内存益出: 这一部分用于存放Class和Meta的信息,Class在被 Load的时候被放入PermGen space区域，它和和存放Instance的Heap区域不同,所以如果你的APP会LOAD很多CLASS的话,就很可能出现PermGen space错误。这种错误常见在web服务器对JSP进行pre compile的时候。\n\nJVM 种类有很多，比如 Oralce-Sun Hotspot, Oralce JRockit, IBM J9, Taobao JVM(淘宝好样的！)等等。当然武林盟主是Hotspot了，这个毫无争议。需要注意的是，PermGen space是Oracle-Sun Hotspot才有，JRockit以及J9是没有这个区域。\n\n\n# 元空间(MetaSpace)一种新的内存空间诞生\n\nJDK8 HotSpot JVM 将移除永久区，使用本地内存来存储类元数据信息并称之为: 元空间(Metaspace)；这与Oracle JRockit 和IBM JVM’s很相似，如下图所示\n\n\n\n这意味着不会再有java.lang.OutOfMemoryError: PermGen问题，也不再需要你进行调优及监控内存空间的使用……但请等等，这么说还为时过早。在默认情况下，这些改变是透明的，接下来我们的展示将使你知道仍然要关注类元数据内存的占用。请一定要牢记，这个新特性也不能神奇地消除类和类加载器导致的内存泄漏。\n\njava8中metaspace总结如下:\n\n * PermGen 空间的状况\n\n这部分内存空间将全部移除。\n\nJVM的参数: PermSize 和 MaxPermSize 会被忽略并给出警告(如果在启用时设置了这两个参数)。\n\n * Metaspace 内存分配模型\n\n大部分类元数据都在本地内存中分配。\n\n用于描述类元数据的“klasses”已经被移除。\n\n * Metaspace 容量\n\n默认情况下，类元数据只受可用的本地内存限制(容量取决于是32位或是64位操作系统的可用虚拟内存大小)。\n\n新参数(MaxMetaspaceSize)用于限制本地内存分配给类元数据的大小。如果没有指定这个参数，元空间会在运行时根据需要动态调整。\n\n * Metaspace 垃圾回收\n\n对于僵死的类及类加载器的垃圾回收将在元数据使用达到“MaxMetaspaceSize”参数的设定值时进行。\n\n适时地监控和调整元空间对于减小垃圾回收频率和减少延时是很有必要的。持续的元空间垃圾回收说明，可能存在类、类加载器导致的内存泄漏或是大小设置不合适。\n\n * Java 堆内存的影响\n\n一些杂项数据已经移到Java堆空间中。升级到JDK8之后，会发现Java堆 空间有所增长。\n\n * Metaspace 监控\n\n元空间的使用情况可以从HotSpot1.8的详细GC日志输出中得到。\n\nJstat 和 JVisualVM两个工具，在使用b75版本进行测试时，已经更新了，但是还是能看到老的PermGen空间的出现。\n\n前面已经从理论上充分说明，下面让我们通过“泄漏”程序进行新内存空间的观察……\n\n\n# PermGen vs. Metaspace 运行时比较\n\n为了更好地理解Metaspace内存空间的运行时行为，\n\n将进行以下几种场景的测试:\n\n * 使用JDK1.7运行Java程序，监控并耗尽默认设定的85MB大小的PermGen内存空间。\n * 使用JDK1.8运行Java程序，监控新Metaspace内存空间的动态增长和垃圾回收过程。\n * 使用JDK1.8运行Java程序，模拟耗尽通过“MaxMetaspaceSize”参数设定的128MB大小的Metaspace内存空间。\n\n首先建立了一个模拟PermGen OOM的代码\n\npublic class ClassA {\n public void method(String name) {\n  // do nothing\n }\n}\n\n\n上面是一个简单的ClassA，把他编译成class字节码放到D: /classes下面，测试代码中用URLClassLoader来加载此类型上面类编译成class\n\n/**\n * 模拟PermGen OOM\n * @author benhail\n */\npublic class OOMTest {\n    public static void main(String[] args) {\n        try {\n            //准备url\n            URL url = new File("D:/classes").toURI().toURL();\n            URL[] urls = {url};\n            //获取有关类型加载的JMX接口\n            ClassLoadingMXBean loadingBean = ManagementFactory.getClassLoadingMXBean();\n            //用于缓存类加载器\n            List<ClassLoader> classLoaders = new ArrayList<ClassLoader>();\n            while (true) {\n                //加载类型并缓存类加载器实例\n                ClassLoader classLoader = new URLClassLoader(urls);\n                classLoaders.add(classLoader);\n                classLoader.loadClass("ClassA");\n                //显示数量信息(共加载过的类型数目，当前还有效的类型数目，已经被卸载的类型数目)\n                System.out.println("total: " + loadingBean.getTotalLoadedClassCount());\n                System.out.println("active: " + loadingBean.getLoadedClassCount());\n                System.out.println("unloaded: " + loadingBean.getUnloadedClassCount());\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\n虚拟机器参数设置如下: -verbose -verbose:gc\n\n设置-verbose参数是为了获取类型加载和卸载的信息\n\n设置-verbose:gc是为了获取垃圾收集的相关信息\n\n\n# JDK 1.7 @64-bit – PermGen 耗尽测试\n\nJava1.7的PermGen默认空间为85 MB(或者可以通过-XX:MaxPermSize=XXXm指定)\n\n\n\n可以从上面的JVisualVM的截图看出: 当加载超过6万个类之后，PermGen被耗尽。我们也能通过程序和GC的输出观察耗尽的过程。\n\n程序输出(摘取了部分)\n\n......\n[Loaded ClassA from file:/D:/classes/]\ntotal: 64887\nactive: 64887\nunloaded: 0\n[GC 245041K->213978K(536768K), 0.0597188 secs]\n[Full GC 213978K->211425K(644992K), 0.6456638 secs]\n[GC 211425K->211425K(656448K), 0.0086696 secs]\n[Full GC 211425K->211411K(731008K), 0.6924754 secs]\n[GC 211411K->211411K(726528K), 0.0088992 secs]\n...............\njava.lang.OutOfMemoryError: PermGen space\n\n\n\n# JDK 1.8 @64-bit – Metaspace大小动态调整测试\n\nJava的Metaspace空间: 不受限制 (默认)\n\n\n\n从上面的截图可以看到，JVM Metaspace进行了动态扩展，本地内存的使用由20MB增长到646MB，以满足程序中不断增长的类数据内存占用需求。我们也能观察到JVM的垃圾回收事件—试图销毁僵死的类或类加载器对象。但是，由于我们程序的泄漏，JVM别无选择只能动态扩展Metaspace内存空间。程序加载超过10万个类，而没有出现OOM事件。\n\n\n# JDK 1.8 @64-bit – Metaspace 受限测试\n\nJava的Metaspace空间: 128MB(-XX:MaxMetaspaceSize=128m)\n\n\n\n可以从上面的JVisualVM的截图看出: 当加载超过2万个类之后，Metaspace被耗尽；与JDK1.7运行时非常相似。我们也能通过程序和GC的输出观察耗尽的过程。另一个有趣的现象是，保留的原生内存占用量是设定的最大大小两倍之多。这可能表明，如果可能的话，可微调元空间容量大小策略，来避免本地内存的浪费。\n\n从Java程序的输出中看到如下异常。\n\n[Loaded ClassA from file:/D:/classes/]\ntotal: 21393\nactive: 21393\nunloaded: 0\n[GC (Metadata GC Threshold) 64306K->57010K(111616K), 0.0145502 secs]\n[Full GC (Metadata GC Threshold) 57010K->56810K(122368K), 0.1068084 secs]\njava.lang.OutOfMemoryError: Metaspace\n\n\n在设置了MaxMetaspaceSize的情况下，该空间的内存仍然会耗尽，进而引发“java.lang.OutOfMemoryError: Metadata space”错误。因为类加载器的泄漏仍然存在，而通常Java又不希望无限制地消耗本机内存，因此设置一个类似于MaxPermSize的限制看起来也是合理的。\n\n\n# 总结\n\n * 之前不管是不是需要，JVM都会吃掉那块空间……如果设置得太小，JVM会死掉；如果设置得太大，这块内存就被JVM浪费了。理论上说，现在你完全可以不关注这个，因为JVM会在运行时自动调校为“合适的大小”；\n\n * 提高Full GC的性能，在Full GC期间，Metadata到Metadata pointers之间不需要扫描了，别小看这几纳秒时间；\n\n * 隐患就是如果程序存在内存泄露，像OOMTest那样，不停的扩展metaspace的空间，会导致机器的内存不足，所以还是要有必要的调试和监控。\n\n\n# 参考文章\n\nhttps://wizardforcel.gitbooks.io/java8-new-features/content/9.html',normalizedContent:'# java 8 - 移除permgen\n\n> 本文主要介绍permgen space，及java 8 - 移除permgen。@pdai\n\n * java 8 - 移除permgen\n   * permgen space简单介绍\n   * 元空间(metaspace)一种新的内存空间诞生\n   * permgen vs. metaspace 运行时比较\n     * jdk 1.7 @64-bit – permgen 耗尽测试\n     * jdk 1.8 @64-bit – metaspace大小动态调整测试\n     * jdk 1.8 @64-bit – metaspace 受限测试\n   * 总结\n   * 参考文章\n\n> 很多开发者都在其系统中见过“java.lang.outofmemoryerror: permgen space”这一问题。这往往是由类加载器相关的内存泄漏以及新类加载器的创建导致的，通常出现于代码热部署时。相对于正式产品，该问题在开发机上出现的频率更高，在产品中最常见的“问题”是默认值太低了。常用的解决方法是将其设置为256mb或更高。\n\n\n# permgen space简单介绍\n\npermgen space的全称是permanent generation space,是指内存的永久保存区域，说说为什么会内存益出: 这一部分用于存放class和meta的信息,class在被 load的时候被放入permgen space区域，它和和存放instance的heap区域不同,所以如果你的app会load很多class的话,就很可能出现permgen space错误。这种错误常见在web服务器对jsp进行pre compile的时候。\n\njvm 种类有很多，比如 oralce-sun hotspot, oralce jrockit, ibm j9, taobao jvm(淘宝好样的！)等等。当然武林盟主是hotspot了，这个毫无争议。需要注意的是，permgen space是oracle-sun hotspot才有，jrockit以及j9是没有这个区域。\n\n\n# 元空间(metaspace)一种新的内存空间诞生\n\njdk8 hotspot jvm 将移除永久区，使用本地内存来存储类元数据信息并称之为: 元空间(metaspace)；这与oracle jrockit 和ibm jvm’s很相似，如下图所示\n\n\n\n这意味着不会再有java.lang.outofmemoryerror: permgen问题，也不再需要你进行调优及监控内存空间的使用……但请等等，这么说还为时过早。在默认情况下，这些改变是透明的，接下来我们的展示将使你知道仍然要关注类元数据内存的占用。请一定要牢记，这个新特性也不能神奇地消除类和类加载器导致的内存泄漏。\n\njava8中metaspace总结如下:\n\n * permgen 空间的状况\n\n这部分内存空间将全部移除。\n\njvm的参数: permsize 和 maxpermsize 会被忽略并给出警告(如果在启用时设置了这两个参数)。\n\n * metaspace 内存分配模型\n\n大部分类元数据都在本地内存中分配。\n\n用于描述类元数据的“klasses”已经被移除。\n\n * metaspace 容量\n\n默认情况下，类元数据只受可用的本地内存限制(容量取决于是32位或是64位操作系统的可用虚拟内存大小)。\n\n新参数(maxmetaspacesize)用于限制本地内存分配给类元数据的大小。如果没有指定这个参数，元空间会在运行时根据需要动态调整。\n\n * metaspace 垃圾回收\n\n对于僵死的类及类加载器的垃圾回收将在元数据使用达到“maxmetaspacesize”参数的设定值时进行。\n\n适时地监控和调整元空间对于减小垃圾回收频率和减少延时是很有必要的。持续的元空间垃圾回收说明，可能存在类、类加载器导致的内存泄漏或是大小设置不合适。\n\n * java 堆内存的影响\n\n一些杂项数据已经移到java堆空间中。升级到jdk8之后，会发现java堆 空间有所增长。\n\n * metaspace 监控\n\n元空间的使用情况可以从hotspot1.8的详细gc日志输出中得到。\n\njstat 和 jvisualvm两个工具，在使用b75版本进行测试时，已经更新了，但是还是能看到老的permgen空间的出现。\n\n前面已经从理论上充分说明，下面让我们通过“泄漏”程序进行新内存空间的观察……\n\n\n# permgen vs. metaspace 运行时比较\n\n为了更好地理解metaspace内存空间的运行时行为，\n\n将进行以下几种场景的测试:\n\n * 使用jdk1.7运行java程序，监控并耗尽默认设定的85mb大小的permgen内存空间。\n * 使用jdk1.8运行java程序，监控新metaspace内存空间的动态增长和垃圾回收过程。\n * 使用jdk1.8运行java程序，模拟耗尽通过“maxmetaspacesize”参数设定的128mb大小的metaspace内存空间。\n\n首先建立了一个模拟permgen oom的代码\n\npublic class classa {\n public void method(string name) {\n  // do nothing\n }\n}\n\n\n上面是一个简单的classa，把他编译成class字节码放到d: /classes下面，测试代码中用urlclassloader来加载此类型上面类编译成class\n\n/**\n * 模拟permgen oom\n * @author benhail\n */\npublic class oomtest {\n    public static void main(string[] args) {\n        try {\n            //准备url\n            url url = new file("d:/classes").touri().tourl();\n            url[] urls = {url};\n            //获取有关类型加载的jmx接口\n            classloadingmxbean loadingbean = managementfactory.getclassloadingmxbean();\n            //用于缓存类加载器\n            list<classloader> classloaders = new arraylist<classloader>();\n            while (true) {\n                //加载类型并缓存类加载器实例\n                classloader classloader = new urlclassloader(urls);\n                classloaders.add(classloader);\n                classloader.loadclass("classa");\n                //显示数量信息(共加载过的类型数目，当前还有效的类型数目，已经被卸载的类型数目)\n                system.out.println("total: " + loadingbean.gettotalloadedclasscount());\n                system.out.println("active: " + loadingbean.getloadedclasscount());\n                system.out.println("unloaded: " + loadingbean.getunloadedclasscount());\n            }\n        } catch (exception e) {\n            e.printstacktrace();\n        }\n    }\n}\n\n\n虚拟机器参数设置如下: -verbose -verbose:gc\n\n设置-verbose参数是为了获取类型加载和卸载的信息\n\n设置-verbose:gc是为了获取垃圾收集的相关信息\n\n\n# jdk 1.7 @64-bit – permgen 耗尽测试\n\njava1.7的permgen默认空间为85 mb(或者可以通过-xx:maxpermsize=xxxm指定)\n\n\n\n可以从上面的jvisualvm的截图看出: 当加载超过6万个类之后，permgen被耗尽。我们也能通过程序和gc的输出观察耗尽的过程。\n\n程序输出(摘取了部分)\n\n......\n[loaded classa from file:/d:/classes/]\ntotal: 64887\nactive: 64887\nunloaded: 0\n[gc 245041k->213978k(536768k), 0.0597188 secs]\n[full gc 213978k->211425k(644992k), 0.6456638 secs]\n[gc 211425k->211425k(656448k), 0.0086696 secs]\n[full gc 211425k->211411k(731008k), 0.6924754 secs]\n[gc 211411k->211411k(726528k), 0.0088992 secs]\n...............\njava.lang.outofmemoryerror: permgen space\n\n\n\n# jdk 1.8 @64-bit – metaspace大小动态调整测试\n\njava的metaspace空间: 不受限制 (默认)\n\n\n\n从上面的截图可以看到，jvm metaspace进行了动态扩展，本地内存的使用由20mb增长到646mb，以满足程序中不断增长的类数据内存占用需求。我们也能观察到jvm的垃圾回收事件—试图销毁僵死的类或类加载器对象。但是，由于我们程序的泄漏，jvm别无选择只能动态扩展metaspace内存空间。程序加载超过10万个类，而没有出现oom事件。\n\n\n# jdk 1.8 @64-bit – metaspace 受限测试\n\njava的metaspace空间: 128mb(-xx:maxmetaspacesize=128m)\n\n\n\n可以从上面的jvisualvm的截图看出: 当加载超过2万个类之后，metaspace被耗尽；与jdk1.7运行时非常相似。我们也能通过程序和gc的输出观察耗尽的过程。另一个有趣的现象是，保留的原生内存占用量是设定的最大大小两倍之多。这可能表明，如果可能的话，可微调元空间容量大小策略，来避免本地内存的浪费。\n\n从java程序的输出中看到如下异常。\n\n[loaded classa from file:/d:/classes/]\ntotal: 21393\nactive: 21393\nunloaded: 0\n[gc (metadata gc threshold) 64306k->57010k(111616k), 0.0145502 secs]\n[full gc (metadata gc threshold) 57010k->56810k(122368k), 0.1068084 secs]\njava.lang.outofmemoryerror: metaspace\n\n\n在设置了maxmetaspacesize的情况下，该空间的内存仍然会耗尽，进而引发“java.lang.outofmemoryerror: metadata space”错误。因为类加载器的泄漏仍然存在，而通常java又不希望无限制地消耗本机内存，因此设置一个类似于maxpermsize的限制看起来也是合理的。\n\n\n# 总结\n\n * 之前不管是不是需要，jvm都会吃掉那块空间……如果设置得太小，jvm会死掉；如果设置得太大，这块内存就被jvm浪费了。理论上说，现在你完全可以不关注这个，因为jvm会在运行时自动调校为“合适的大小”；\n\n * 提高full gc的性能，在full gc期间，metadata到metadata pointers之间不需要扫描了，别小看这几纳秒时间；\n\n * 隐患就是如果程序存在内存泄露，像oomtest那样，不停的扩展metaspace的空间，会导致机器的内存不足，所以还是要有必要的调试和监控。\n\n\n# 参考文章\n\nhttps://wizardforcel.gitbooks.io/java8-new-features/content/9.html',charsets:{cjk:!0}},{title:"Java 8 - StampedLock",frontmatter:{},regularPath:"/java/java8/java8-stampedlock.html",relativePath:"java/java8/java8-stampedlock.md",key:"v-f4a06f18",path:"/java/java8/java8-stampedlock.html",headers:[{level:2,title:"Java 8 - StampedLock",slug:"java-8-stampedlock",normalizedTitle:"java 8 - stampedlock",charIndex:2},{level:2,title:"synchronized",slug:"synchronized",normalizedTitle:"synchronized",charIndex:30},{level:2,title:"Lock",slug:"lock",normalizedTitle:"lock",charIndex:18},{level:2,title:"StampedLock",slug:"stampedlock",normalizedTitle:"stampedlock",charIndex:11},{level:2,title:"StampedLock与ReadWriteLock性能对比",slug:"stampedlock与readwritelock性能对比",normalizedTitle:"stampedlock与readwritelock性能对比",charIndex:176},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:211},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:219}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java 8 - StampedLock synchronized Lock StampedLock StampedLock与ReadWriteLock性能对比 总结 参考",content:"# Java 8 - StampedLock\n\n> 本文将从synchronized、Lock到Java8新增的StampedLock进行对比分析，相信StampedLock不会让大家失望。@pdai\n\n * Java 8 - StampedLock\n   * synchronized\n   * Lock\n   * StampedLock\n   * StampedLock与ReadWriteLock性能对比\n   * 总结\n   * 参考\n\n\n# synchronized\n\n在java5之前，实现同步主要是使用synchronized。它是Java语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。\n\n有四种不同的同步块:\n\n实例方法\n静态方法\n实例方法中的同步块\n静态方法中的同步块\n\n\n大家对此应该不陌生，所以不多讲了，以下是代码示例\n\nsynchronized(this)\n// do operation\n}\n\n\n小结: 在多线程并发编程中Synchronized一直是元老级角色，很多人都会称呼它为重量级锁，但是随着Java SE1.6对Synchronized进行了各种优化之后，性能上也有所提升。\n\n\n# Lock\n\nrwlock.writeLock().lock();\ntry {\n\t// do operation\n} finally {\n\trwlock.writeLock().unlock();\n}\n\n\n它是Java 5在java.util.concurrent.locks新增的一个API。\n\nLock是一个接口，核心方法是lock()，unlock()，tryLock()，实现类有ReentrantLock, ReentrantReadWriteLock.ReadLock, ReentrantReadWriteLock.WriteLock；\n\nReentrantReadWriteLock, ReentrantLock 和synchronized锁都有相同的内存语义。\n\n与synchronized不同的是，Lock完全用Java写成，在java这个层面是无关JVM实现的。Lock提供更灵活的锁机制，很多synchronized 没有提供的许多特性，比如锁投票，定时锁等候和中断锁等候，但因为lock是通过代码实现的，要保证锁定一定会被释放，就必须将unLock()放到finally{}中\n\n下面是Lock的一个代码示例\n\nclass Point {\n   private double x, y;\n   private final StampedLock sl = new StampedLock();\n   void move(double deltaX, double deltaY) { // an exclusively locked method\n     long stamp = sl.writeLock();\n     try {\n       x += deltaX;\n       y += deltaY;\n     } finally {\n       sl.unlockWrite(stamp);\n     }\n   }\n  \t//下面看看乐观读锁案例\n   double distanceFromOrigin() { // A read-only method\n     long stamp = sl.tryOptimisticRead(); //获得一个乐观读锁\n     double currentX = x, currentY = y; //将两个字段读入本地局部变量\n     if (!sl.validate(stamp)) { //检查发出乐观读锁后同时是否有其他写锁发生? \n        stamp = sl.readLock(); //如果没有，我们再次获得一个读悲观锁\n        try {\n          currentX = x; // 将两个字段读入本地局部变量\n          currentY = y; // 将两个字段读入本地局部变量\n        } finally {\n           sl.unlockRead(stamp);\n        }\n     }\n     return Math.sqrt(currentX * currentX + currentY * currentY);\n   }\n\t//下面是悲观读锁案例\n   void moveIfAtOrigin(double newX, double newY) { // upgrade\n     // Could instead start with optimistic, not read mode\n     long stamp = sl.readLock();\n     try {\n       while (x == 0.0 && y == 0.0) { //循环，检查当前状态是否符合\n         long ws = sl.tryConvertToWriteLock(stamp); //将读锁转为写锁\n         if (ws != 0L) { //这是确认转为写锁是否成功\n           stamp = ws; //如果成功 替换票据\n           x = newX; //进行状态改变\n           y = newY; //进行状态改变\n           break;\n         }\n         else { //如果不能成功转换为写锁\n           sl.unlockRead(stamp); //我们显式释放读锁\n           stamp = sl.writeLock(); //显式直接进行写锁 然后再通过循环再试\n         }\n       }\n     } finally {\n       sl.unlock(stamp); //释放读锁或写锁\n     }\n   }\n }\n\n\n小结: 比synchronized更灵活、更具可伸缩性的锁定机制，但不管怎么说还是synchronized代码要更容易书写些\n\n\n# StampedLock\n\n它是java8在java.util.concurrent.locks新增的一个API。\n\nReentrantReadWriteLock 在沒有任何读写锁时，才可以取得写入锁，这可用于实现了悲观读取(Pessimistic Reading)，即如果执行中进行读取时，经常可能有另一执行要写入的需求，为了保持同步，ReentrantReadWriteLock 的读取锁定就可派上用场。\n\n然而，如果读取执行情况很多，写入很少的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿(Starvation)问题，也就是写入线程迟迟无法竞争到锁定而一直处于等待状态。\n\nStampedLock控制锁有三种模式(写，读，乐观读)，一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。\n\n所谓的乐观读模式，也就是若读的操作很多，写的操作很少的情况下，你可以乐观地认为，写入与读取同时发生几率很少，因此不悲观地使用完全的读取锁定，程序可以查看读取资料之后，是否遭到写入执行的变更，再采取后续的措施(重新读取变更信息，或者抛出异常) ，这一个小小改进，可大幅度提高程序的吞吐量！！\n\n下面是java doc提供的StampedLock一个例子\n\nclass Point {\n   private double x, y;\n   private final StampedLock sl = new StampedLock();\n   void move(double deltaX, double deltaY) { // an exclusively locked method\n     long stamp = sl.writeLock();\n     try {\n       x += deltaX;\n       y += deltaY;\n     } finally {\n       sl.unlockWrite(stamp);\n     }\n   }\n  //下面看看乐观读锁案例\n   double distanceFromOrigin() { // A read-only method\n     long stamp = sl.tryOptimisticRead(); //获得一个乐观读锁\n     double currentX = x, currentY = y; //将两个字段读入本地局部变量\n     if (!sl.validate(stamp)) { //检查发出乐观读锁后同时是否有其他写锁发生? \n        stamp = sl.readLock(); //如果没有，我们再次获得一个读悲观锁\n        try {\n          currentX = x; // 将两个字段读入本地局部变量\n          currentY = y; // 将两个字段读入本地局部变量\n        } finally {\n           sl.unlockRead(stamp);\n        }\n     }\n     return Math.sqrt(currentX * currentX + currentY * currentY);\n   }\n\t//下面是悲观读锁案例\n   void moveIfAtOrigin(double newX, double newY) { // upgrade\n     // Could instead start with optimistic, not read mode\n     long stamp = sl.readLock();\n     try {\n       while (x == 0.0 && y == 0.0) { //循环，检查当前状态是否符合\n         long ws = sl.tryConvertToWriteLock(stamp); //将读锁转为写锁\n         if (ws != 0L) { //这是确认转为写锁是否成功\n           stamp = ws; //如果成功 替换票据\n           x = newX; //进行状态改变\n           y = newY; //进行状态改变\n           break;\n         }\n         else { //如果不能成功转换为写锁\n           sl.unlockRead(stamp); //我们显式释放读锁\n           stamp = sl.writeLock(); //显式直接进行写锁 然后再通过循环再试\n         }\n       }\n     } finally {\n       sl.unlock(stamp); //释放读锁或写锁\n     }\n   }\n }\n\n\n小结:\n\nStampedLock要比ReentrantReadWriteLock更加廉价，也就是消耗比较小。\n\n\n# StampedLock与ReadWriteLock性能对比\n\n是和ReadWritLock相比，在一个线程情况下，是读速度其4倍左右，写是1倍。\n\n下图是六个线程情况下，读性能是其几十倍，写性能也是近10倍左右:\n\n\n\n\n# 总结\n\n * synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定；\n * ReentrantLock、ReentrantReadWriteLock,、StampedLock都是对象层面的锁定，要保证锁定一定会被释放，就必须将unLock()放到finally{}中；\n * StampedLock 对吞吐量有巨大的改进，特别是在读线程越来越多的场景下；\n * StampedLock有一个复杂的API，对于加锁操作，很容易误用其他方法;\n * 当只有少量竞争者的时候，synchronized是一个很好的通用的锁实现;\n * 当线程增长能够预估，ReentrantLock是一个很好的通用的锁实现;\n\nStampedLock 可以说是Lock的一个很好的补充，吞吐量以及性能上的提升足以打动很多人了，但并不是说要替代之前Lock的东西，毕竟他还是有些应用场景的，起码API比StampedLock容易入手。\n\n\n# 参考\n\n * https://wizardforcel.gitbooks.io/java8-tutorials/content/Java%208%20%E5%B9%B6%E5%8F%91%E6%95%99%E7%A8%8B%20Threads%20%E5%92%8C%20Executors.html\n\n * https://wizardforcel.gitbooks.io/java8-new-features/content/10.html",normalizedContent:"# java 8 - stampedlock\n\n> 本文将从synchronized、lock到java8新增的stampedlock进行对比分析，相信stampedlock不会让大家失望。@pdai\n\n * java 8 - stampedlock\n   * synchronized\n   * lock\n   * stampedlock\n   * stampedlock与readwritelock性能对比\n   * 总结\n   * 参考\n\n\n# synchronized\n\n在java5之前，实现同步主要是使用synchronized。它是java语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。\n\n有四种不同的同步块:\n\n实例方法\n静态方法\n实例方法中的同步块\n静态方法中的同步块\n\n\n大家对此应该不陌生，所以不多讲了，以下是代码示例\n\nsynchronized(this)\n// do operation\n}\n\n\n小结: 在多线程并发编程中synchronized一直是元老级角色，很多人都会称呼它为重量级锁，但是随着java se1.6对synchronized进行了各种优化之后，性能上也有所提升。\n\n\n# lock\n\nrwlock.writelock().lock();\ntry {\n\t// do operation\n} finally {\n\trwlock.writelock().unlock();\n}\n\n\n它是java 5在java.util.concurrent.locks新增的一个api。\n\nlock是一个接口，核心方法是lock()，unlock()，trylock()，实现类有reentrantlock, reentrantreadwritelock.readlock, reentrantreadwritelock.writelock；\n\nreentrantreadwritelock, reentrantlock 和synchronized锁都有相同的内存语义。\n\n与synchronized不同的是，lock完全用java写成，在java这个层面是无关jvm实现的。lock提供更灵活的锁机制，很多synchronized 没有提供的许多特性，比如锁投票，定时锁等候和中断锁等候，但因为lock是通过代码实现的，要保证锁定一定会被释放，就必须将unlock()放到finally{}中\n\n下面是lock的一个代码示例\n\nclass point {\n   private double x, y;\n   private final stampedlock sl = new stampedlock();\n   void move(double deltax, double deltay) { // an exclusively locked method\n     long stamp = sl.writelock();\n     try {\n       x += deltax;\n       y += deltay;\n     } finally {\n       sl.unlockwrite(stamp);\n     }\n   }\n  \t//下面看看乐观读锁案例\n   double distancefromorigin() { // a read-only method\n     long stamp = sl.tryoptimisticread(); //获得一个乐观读锁\n     double currentx = x, currenty = y; //将两个字段读入本地局部变量\n     if (!sl.validate(stamp)) { //检查发出乐观读锁后同时是否有其他写锁发生? \n        stamp = sl.readlock(); //如果没有，我们再次获得一个读悲观锁\n        try {\n          currentx = x; // 将两个字段读入本地局部变量\n          currenty = y; // 将两个字段读入本地局部变量\n        } finally {\n           sl.unlockread(stamp);\n        }\n     }\n     return math.sqrt(currentx * currentx + currenty * currenty);\n   }\n\t//下面是悲观读锁案例\n   void moveifatorigin(double newx, double newy) { // upgrade\n     // could instead start with optimistic, not read mode\n     long stamp = sl.readlock();\n     try {\n       while (x == 0.0 && y == 0.0) { //循环，检查当前状态是否符合\n         long ws = sl.tryconverttowritelock(stamp); //将读锁转为写锁\n         if (ws != 0l) { //这是确认转为写锁是否成功\n           stamp = ws; //如果成功 替换票据\n           x = newx; //进行状态改变\n           y = newy; //进行状态改变\n           break;\n         }\n         else { //如果不能成功转换为写锁\n           sl.unlockread(stamp); //我们显式释放读锁\n           stamp = sl.writelock(); //显式直接进行写锁 然后再通过循环再试\n         }\n       }\n     } finally {\n       sl.unlock(stamp); //释放读锁或写锁\n     }\n   }\n }\n\n\n小结: 比synchronized更灵活、更具可伸缩性的锁定机制，但不管怎么说还是synchronized代码要更容易书写些\n\n\n# stampedlock\n\n它是java8在java.util.concurrent.locks新增的一个api。\n\nreentrantreadwritelock 在沒有任何读写锁时，才可以取得写入锁，这可用于实现了悲观读取(pessimistic reading)，即如果执行中进行读取时，经常可能有另一执行要写入的需求，为了保持同步，reentrantreadwritelock 的读取锁定就可派上用场。\n\n然而，如果读取执行情况很多，写入很少的情况下，使用 reentrantreadwritelock 可能会使写入线程遭遇饥饿(starvation)问题，也就是写入线程迟迟无法竞争到锁定而一直处于等待状态。\n\nstampedlock控制锁有三种模式(写，读，乐观读)，一个stampedlock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。\n\n所谓的乐观读模式，也就是若读的操作很多，写的操作很少的情况下，你可以乐观地认为，写入与读取同时发生几率很少，因此不悲观地使用完全的读取锁定，程序可以查看读取资料之后，是否遭到写入执行的变更，再采取后续的措施(重新读取变更信息，或者抛出异常) ，这一个小小改进，可大幅度提高程序的吞吐量！！\n\n下面是java doc提供的stampedlock一个例子\n\nclass point {\n   private double x, y;\n   private final stampedlock sl = new stampedlock();\n   void move(double deltax, double deltay) { // an exclusively locked method\n     long stamp = sl.writelock();\n     try {\n       x += deltax;\n       y += deltay;\n     } finally {\n       sl.unlockwrite(stamp);\n     }\n   }\n  //下面看看乐观读锁案例\n   double distancefromorigin() { // a read-only method\n     long stamp = sl.tryoptimisticread(); //获得一个乐观读锁\n     double currentx = x, currenty = y; //将两个字段读入本地局部变量\n     if (!sl.validate(stamp)) { //检查发出乐观读锁后同时是否有其他写锁发生? \n        stamp = sl.readlock(); //如果没有，我们再次获得一个读悲观锁\n        try {\n          currentx = x; // 将两个字段读入本地局部变量\n          currenty = y; // 将两个字段读入本地局部变量\n        } finally {\n           sl.unlockread(stamp);\n        }\n     }\n     return math.sqrt(currentx * currentx + currenty * currenty);\n   }\n\t//下面是悲观读锁案例\n   void moveifatorigin(double newx, double newy) { // upgrade\n     // could instead start with optimistic, not read mode\n     long stamp = sl.readlock();\n     try {\n       while (x == 0.0 && y == 0.0) { //循环，检查当前状态是否符合\n         long ws = sl.tryconverttowritelock(stamp); //将读锁转为写锁\n         if (ws != 0l) { //这是确认转为写锁是否成功\n           stamp = ws; //如果成功 替换票据\n           x = newx; //进行状态改变\n           y = newy; //进行状态改变\n           break;\n         }\n         else { //如果不能成功转换为写锁\n           sl.unlockread(stamp); //我们显式释放读锁\n           stamp = sl.writelock(); //显式直接进行写锁 然后再通过循环再试\n         }\n       }\n     } finally {\n       sl.unlock(stamp); //释放读锁或写锁\n     }\n   }\n }\n\n\n小结:\n\nstampedlock要比reentrantreadwritelock更加廉价，也就是消耗比较小。\n\n\n# stampedlock与readwritelock性能对比\n\n是和readwritlock相比，在一个线程情况下，是读速度其4倍左右，写是1倍。\n\n下图是六个线程情况下，读性能是其几十倍，写性能也是近10倍左右:\n\n\n\n\n# 总结\n\n * synchronized是在jvm层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，jvm会自动释放锁定；\n * reentrantlock、reentrantreadwritelock,、stampedlock都是对象层面的锁定，要保证锁定一定会被释放，就必须将unlock()放到finally{}中；\n * stampedlock 对吞吐量有巨大的改进，特别是在读线程越来越多的场景下；\n * stampedlock有一个复杂的api，对于加锁操作，很容易误用其他方法;\n * 当只有少量竞争者的时候，synchronized是一个很好的通用的锁实现;\n * 当线程增长能够预估，reentrantlock是一个很好的通用的锁实现;\n\nstampedlock 可以说是lock的一个很好的补充，吞吐量以及性能上的提升足以打动很多人了，但并不是说要替代之前lock的东西，毕竟他还是有些应用场景的，起码api比stampedlock容易入手。\n\n\n# 参考\n\n * https://wizardforcel.gitbooks.io/java8-tutorials/content/java%208%20%e5%b9%b6%e5%8f%91%e6%95%99%e7%a8%8b%20threads%20%e5%92%8c%20executors.html\n\n * https://wizardforcel.gitbooks.io/java8-new-features/content/10.html",charsets:{cjk:!0}},{title:"Java 8 - 其它更新: 字符串，base64,...",frontmatter:{},regularPath:"/java/java8/java8-others.html",relativePath:"java/java8/java8-others.md",key:"v-3a16cf30",path:"/java/java8/java8-others.html",headers:[{level:2,title:"Java 8 - 其它更新: 字符串，base64,...",slug:"java-8-其它更新-字符串-base64",normalizedTitle:"java 8 - 其它更新: 字符串，base64,...",charIndex:2},{level:2,title:"处理数值",slug:"处理数值",normalizedTitle:"处理数值",charIndex:156},{level:2,title:"处理文件",slug:"处理文件",normalizedTitle:"处理文件",charIndex:166},{level:2,title:"查找文件",slug:"查找文件",normalizedTitle:"查找文件",charIndex:176},{level:2,title:"读写文件",slug:"读写文件",normalizedTitle:"读写文件",charIndex:186},{level:2,title:"java.util.Random",slug:"java-util-random",normalizedTitle:"java.util.random",charIndex:196},{level:2,title:"java.util.Base64",slug:"java-util-base64",normalizedTitle:"java.util.base64",charIndex:218},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:240}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java 8 - 其它更新: 字符串，base64,... 处理数值 处理文件 查找文件 读写文件 java.util.Random java.util.Base64 参考",content:'# Java 8 - 其它更新: 字符串，base64,...\n\n> 本文对Java 8 其它更新介绍和解读。转载@pdai https://www.pdai.tech/md/java/java8/java8-others.html\n\n * Java 8 - 其它更新: 字符串，base64,...\n   * 处理数值\n   * 处理文件\n   * 查找文件\n   * 读写文件\n   * java.util.Random\n   * java.util.Base64\n   * 参考\n\n\n# 处理数值\n\nJava8添加了对无符号数的额外支持。Java中的数值总是有符号的，例如，让我们来观察Integer:\n\nint可表示最多2 ** 32个数。Java中的数值默认为有符号的，所以最后一个二进制数字表示符号(0为正数，1为负数)。所以从十进制的0开始，最大的有符号正整数为2 ** 31 - 1。\n\n你可以通过Integer.MAX_VALUE来访问它:\n\nSystem.out.println(Integer.MAX_VALUE);      // 2147483647\nSystem.out.println(Integer.MAX_VALUE + 1);  // -2147483648\n\n\nJava8添加了解析无符号整数的支持，让我们看看它如何工作:\n\nlong maxUnsignedInt = (1l << 32) - 1;\nString string = String.valueOf(maxUnsignedInt);\nint unsignedInt = Integer.parseUnsignedInt(string, 10);\nString string2 = Integer.toUnsignedString(unsignedInt, 10);\n\n\n就像你看到的那样，现在可以将最大的无符号数2 ** 32 - 1解析为整数。而且你也可以将这个数值转换回无符号数的字符串表示。\n\n这在之前不可能使用parseInt完成，就像这个例子展示的那样:\n\ntry {\n    Integer.parseInt(string, 10);\n}\ncatch (NumberFormatException e) {\n    System.err.println("could not parse signed int of " + maxUnsignedInt);\n}\n\n\n这个数值不可解析为有符号整数，因为它超出了最大范围2 ** 31 - 1。 算术运算\n\nMath工具类新增了一些方法来处理数值溢出。这是什么意思呢? 我们已经看到了所有数值类型都有最大值。所以当算术运算的结果不能被它的大小装下时，会发生什么呢?\n\nSystem.out.println(Integer.MAX_VALUE);      // 2147483647\nSystem.out.println(Integer.MAX_VALUE + 1);  // -2147483648\n\n\n就像你看到的那样，发生了整数溢出，这通常是我们不愿意看到的。\n\nJava8添加了严格数学运算的支持来解决这个问题。Math扩展了一些方法，它们全部以exact结尾，例如addExact。当运算结果不能被数值类型装下时，这些方法通过抛出ArithmeticException异常来合理地处理溢出。\n\ntry {\n    Math.addExact(Integer.MAX_VALUE, 1);\n}\ncatch (ArithmeticException e) {\n    System.err.println(e.getMessage());\n    // => integer overflow\n}\n\n\n当尝试通过toIntExact将长整数转换为整数时，可能会抛出同样的异常:\n\ntry {\n    Math.toIntExact(Long.MAX_VALUE);\n}\ncatch (ArithmeticException e) {\n    System.err.println(e.getMessage());\n    // => integer overflow\n}\n\n\n\n# 处理文件\n\nFiles工具类首次在Java7中引入，作为NIO的一部分。JDK8 API添加了一些额外的方法，它们可以将文件用于函数式数据流。让我们深入探索一些代码示例。 列出文件\n\nFiles.list方法将指定目录的所有路径转换为数据流，便于我们在文件系统的内容上使用类似filter和sorted的流操作。\n\ntry (Stream<Path> stream = Files.list(Paths.get(""))) {\n    String joined = stream\n        .map(String::valueOf)\n        .filter(path -> !path.startsWith("."))\n        .sorted()\n        .collect(Collectors.joining("; "));\n    System.out.println("List: " + joined);\n}\n\n\n上面的例子列出了当前工作目录的所有文件，之后将每个路径都映射为它的字符串表示。之后结果被过滤、排序，最后连接为一个字符串。如果你还不熟悉函数式数据流，你应该阅读我的Java8数据流教程。\n\n你可能已经注意到，数据流的创建包装在try-with语句中。数据流实现了AutoCloseable，并且这里我们需要显式关闭数据流，因为它基于IO操作。\n\n> 返回的数据流是DirectoryStream的封装。如果需要及时处理文件资源，就应该使用try-with结构来确保在流式操作完成后，数据流的close方法被调用。\n\n\n# 查找文件\n\n下面的例子演示了如何查找在目录及其子目录下的文件:\n\nPath start = Paths.get("");\nint maxDepth = 5;\ntry (Stream<Path> stream = Files.find(start, maxDepth, (path, attr) ->\n        String.valueOf(path).endsWith(".js"))) {\n    String joined = stream\n        .sorted()\n        .map(String::valueOf)\n        .collect(Collectors.joining("; "));\n    System.out.println("Found: " + joined);\n}\n\n\nfind方法接受三个参数: 目录路径start是起始点，maxDepth定义了最大搜索深度。第三个参数是一个匹配谓词，定义了搜索的逻辑。上面的例子中，我们搜索了所有JavaScirpt文件(以.js结尾的文件名)。\n\n我们可以使用Files.walk方法来完成相同的行为。这个方法会遍历每个文件，而不需要传递搜索谓词。\n\nPath start = Paths.get("");\nint maxDepth = 5;\ntry (Stream<Path> stream = Files.walk(start, maxDepth)) {\n    String joined = stream\n        .map(String::valueOf)\n        .filter(path -> path.endsWith(".js"))\n        .sorted()\n        .collect(Collectors.joining("; "));\n    System.out.println("walk(): " + joined);\n}\n\n\n这个例子中，我们使用了流式操作filter来完成和上个例子相同的行为。\n\n\n# 读写文件\n\n将文本文件读到内存，以及向文本文件写入字符串在Java 8 中是简单的任务。不需要再去摆弄读写器了。Files.readAllLines从指定的文件把所有行读进字符串列表中。你可以简单地修改这个列表，并且将它通过Files.write写到另一个文件中:\n\nList<String> lines = Files.readAllLines(Paths.get("res/nashorn1.js"));\nlines.add("print(\'foobar\');");\nFiles.write(Paths.get("res/nashorn1-modified.js"), lines);\n\n\n要注意这些方法对内存并不十分高效，因为整个文件都会读进内存。文件越大，所用的堆区也就越大。\n\n你可以使用Files.lines方法来作为内存高效的替代。这个方法读取每一行，并使用函数式数据流来对其流式处理，而不是一次性把所有行都读进内存。\n\ntry (Stream<String> stream = Files.lines(Paths.get("res/nashorn1.js"))) {\n    stream\n        .filter(line -> line.contains("print"))\n        .map(String::trim)\n        .forEach(System.out::println);\n}\n\n\n如果你需要更多的精细控制，你需要构造一个新的BufferedReader来代替:\n\nPath path = Paths.get("res/nashorn1.js");\ntry (BufferedReader reader = Files.newBufferedReader(path)) {\n    System.out.println(reader.readLine());\n}\n\n\n或者，你需要写入文件时，简单地构造一个BufferedWriter来代替:\n\nPath path = Paths.get("res/output.js");\ntry (BufferedWriter writer = Files.newBufferedWriter(path)) {\n    writer.write("print(\'Hello World\');");\n}\n\n\nBufferedReader也可以访问函数式数据流。lines方法在它所有行上面构建数据流:\n\nPath path = Paths.get("res/nashorn1.js");\ntry (BufferedReader reader = Files.newBufferedReader(path)) {\n    long countPrints = reader\n        .lines()\n        .filter(line -> line.contains("print"))\n        .count();\n    System.out.println(countPrints);\n}\n\n\n目前为止你可以看到Java8提供了三个简单的方法来读取文本文件的每一行，使文件处理更加便捷。\n\n不幸的是你需要显式使用try-with语句来关闭文件流，这会使示例代码有些凌乱。我期待函数式数据流可以在调用类似count和collect时可以自动关闭，因为你不能在相同数据流上调用终止操作两次。\n\n\n# java.util.Random\n\n在Java8中java.util.Random类的一个非常明显的变化就是新增了返回随机数流(random Stream of numbers)的一些方法。\n\n下面的代码是创建一个无穷尽的double类型的数字流，这些数字在0(包括0)和1(不包含1)之间。\n\nRandom random = new Random();\nDoubleStream doubleStream = random.doubles();\n\n\n下面的代码是创建一个无穷尽的int类型的数字流，这些数字在0(包括0)和100(不包括100)之间。\n\nRandom random = new Random();\nIntStream intStream = random.ints(0, 100);\n\n\n那么这些无穷尽的数字流用来做什么呢? 接下来，我通过一些案例来分析。记住，这些无穷大的数字流只能通过某种方式被截断(limited)。\n\n示例1: 创建10个随机的整数流并打印出来:\n\nintStream.limit(10).forEach(System.out::println);\n\n\n示例2: 创建100个随机整数:\n\n    List<Integer> randomBetween0And99 = intStream\n                                       .limit(100)\n                                       .boxed()\n                                       .collect(Collectors.toList());\n\n\n对于高斯伪随机数(gaussian pseudo-random values)来说，random.doubles()方法所创建的流不能等价于高斯伪随机数，然而，如果用java8所提供的功能是非常容易实现的。\n\nRandom random = new Random();\nDoubleStream gaussianStream = Stream.generate(random::nextGaussian).mapToDouble(e -> e);\n\n\n这里，我使用了Stream.generate api，并传入Supplier 类的对象作为参数，这个对象是通过调用Random类中的方法 nextGaussian()创建另一个高斯伪随机数。\n\n接下来，我们来对double类型的伪随机数流和double类型的高斯伪随机数流做一个更加有意思的事情，那就是获得两个流的随机数的分配情况。预期的结果是: double类型的伪随机数是均匀的分配的，而double类型的高斯伪随机数应该是正态分布的。\n\n通过下面的代码，我生成了一百万个伪随机数，这是通过java8提供的api实现的:\n\nRandom random = new Random();\nDoubleStream doubleStream = random.doubles(-1.0, 1.0);\nLinkedHashMap<Range, Integer> rangeCountMap = doubleStream.limit(1000000)\n    .boxed()\n    .map(Ranges::of)\n    .collect(Ranges::emptyRangeCountMap, (m, e) -> m.put(e, m.get(e) + 1), Ranges::mergeRangeCountMaps);\n\nrangeCountMap.forEach((k, v) -> System.out.println(k.from() + "\\t" + v));\n\n\n代码的运行结果如下:\n\n    -1      49730\n    -0.9    49931\n    -0.8    50057\n    -0.7    50060\n    -0.6    49963\n    -0.5    50159\n    -0.4    49921\n    -0.3    49962\n    -0.2    50231\n    -0.1    49658\n    0       50177\n    0.1     49861\n    0.2     49947\n    0.3     50157\n    0.4     50414\n    0.5     50006\n    0.6     50038\n    0.7     49962\n    0.8     50071\n    0.9     49695\n\n\n为了类比，我们再生成一百万个高斯伪随机数:\n\nRandom random = new Random();\nDoubleStream gaussianStream = Stream.generate(random::nextGaussian).mapToDouble(e -> e);\nLinkedHashMap<Range, Integer> gaussianRangeCountMap =\n    gaussianStream\n            .filter(e -> (e >= -1.0 && e < 1.0))\n            .limit(1000000)\n            .boxed()\n            .map(Ranges::of)\n            .collect(Ranges::emptyRangeCountMap, (m, e) -> m.put(e, m.get(e) + 1), Ranges::mergeRangeCountMaps);\n\ngaussianRangeCountMap.forEach((k, v) -> System.out.println(k.from() + "\\t" + v));\n\n\n上面代码输出的结果恰恰与我们预期结果相吻合，即: double类型的伪随机数是均匀的分配的，而double类型的高斯伪随机数应该是正态分布的。\n\n附: 完整代码可点击这里获取 https://gist.github.com/bijukunjummen/8129250\n\n译文链接: http://www.importnew.com/9672.html\n\n\n# java.util.Base64\n\n> Java8中java.util.Base64性能比较高，推荐使用。请参考:\n\n * 性能对比: https://wizardforcel.gitbooks.io/java8-new-features/content/11.html\n * 源代码: http://git.oschina.net/benhail/javase8-sample\n\n该类提供了一套静态方法获取下面三种BASE64编解码器:\n\n1)Basic编码: 是标准的BASE64编码，用于处理常规的需求\n\n// 编码\nString asB64 = Base64.getEncoder().encodeToString("some string".getBytes("utf-8"));\nSystem.out.println(asB64); // 输出为: c29tZSBzdHJpbmc=\n// 解码\nbyte[] asBytes = Base64.getDecoder().decode("c29tZSBzdHJpbmc=");\nSystem.out.println(new String(asBytes, "utf-8")); // 输出为: some string\n\n\n2)URL编码: 使用下划线替换URL里面的反斜线“/”\n\nString urlEncoded = Base64.getUrlEncoder().encodeToString("subjects?abcd".getBytes("utf-8"));\nSystem.out.println("Using URL Alphabet: " + urlEncoded);\n// 输出为:\nUsing URL Alphabet: c3ViamVjdHM_YWJjZA==\n\n\n3)MIME编码: 使用基本的字母数字产生BASE64输出，而且对MIME格式友好: 每一行输出不超过76个字符，而且每行以“\\r\\n”符结束。\n\nStringBuilder sb = new StringBuilder();\nfor (int t = 0; t < 10; ++t) {\n  sb.append(UUID.randomUUID().toString());\n}\nbyte[] toEncode = sb.toString().getBytes("utf-8");\nString mimeEncoded = Base64.getMimeEncoder().encodeToString(toEncode);\nSystem.out.println(mimeEncoded);\n\n\n\n# 参考\n\n * https://wizardforcel.gitbooks.io/modern-java/ch7.html\n\n * http://www.importnew.com/9672.html',normalizedContent:'# java 8 - 其它更新: 字符串，base64,...\n\n> 本文对java 8 其它更新介绍和解读。转载@pdai https://www.pdai.tech/md/java/java8/java8-others.html\n\n * java 8 - 其它更新: 字符串，base64,...\n   * 处理数值\n   * 处理文件\n   * 查找文件\n   * 读写文件\n   * java.util.random\n   * java.util.base64\n   * 参考\n\n\n# 处理数值\n\njava8添加了对无符号数的额外支持。java中的数值总是有符号的，例如，让我们来观察integer:\n\nint可表示最多2 ** 32个数。java中的数值默认为有符号的，所以最后一个二进制数字表示符号(0为正数，1为负数)。所以从十进制的0开始，最大的有符号正整数为2 ** 31 - 1。\n\n你可以通过integer.max_value来访问它:\n\nsystem.out.println(integer.max_value);      // 2147483647\nsystem.out.println(integer.max_value + 1);  // -2147483648\n\n\njava8添加了解析无符号整数的支持，让我们看看它如何工作:\n\nlong maxunsignedint = (1l << 32) - 1;\nstring string = string.valueof(maxunsignedint);\nint unsignedint = integer.parseunsignedint(string, 10);\nstring string2 = integer.tounsignedstring(unsignedint, 10);\n\n\n就像你看到的那样，现在可以将最大的无符号数2 ** 32 - 1解析为整数。而且你也可以将这个数值转换回无符号数的字符串表示。\n\n这在之前不可能使用parseint完成，就像这个例子展示的那样:\n\ntry {\n    integer.parseint(string, 10);\n}\ncatch (numberformatexception e) {\n    system.err.println("could not parse signed int of " + maxunsignedint);\n}\n\n\n这个数值不可解析为有符号整数，因为它超出了最大范围2 ** 31 - 1。 算术运算\n\nmath工具类新增了一些方法来处理数值溢出。这是什么意思呢? 我们已经看到了所有数值类型都有最大值。所以当算术运算的结果不能被它的大小装下时，会发生什么呢?\n\nsystem.out.println(integer.max_value);      // 2147483647\nsystem.out.println(integer.max_value + 1);  // -2147483648\n\n\n就像你看到的那样，发生了整数溢出，这通常是我们不愿意看到的。\n\njava8添加了严格数学运算的支持来解决这个问题。math扩展了一些方法，它们全部以exact结尾，例如addexact。当运算结果不能被数值类型装下时，这些方法通过抛出arithmeticexception异常来合理地处理溢出。\n\ntry {\n    math.addexact(integer.max_value, 1);\n}\ncatch (arithmeticexception e) {\n    system.err.println(e.getmessage());\n    // => integer overflow\n}\n\n\n当尝试通过tointexact将长整数转换为整数时，可能会抛出同样的异常:\n\ntry {\n    math.tointexact(long.max_value);\n}\ncatch (arithmeticexception e) {\n    system.err.println(e.getmessage());\n    // => integer overflow\n}\n\n\n\n# 处理文件\n\nfiles工具类首次在java7中引入，作为nio的一部分。jdk8 api添加了一些额外的方法，它们可以将文件用于函数式数据流。让我们深入探索一些代码示例。 列出文件\n\nfiles.list方法将指定目录的所有路径转换为数据流，便于我们在文件系统的内容上使用类似filter和sorted的流操作。\n\ntry (stream<path> stream = files.list(paths.get(""))) {\n    string joined = stream\n        .map(string::valueof)\n        .filter(path -> !path.startswith("."))\n        .sorted()\n        .collect(collectors.joining("; "));\n    system.out.println("list: " + joined);\n}\n\n\n上面的例子列出了当前工作目录的所有文件，之后将每个路径都映射为它的字符串表示。之后结果被过滤、排序，最后连接为一个字符串。如果你还不熟悉函数式数据流，你应该阅读我的java8数据流教程。\n\n你可能已经注意到，数据流的创建包装在try-with语句中。数据流实现了autocloseable，并且这里我们需要显式关闭数据流，因为它基于io操作。\n\n> 返回的数据流是directorystream的封装。如果需要及时处理文件资源，就应该使用try-with结构来确保在流式操作完成后，数据流的close方法被调用。\n\n\n# 查找文件\n\n下面的例子演示了如何查找在目录及其子目录下的文件:\n\npath start = paths.get("");\nint maxdepth = 5;\ntry (stream<path> stream = files.find(start, maxdepth, (path, attr) ->\n        string.valueof(path).endswith(".js"))) {\n    string joined = stream\n        .sorted()\n        .map(string::valueof)\n        .collect(collectors.joining("; "));\n    system.out.println("found: " + joined);\n}\n\n\nfind方法接受三个参数: 目录路径start是起始点，maxdepth定义了最大搜索深度。第三个参数是一个匹配谓词，定义了搜索的逻辑。上面的例子中，我们搜索了所有javascirpt文件(以.js结尾的文件名)。\n\n我们可以使用files.walk方法来完成相同的行为。这个方法会遍历每个文件，而不需要传递搜索谓词。\n\npath start = paths.get("");\nint maxdepth = 5;\ntry (stream<path> stream = files.walk(start, maxdepth)) {\n    string joined = stream\n        .map(string::valueof)\n        .filter(path -> path.endswith(".js"))\n        .sorted()\n        .collect(collectors.joining("; "));\n    system.out.println("walk(): " + joined);\n}\n\n\n这个例子中，我们使用了流式操作filter来完成和上个例子相同的行为。\n\n\n# 读写文件\n\n将文本文件读到内存，以及向文本文件写入字符串在java 8 中是简单的任务。不需要再去摆弄读写器了。files.readalllines从指定的文件把所有行读进字符串列表中。你可以简单地修改这个列表，并且将它通过files.write写到另一个文件中:\n\nlist<string> lines = files.readalllines(paths.get("res/nashorn1.js"));\nlines.add("print(\'foobar\');");\nfiles.write(paths.get("res/nashorn1-modified.js"), lines);\n\n\n要注意这些方法对内存并不十分高效，因为整个文件都会读进内存。文件越大，所用的堆区也就越大。\n\n你可以使用files.lines方法来作为内存高效的替代。这个方法读取每一行，并使用函数式数据流来对其流式处理，而不是一次性把所有行都读进内存。\n\ntry (stream<string> stream = files.lines(paths.get("res/nashorn1.js"))) {\n    stream\n        .filter(line -> line.contains("print"))\n        .map(string::trim)\n        .foreach(system.out::println);\n}\n\n\n如果你需要更多的精细控制，你需要构造一个新的bufferedreader来代替:\n\npath path = paths.get("res/nashorn1.js");\ntry (bufferedreader reader = files.newbufferedreader(path)) {\n    system.out.println(reader.readline());\n}\n\n\n或者，你需要写入文件时，简单地构造一个bufferedwriter来代替:\n\npath path = paths.get("res/output.js");\ntry (bufferedwriter writer = files.newbufferedwriter(path)) {\n    writer.write("print(\'hello world\');");\n}\n\n\nbufferedreader也可以访问函数式数据流。lines方法在它所有行上面构建数据流:\n\npath path = paths.get("res/nashorn1.js");\ntry (bufferedreader reader = files.newbufferedreader(path)) {\n    long countprints = reader\n        .lines()\n        .filter(line -> line.contains("print"))\n        .count();\n    system.out.println(countprints);\n}\n\n\n目前为止你可以看到java8提供了三个简单的方法来读取文本文件的每一行，使文件处理更加便捷。\n\n不幸的是你需要显式使用try-with语句来关闭文件流，这会使示例代码有些凌乱。我期待函数式数据流可以在调用类似count和collect时可以自动关闭，因为你不能在相同数据流上调用终止操作两次。\n\n\n# java.util.random\n\n在java8中java.util.random类的一个非常明显的变化就是新增了返回随机数流(random stream of numbers)的一些方法。\n\n下面的代码是创建一个无穷尽的double类型的数字流，这些数字在0(包括0)和1(不包含1)之间。\n\nrandom random = new random();\ndoublestream doublestream = random.doubles();\n\n\n下面的代码是创建一个无穷尽的int类型的数字流，这些数字在0(包括0)和100(不包括100)之间。\n\nrandom random = new random();\nintstream intstream = random.ints(0, 100);\n\n\n那么这些无穷尽的数字流用来做什么呢? 接下来，我通过一些案例来分析。记住，这些无穷大的数字流只能通过某种方式被截断(limited)。\n\n示例1: 创建10个随机的整数流并打印出来:\n\nintstream.limit(10).foreach(system.out::println);\n\n\n示例2: 创建100个随机整数:\n\n    list<integer> randombetween0and99 = intstream\n                                       .limit(100)\n                                       .boxed()\n                                       .collect(collectors.tolist());\n\n\n对于高斯伪随机数(gaussian pseudo-random values)来说，random.doubles()方法所创建的流不能等价于高斯伪随机数，然而，如果用java8所提供的功能是非常容易实现的。\n\nrandom random = new random();\ndoublestream gaussianstream = stream.generate(random::nextgaussian).maptodouble(e -> e);\n\n\n这里，我使用了stream.generate api，并传入supplier 类的对象作为参数，这个对象是通过调用random类中的方法 nextgaussian()创建另一个高斯伪随机数。\n\n接下来，我们来对double类型的伪随机数流和double类型的高斯伪随机数流做一个更加有意思的事情，那就是获得两个流的随机数的分配情况。预期的结果是: double类型的伪随机数是均匀的分配的，而double类型的高斯伪随机数应该是正态分布的。\n\n通过下面的代码，我生成了一百万个伪随机数，这是通过java8提供的api实现的:\n\nrandom random = new random();\ndoublestream doublestream = random.doubles(-1.0, 1.0);\nlinkedhashmap<range, integer> rangecountmap = doublestream.limit(1000000)\n    .boxed()\n    .map(ranges::of)\n    .collect(ranges::emptyrangecountmap, (m, e) -> m.put(e, m.get(e) + 1), ranges::mergerangecountmaps);\n\nrangecountmap.foreach((k, v) -> system.out.println(k.from() + "\\t" + v));\n\n\n代码的运行结果如下:\n\n    -1      49730\n    -0.9    49931\n    -0.8    50057\n    -0.7    50060\n    -0.6    49963\n    -0.5    50159\n    -0.4    49921\n    -0.3    49962\n    -0.2    50231\n    -0.1    49658\n    0       50177\n    0.1     49861\n    0.2     49947\n    0.3     50157\n    0.4     50414\n    0.5     50006\n    0.6     50038\n    0.7     49962\n    0.8     50071\n    0.9     49695\n\n\n为了类比，我们再生成一百万个高斯伪随机数:\n\nrandom random = new random();\ndoublestream gaussianstream = stream.generate(random::nextgaussian).maptodouble(e -> e);\nlinkedhashmap<range, integer> gaussianrangecountmap =\n    gaussianstream\n            .filter(e -> (e >= -1.0 && e < 1.0))\n            .limit(1000000)\n            .boxed()\n            .map(ranges::of)\n            .collect(ranges::emptyrangecountmap, (m, e) -> m.put(e, m.get(e) + 1), ranges::mergerangecountmaps);\n\ngaussianrangecountmap.foreach((k, v) -> system.out.println(k.from() + "\\t" + v));\n\n\n上面代码输出的结果恰恰与我们预期结果相吻合，即: double类型的伪随机数是均匀的分配的，而double类型的高斯伪随机数应该是正态分布的。\n\n附: 完整代码可点击这里获取 https://gist.github.com/bijukunjummen/8129250\n\n译文链接: http://www.importnew.com/9672.html\n\n\n# java.util.base64\n\n> java8中java.util.base64性能比较高，推荐使用。请参考:\n\n * 性能对比: https://wizardforcel.gitbooks.io/java8-new-features/content/11.html\n * 源代码: http://git.oschina.net/benhail/javase8-sample\n\n该类提供了一套静态方法获取下面三种base64编解码器:\n\n1)basic编码: 是标准的base64编码，用于处理常规的需求\n\n// 编码\nstring asb64 = base64.getencoder().encodetostring("some string".getbytes("utf-8"));\nsystem.out.println(asb64); // 输出为: c29tzsbzdhjpbmc=\n// 解码\nbyte[] asbytes = base64.getdecoder().decode("c29tzsbzdhjpbmc=");\nsystem.out.println(new string(asbytes, "utf-8")); // 输出为: some string\n\n\n2)url编码: 使用下划线替换url里面的反斜线“/”\n\nstring urlencoded = base64.geturlencoder().encodetostring("subjects?abcd".getbytes("utf-8"));\nsystem.out.println("using url alphabet: " + urlencoded);\n// 输出为:\nusing url alphabet: c3viamvjdhm_ywjjza==\n\n\n3)mime编码: 使用基本的字母数字产生base64输出，而且对mime格式友好: 每一行输出不超过76个字符，而且每行以“\\r\\n”符结束。\n\nstringbuilder sb = new stringbuilder();\nfor (int t = 0; t < 10; ++t) {\n  sb.append(uuid.randomuuid().tostring());\n}\nbyte[] toencode = sb.tostring().getbytes("utf-8");\nstring mimeencoded = base64.getmimeencoder().encodetostring(toencode);\nsystem.out.println(mimeencoded);\n\n\n\n# 参考\n\n * https://wizardforcel.gitbooks.io/modern-java/ch7.html\n\n * http://www.importnew.com/9672.html',charsets:{cjk:!0}},{title:"Java 8 - 函数编程(lambda表达式)",frontmatter:{},regularPath:"/java/java8/java8-stream.html",relativePath:"java/java8/java8-stream.md",key:"v-fd7622f0",path:"/java/java8/java8-stream.html",headers:[{level:2,title:"Java 8 - 函数编程(lambda表达式)",slug:"java-8-函数编程-lambda表达式",normalizedTitle:"java 8 - 函数编程(lambda表达式)",charIndex:2},{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:100},{level:2,title:"lambda表达式",slug:"lambda表达式",normalizedTitle:"lambda表达式",charIndex:16},{level:2,title:"分类",slug:"分类",normalizedTitle:"分类",charIndex:123},{level:3,title:"惰性求值方法",slug:"惰性求值方法",normalizedTitle:"惰性求值方法",charIndex:133},{level:3,title:"及早求值方法",slug:"及早求值方法",normalizedTitle:"及早求值方法",charIndex:147},{level:2,title:"stream & parallelStream",slug:"stream-parallelstream",normalizedTitle:"stream &amp; parallelstream",charIndex:null},{level:3,title:"stream & parallelStream",slug:"stream-parallelstream-2",normalizedTitle:"stream &amp; parallelstream",charIndex:null},{level:3,title:"parallelStream原理:",slug:"parallelstream原理",normalizedTitle:"parallelstream原理:",charIndex:221},{level:3,title:"stream与parallelStream性能测试对比",slug:"stream与parallelstream性能测试对比",normalizedTitle:"stream与parallelstream性能测试对比",charIndex:246},{level:3,title:"Stream中常用方法如下:",slug:"stream中常用方法如下",normalizedTitle:"stream中常用方法如下:",charIndex:281},{level:2,title:"常用例子",slug:"常用例子",normalizedTitle:"常用例子",charIndex:301},{level:3,title:"匿名类简写",slug:"匿名类简写",normalizedTitle:"匿名类简写",charIndex:313},{level:3,title:"forEach",slug:"foreach",normalizedTitle:"foreach",charIndex:326},{level:3,title:"方法引用",slug:"方法引用",normalizedTitle:"方法引用",charIndex:341},{level:3,title:"Filter & Predicate",slug:"filter-predicate",normalizedTitle:"filter &amp; predicate",charIndex:null},{level:3,title:"Map&Reduce",slug:"map-reduce",normalizedTitle:"map&amp;reduce",charIndex:null},{level:3,title:"Collectors",slug:"collectors",normalizedTitle:"collectors",charIndex:397},{level:3,title:"flatMap",slug:"flatmap",normalizedTitle:"flatmap",charIndex:415},{level:3,title:"distinct",slug:"distinct",normalizedTitle:"distinct",charIndex:430},{level:3,title:"count",slug:"count",normalizedTitle:"count",charIndex:446},{level:3,title:"Match",slug:"match",normalizedTitle:"match",charIndex:459},{level:3,title:"min,max,summaryStatistics",slug:"min-max-summarystatistics",normalizedTitle:"min,max,summarystatistics",charIndex:472},{level:3,title:"peek",slug:"peek",normalizedTitle:"peek",charIndex:505},{level:2,title:"FunctionalInterface",slug:"functionalinterface",normalizedTitle:"functionalinterface",charIndex:515},{level:3,title:"理解注解 @FunctionInterface",slug:"理解注解-functioninterface",normalizedTitle:"理解注解 @functioninterface",charIndex:542},{level:3,title:"自定义函数接口",slug:"自定义函数接口",normalizedTitle:"自定义函数接口",charIndex:573},{level:3,title:"内置四大函数接口",slug:"内置四大函数接口",normalizedTitle:"内置四大函数接口",charIndex:588},{level:2,title:"一些例子",slug:"一些例子",normalizedTitle:"一些例子",charIndex:602},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:612}],lastUpdated:"2023/4/10 01:17:23",lastUpdatedTimestamp:1681060643e3,headersStr:"Java 8 - 函数编程(lambda表达式) 简介 lambda表达式 分类 惰性求值方法 及早求值方法 stream & parallelStream stream & parallelStream parallelStream原理: stream与parallelStream性能测试对比 Stream中常用方法如下: 常用例子 匿名类简写 forEach 方法引用 Filter & Predicate Map&Reduce Collectors flatMap distinct count Match min,max,summaryStatistics peek FunctionalInterface 理解注解 @FunctionInterface 自定义函数接口 内置四大函数接口 一些例子 参考资料",content:'# Java 8 - 函数编程(lambda表达式)\n\n> 我们关心的是如何写出好代码，而不是符合函数编程风格的代码。 @pdai\n\n * Java 8 - 函数编程(lambda表达式)\n   * 简介\n   * lambda表达式\n   * 分类\n     * 惰性求值方法\n     * 及早求值方法\n   * stream & parallelStream\n     * stream & parallelStream\n     * parallelStream原理:\n     * stream与parallelStream性能测试对比\n     * Stream中常用方法如下:\n   * 常用例子\n     * 匿名类简写\n     * forEach\n     * 方法引用\n     * Filter & Predicate\n     * Map&Reduce\n     * Collectors\n     * flatMap\n     * distinct\n     * count\n     * Match\n     * min,max,summaryStatistics\n     * peek\n   * FunctionalInterface\n     * 理解注解 @FunctionInterface\n     * 自定义函数接口\n     * 内置四大函数接口\n   * 一些例子\n   * 参考资料\n\n\n# 简介\n\n> 在Java世界里面，面向对象还是主流思想，对于习惯了面向对象编程的开发者来说，抽象的概念并不陌生。面向对象编程是对数据进行抽象，而函数式编程是对行为进行抽象。现实世界中，数据和行为并存，程序也是如此，因此这两种编程方式我们都得学。\n\n> 这种新的抽象方式还有其他好处。很多人不总是在编写性能优先的代码，对于这些人来说，函数式编程带来的好处尤为明显。程序员能编写出更容易阅读的代码——这种代码更多地表达了业务逻辑，而不是从机制上如何实现。易读的代码也易于维护、更可靠、更不容易出错。\n\n> 在写回调函数和事件处理器时，程序员不必再纠缠于匿名内部类的冗繁和可读性，函数式编程让事件处理系统变得更加简单。能将函数方便地传递也让编写惰性代码变得容易，只有在真正需要的时候，才初始化变量的值。\n\n面向对象编程是对数据进行抽象；函数式编程是对行为进行抽象。\n\n核心思想: 使用不可变值和函数，函数对一个值进行处理，映射成另一个值。\n\n对核心类库的改进主要包括集合类的API和新引入的流Stream。流使程序员可以站在更高的抽象层次上对集合进行操作。\n\n\n# lambda表达式\n\n * lambda表达式仅能放入如下代码: 预定义使用了 @Functional 注释的函数式接口，自带一个抽象函数的方法，或者SAM(Single Abstract Method 单个抽象方法)类型。这些称为lambda表达式的目标类型，可以用作返回类型，或lambda目标代码的参数。例如，若一个方法接收Runnable、Comparable或者 Callable 接口，都有单个抽象方法，可以传入lambda表达式。类似的，如果一个方法接受声明于 java.util.function 包内的接口，例如 Predicate、Function、Consumer 或 Supplier，那么可以向其传lambda表达式。\n\n * lambda表达式内可以使用方法引用，仅当该方法不修改lambda表达式提供的参数。本例中的lambda表达式可以换为方法引用，因为这仅是一个参数相同的简单方法调用。\n\nlist.forEach(n -> System.out.println(n)); \nlist.forEach(System.out::println);  // 使用方法引用\n\n\n然而，若对参数有任何修改，则不能使用方法引用，而需键入完整地lambda表达式，如下所示:\n\nlist.forEach((String s) -> System.out.println("*" + s + "*"));\n\n\n事实上，可以省略这里的lambda参数的类型声明，编译器可以从列表的类属性推测出来。\n\n * lambda内部可以使用静态、非静态和局部变量，这称为lambda内的变量捕获。\n\n * Lambda表达式在Java中又称为闭包或匿名函数，所以如果有同事把它叫闭包的时候，不用惊讶。\n\n * Lambda方法在编译器内部被翻译成私有方法，并派发 invokedynamic 字节码指令来进行调用。可以使用JDK中的 javap 工具来反编译class文件。使用 javap -p 或 javap -c -v 命令来看一看lambda表达式生成的字节码。大致应该长这样:\n\nprivate static java.lang.Object lambda$0(java.lang.String);\n\n\n * lambda表达式有个限制，那就是只能引用 final 或 final 局部变量，这就是说不能在lambda内部修改定义在域外的变量。\n\nList<Integer> primes = Arrays.asList(new Integer[]{2, 3,5,7});\nint factor = 2;\nprimes.forEach(element -> { factor++; });\n\n\nCompile time error : "local variables referenced from a lambda expression must be final or effectively final" 另外，只是访问它而不作修改是可以的，如下所示:\n\nList<Integer> primes = Arrays.asList(new Integer[]{2, 3,5,7});\nint factor = 2;\nprimes.forEach(element -> { System.out.println(factor*element); });\n\n\n\n# 分类\n\n\n# 惰性求值方法\n\nlists.stream().filter(f -> f.getName().equals("p1"))\n\n\n如上示例，这行代码并未做什么实际性的工作，filter只是描述了Stream，没有产生新的集合。\n\n如果是多个条件组合，可以通过代码块{}\n\n\n# 及早求值方法\n\nList<Person> list2 = lists.stream().filter(f -> f.getName().equals("p1")).collect(Collectors.toList());\n\n\n如上示例，collect最终会从Stream产生新值，拥有终止操作。\n\n理想方式是形成一个惰性求值的链，最后用一个及早求值的操作返回想要的结果。与建造者模式相似，建造者模式先是使用一系列操作设置属性和配置，最后调用build方法，创建对象。\n\n\n# stream & parallelStream\n\n\n# stream & parallelStream\n\n每个Stream都有两种模式: 顺序执行和并行执行。\n\n顺序流:\n\nList <Person> people = list.getStream.collect(Collectors.toList());\n\n\n并行流:\n\nList <Person> people = list.getStream.parallel().collect(Collectors.toList());\n\n\n顾名思义，当使用顺序方式去遍历时，每个item读完后再读下一个item。而使用并行去遍历时，数组会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。\n\n\n# parallelStream原理:\n\nList originalList = someData;\nsplit1 = originalList(0, mid);//将数据分小部分\nsplit2 = originalList(mid,end);\nnew Runnable(split1.process());//小部分执行操作\nnew Runnable(split2.process());\nList revisedList = split1 + split2;//将结果合并\n\n\n大家对hadoop有稍微了解就知道，里面的 MapReduce 本身就是用于并行处理大数据集的软件框架，其 处理大数据的核心思想就是大而化小，分配到不同机器去运行map，最终通过reduce将所有机器的结果结合起来得到一个最终结果，与MapReduce不同，Stream则是利用多核技术可将大数据通过多核并行处理，而MapReduce则可以分布式的。\n\n\n# stream与parallelStream性能测试对比\n\n如果是多核机器，理论上并行流则会比顺序流快上一倍，下面是测试代码\n\nlong t0 = System.nanoTime();\n\n//初始化一个范围100万整数流,求能被2整除的数字，toArray()是终点方法\n\nint a[]=IntStream.range(0, 1_000_000).filter(p -> p % 2==0).toArray();\n\nlong t1 = System.nanoTime();\n\n//和上面功能一样，这里是用并行流来计算\n\nint b[]=IntStream.range(0, 1_000_000).parallel().filter(p -> p % 2==0).toArray();\n\nlong t2 = System.nanoTime();\n\n//我本机的结果是serial: 0.06s, parallel 0.02s，证明并行流确实比顺序流快\n\nSystem.out.printf("serial: %.2fs, parallel %.2fs%n", (t1 - t0) * 1e-9, (t2 - t1) * 1e-9);\n\n\n\n# Stream中常用方法如下:\n\n * stream(), parallelStream()\n * filter()\n * findAny() findFirst()\n * sort\n * forEach void\n * map(), reduce()\n * flatMap() - 将多个Stream连接成一个Stream\n * collect(Collectors.toList())\n * distinct, limit\n * count\n * min, max, summaryStatistics\n\n看下所有API:\n\n\n\n\n# 常用例子\n\n\n# 匿名类简写\n\nnew Thread( () -> System.out.println("In Java8, Lambda expression rocks !!") ).start();\n\n// 用法\n(params) -> expression\n(params) -> statement\n(params) -> { statements }\n\n\n\n# forEach\n\n// forEach\nList features = Arrays.asList("Lambdas", "Default Method", "Stream API", "Date and Time API");\nfeatures.forEach(n -> System.out.println(n));\n \n// 使用Java 8的方法引用更方便，方法引用由::双冒号操作符标示，\nfeatures.forEach(System.out::println);\n\n\n\n# 方法引用\n\n构造引用\n\n// Supplier<Student> s = () -> new Student();\nSupplier<Student> s = Student::new;\n\n\n对象::实例方法 Lambda表达式的(形参列表)与实例方法的(实参列表)类型，个数是对应\n\n// set.forEach(t -> System.out.println(t));\nset.forEach(System.out::println);\n\n\n类名::静态方法\n\n// Stream<Double> stream = Stream.generate(() -> Math.random());\nStream<Double> stream = Stream.generate(Math::random);\n\n\n类名::实例方法\n\n//  TreeSet<String> set = new TreeSet<>((s1,s2) -> s1.compareTo(s2));\n/*  这里如果使用第一句话，编译器会有提示: Can be replaced with Comparator.naturalOrder，这句话告诉我们\n  String已经重写了compareTo()方法，在这里写是多此一举，这里为什么这么写，是因为为了体现下面\n  这句编译器的提示: Lambda can be replaced with method reference。好了，下面的这句就是改写成方法引用之后: \n*/\nTreeSet<String> set = new TreeSet<>(String::compareTo);\n\n\n\n# Filter & Predicate\n\n常规用法\n\npublic static void main(args[]){\n    List languages = Arrays.asList("Java", "Scala", "C++", "Haskell", "Lisp");\n \n    System.out.println("Languages which starts with J :");\n    filter(languages, (str)->str.startsWith("J"));\n \n    System.out.println("Languages which ends with a ");\n    filter(languages, (str)->str.endsWith("a"));\n \n    System.out.println("Print all languages :");\n    filter(languages, (str)->true);\n \n    System.out.println("Print no language : ");\n    filter(languages, (str)->false);\n \n    System.out.println("Print language whose length greater than 4:");\n    filter(languages, (str)->str.length() > 4);\n}\n \npublic static void filter(List names, Predicate condition) {\n    names.stream().filter((name) -> (condition.test(name))).forEach((name) -> {\n        System.out.println(name + " ");\n    });\n}\n\n\n多个Predicate组合filter\n\n// 可以用and()、or()和xor()逻辑函数来合并Predicate，\n// 例如要找到所有以J开始，长度为四个字母的名字，你可以合并两个Predicate并传入\nPredicate<String> startsWithJ = (n) -> n.startsWith("J");\nPredicate<String> fourLetterLong = (n) -> n.length() == 4;\nnames.stream()\n    .filter(startsWithJ.and(fourLetterLong))\n    .forEach((n) -> System.out.print("nName, which starts with \'J\' and four letter long is : " + n));\n\n\n\n# Map&Reduce\n\nmap将集合类(例如列表)元素进行转换的。还有一个 reduce() 函数可以将所有值合并成一个\n\nList costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);\ndouble bill = costBeforeTax.stream().map((cost) -> cost + .12*cost).reduce((sum, cost) -> sum + cost).get();\nSystem.out.println("Total : " + bill);\n\n\n\n# Collectors\n\n// 将字符串换成大写并用逗号链接起来\nList<String> G7 = Arrays.asList("USA", "Japan", "France", "Germany", "Italy", "U.K.","Canada");\nString G7Countries = G7.stream().map(x -> x.toUpperCase()).collect(Collectors.joining(", "));\nSystem.out.println(G7Countries);\n\n\n * Collectors.joining(", ")\n * Collectors.toList()\n * Collectors.toSet() ，生成set集合\n * Collectors.toMap(MemberModel::getUid, Function.identity())\n * Collectors.toMap(ImageModel::getAid, o -> IMAGE_ADDRESS_PREFIX + o.getUrl())\n\n\n# flatMap\n\n将多个Stream连接成一个Stream\n\nList<Integer> result= Stream.of(Arrays.asList(1,3),Arrays.asList(5,6)).flatMap(a->a.stream()).collect(Collectors.toList());\n\n\n结果: [1, 3, 5, 6]\n\n\n# distinct\n\n去重\n\nList<LikeDO> likeDOs=new ArrayList<LikeDO>();\nList<Long> likeTidList = likeDOs.stream().map(LikeDO::getTid)\n                .distinct().collect(Collectors.toList());\n\n\n\n# count\n\n计总数\n\nint countOfAdult=persons.stream()\n                       .filter(p -> p.getAge() > 18)\n                       .map(person -> new Adult(person))\n                       .count();\n\n\n\n# Match\n\nboolean anyStartsWithA =\n    stringCollection\n        .stream()\n        .anyMatch((s) -> s.startsWith("a"));\n\nSystem.out.println(anyStartsWithA);      // true\n\nboolean allStartsWithA =\n    stringCollection\n        .stream()\n        .allMatch((s) -> s.startsWith("a"));\n\nSystem.out.println(allStartsWithA);      // false\n\nboolean noneStartsWithZ =\n    stringCollection\n        .stream()\n        .noneMatch((s) -> s.startsWith("z"));\n\nSystem.out.println(noneStartsWithZ);      // true\n\n\n\n# min,max,summaryStatistics\n\n最小值，最大值\n\nList<Person> lists = new ArrayList<Person>();\nlists.add(new Person(1L, "p1"));\nlists.add(new Person(2L, "p2"));\nlists.add(new Person(3L, "p3"));\nlists.add(new Person(4L, "p4"));\nPerson a = lists.stream().max(Comparator.comparing(t -> t.getId())).get();\nSystem.out.println(a.getId());\n\n\n如果比较器涉及多个条件，比较复杂，可以定制\n\n Person a = lists.stream().min(new Comparator<Person>() {\n\n      @Override\n      public int compare(Person o1, Person o2) {\n           if (o1.getId() > o2.getId()) return -1;\n           if (o1.getId() < o2.getId()) return 1;\n           return 0;\n       }\n }).get();\n\n\nsummaryStatistics\n\n//获取数字的个数、最小值、最大值、总和以及平均值\nList<Integer> primes = Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29);\nIntSummaryStatistics stats = primes.stream().mapToInt((x) -> x).summaryStatistics();\nSystem.out.println("Highest prime number in List : " + stats.getMax());\nSystem.out.println("Lowest prime number in List : " + stats.getMin());\nSystem.out.println("Sum of all prime numbers : " + stats.getSum());\nSystem.out.println("Average of all prime numbers : " + stats.getAverage());\n\n\n\n# peek\n\n可以使用peek方法，peek方法可只包含一个空的方法体，只要能设置断点即可，但有些IDE不允许空，可以如下文示例，简单写一个打印逻辑。\n\n注意，调试完后要删掉。\n\nList<Person> lists = new ArrayList<Person>();\nlists.add(new Person(1L, "p1"));\nlists.add(new Person(2L, "p2"));\nlists.add(new Person(3L, "p3"));\nlists.add(new Person(4L, "p4"));\nSystem.out.println(lists);\n\nList<Person> list2 = lists.stream()\n\t\t\t\t .filter(f -> f.getName().startsWith("p"))\n                .peek(t -> {\n                    System.out.println(t.getName());\n                })\n                .collect(Collectors.toList());\nSystem.out.println(list2);\n\n\n\n# FunctionalInterface\n\n\n# 理解注解 @FunctionInterface\n\n/**\n * An informative annotation type used to indicate that an interface\n * type declaration is intended to be a <i>functional interface</i> as\n * defined by the Java Language Specification.\n *\n * Conceptually, a functional interface has exactly one abstract\n * method.  Since {@linkplain java.lang.reflect.Method#isDefault()\n * default methods} have an implementation, they are not abstract.  If\n * an interface declares an abstract method overriding one of the\n * public methods of {@code java.lang.Object}, that also does\n * <em>not</em> count toward the interface\'s abstract method count\n * since any implementation of the interface will have an\n * implementation from {@code java.lang.Object} or elsewhere.\n *\n * <p>Note that instances of functional interfaces can be created with\n * lambda expressions, method references, or constructor references.\n *\n * <p>If a type is annotated with this annotation type, compilers are\n * required to generate an error message unless:\n *\n * <ul>\n * <li> The type is an interface type and not an annotation type, enum, or class.\n * <li> The annotated type satisfies the requirements of a functional interface.\n * </ul>\n *\n * <p>However, the compiler will treat any interface meeting the\n * definition of a functional interface as a functional interface\n * regardless of whether or not a {@code FunctionalInterface}\n * annotation is present on the interface declaration.\n *\n * @jls 4.3.2. The Class Object\n * @jls 9.8 Functional Interfaces\n * @jls 9.4.3 Interface Method Body\n * @since 1.8\n */\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface FunctionalInterface{}\n\n\n * interface做注解的注解类型，被定义成java语言规范\n\n * 一个被它注解的接口只能有一个抽象方法，有两种例外\n\n * 第一是接口允许有实现的方法，这种实现的方法是用default关键字来标记的(java反射中java.lang.reflect.Method#isDefault()方法用来判断是否是default方法)\n\n * 第二如果声明的方法和java.lang.Object中的某个方法一样，它可以不当做未实现的方法，不违背这个原则: 一个被它注解的接口只能有一个抽象方法, 比如:\n\njava public interface Comparator<T> { \n\tint compare(T o1, T o2); \n\tboolean equals(Object obj); \n}\n\n\n * 如果一个类型被这个注解修饰，那么编译器会要求这个类型必须满足如下条件:\n   \n   * 这个类型必须是一个interface，而不是其他的注解类型、枚举enum或者类class\n   * 这个类型必须满足function interface的所有要求，如你个包含两个抽象方法的接口增加这个注解，会有编译错误。\n\n * 编译器会自动把满足function interface要求的接口自动识别为function interface，所以你才不需要对上面示例中的 ITest接口增加@FunctionInterface注解。\n\n\n# 自定义函数接口\n\n@FunctionalInterface\npublic interface IMyInterface {\n    void study();\n}\n\npackage com.isea.java;\npublic class TestIMyInterface {\n    public static void main(String[] args) {\n        IMyInterface iMyInterface = () -> System.out.println("I like study");\n        iMyInterface.study();\n    }\n}\n\n\n\n# 内置四大函数接口\n\n * 消费型接口: Consumer<T> void accept(T t)有参数，无返回值的抽象方法；\n\n> 比如: map.forEach(BiConsumer<A, T>)\n\nConsumer<Person> greeter = (p) -> System.out.println("Hello, " + p.firstName);\ngreeter.accept(new Person("Luke", "Skywalker"));\n\n\n * 供给型接口: Supplier <T> T get() 无参有返回值的抽象方法；\n\n> 以stream().collect(Collector<? super T, A, R> collector)为例:\n\n比如:\n\nSupplier<Person> personSupplier = Person::new;\npersonSupplier.get();   // new Person\n\n\n再如:\n\n// 调用方法\n<R, A> R collect(Collector<? super T, A, R> collector)\n\n// Collectors.toSet\npublic static <T>\n\tCollector<T, ?, Set<T>> toSet() {\n    \treturn new CollectorImpl<>((Supplier<Set<T>>) HashSet::new, Set::add,\n                               (left, right) -> { left.addAll(right); return left; },\n                               CH_UNORDERED_ID);\n}\n\n// CollectorImpl\nprivate final Supplier<A> supplier;\nprivate final BiConsumer<A, T> accumulator;\nprivate final BinaryOperator<A> combiner;\nprivate final Function<A, R> finisher;\nprivate final Set<Characteristics> characteristics;\n\nCollectorImpl(Supplier<A> supplier,\n              BiConsumer<A, T> accumulator,\n              BinaryOperator<A> combiner,\n              Function<A,R> finisher,\n              Set<Characteristics> characteristics) {\n    this.supplier = supplier;\n    this.accumulator = accumulator;\n    this.combiner = combiner;\n    this.finisher = finisher;\n    this.characteristics = characteristics;\n}\n\nCollectorImpl(Supplier<A> supplier,\n              BiConsumer<A, T> accumulator,\n              BinaryOperator<A> combiner,\n              Set<Characteristics> characteristics) {\n    this(supplier, accumulator, combiner, castingIdentity(), characteristics);\n}\n\n// collect()方法实现\npublic final <R, A> R collect(Collector<? super P_OUT, A, R> collector) {\n    A container;\n    if (isParallel()\n            && (collector.characteristics().contains(Collector.Characteristics.CONCURRENT))\n            && (!isOrdered() || collector.characteristics().contains(Collector.Characteristics.UNORDERED))) {\n        container = collector.supplier().get();\n        BiConsumer<A, ? super P_OUT> accumulator = collector.accumulator();\n        forEach(u -> accumulator.accept(container, u));\n    }\n    else {\n        container = evaluate(ReduceOps.makeRef(collector));\n    }\n    return collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)\n           ? (R) container\n           : collector.finisher().apply(container);\n}\n\n\n * 断定型接口: Predicate<T> boolean test(T t):有参，但是返回值类型是固定的boolean\n\n> 比如: steam().filter()中参数就是Predicate\n\nPredicate<String> predicate = (s) -> s.length() > 0;\n\npredicate.test("foo");              // true\npredicate.negate().test("foo");     // false\n\nPredicate<Boolean> nonNull = Objects::nonNull;\nPredicate<Boolean> isNull = Objects::isNull;\n\nPredicate<String> isEmpty = String::isEmpty;\nPredicate<String> isNotEmpty = isEmpty.negate();\n\n\n * 函数型接口: Function<T,R> R apply(T t)有参有返回值的抽象方法；\n\n> 比如: steam().map() 中参数就是Function<? super T, ? extends R>；reduce()中参数BinaryOperator<T> (ps: BinaryOperator<T> extends BiFunction<T,T,T>)\n\nFunction<String, Integer> toInteger = Integer::valueOf;\nFunction<String, String> backToString = toInteger.andThen(String::valueOf);\n\nbackToString.apply("123");     // "123"\n\n\n\n# 一些例子\n\n * 输出 年龄>25的女程序员中名字排名前3位的姓名\n\njavaProgrammers.stream()\n          .filter((p) -> (p.getAge() > 25))\n          .filter((p) -> ("female".equals(p.getGender())))\n          .sorted((p, p2) -> (p.getFirstName().compareTo(p2.getFirstName())))\n          .limit(3)\n          //.forEach(e -> e.setSalary(e.getSalary() / 100 * 5 + e.getSalary()))//涨工资\n          .forEach((p) -> System.out.printf("%s %s; ", p.getFirstName(), p.getLastName()));\n\n\n * 工资最高的 Java programmer\n\nPerson person = javaProgrammers\n          .stream()\n          .max((p, p2) -> (p.getSalary() - p2.getSalary()))\n          .get()\n\n\n * 将 Java programmers 的 first name 存放到 TreeSet\n\nTreeSet<String> javaDevLastName = javaProgrammers\n          .stream()\n          .map(Person::getLastName)\n          .collect(toCollection(TreeSet::new))\n\n\n * 计算付给 Java programmers 的所有money\n\nint totalSalary = javaProgrammers\n          .parallelStream()\n          .mapToInt(p -> p.getSalary())\n          .sum();\n\n\n * Comparator多属性排序: 先按名字不分大小写排，再按GID倒序排，最后按年龄正序排\n\npublic static void main(String[] args) {\n\tList<Person> personList = getTestList();\n\tpersonList.sort(Comparator.comparing(Person::getName, String.CASE_INSENSITIVE_ORDER)\n\t\t\t.thenComparing(Person::getGid, (a, b) -> b.compareTo(a))\n\t\t\t.thenComparingInt(Person::getAge));\n\tpersonList.stream().forEach(System.out::println);\n}\n\npublic static List<Person> getTestList() {\n\treturn Lists.newArrayList(new Person("dai", "301", 10), new Person("dai", "303", 10),\n\t\t\tnew Person("dai", "303", 8), new Person("dai", "303", 6), new Person("dai", "303", 11),\n\t\t\tnew Person("dai", "302", 9), new Person("zhang", "302", 9), new Person("zhang", "301", 9),\n\t\t\tnew Person("Li", "301", 8));\n}\n\n// 输出结果\n// Person [name=dai, gid=303, age=6]\n// Person [name=dai, gid=303, age=8]\n// Person [name=dai, gid=303, age=10]\n// Person [name=dai, gid=303, age=11]\n// Person [name=dai, gid=302, age=9]\n// Person [name=dai, gid=301, age=10]\n// Person [name=Li, gid=301, age=8]\n// Person [name=zhang, gid=302, age=9]\n// Person [name=zhang, gid=301, age=9]\n\n\n * 处理字符串\n\n两个新的方法可在字符串类上使用: join和chars。第一个方法使用指定的分隔符，将任何数量的字符串连接为一个字符串。\n\nString.join(":", "foobar", "foo", "bar");\n// => foobar:foo:bar\n\n\n第二个方法chars从字符串所有字符创建数据流，所以你可以在这些字符上使用流式操作。\n\n"foobar:foo:bar"\n    .chars()\n    .distinct()\n    .mapToObj(c -> String.valueOf((char)c))\n    .sorted()\n    .collect(Collectors.joining());\n// => :abfor\n\n\n不仅仅是字符串，正则表达式模式串也能受益于数据流。我们可以分割任何模式串，并创建数据流来处理它们，而不是将字符串分割为单个字符的数据流，像下面这样:\n\nPattern.compile(":")\n    .splitAsStream("foobar:foo:bar")\n    .filter(s -> s.contains("bar"))\n    .sorted()\n    .collect(Collectors.joining(":"));\n// => bar:foobar\n\n\n此外，正则模式串可以转换为谓词。这些谓词可以像下面那样用于过滤字符串流:\n\nPattern pattern = Pattern.compile(".*@gmail\\\\.com");\nStream.of("bob@gmail.com", "alice@hotmail.com")\n    .filter(pattern.asPredicate())\n    .count();\n// => 1\n\n\n上面的模式串接受任何以@gmail.com结尾的字符串，并且之后用作Java8的Predicate来过滤电子邮件地址流。\n\n * Local Cache实现\n\npublic class TestLocalCache {\n\n\tprivate static ConcurrentHashMap<Integer, Long> cache = new ConcurrentHashMap<>();\n\n\tstatic long fibonacci(int i) {\n\t\tif (i == 0)\n\t\t\treturn i;\n\n\t\tif (i == 1)\n\t\t\treturn 1;\n\n\t\treturn cache.computeIfAbsent(i, (key) -> {\n\t\t\tSystem.out.println("Slow calculation of " + key);\n\n\t\t\treturn fibonacci(i - 2) + fibonacci(i - 1);\n\t\t});\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// warm up\n\t\tfor (int i = 0; i < 101; i++)\n\t        System.out.println(\n\t            "f(" + i + ") = " + fibonacci(i));\n\t\t\n\t\t// read -> cal\n\t\tlong current = System.currentTimeMillis();\n\t\tSystem.out.println(fibonacci(100));\n\t\tSystem.out.println(System.currentTimeMillis()-current);\n\t}\n}\n\n\n * 集合--》取元素的一个属性--》去重---》组装成List--》返回\n\nList<LikeDO> likeDOs=new ArrayList<LikeDO>();\nList<Long> likeTidList = likeDOs.stream().map(LikeDO::getTid)\n                .distinct().collect(Collectors.toList());\n\n\n * 集合--》按表达式过滤--》遍历、每个元系处理--》放入预先定义的集合中\n\n  Map<String, StkProduct> newStockName2Product = Maps.newConcurrentMap();\n        stockProducts.stream().filter(stkProduct -> stkProduct.enabled).forEach(stkProduct -> {\n            String newName = BCConvert.bj2qj(StringUtils.replace(stkProduct.name, " ", ""));\n            newStockName2Product.put(newName, stkProduct);\n        });\n\n\n Set<String> qjStockNames;\n qjStockNames.stream().filter(name -> !acAutomaton.getKey2link().containsKey(name)).forEach(name -> {\n            String value = "";\n            StkProduct stkProduct = stockNameQj2Product.get(name);\n            if (stkProduct != null) {\n                value = stkProduct.name;\n            }\n            acAutomaton.getKey2link().put(name, value);\n        });\n\n\n * 集合--》map\n\nList<ImageModel> imageModelList = null;\nMap<Long, String> imagesMap = null;\nimagesMap = imageModelList.stream().collect(Collectors.toMap(ImageModel::getAid, o -> IMAGE_ADDRESS_PREFIX + o.getUrl()));\n              \n             \n\nMap<String, String> kvMap = postDetailCacheList.stream().collect(Collectors.toMap((detailCache) ->\n                getBbsSimplePostKey(detailCache.getTid()), JSON::toJSONString));\n\n\nMap<Long, Long> pidToTid；\nList<String> pidKeyList = pidToTid.entrySet().stream().map((o) -> getKeyBbsReplyPid(o.getValue(), o.getKey())).collect(Collectors.toList());\n\n\n\n * DO模型---》Model模型\n\nList<AdDO> adDOList;\nadDOList.stream().map(adDo -> convertAdModel(adDo))\n                .collect(Collectors.toList());\n\n\n * phones 是一个List<String>，将相同的元素分组、归类\n\nList<String> phones=new ArrayList<String>();\n        phones.add("a");\n        phones.add("b");\n        phones.add("a");\n        phones.add("a");\n        phones.add("c");\n        phones.add("b");\n        Map<String, List<String>> phoneClassify = phones.stream().collect(Collectors.groupingBy(item -> item));\n        System.out.println(phoneClassify);\n返回结果: \n{a=[a, a, a], b=[b, b], c=[c]}\n\n\n\n# 参考资料\n\n * Lambda 表达式的 10 个示例在新窗口打开\n * learn-java8在新窗口打开\n * java8-tutorial在新窗口打开\n * 一文让你明白lambda用法与源码分析在新窗口打开\n * http://blog.csdn.net/renfufei/article/details/24600507在新窗口打开\n * http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html在新窗口打开\n * Java8 Lambda表达式教程 https://blog.csdn.net/ioriogami/article/details/12782141\n * Java8 6个问题 https://wizardforcel.gitbooks.io/java8-tutorials/content/Java%208%20%E7%9A%846%E4%B8%AA%E9%97%AE%E9%A2%98.html',normalizedContent:'# java 8 - 函数编程(lambda表达式)\n\n> 我们关心的是如何写出好代码，而不是符合函数编程风格的代码。 @pdai\n\n * java 8 - 函数编程(lambda表达式)\n   * 简介\n   * lambda表达式\n   * 分类\n     * 惰性求值方法\n     * 及早求值方法\n   * stream & parallelstream\n     * stream & parallelstream\n     * parallelstream原理:\n     * stream与parallelstream性能测试对比\n     * stream中常用方法如下:\n   * 常用例子\n     * 匿名类简写\n     * foreach\n     * 方法引用\n     * filter & predicate\n     * map&reduce\n     * collectors\n     * flatmap\n     * distinct\n     * count\n     * match\n     * min,max,summarystatistics\n     * peek\n   * functionalinterface\n     * 理解注解 @functioninterface\n     * 自定义函数接口\n     * 内置四大函数接口\n   * 一些例子\n   * 参考资料\n\n\n# 简介\n\n> 在java世界里面，面向对象还是主流思想，对于习惯了面向对象编程的开发者来说，抽象的概念并不陌生。面向对象编程是对数据进行抽象，而函数式编程是对行为进行抽象。现实世界中，数据和行为并存，程序也是如此，因此这两种编程方式我们都得学。\n\n> 这种新的抽象方式还有其他好处。很多人不总是在编写性能优先的代码，对于这些人来说，函数式编程带来的好处尤为明显。程序员能编写出更容易阅读的代码——这种代码更多地表达了业务逻辑，而不是从机制上如何实现。易读的代码也易于维护、更可靠、更不容易出错。\n\n> 在写回调函数和事件处理器时，程序员不必再纠缠于匿名内部类的冗繁和可读性，函数式编程让事件处理系统变得更加简单。能将函数方便地传递也让编写惰性代码变得容易，只有在真正需要的时候，才初始化变量的值。\n\n面向对象编程是对数据进行抽象；函数式编程是对行为进行抽象。\n\n核心思想: 使用不可变值和函数，函数对一个值进行处理，映射成另一个值。\n\n对核心类库的改进主要包括集合类的api和新引入的流stream。流使程序员可以站在更高的抽象层次上对集合进行操作。\n\n\n# lambda表达式\n\n * lambda表达式仅能放入如下代码: 预定义使用了 @functional 注释的函数式接口，自带一个抽象函数的方法，或者sam(single abstract method 单个抽象方法)类型。这些称为lambda表达式的目标类型，可以用作返回类型，或lambda目标代码的参数。例如，若一个方法接收runnable、comparable或者 callable 接口，都有单个抽象方法，可以传入lambda表达式。类似的，如果一个方法接受声明于 java.util.function 包内的接口，例如 predicate、function、consumer 或 supplier，那么可以向其传lambda表达式。\n\n * lambda表达式内可以使用方法引用，仅当该方法不修改lambda表达式提供的参数。本例中的lambda表达式可以换为方法引用，因为这仅是一个参数相同的简单方法调用。\n\nlist.foreach(n -> system.out.println(n)); \nlist.foreach(system.out::println);  // 使用方法引用\n\n\n然而，若对参数有任何修改，则不能使用方法引用，而需键入完整地lambda表达式，如下所示:\n\nlist.foreach((string s) -> system.out.println("*" + s + "*"));\n\n\n事实上，可以省略这里的lambda参数的类型声明，编译器可以从列表的类属性推测出来。\n\n * lambda内部可以使用静态、非静态和局部变量，这称为lambda内的变量捕获。\n\n * lambda表达式在java中又称为闭包或匿名函数，所以如果有同事把它叫闭包的时候，不用惊讶。\n\n * lambda方法在编译器内部被翻译成私有方法，并派发 invokedynamic 字节码指令来进行调用。可以使用jdk中的 javap 工具来反编译class文件。使用 javap -p 或 javap -c -v 命令来看一看lambda表达式生成的字节码。大致应该长这样:\n\nprivate static java.lang.object lambda$0(java.lang.string);\n\n\n * lambda表达式有个限制，那就是只能引用 final 或 final 局部变量，这就是说不能在lambda内部修改定义在域外的变量。\n\nlist<integer> primes = arrays.aslist(new integer[]{2, 3,5,7});\nint factor = 2;\nprimes.foreach(element -> { factor++; });\n\n\ncompile time error : "local variables referenced from a lambda expression must be final or effectively final" 另外，只是访问它而不作修改是可以的，如下所示:\n\nlist<integer> primes = arrays.aslist(new integer[]{2, 3,5,7});\nint factor = 2;\nprimes.foreach(element -> { system.out.println(factor*element); });\n\n\n\n# 分类\n\n\n# 惰性求值方法\n\nlists.stream().filter(f -> f.getname().equals("p1"))\n\n\n如上示例，这行代码并未做什么实际性的工作，filter只是描述了stream，没有产生新的集合。\n\n如果是多个条件组合，可以通过代码块{}\n\n\n# 及早求值方法\n\nlist<person> list2 = lists.stream().filter(f -> f.getname().equals("p1")).collect(collectors.tolist());\n\n\n如上示例，collect最终会从stream产生新值，拥有终止操作。\n\n理想方式是形成一个惰性求值的链，最后用一个及早求值的操作返回想要的结果。与建造者模式相似，建造者模式先是使用一系列操作设置属性和配置，最后调用build方法，创建对象。\n\n\n# stream & parallelstream\n\n\n# stream & parallelstream\n\n每个stream都有两种模式: 顺序执行和并行执行。\n\n顺序流:\n\nlist <person> people = list.getstream.collect(collectors.tolist());\n\n\n并行流:\n\nlist <person> people = list.getstream.parallel().collect(collectors.tolist());\n\n\n顾名思义，当使用顺序方式去遍历时，每个item读完后再读下一个item。而使用并行去遍历时，数组会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。\n\n\n# parallelstream原理:\n\nlist originallist = somedata;\nsplit1 = originallist(0, mid);//将数据分小部分\nsplit2 = originallist(mid,end);\nnew runnable(split1.process());//小部分执行操作\nnew runnable(split2.process());\nlist revisedlist = split1 + split2;//将结果合并\n\n\n大家对hadoop有稍微了解就知道，里面的 mapreduce 本身就是用于并行处理大数据集的软件框架，其 处理大数据的核心思想就是大而化小，分配到不同机器去运行map，最终通过reduce将所有机器的结果结合起来得到一个最终结果，与mapreduce不同，stream则是利用多核技术可将大数据通过多核并行处理，而mapreduce则可以分布式的。\n\n\n# stream与parallelstream性能测试对比\n\n如果是多核机器，理论上并行流则会比顺序流快上一倍，下面是测试代码\n\nlong t0 = system.nanotime();\n\n//初始化一个范围100万整数流,求能被2整除的数字，toarray()是终点方法\n\nint a[]=intstream.range(0, 1_000_000).filter(p -> p % 2==0).toarray();\n\nlong t1 = system.nanotime();\n\n//和上面功能一样，这里是用并行流来计算\n\nint b[]=intstream.range(0, 1_000_000).parallel().filter(p -> p % 2==0).toarray();\n\nlong t2 = system.nanotime();\n\n//我本机的结果是serial: 0.06s, parallel 0.02s，证明并行流确实比顺序流快\n\nsystem.out.printf("serial: %.2fs, parallel %.2fs%n", (t1 - t0) * 1e-9, (t2 - t1) * 1e-9);\n\n\n\n# stream中常用方法如下:\n\n * stream(), parallelstream()\n * filter()\n * findany() findfirst()\n * sort\n * foreach void\n * map(), reduce()\n * flatmap() - 将多个stream连接成一个stream\n * collect(collectors.tolist())\n * distinct, limit\n * count\n * min, max, summarystatistics\n\n看下所有api:\n\n\n\n\n# 常用例子\n\n\n# 匿名类简写\n\nnew thread( () -> system.out.println("in java8, lambda expression rocks !!") ).start();\n\n// 用法\n(params) -> expression\n(params) -> statement\n(params) -> { statements }\n\n\n\n# foreach\n\n// foreach\nlist features = arrays.aslist("lambdas", "default method", "stream api", "date and time api");\nfeatures.foreach(n -> system.out.println(n));\n \n// 使用java 8的方法引用更方便，方法引用由::双冒号操作符标示，\nfeatures.foreach(system.out::println);\n\n\n\n# 方法引用\n\n构造引用\n\n// supplier<student> s = () -> new student();\nsupplier<student> s = student::new;\n\n\n对象::实例方法 lambda表达式的(形参列表)与实例方法的(实参列表)类型，个数是对应\n\n// set.foreach(t -> system.out.println(t));\nset.foreach(system.out::println);\n\n\n类名::静态方法\n\n// stream<double> stream = stream.generate(() -> math.random());\nstream<double> stream = stream.generate(math::random);\n\n\n类名::实例方法\n\n//  treeset<string> set = new treeset<>((s1,s2) -> s1.compareto(s2));\n/*  这里如果使用第一句话，编译器会有提示: can be replaced with comparator.naturalorder，这句话告诉我们\n  string已经重写了compareto()方法，在这里写是多此一举，这里为什么这么写，是因为为了体现下面\n  这句编译器的提示: lambda can be replaced with method reference。好了，下面的这句就是改写成方法引用之后: \n*/\ntreeset<string> set = new treeset<>(string::compareto);\n\n\n\n# filter & predicate\n\n常规用法\n\npublic static void main(args[]){\n    list languages = arrays.aslist("java", "scala", "c++", "haskell", "lisp");\n \n    system.out.println("languages which starts with j :");\n    filter(languages, (str)->str.startswith("j"));\n \n    system.out.println("languages which ends with a ");\n    filter(languages, (str)->str.endswith("a"));\n \n    system.out.println("print all languages :");\n    filter(languages, (str)->true);\n \n    system.out.println("print no language : ");\n    filter(languages, (str)->false);\n \n    system.out.println("print language whose length greater than 4:");\n    filter(languages, (str)->str.length() > 4);\n}\n \npublic static void filter(list names, predicate condition) {\n    names.stream().filter((name) -> (condition.test(name))).foreach((name) -> {\n        system.out.println(name + " ");\n    });\n}\n\n\n多个predicate组合filter\n\n// 可以用and()、or()和xor()逻辑函数来合并predicate，\n// 例如要找到所有以j开始，长度为四个字母的名字，你可以合并两个predicate并传入\npredicate<string> startswithj = (n) -> n.startswith("j");\npredicate<string> fourletterlong = (n) -> n.length() == 4;\nnames.stream()\n    .filter(startswithj.and(fourletterlong))\n    .foreach((n) -> system.out.print("nname, which starts with \'j\' and four letter long is : " + n));\n\n\n\n# map&reduce\n\nmap将集合类(例如列表)元素进行转换的。还有一个 reduce() 函数可以将所有值合并成一个\n\nlist costbeforetax = arrays.aslist(100, 200, 300, 400, 500);\ndouble bill = costbeforetax.stream().map((cost) -> cost + .12*cost).reduce((sum, cost) -> sum + cost).get();\nsystem.out.println("total : " + bill);\n\n\n\n# collectors\n\n// 将字符串换成大写并用逗号链接起来\nlist<string> g7 = arrays.aslist("usa", "japan", "france", "germany", "italy", "u.k.","canada");\nstring g7countries = g7.stream().map(x -> x.touppercase()).collect(collectors.joining(", "));\nsystem.out.println(g7countries);\n\n\n * collectors.joining(", ")\n * collectors.tolist()\n * collectors.toset() ，生成set集合\n * collectors.tomap(membermodel::getuid, function.identity())\n * collectors.tomap(imagemodel::getaid, o -> image_address_prefix + o.geturl())\n\n\n# flatmap\n\n将多个stream连接成一个stream\n\nlist<integer> result= stream.of(arrays.aslist(1,3),arrays.aslist(5,6)).flatmap(a->a.stream()).collect(collectors.tolist());\n\n\n结果: [1, 3, 5, 6]\n\n\n# distinct\n\n去重\n\nlist<likedo> likedos=new arraylist<likedo>();\nlist<long> liketidlist = likedos.stream().map(likedo::gettid)\n                .distinct().collect(collectors.tolist());\n\n\n\n# count\n\n计总数\n\nint countofadult=persons.stream()\n                       .filter(p -> p.getage() > 18)\n                       .map(person -> new adult(person))\n                       .count();\n\n\n\n# match\n\nboolean anystartswitha =\n    stringcollection\n        .stream()\n        .anymatch((s) -> s.startswith("a"));\n\nsystem.out.println(anystartswitha);      // true\n\nboolean allstartswitha =\n    stringcollection\n        .stream()\n        .allmatch((s) -> s.startswith("a"));\n\nsystem.out.println(allstartswitha);      // false\n\nboolean nonestartswithz =\n    stringcollection\n        .stream()\n        .nonematch((s) -> s.startswith("z"));\n\nsystem.out.println(nonestartswithz);      // true\n\n\n\n# min,max,summarystatistics\n\n最小值，最大值\n\nlist<person> lists = new arraylist<person>();\nlists.add(new person(1l, "p1"));\nlists.add(new person(2l, "p2"));\nlists.add(new person(3l, "p3"));\nlists.add(new person(4l, "p4"));\nperson a = lists.stream().max(comparator.comparing(t -> t.getid())).get();\nsystem.out.println(a.getid());\n\n\n如果比较器涉及多个条件，比较复杂，可以定制\n\n person a = lists.stream().min(new comparator<person>() {\n\n      @override\n      public int compare(person o1, person o2) {\n           if (o1.getid() > o2.getid()) return -1;\n           if (o1.getid() < o2.getid()) return 1;\n           return 0;\n       }\n }).get();\n\n\nsummarystatistics\n\n//获取数字的个数、最小值、最大值、总和以及平均值\nlist<integer> primes = arrays.aslist(2, 3, 5, 7, 11, 13, 17, 19, 23, 29);\nintsummarystatistics stats = primes.stream().maptoint((x) -> x).summarystatistics();\nsystem.out.println("highest prime number in list : " + stats.getmax());\nsystem.out.println("lowest prime number in list : " + stats.getmin());\nsystem.out.println("sum of all prime numbers : " + stats.getsum());\nsystem.out.println("average of all prime numbers : " + stats.getaverage());\n\n\n\n# peek\n\n可以使用peek方法，peek方法可只包含一个空的方法体，只要能设置断点即可，但有些ide不允许空，可以如下文示例，简单写一个打印逻辑。\n\n注意，调试完后要删掉。\n\nlist<person> lists = new arraylist<person>();\nlists.add(new person(1l, "p1"));\nlists.add(new person(2l, "p2"));\nlists.add(new person(3l, "p3"));\nlists.add(new person(4l, "p4"));\nsystem.out.println(lists);\n\nlist<person> list2 = lists.stream()\n\t\t\t\t .filter(f -> f.getname().startswith("p"))\n                .peek(t -> {\n                    system.out.println(t.getname());\n                })\n                .collect(collectors.tolist());\nsystem.out.println(list2);\n\n\n\n# functionalinterface\n\n\n# 理解注解 @functioninterface\n\n/**\n * an informative annotation type used to indicate that an interface\n * type declaration is intended to be a <i>functional interface</i> as\n * defined by the java language specification.\n *\n * conceptually, a functional interface has exactly one abstract\n * method.  since {@linkplain java.lang.reflect.method#isdefault()\n * default methods} have an implementation, they are not abstract.  if\n * an interface declares an abstract method overriding one of the\n * public methods of {@code java.lang.object}, that also does\n * <em>not</em> count toward the interface\'s abstract method count\n * since any implementation of the interface will have an\n * implementation from {@code java.lang.object} or elsewhere.\n *\n * <p>note that instances of functional interfaces can be created with\n * lambda expressions, method references, or constructor references.\n *\n * <p>if a type is annotated with this annotation type, compilers are\n * required to generate an error message unless:\n *\n * <ul>\n * <li> the type is an interface type and not an annotation type, enum, or class.\n * <li> the annotated type satisfies the requirements of a functional interface.\n * </ul>\n *\n * <p>however, the compiler will treat any interface meeting the\n * definition of a functional interface as a functional interface\n * regardless of whether or not a {@code functionalinterface}\n * annotation is present on the interface declaration.\n *\n * @jls 4.3.2. the class object\n * @jls 9.8 functional interfaces\n * @jls 9.4.3 interface method body\n * @since 1.8\n */\n@documented\n@retention(retentionpolicy.runtime)\n@target(elementtype.type)\npublic @interface functionalinterface{}\n\n\n * interface做注解的注解类型，被定义成java语言规范\n\n * 一个被它注解的接口只能有一个抽象方法，有两种例外\n\n * 第一是接口允许有实现的方法，这种实现的方法是用default关键字来标记的(java反射中java.lang.reflect.method#isdefault()方法用来判断是否是default方法)\n\n * 第二如果声明的方法和java.lang.object中的某个方法一样，它可以不当做未实现的方法，不违背这个原则: 一个被它注解的接口只能有一个抽象方法, 比如:\n\njava public interface comparator<t> { \n\tint compare(t o1, t o2); \n\tboolean equals(object obj); \n}\n\n\n * 如果一个类型被这个注解修饰，那么编译器会要求这个类型必须满足如下条件:\n   \n   * 这个类型必须是一个interface，而不是其他的注解类型、枚举enum或者类class\n   * 这个类型必须满足function interface的所有要求，如你个包含两个抽象方法的接口增加这个注解，会有编译错误。\n\n * 编译器会自动把满足function interface要求的接口自动识别为function interface，所以你才不需要对上面示例中的 itest接口增加@functioninterface注解。\n\n\n# 自定义函数接口\n\n@functionalinterface\npublic interface imyinterface {\n    void study();\n}\n\npackage com.isea.java;\npublic class testimyinterface {\n    public static void main(string[] args) {\n        imyinterface imyinterface = () -> system.out.println("i like study");\n        imyinterface.study();\n    }\n}\n\n\n\n# 内置四大函数接口\n\n * 消费型接口: consumer<t> void accept(t t)有参数，无返回值的抽象方法；\n\n> 比如: map.foreach(biconsumer<a, t>)\n\nconsumer<person> greeter = (p) -> system.out.println("hello, " + p.firstname);\ngreeter.accept(new person("luke", "skywalker"));\n\n\n * 供给型接口: supplier <t> t get() 无参有返回值的抽象方法；\n\n> 以stream().collect(collector<? super t, a, r> collector)为例:\n\n比如:\n\nsupplier<person> personsupplier = person::new;\npersonsupplier.get();   // new person\n\n\n再如:\n\n// 调用方法\n<r, a> r collect(collector<? super t, a, r> collector)\n\n// collectors.toset\npublic static <t>\n\tcollector<t, ?, set<t>> toset() {\n    \treturn new collectorimpl<>((supplier<set<t>>) hashset::new, set::add,\n                               (left, right) -> { left.addall(right); return left; },\n                               ch_unordered_id);\n}\n\n// collectorimpl\nprivate final supplier<a> supplier;\nprivate final biconsumer<a, t> accumulator;\nprivate final binaryoperator<a> combiner;\nprivate final function<a, r> finisher;\nprivate final set<characteristics> characteristics;\n\ncollectorimpl(supplier<a> supplier,\n              biconsumer<a, t> accumulator,\n              binaryoperator<a> combiner,\n              function<a,r> finisher,\n              set<characteristics> characteristics) {\n    this.supplier = supplier;\n    this.accumulator = accumulator;\n    this.combiner = combiner;\n    this.finisher = finisher;\n    this.characteristics = characteristics;\n}\n\ncollectorimpl(supplier<a> supplier,\n              biconsumer<a, t> accumulator,\n              binaryoperator<a> combiner,\n              set<characteristics> characteristics) {\n    this(supplier, accumulator, combiner, castingidentity(), characteristics);\n}\n\n// collect()方法实现\npublic final <r, a> r collect(collector<? super p_out, a, r> collector) {\n    a container;\n    if (isparallel()\n            && (collector.characteristics().contains(collector.characteristics.concurrent))\n            && (!isordered() || collector.characteristics().contains(collector.characteristics.unordered))) {\n        container = collector.supplier().get();\n        biconsumer<a, ? super p_out> accumulator = collector.accumulator();\n        foreach(u -> accumulator.accept(container, u));\n    }\n    else {\n        container = evaluate(reduceops.makeref(collector));\n    }\n    return collector.characteristics().contains(collector.characteristics.identity_finish)\n           ? (r) container\n           : collector.finisher().apply(container);\n}\n\n\n * 断定型接口: predicate<t> boolean test(t t):有参，但是返回值类型是固定的boolean\n\n> 比如: steam().filter()中参数就是predicate\n\npredicate<string> predicate = (s) -> s.length() > 0;\n\npredicate.test("foo");              // true\npredicate.negate().test("foo");     // false\n\npredicate<boolean> nonnull = objects::nonnull;\npredicate<boolean> isnull = objects::isnull;\n\npredicate<string> isempty = string::isempty;\npredicate<string> isnotempty = isempty.negate();\n\n\n * 函数型接口: function<t,r> r apply(t t)有参有返回值的抽象方法；\n\n> 比如: steam().map() 中参数就是function<? super t, ? extends r>；reduce()中参数binaryoperator<t> (ps: binaryoperator<t> extends bifunction<t,t,t>)\n\nfunction<string, integer> tointeger = integer::valueof;\nfunction<string, string> backtostring = tointeger.andthen(string::valueof);\n\nbacktostring.apply("123");     // "123"\n\n\n\n# 一些例子\n\n * 输出 年龄>25的女程序员中名字排名前3位的姓名\n\njavaprogrammers.stream()\n          .filter((p) -> (p.getage() > 25))\n          .filter((p) -> ("female".equals(p.getgender())))\n          .sorted((p, p2) -> (p.getfirstname().compareto(p2.getfirstname())))\n          .limit(3)\n          //.foreach(e -> e.setsalary(e.getsalary() / 100 * 5 + e.getsalary()))//涨工资\n          .foreach((p) -> system.out.printf("%s %s; ", p.getfirstname(), p.getlastname()));\n\n\n * 工资最高的 java programmer\n\nperson person = javaprogrammers\n          .stream()\n          .max((p, p2) -> (p.getsalary() - p2.getsalary()))\n          .get()\n\n\n * 将 java programmers 的 first name 存放到 treeset\n\ntreeset<string> javadevlastname = javaprogrammers\n          .stream()\n          .map(person::getlastname)\n          .collect(tocollection(treeset::new))\n\n\n * 计算付给 java programmers 的所有money\n\nint totalsalary = javaprogrammers\n          .parallelstream()\n          .maptoint(p -> p.getsalary())\n          .sum();\n\n\n * comparator多属性排序: 先按名字不分大小写排，再按gid倒序排，最后按年龄正序排\n\npublic static void main(string[] args) {\n\tlist<person> personlist = gettestlist();\n\tpersonlist.sort(comparator.comparing(person::getname, string.case_insensitive_order)\n\t\t\t.thencomparing(person::getgid, (a, b) -> b.compareto(a))\n\t\t\t.thencomparingint(person::getage));\n\tpersonlist.stream().foreach(system.out::println);\n}\n\npublic static list<person> gettestlist() {\n\treturn lists.newarraylist(new person("dai", "301", 10), new person("dai", "303", 10),\n\t\t\tnew person("dai", "303", 8), new person("dai", "303", 6), new person("dai", "303", 11),\n\t\t\tnew person("dai", "302", 9), new person("zhang", "302", 9), new person("zhang", "301", 9),\n\t\t\tnew person("li", "301", 8));\n}\n\n// 输出结果\n// person [name=dai, gid=303, age=6]\n// person [name=dai, gid=303, age=8]\n// person [name=dai, gid=303, age=10]\n// person [name=dai, gid=303, age=11]\n// person [name=dai, gid=302, age=9]\n// person [name=dai, gid=301, age=10]\n// person [name=li, gid=301, age=8]\n// person [name=zhang, gid=302, age=9]\n// person [name=zhang, gid=301, age=9]\n\n\n * 处理字符串\n\n两个新的方法可在字符串类上使用: join和chars。第一个方法使用指定的分隔符，将任何数量的字符串连接为一个字符串。\n\nstring.join(":", "foobar", "foo", "bar");\n// => foobar:foo:bar\n\n\n第二个方法chars从字符串所有字符创建数据流，所以你可以在这些字符上使用流式操作。\n\n"foobar:foo:bar"\n    .chars()\n    .distinct()\n    .maptoobj(c -> string.valueof((char)c))\n    .sorted()\n    .collect(collectors.joining());\n// => :abfor\n\n\n不仅仅是字符串，正则表达式模式串也能受益于数据流。我们可以分割任何模式串，并创建数据流来处理它们，而不是将字符串分割为单个字符的数据流，像下面这样:\n\npattern.compile(":")\n    .splitasstream("foobar:foo:bar")\n    .filter(s -> s.contains("bar"))\n    .sorted()\n    .collect(collectors.joining(":"));\n// => bar:foobar\n\n\n此外，正则模式串可以转换为谓词。这些谓词可以像下面那样用于过滤字符串流:\n\npattern pattern = pattern.compile(".*@gmail\\\\.com");\nstream.of("bob@gmail.com", "alice@hotmail.com")\n    .filter(pattern.aspredicate())\n    .count();\n// => 1\n\n\n上面的模式串接受任何以@gmail.com结尾的字符串，并且之后用作java8的predicate来过滤电子邮件地址流。\n\n * local cache实现\n\npublic class testlocalcache {\n\n\tprivate static concurrenthashmap<integer, long> cache = new concurrenthashmap<>();\n\n\tstatic long fibonacci(int i) {\n\t\tif (i == 0)\n\t\t\treturn i;\n\n\t\tif (i == 1)\n\t\t\treturn 1;\n\n\t\treturn cache.computeifabsent(i, (key) -> {\n\t\t\tsystem.out.println("slow calculation of " + key);\n\n\t\t\treturn fibonacci(i - 2) + fibonacci(i - 1);\n\t\t});\n\t}\n\t\n\tpublic static void main(string[] args) {\n\t\t// warm up\n\t\tfor (int i = 0; i < 101; i++)\n\t        system.out.println(\n\t            "f(" + i + ") = " + fibonacci(i));\n\t\t\n\t\t// read -> cal\n\t\tlong current = system.currenttimemillis();\n\t\tsystem.out.println(fibonacci(100));\n\t\tsystem.out.println(system.currenttimemillis()-current);\n\t}\n}\n\n\n * 集合--》取元素的一个属性--》去重---》组装成list--》返回\n\nlist<likedo> likedos=new arraylist<likedo>();\nlist<long> liketidlist = likedos.stream().map(likedo::gettid)\n                .distinct().collect(collectors.tolist());\n\n\n * 集合--》按表达式过滤--》遍历、每个元系处理--》放入预先定义的集合中\n\n  map<string, stkproduct> newstockname2product = maps.newconcurrentmap();\n        stockproducts.stream().filter(stkproduct -> stkproduct.enabled).foreach(stkproduct -> {\n            string newname = bcconvert.bj2qj(stringutils.replace(stkproduct.name, " ", ""));\n            newstockname2product.put(newname, stkproduct);\n        });\n\n\n set<string> qjstocknames;\n qjstocknames.stream().filter(name -> !acautomaton.getkey2link().containskey(name)).foreach(name -> {\n            string value = "";\n            stkproduct stkproduct = stocknameqj2product.get(name);\n            if (stkproduct != null) {\n                value = stkproduct.name;\n            }\n            acautomaton.getkey2link().put(name, value);\n        });\n\n\n * 集合--》map\n\nlist<imagemodel> imagemodellist = null;\nmap<long, string> imagesmap = null;\nimagesmap = imagemodellist.stream().collect(collectors.tomap(imagemodel::getaid, o -> image_address_prefix + o.geturl()));\n              \n             \n\nmap<string, string> kvmap = postdetailcachelist.stream().collect(collectors.tomap((detailcache) ->\n                getbbssimplepostkey(detailcache.gettid()), json::tojsonstring));\n\n\nmap<long, long> pidtotid；\nlist<string> pidkeylist = pidtotid.entryset().stream().map((o) -> getkeybbsreplypid(o.getvalue(), o.getkey())).collect(collectors.tolist());\n\n\n\n * do模型---》model模型\n\nlist<addo> addolist;\naddolist.stream().map(addo -> convertadmodel(addo))\n                .collect(collectors.tolist());\n\n\n * phones 是一个list<string>，将相同的元素分组、归类\n\nlist<string> phones=new arraylist<string>();\n        phones.add("a");\n        phones.add("b");\n        phones.add("a");\n        phones.add("a");\n        phones.add("c");\n        phones.add("b");\n        map<string, list<string>> phoneclassify = phones.stream().collect(collectors.groupingby(item -> item));\n        system.out.println(phoneclassify);\n返回结果: \n{a=[a, a, a], b=[b, b], c=[c]}\n\n\n\n# 参考资料\n\n * lambda 表达式的 10 个示例在新窗口打开\n * learn-java8在新窗口打开\n * java8-tutorial在新窗口打开\n * 一文让你明白lambda用法与源码分析在新窗口打开\n * http://blog.csdn.net/renfufei/article/details/24600507在新窗口打开\n * http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/lambda-quickstart/index.html在新窗口打开\n * java8 lambda表达式教程 https://blog.csdn.net/ioriogami/article/details/12782141\n * java8 6个问题 https://wizardforcel.gitbooks.io/java8-tutorials/content/java%208%20%e7%9a%846%e4%b8%aa%e9%97%ae%e9%a2%98.html',charsets:{cjk:!0}},{title:"Java 8 - 类型推断优化",frontmatter:{},regularPath:"/java/java8/java8-type.html",relativePath:"java/java8/java8-type.md",key:"v-66e98988",path:"/java/java8/java8-type.html",headers:[{level:2,title:"Java 8 - 类型推断优化",slug:"java-8-类型推断优化",normalizedTitle:"java 8 - 类型推断优化",charIndex:2},{level:2,title:"简单理解泛型",slug:"简单理解泛型",normalizedTitle:"简单理解泛型",charIndex:130},{level:2,title:"泛型的尴尬",slug:"泛型的尴尬",normalizedTitle:"泛型的尴尬",charIndex:142},{level:2,title:"java7的泛型类型推断改进",slug:"java7的泛型类型推断改进",normalizedTitle:"java7的泛型类型推断改进",charIndex:153},{level:2,title:"Java8的泛型类型推断改进",slug:"java8的泛型类型推断改进",normalizedTitle:"java8的泛型类型推断改进",charIndex:173},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:193}],lastUpdated:"2023/4/10 01:17:23",lastUpdatedTimestamp:1681060643e3,headersStr:"Java 8 - 类型推断优化 简单理解泛型 泛型的尴尬 java7的泛型类型推断改进 Java8的泛型类型推断改进 总结",content:'# Java 8 - 类型推断优化\n\n> 理解Java 8 类型推断需理解几个问题: @pdai\n> \n>  * 什么是泛型\n>  * Java7对泛型推断做了哪些优化\n>  * Java8对此有做了哪些优化\n\n * Java 8 - 类型推断优化\n   * 简单理解泛型\n   * 泛型的尴尬\n   * java7的泛型类型推断改进\n   * Java8的泛型类型推断改进\n   * 总结\n\n\n# 简单理解泛型\n\n泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。通俗点将就是“类型的变量”。这种类型变量可以用在类、接口和方法的创建中。\n\n理解Java泛型最简单的方法是把它看成一种便捷语法，能节省你某些Java类型转换(casting)上的操作:\n\nList<Apple> box = new ArrayList<Apple>();\nbox.add(new Apple());\nApple apple =box.get(0);\n\n\n上面的代码自身已表达的很清楚: box是一个装有Apple对象的List。get方法返回一个Apple对象实例，这个过程不需要进行类型转换。没有泛型，上面的代码需要写成这样:\n\nApple apple = (Apple)box.get(0);\n\n\n\n# 泛型的尴尬\n\n泛型的最大优点是提供了程序的类型安全同时可以向后兼容，但也有尴尬的地方，就是每次定义时都要写明泛型的类型，这样显示指定不仅感觉有些冗长，最主要是很多程序员不熟悉泛型，因此很多时候不能够给出正确的类型参数，现在通过编译器自动推断泛型的参数类型，能够减少这样的情况，并提高代码可读性。\n\n\n# java7的泛型类型推断改进\n\n在以前的版本中使用泛型类型，需要在声明并赋值的时候，两侧都加上泛型类型。例如:\n\nMap<String, String> myMap = new HashMap<String, String>();\n\n\n你可能觉得:老子在声明变量的的时候已经指明了参数类型，为毛还要在初始化对象时再指定? 幸好，在Java SE 7中，这种方式得以改进，现在你可以使用如下语句进行声明并赋值:\n\nMap<String, String> myMap = new HashMap<>(); //注意后面的"<>"\n\n\n在这条语句中，编译器会根据变量声明时的泛型类型自动推断出实例化HashMap时的泛型类型。再次提醒一定要注意new HashMap后面的“<>”，只有加上这个“<>”才表示是自动类型推断，否则就是非泛型类型的HashMap，并且在使用编译器编译源代码时会给出一个警告提示。\n\n但是: Java SE 7在创建泛型实例时的类型推断是有限制的: 只有构造器的参数化类型在上下文中被显著的声明了，才可以使用类型推断，否则不行。例如: 下面的例子在java 7无法正确编译(但现在在java8里面可以编译，因为根据方法参数来自动推断泛型的类型):\n\nList<String> list = new ArrayList<>();\nlist.add("A");// 由于addAll期望获得Collection<? extends String>类型的参数，因此下面的语句无法通过\nlist.addAll(new ArrayList<>());\n\n\n\n# Java8的泛型类型推断改进\n\njava8里面泛型的目标类型推断主要2个:\n\n1.支持通过方法上下文推断泛型目标类型\n\n2.支持在方法调用链路当中，泛型类型推断传递到最后一个方法\n\n让我们看看官网的例子\n\nclass List<E> {\n   static <Z> List<Z> nil() { ... };\n   static <Z> List<Z> cons(Z head, List<Z> tail) { ... };\n   E head() { ... }\n}\n\n\n根据JEP101的特性，我们在调用上面方法的时候可以这样写\n\n//通过方法赋值的目标参数来自动推断泛型的类型\nList<String> l = List.nil();\n//而不是显示的指定类型\n//List<String> l = List.<String>nil();\n//通过前面方法参数类型推断泛型的类型\nList.cons(42, List.nil());\n//而不是显示的指定类型\n//List.cons(42, List.<Integer>nil());\n\n\n\n# 总结\n\n以上是JEP101的特性内容了，Java作为静态语言的代表者，可以说类型系统相当丰富。导致类型间互相转换的问题困扰着每个java程序员，通过编译器自动推断类型的东西可以稍微缓解一下类型转换太复杂的问题。 虽然说是小进步，但对于我们天天写代码的程序员，肯定能带来巨大的作用，至少心情更愉悦了',normalizedContent:'# java 8 - 类型推断优化\n\n> 理解java 8 类型推断需理解几个问题: @pdai\n> \n>  * 什么是泛型\n>  * java7对泛型推断做了哪些优化\n>  * java8对此有做了哪些优化\n\n * java 8 - 类型推断优化\n   * 简单理解泛型\n   * 泛型的尴尬\n   * java7的泛型类型推断改进\n   * java8的泛型类型推断改进\n   * 总结\n\n\n# 简单理解泛型\n\n泛型是java se 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。通俗点将就是“类型的变量”。这种类型变量可以用在类、接口和方法的创建中。\n\n理解java泛型最简单的方法是把它看成一种便捷语法，能节省你某些java类型转换(casting)上的操作:\n\nlist<apple> box = new arraylist<apple>();\nbox.add(new apple());\napple apple =box.get(0);\n\n\n上面的代码自身已表达的很清楚: box是一个装有apple对象的list。get方法返回一个apple对象实例，这个过程不需要进行类型转换。没有泛型，上面的代码需要写成这样:\n\napple apple = (apple)box.get(0);\n\n\n\n# 泛型的尴尬\n\n泛型的最大优点是提供了程序的类型安全同时可以向后兼容，但也有尴尬的地方，就是每次定义时都要写明泛型的类型，这样显示指定不仅感觉有些冗长，最主要是很多程序员不熟悉泛型，因此很多时候不能够给出正确的类型参数，现在通过编译器自动推断泛型的参数类型，能够减少这样的情况，并提高代码可读性。\n\n\n# java7的泛型类型推断改进\n\n在以前的版本中使用泛型类型，需要在声明并赋值的时候，两侧都加上泛型类型。例如:\n\nmap<string, string> mymap = new hashmap<string, string>();\n\n\n你可能觉得:老子在声明变量的的时候已经指明了参数类型，为毛还要在初始化对象时再指定? 幸好，在java se 7中，这种方式得以改进，现在你可以使用如下语句进行声明并赋值:\n\nmap<string, string> mymap = new hashmap<>(); //注意后面的"<>"\n\n\n在这条语句中，编译器会根据变量声明时的泛型类型自动推断出实例化hashmap时的泛型类型。再次提醒一定要注意new hashmap后面的“<>”，只有加上这个“<>”才表示是自动类型推断，否则就是非泛型类型的hashmap，并且在使用编译器编译源代码时会给出一个警告提示。\n\n但是: java se 7在创建泛型实例时的类型推断是有限制的: 只有构造器的参数化类型在上下文中被显著的声明了，才可以使用类型推断，否则不行。例如: 下面的例子在java 7无法正确编译(但现在在java8里面可以编译，因为根据方法参数来自动推断泛型的类型):\n\nlist<string> list = new arraylist<>();\nlist.add("a");// 由于addall期望获得collection<? extends string>类型的参数，因此下面的语句无法通过\nlist.addall(new arraylist<>());\n\n\n\n# java8的泛型类型推断改进\n\njava8里面泛型的目标类型推断主要2个:\n\n1.支持通过方法上下文推断泛型目标类型\n\n2.支持在方法调用链路当中，泛型类型推断传递到最后一个方法\n\n让我们看看官网的例子\n\nclass list<e> {\n   static <z> list<z> nil() { ... };\n   static <z> list<z> cons(z head, list<z> tail) { ... };\n   e head() { ... }\n}\n\n\n根据jep101的特性，我们在调用上面方法的时候可以这样写\n\n//通过方法赋值的目标参数来自动推断泛型的类型\nlist<string> l = list.nil();\n//而不是显示的指定类型\n//list<string> l = list.<string>nil();\n//通过前面方法参数类型推断泛型的类型\nlist.cons(42, list.nil());\n//而不是显示的指定类型\n//list.cons(42, list.<integer>nil());\n\n\n\n# 总结\n\n以上是jep101的特性内容了，java作为静态语言的代表者，可以说类型系统相当丰富。导致类型间互相转换的问题困扰着每个java程序员，通过编译器自动推断类型的东西可以稍微缓解一下类型转换太复杂的问题。 虽然说是小进步，但对于我们天天写代码的程序员，肯定能带来巨大的作用，至少心情更愉悦了',charsets:{cjk:!0}},{title:"Java 8 - 类型注解",frontmatter:{},regularPath:"/java/java8/java8-type-anno.html",relativePath:"java/java8/java8-type-anno.md",key:"v-58b25868",path:"/java/java8/java8-type-anno.html",headers:[{level:2,title:"Java 8 - 类型注解",slug:"java-8-类型注解",normalizedTitle:"java 8 - 类型注解",charIndex:2},{level:2,title:"什么是类型注解",slug:"什么是类型注解",normalizedTitle:"什么是类型注解",charIndex:87},{level:2,title:"类型注解的作用",slug:"类型注解的作用",normalizedTitle:"类型注解的作用",charIndex:101},{level:2,title:"类型注解向下兼容的解决方案",slug:"类型注解向下兼容的解决方案",normalizedTitle:"类型注解向下兼容的解决方案",charIndex:187},{level:2,title:"关于JSR 308",slug:"关于jsr-308",normalizedTitle:"关于jsr 308",charIndex:206},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:221}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java 8 - 类型注解 什么是类型注解 类型注解的作用 类型注解向下兼容的解决方案 关于JSR 308 总结",content:'# Java 8 - 类型注解\n\n> 理解Java 8 类型注解需理解几个问题: @pdai\n> \n>  * 注解在JDK哪个版本中出现的，可以在哪些地方用注解?\n>  * 什么是类型注解?\n>  * 类型注解的作用是什么?\n>  * 为什么会出现类型注解(JSR308)?\n\n * Java 8 - 类型注解\n   * 什么是类型注解\n   * 类型注解的作用\n   * 类型注解向下兼容的解决方案\n   * 关于JSR 308\n   * 总结\n\n\n# 什么是类型注解\n\n> 注解大家都知道，从java5开始加入这一特性，发展到现在已然是遍地开花，在很多框架中得到了广泛的使用，用来简化程序中的配置。那充满争议的类型注解究竟是什么? 复杂还是便捷?\n\n 1. 在java 8之前，注解只能是在声明的地方所使用，比如类，方法，属性；\n\n 2. java 8里面，注解可以应用在任何地方，比如:\n\n创建类实例\n\nnew @Interned MyObject();\n\n\n类型映射\n\nmyString = (@NonNull String) str;\n\n\nimplements 语句中\n\nclass UnmodifiableList<T> implements @Readonly List<@Readonly T> { … }\n\n\nthrow exception声明\n\nvoid monitorTemperature() throws @Critical TemperatureException { … }\n\n\n需要注意的是，类型注解只是语法而不是语义，并不会影响java的编译时间，加载时间，以及运行时间，也就是说，编译成class文件的时候并不包含类型注解。\n\n\n# 类型注解的作用\n\n先看看下面代码\n\nCollections.emptyList().add("One");\nint i=Integer.parseInt("hello");\nSystem.console().readLine();\n\n\n上面的代码编译是通过的，但运行是会分别报UnsupportedOperationException； NumberFormatException；NullPointerException异常，这些都是runtime error；\n\n类型注解被用来支持在Java的程序中做强类型检查。配合插件式的check framework，可以在编译的时候检测出runtime error，以提高代码质量。这就是类型注解的作用了。\n\ncheck framework是第三方工具，配合Java的类型注解效果就是1+1>2。它可以嵌入到javac编译器里面，可以配合ant和maven使用, 地址是http://types.cs.washington.edu/checker-framework/。 check framework可以找到类型注解出现的地方并检查，举个简单的例子:\n\nimport checkers.nullness.quals.*;\npublic class GetStarted {\n    void sample() {\n        @NonNull Object ref = new Object();\n    }\n}\n\n\n使用javac编译上面的类\n\njavac -processor checkers.nullness.NullnessChecker GetStarted.java\n\n\n编译是通过，但如果修改成\n\n@NonNull Object ref = null;\n\n\n再次编译，则出现\n\nGetStarted.java:5: incompatible types.\nfound   : @Nullable <nulltype>\nrequired: @NonNull Object\n        @NonNull Object ref = null;\n                              ^\n1 error\n\n\n\n# 类型注解向下兼容的解决方案\n\n如果你不想使用类型注解检测出来错误，则不需要processor，直接javac GetStarted.java是可以编译通过的，这是在java 8 with Type Annotation Support版本里面可以，但java 5,6,7版本都不行，因为javac编译器不知道@NonNull是什么东西，但check framework 有个向下兼容的解决方案，就是将类型注解nonnull用/**/注释起来，比如上面例子修改为\n\nimport checkers.nullness.quals.*;\npublic class GetStarted {\n    void sample() {\n        /*@NonNull*/ Object ref = null;\n    }\n}\n\n\n这样javac编译器就会忽略掉注释块，但用check framework里面的javac编译器同样能够检测出nonnull错误。 通过类型注解+check framework我们可以看到，现在runtime error可以在编译时候就能找到。\n\n\n# 关于JSR 308\n\nJSR 308想要解决在Java 1.5注解中出现的两个问题:\n\n * 在句法上对注解的限制: 只能把注解写在声明的地方\n * 类型系统在语义上的限制: 类型系统还做不到预防所有的bug\n\nJSR 308 通过如下方法解决上述两个问题:\n\n * 对Java语言的句法进行扩充，允许注解出现在更多的位置上。包括: 方法接收器(method receivers，译注: 例public int size() @Readonly { … })，泛型参数，数组，类型转换，类型测试，对象创建，类型参数绑定，类继承和throws子句。其实就是类型注解，现在是java 8的一个特性\n * 通过引入可插拔的类型系统(pluggable type systems)能够创建功能更强大的注解处理器。类型检查器对带有类型限定注解的源码进行分析，一旦发现不匹配等错误之处就会产生警告信息。其实就是check framework\n\n对JSR308，有人反对，觉得更复杂更静态了，比如\n\n@NotEmpty List<@NonNull String> strings = new ArrayList<@NonNull String>()>\n\n\n换成动态语言为\n\nvar strings = ["one", "two"];\n\n\n有人赞成，说到底，代码才是“最根本”的文档。代码中包含的注解清楚表明了代码编写者的意图。当没有及时更新或者有遗漏的时候，恰恰是注解中包含的意图信息，最容易在其他文档中被丢失。而且将运行时的错误转到编译阶段，不但可以加速开发进程，还可以节省测试时检查bug的时间。\n\n\n# 总结\n\n并不是人人都喜欢这个特性，特别是动态语言比较流行的今天，所幸，java 8并不强求大家使用这个特性，反对的人可以不使用这一特性，而对代码质量有些要求比较高的人或公司可以采用JSR 308，毕竟代码才是“最基本”的文档，这句话我是赞同的。虽然代码会增多，但可以使你的代码更具有表达意义。对这个特性有何看法，大家各抒己见。。。。',normalizedContent:'# java 8 - 类型注解\n\n> 理解java 8 类型注解需理解几个问题: @pdai\n> \n>  * 注解在jdk哪个版本中出现的，可以在哪些地方用注解?\n>  * 什么是类型注解?\n>  * 类型注解的作用是什么?\n>  * 为什么会出现类型注解(jsr308)?\n\n * java 8 - 类型注解\n   * 什么是类型注解\n   * 类型注解的作用\n   * 类型注解向下兼容的解决方案\n   * 关于jsr 308\n   * 总结\n\n\n# 什么是类型注解\n\n> 注解大家都知道，从java5开始加入这一特性，发展到现在已然是遍地开花，在很多框架中得到了广泛的使用，用来简化程序中的配置。那充满争议的类型注解究竟是什么? 复杂还是便捷?\n\n 1. 在java 8之前，注解只能是在声明的地方所使用，比如类，方法，属性；\n\n 2. java 8里面，注解可以应用在任何地方，比如:\n\n创建类实例\n\nnew @interned myobject();\n\n\n类型映射\n\nmystring = (@nonnull string) str;\n\n\nimplements 语句中\n\nclass unmodifiablelist<t> implements @readonly list<@readonly t> { … }\n\n\nthrow exception声明\n\nvoid monitortemperature() throws @critical temperatureexception { … }\n\n\n需要注意的是，类型注解只是语法而不是语义，并不会影响java的编译时间，加载时间，以及运行时间，也就是说，编译成class文件的时候并不包含类型注解。\n\n\n# 类型注解的作用\n\n先看看下面代码\n\ncollections.emptylist().add("one");\nint i=integer.parseint("hello");\nsystem.console().readline();\n\n\n上面的代码编译是通过的，但运行是会分别报unsupportedoperationexception； numberformatexception；nullpointerexception异常，这些都是runtime error；\n\n类型注解被用来支持在java的程序中做强类型检查。配合插件式的check framework，可以在编译的时候检测出runtime error，以提高代码质量。这就是类型注解的作用了。\n\ncheck framework是第三方工具，配合java的类型注解效果就是1+1>2。它可以嵌入到javac编译器里面，可以配合ant和maven使用, 地址是http://types.cs.washington.edu/checker-framework/。 check framework可以找到类型注解出现的地方并检查，举个简单的例子:\n\nimport checkers.nullness.quals.*;\npublic class getstarted {\n    void sample() {\n        @nonnull object ref = new object();\n    }\n}\n\n\n使用javac编译上面的类\n\njavac -processor checkers.nullness.nullnesschecker getstarted.java\n\n\n编译是通过，但如果修改成\n\n@nonnull object ref = null;\n\n\n再次编译，则出现\n\ngetstarted.java:5: incompatible types.\nfound   : @nullable <nulltype>\nrequired: @nonnull object\n        @nonnull object ref = null;\n                              ^\n1 error\n\n\n\n# 类型注解向下兼容的解决方案\n\n如果你不想使用类型注解检测出来错误，则不需要processor，直接javac getstarted.java是可以编译通过的，这是在java 8 with type annotation support版本里面可以，但java 5,6,7版本都不行，因为javac编译器不知道@nonnull是什么东西，但check framework 有个向下兼容的解决方案，就是将类型注解nonnull用/**/注释起来，比如上面例子修改为\n\nimport checkers.nullness.quals.*;\npublic class getstarted {\n    void sample() {\n        /*@nonnull*/ object ref = null;\n    }\n}\n\n\n这样javac编译器就会忽略掉注释块，但用check framework里面的javac编译器同样能够检测出nonnull错误。 通过类型注解+check framework我们可以看到，现在runtime error可以在编译时候就能找到。\n\n\n# 关于jsr 308\n\njsr 308想要解决在java 1.5注解中出现的两个问题:\n\n * 在句法上对注解的限制: 只能把注解写在声明的地方\n * 类型系统在语义上的限制: 类型系统还做不到预防所有的bug\n\njsr 308 通过如下方法解决上述两个问题:\n\n * 对java语言的句法进行扩充，允许注解出现在更多的位置上。包括: 方法接收器(method receivers，译注: 例public int size() @readonly { … })，泛型参数，数组，类型转换，类型测试，对象创建，类型参数绑定，类继承和throws子句。其实就是类型注解，现在是java 8的一个特性\n * 通过引入可插拔的类型系统(pluggable type systems)能够创建功能更强大的注解处理器。类型检查器对带有类型限定注解的源码进行分析，一旦发现不匹配等错误之处就会产生警告信息。其实就是check framework\n\n对jsr308，有人反对，觉得更复杂更静态了，比如\n\n@notempty list<@nonnull string> strings = new arraylist<@nonnull string>()>\n\n\n换成动态语言为\n\nvar strings = ["one", "two"];\n\n\n有人赞成，说到底，代码才是“最根本”的文档。代码中包含的注解清楚表明了代码编写者的意图。当没有及时更新或者有遗漏的时候，恰恰是注解中包含的意图信息，最容易在其他文档中被丢失。而且将运行时的错误转到编译阶段，不但可以加速开发进程，还可以节省测试时检查bug的时间。\n\n\n# 总结\n\n并不是人人都喜欢这个特性，特别是动态语言比较流行的今天，所幸，java 8并不强求大家使用这个特性，反对的人可以不使用这一特性，而对代码质量有些要求比较高的人或公司可以采用jsr 308，毕竟代码才是“最基本”的文档，这句话我是赞同的。虽然代码会增多，但可以使你的代码更具有表达意义。对这个特性有何看法，大家各抒己见。。。。',charsets:{cjk:!0}},{title:"♥Java8特性知识体系详解♥",frontmatter:{},regularPath:"/java/java8/java8.html",relativePath:"java/java8/java8.md",key:"v-6b101374",path:"/java/java8/java8.html",headers:[{level:2,title:"♥Java8特性知识体系详解♥",slug:"♥java8特性知识体系详解♥",normalizedTitle:"♥java8特性知识体系详解♥",charIndex:2},{level:2,title:"知识体系",slug:"知识体系",normalizedTitle:"知识体系",charIndex:10},{level:2,title:"相关文章",slug:"相关文章",normalizedTitle:"相关文章",charIndex:160},{level:3,title:"函数编程",slug:"函数编程",normalizedTitle:"函数编程",charIndex:172},{level:3,title:"Optional类",slug:"optional类",normalizedTitle:"optional类",charIndex:184},{level:3,title:"default方法",slug:"default方法",normalizedTitle:"default方法",charIndex:201},{level:3,title:"类型注解",slug:"类型注解",normalizedTitle:"类型注解",charIndex:218},{level:3,title:"重复注解",slug:"重复注解",normalizedTitle:"重复注解",charIndex:230},{level:3,title:"类型推断",slug:"类型推断",normalizedTitle:"类型推断",charIndex:242},{level:3,title:"JRE 精简",slug:"jre-精简",normalizedTitle:"jre 精简",charIndex:254},{level:3,title:"LocalDate/LocalDateTime",slug:"localdate-localdatetime",normalizedTitle:"localdate/localdatetime",charIndex:268},{level:3,title:"JavaFX",slug:"javafx",normalizedTitle:"javafx",charIndex:299},{level:3,title:"PermGen移除",slug:"permgen移除",normalizedTitle:"permgen移除",charIndex:313},{level:3,title:"StampedLock",slug:"stampedlock",normalizedTitle:"stampedlock",charIndex:330},{level:3,title:"其它更新",slug:"其它更新",normalizedTitle:"其它更新",charIndex:349},{level:2,title:"参考文档",slug:"参考文档",normalizedTitle:"参考文档",charIndex:359}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"♥Java8特性知识体系详解♥ 知识体系 相关文章 函数编程 Optional类 default方法 类型注解 重复注解 类型推断 JRE 精简 LocalDate/LocalDateTime JavaFX PermGen移除 StampedLock 其它更新 参考文档",content:"# ♥Java8特性知识体系详解♥\n\n> Java 8 新特性详解汇总。@pdai\n> \n>  * Java 新特性的增加都是来源于 JSR或者JEP\n>  * JSR论坛: https://jcp.org/en/jsr/detail?id=335\n\n * ♥Java8特性知识体系详解♥\n   * 知识体系\n   * 相关文章\n     * 函数编程\n     * Optional类\n     * default方法\n     * 类型注解\n     * 重复注解\n     * 类型推断\n     * JRE 精简\n     * LocalDate/LocalDateTime\n     * JavaFX\n     * PermGen移除\n     * StampedLock\n     * 其它更新\n   * 参考文档\n\n\n# 知识体系\n\n\n\n\n# 相关文章\n\n\n# 函数编程\n\n> 面向对象编程是对数据进行抽象；函数式编程是对行为进行抽象。\n\n * Lambda 表达式的特点\n * Lambda 表达式使用和Stream下的接口\n * 函数接口定义和使用，四大内置函数接口Consumer，Function，Supplier, Predicate.\n * Comparator排序为例贯穿所有知识点。\n\n详细分析请参看: Java 8 - 函数编程\n\n\n# Optional类\n\n> 这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。\n\n * Optional类的意义\n * Optional类有哪些常用的方法\n * Optional举例贯穿所有知识点\n * 多重类嵌套Null值判断\n\n详细分析请参看: Java 8 - Optional类\n\n\n# default方法\n\n> 默认方法给予我们修改接口而不破坏原来的实现类的结构提供了便利，目前java 8的集合框架已经大量使用了默认方法来改进了，当我们最终开始使用Java 8的lambdas表达式时，提供给我们一个平滑的过渡体验。\n\n * 为什么会出现默认方法?\n * 接口中出现默认方法，且类可以实现多接口的，那和抽象类有啥区别?\n * 多重实现的默认方法冲突怎么办?\n\n详细分析请参看: Java 8 - default方法\n\n\n# 类型注解\n\n> 那充满争议的类型注解究竟是什么? 复杂还是便捷?\n\n * 注解在JDK哪个版本中出现的，可以在哪些地方用注解?\n * 什么是类型注解?\n * 类型注解的作用是什么?\n * 为什么会出现类型注解(JSR308)?\n\n详细分析请参看: Java 8 - 类型注解\n\n\n# 重复注解\n\n * Java8之前对重复注解是怎么做的?\n * Java8对重复注解添加了什么支持?\n\n详细分析请参看: Java 8 - 重复注解\n\n\n# 类型推断\n\n> 导致类型间互相转换的问题困扰着每个java程序员，通过编译器自动推断类型的东西可以稍微缓解一下类型转换太复杂的问题。\n\n * 什么是泛型?\n * Java7对泛型推断做了哪些优化?\n * Java8对此有做了哪些优化?\n\n详细分析请参看: Java 8 - 类型推断优化\n\n\n# JRE 精简\n\n> 模块化特性是javaer所期待的特性, 一个占用资源少的JRE运行环境，紧凑的JRE特性的出现，能带来以后的物联网的发展，甚至还是会有大量的java应用程序出现在物联网上面。\n\n * 为什么精简Java8 JRE，及好处是啥?\n * 紧凑的JRE分3种，分别是compact1、compact2、compact3，他们的关系是?\n * 在不同平台上如何编译等?\n\n详细分析请参看: Java 8 - JRE精简\n\n\n# LocalDate/LocalDateTime\n\n> Date/Calendar槽点, java8对其进行了重写。\n\n * Java8之前的Date有哪些槽点? (Calendar的所有属性都是可变的，SimpleDateFormat的线程不安全性等)\n * Java8之前使用哪些常用的第三方时间库?\n * Java8关于时间和日期有哪些类和方法，变比Java8之前它的特点是什么?\n * 其它语言时间库?\n\n详细分析请参看: Java 8 - LocalDate/LocalDateTime\n\n\n# JavaFX\n\n> JavaFX主要致力于富客户端开发，以弥补swing的缺陷，主要提供图形库与media库，支持audio,video,graphics,animation,3D等，同时采用现代化的css方式支持界面设计。同时又采用XUI方式以XML方式设计UI界面，达到显示与逻辑的分离。\n\n * javaFX发展历程?\n * Java8对其增加了哪些特性?\n\n详细分析请参看: Java 8 - JavaFX\n\n\n# PermGen移除\n\n> PermGen space的全称是Permanent Generation space,是指内存的永久保存区域。PermGen space是Oracle-Sun Hotspot才有，JRockit以及J9是没有这个区域。\n\n * Java8之前 “java.lang.OutOfMemoryError: PermGen space”是怎么引起的，怎么解决的?\n * 新增加的元空间(Metaspace)包含哪些东西，画出图\n * 元空间(Metaspace)和PermGen对比\n\n详细分析请参看: Java 8 - 移除Permgen\n\n\n# StampedLock\n\n * 为什么会引入StampedLock\n * 用Lock写悲观锁和乐观锁举例\n * 用StampedLock写悲观锁和乐观锁举例\n * 性能对比\n\n详细分析请参看: Java 8 - StampedLock\n\n\n# 其它更新\n\n * Java8 还有哪些其它更新\n   * 字符串\n   * Base64\n   * Random\n   * Nashorn\n   * ...\n\n详细分析请参看: Java 8 - 其它更新\n\n\n# 参考文档\n\n> 主要参考自以下文档:\n\n * Java 8 教程汇总 https://wizardforcel.gitbooks.io/java8-tutorials/content/index.html\n\n * Java8简明教程gitbook https://wizardforcel.gitbooks.io/modern-java\n\n * Java8简明教程 https://github.com/wizardforcel/modern-java-zh\n\n * Java8新特性探究 https://wizardforcel.gitbooks.io/java8-new-features/content/",normalizedContent:"# ♥java8特性知识体系详解♥\n\n> java 8 新特性详解汇总。@pdai\n> \n>  * java 新特性的增加都是来源于 jsr或者jep\n>  * jsr论坛: https://jcp.org/en/jsr/detail?id=335\n\n * ♥java8特性知识体系详解♥\n   * 知识体系\n   * 相关文章\n     * 函数编程\n     * optional类\n     * default方法\n     * 类型注解\n     * 重复注解\n     * 类型推断\n     * jre 精简\n     * localdate/localdatetime\n     * javafx\n     * permgen移除\n     * stampedlock\n     * 其它更新\n   * 参考文档\n\n\n# 知识体系\n\n\n\n\n# 相关文章\n\n\n# 函数编程\n\n> 面向对象编程是对数据进行抽象；函数式编程是对行为进行抽象。\n\n * lambda 表达式的特点\n * lambda 表达式使用和stream下的接口\n * 函数接口定义和使用，四大内置函数接口consumer，function，supplier, predicate.\n * comparator排序为例贯穿所有知识点。\n\n详细分析请参看: java 8 - 函数编程\n\n\n# optional类\n\n> 这是一个可以为null的容器对象。如果值存在则ispresent()方法会返回true，调用get()方法会返回该对象。\n\n * optional类的意义\n * optional类有哪些常用的方法\n * optional举例贯穿所有知识点\n * 多重类嵌套null值判断\n\n详细分析请参看: java 8 - optional类\n\n\n# default方法\n\n> 默认方法给予我们修改接口而不破坏原来的实现类的结构提供了便利，目前java 8的集合框架已经大量使用了默认方法来改进了，当我们最终开始使用java 8的lambdas表达式时，提供给我们一个平滑的过渡体验。\n\n * 为什么会出现默认方法?\n * 接口中出现默认方法，且类可以实现多接口的，那和抽象类有啥区别?\n * 多重实现的默认方法冲突怎么办?\n\n详细分析请参看: java 8 - default方法\n\n\n# 类型注解\n\n> 那充满争议的类型注解究竟是什么? 复杂还是便捷?\n\n * 注解在jdk哪个版本中出现的，可以在哪些地方用注解?\n * 什么是类型注解?\n * 类型注解的作用是什么?\n * 为什么会出现类型注解(jsr308)?\n\n详细分析请参看: java 8 - 类型注解\n\n\n# 重复注解\n\n * java8之前对重复注解是怎么做的?\n * java8对重复注解添加了什么支持?\n\n详细分析请参看: java 8 - 重复注解\n\n\n# 类型推断\n\n> 导致类型间互相转换的问题困扰着每个java程序员，通过编译器自动推断类型的东西可以稍微缓解一下类型转换太复杂的问题。\n\n * 什么是泛型?\n * java7对泛型推断做了哪些优化?\n * java8对此有做了哪些优化?\n\n详细分析请参看: java 8 - 类型推断优化\n\n\n# jre 精简\n\n> 模块化特性是javaer所期待的特性, 一个占用资源少的jre运行环境，紧凑的jre特性的出现，能带来以后的物联网的发展，甚至还是会有大量的java应用程序出现在物联网上面。\n\n * 为什么精简java8 jre，及好处是啥?\n * 紧凑的jre分3种，分别是compact1、compact2、compact3，他们的关系是?\n * 在不同平台上如何编译等?\n\n详细分析请参看: java 8 - jre精简\n\n\n# localdate/localdatetime\n\n> date/calendar槽点, java8对其进行了重写。\n\n * java8之前的date有哪些槽点? (calendar的所有属性都是可变的，simpledateformat的线程不安全性等)\n * java8之前使用哪些常用的第三方时间库?\n * java8关于时间和日期有哪些类和方法，变比java8之前它的特点是什么?\n * 其它语言时间库?\n\n详细分析请参看: java 8 - localdate/localdatetime\n\n\n# javafx\n\n> javafx主要致力于富客户端开发，以弥补swing的缺陷，主要提供图形库与media库，支持audio,video,graphics,animation,3d等，同时采用现代化的css方式支持界面设计。同时又采用xui方式以xml方式设计ui界面，达到显示与逻辑的分离。\n\n * javafx发展历程?\n * java8对其增加了哪些特性?\n\n详细分析请参看: java 8 - javafx\n\n\n# permgen移除\n\n> permgen space的全称是permanent generation space,是指内存的永久保存区域。permgen space是oracle-sun hotspot才有，jrockit以及j9是没有这个区域。\n\n * java8之前 “java.lang.outofmemoryerror: permgen space”是怎么引起的，怎么解决的?\n * 新增加的元空间(metaspace)包含哪些东西，画出图\n * 元空间(metaspace)和permgen对比\n\n详细分析请参看: java 8 - 移除permgen\n\n\n# stampedlock\n\n * 为什么会引入stampedlock\n * 用lock写悲观锁和乐观锁举例\n * 用stampedlock写悲观锁和乐观锁举例\n * 性能对比\n\n详细分析请参看: java 8 - stampedlock\n\n\n# 其它更新\n\n * java8 还有哪些其它更新\n   * 字符串\n   * base64\n   * random\n   * nashorn\n   * ...\n\n详细分析请参看: java 8 - 其它更新\n\n\n# 参考文档\n\n> 主要参考自以下文档:\n\n * java 8 教程汇总 https://wizardforcel.gitbooks.io/java8-tutorials/content/index.html\n\n * java8简明教程gitbook https://wizardforcel.gitbooks.io/modern-java\n\n * java8简明教程 https://github.com/wizardforcel/modern-java-zh\n\n * java8新特性探究 https://wizardforcel.gitbooks.io/java8-new-features/content/",charsets:{cjk:!0}},{title:"JUC原子类: CAS, Unsafe和原子类详解",frontmatter:{},regularPath:"/java/thread/java-thread-x-juc-AtomicInteger.html",relativePath:"java/thread/java-thread-x-juc-AtomicInteger.md",key:"v-4a34de8e",path:"/java/thread/java-thread-x-juc-AtomicInteger.html",headers:[{level:2,title:"JUC原子类: CAS, Unsafe和原子类详解",slug:"juc原子类-cas-unsafe和原子类详解",normalizedTitle:"juc原子类: cas, unsafe和原子类详解",charIndex:2},{level:2,title:"带着BAT大厂的面试问题去理解",slug:"带着bat大厂的面试问题去理解",normalizedTitle:"带着bat大厂的面试问题去理解",charIndex:199},{level:2,title:"CAS",slug:"cas",normalizedTitle:"cas",charIndex:10},{level:3,title:"什么是CAS",slug:"什么是cas",normalizedTitle:"什么是cas",charIndex:231},{level:3,title:"CAS使用示例",slug:"cas使用示例",normalizedTitle:"cas使用示例",charIndex:245},{level:3,title:"CAS 问题",slug:"cas-问题",normalizedTitle:"cas 问题",charIndex:260},{level:2,title:"UnSafe类详解",slug:"unsafe类详解",normalizedTitle:"unsafe类详解",charIndex:330},{level:3,title:"Unsafe与CAS",slug:"unsafe与cas",normalizedTitle:"unsafe与cas",charIndex:347},{level:3,title:"Unsafe底层",slug:"unsafe底层",normalizedTitle:"unsafe底层",charIndex:365},{level:3,title:"Unsafe其它功能",slug:"unsafe其它功能",normalizedTitle:"unsafe其它功能",charIndex:381},{level:2,title:"AtomicInteger",slug:"atomicinteger",normalizedTitle:"atomicinteger",charIndex:397},{level:3,title:"使用举例",slug:"使用举例",normalizedTitle:"使用举例",charIndex:418},{level:3,title:"源码解析",slug:"源码解析",normalizedTitle:"源码解析",charIndex:430},{level:2,title:"延伸到所有原子类：共12个",slug:"延伸到所有原子类-共12个",normalizedTitle:"延伸到所有原子类：共12个",charIndex:9745},{level:3,title:"原子更新基本类型",slug:"原子更新基本类型",normalizedTitle:"原子更新基本类型",charIndex:461},{level:3,title:"原子更新数组",slug:"原子更新数组",normalizedTitle:"原子更新数组",charIndex:477},{level:3,title:"原子更新引用类型",slug:"原子更新引用类型",normalizedTitle:"原子更新引用类型",charIndex:491},{level:3,title:"原子更新字段类",slug:"原子更新字段类",normalizedTitle:"原子更新字段类",charIndex:507},{level:2,title:"再讲讲AtomicStampedReference解决CAS的ABA问题",slug:"再讲讲atomicstampedreference解决cas的aba问题",normalizedTitle:"再讲讲atomicstampedreference解决cas的aba问题",charIndex:520},{level:3,title:"AtomicStampedReference解决ABA问题",slug:"atomicstampedreference解决aba问题",normalizedTitle:"atomicstampedreference解决aba问题",charIndex:564},{level:3,title:"使用举例",slug:"使用举例-2",normalizedTitle:"使用举例",charIndex:418},{level:3,title:"java中还有哪些类可以解决ABA的问题?",slug:"java中还有哪些类可以解决aba的问题",normalizedTitle:"java中还有哪些类可以解决aba的问题?",charIndex:613},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:640}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"JUC原子类: CAS, Unsafe和原子类详解 带着BAT大厂的面试问题去理解 CAS 什么是CAS CAS使用示例 CAS 问题 UnSafe类详解 Unsafe与CAS Unsafe底层 Unsafe其它功能 AtomicInteger 使用举例 源码解析 延伸到所有原子类：共12个 原子更新基本类型 原子更新数组 原子更新引用类型 原子更新字段类 再讲讲AtomicStampedReference解决CAS的ABA问题 AtomicStampedReference解决ABA问题 使用举例 java中还有哪些类可以解决ABA的问题? 参考文章",content:'# JUC原子类: CAS, Unsafe和原子类详解\n\n> JUC中多数类是通过volatile和CAS来实现的，CAS本质上提供的是一种无锁方案，而Synchronized和Lock是互斥锁方案; java原子类本质上使用的是CAS，而CAS底层是通过Unsafe类实现的。所以本章将对CAS, Unsafe和原子类详解。\n\n * JUC原子类: CAS, Unsafe和原子类详解\n   * 带着BAT大厂的面试问题去理解\n   * CAS\n     * 什么是CAS\n     * CAS使用示例\n     * CAS 问题\n       * ABA问题\n       * 循环时间长开销大\n       * 只能保证一个共享变量的原子操作\n   * UnSafe类详解\n     * Unsafe与CAS\n     * Unsafe底层\n     * Unsafe其它功能\n   * AtomicInteger\n     * 使用举例\n     * 源码解析\n   * 延伸到所有原子类：共13个\n     * 原子更新基本类型\n     * 原子更新数组\n     * 原子更新引用类型\n     * 原子更新字段类\n   * 再讲讲AtomicStampedReference解决CAS的ABA问题\n     * AtomicStampedReference解决ABA问题\n     * 使用举例\n     * java中还有哪些类可以解决ABA的问题?\n   * 参考文章\n\n\n# 带着BAT大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 线程安全的实现方法有哪些?\n * 什么是CAS?\n * CAS使用示例，结合AtomicInteger给出示例?\n * CAS会有哪些问题?\n * 针对这这些问题，Java提供了哪几个解决的?\n * AtomicInteger底层实现? CAS+volatile\n * 请阐述你对Unsafe类的理解?\n * 说说你对Java原子类的理解? 包含13个，4组分类，说说作用和使用场景。\n * AtomicStampedReference是什么?\n * AtomicStampedReference是怎么解决ABA的? 内部使用Pair来存储元素值及其版本号\n * java中还有哪些类可以解决ABA的问题? AtomicMarkableReference\n\n\n# CAS\n\n前面我们说到，线程安全的实现方法包含:\n\n * 互斥同步: synchronized 和 ReentrantLock\n * 非阻塞同步: CAS, AtomicXXXX\n * 无同步方案: 栈封闭，Thread Local，可重入代码\n\n具体可以参看：线程安全的实现方法，这里我们将对CAS重点阐释。\n\n\n# 什么是CAS\n\nCAS的全称为Compare-And-Swap，直译就是对比交换。是一条CPU的原子指令，其作用是让CPU先进行比较两个值是否相等，然后原子地更新某个位置的值，经过调查发现，其实现方式是基于硬件平台的汇编指令，就是说CAS是靠硬件实现的，JVM只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的接口。   简单解释：CAS操作需要输入两个数值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较下在旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。\n\nCAS操作是原子性的，所以多线程并发使用CAS更新数据时，可以不使用锁。JDK中大量使用了CAS来更新数据而防止加锁(synchronized 重量级锁)来保持原子更新。\n\n相信sql大家都熟悉，类似sql中的条件更新一样：update set id=3 from table where id=2。因为单条sql执行具有原子性，如果有多个线程同时执行此sql语句，只有一条能更新成功。\n\n\n# CAS使用示例\n\n如果不使用CAS，在高并发下，多线程同时修改一个变量的值我们需要synchronized加锁(可能有人说可以用Lock加锁，Lock底层的AQS也是基于CAS进行获取锁的)。\n\npublic class Test {\n    private int i=0;\n    public synchronized int add(){\n        return i++;\n    }\n}\n\n\njava中为我们提供了AtomicInteger 原子类(底层基于CAS进行更新数据的)，不需要加锁就在多线程并发场景下实现数据的一致性。\n\npublic class Test {\n    private  AtomicInteger i = new AtomicInteger(0);\n    public int add(){\n        return i.addAndGet(1);\n    }\n}\n\n\n\n# CAS 问题\n\nCAS 方式为乐观锁，synchronized 为悲观锁。因此使用 CAS 解决并发问题通常情况下性能更优。\n\n但使用 CAS 方式也会有几个问题：\n\n# ABA问题\n\n因为CAS需要在操作值的时候，检查值有没有发生变化，比如没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时则会发现它的值没有发生变化，但是实际上却变化了。\n\nABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A->B->A就会变成1A->2B->3A。\n\n从Java 1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。\n\n# 循环时间长开销大\n\n自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。pause指令有两个作用：第一，它可以延迟流水线执行命令(de-pipeline)，使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；第二，它可以避免在退出循环的时候因内存顺序冲突(Memory Order Violation)而引起CPU流水线被清空(CPU Pipeline Flush)，从而提高CPU的执行效率。\n\n# 只能保证一个共享变量的原子操作\n\n当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。\n\n还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i = 2，j = a，合并一下ij = 2a，然后用CAS来操作ij。\n\n从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。\n\n\n# UnSafe类详解\n\n> 上文我们了解到Java原子类是通过UnSafe类实现的，这节主要分析下UnSafe类。UnSafe类在J.U.C中CAS操作有很广泛的应用。\n\nUnsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。\n\n这个类尽管里面的方法都是 public 的，但是并没有办法使用它们，JDK API 文档也没有提供任何关于这个类的方法的解释。总而言之，对于 Unsafe 类的使用都是受限制的，只有授信的代码才能获得该类的实例，当然 JDK 库里面的类是可以随意使用的。\n\n先来看下这张图，对UnSafe类总体功能：\n\n\n\n如上图所示，Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类，下面将对其相关方法和应用场景进行详细介绍。\n\n\n# Unsafe与CAS\n\n反编译出来的代码：\n\npublic final int getAndAddInt(Object paramObject, long paramLong, int paramInt)\n  {\n    int i;\n    do\n      i = getIntVolatile(paramObject, paramLong);\n    while (!compareAndSwapInt(paramObject, paramLong, i, i + paramInt));\n    return i;\n  }\n\n  public final long getAndAddLong(Object paramObject, long paramLong1, long paramLong2)\n  {\n    long l;\n    do\n      l = getLongVolatile(paramObject, paramLong1);\n    while (!compareAndSwapLong(paramObject, paramLong1, l, l + paramLong2));\n    return l;\n  }\n\n  public final int getAndSetInt(Object paramObject, long paramLong, int paramInt)\n  {\n    int i;\n    do\n      i = getIntVolatile(paramObject, paramLong);\n    while (!compareAndSwapInt(paramObject, paramLong, i, paramInt));\n    return i;\n  }\n\n  public final long getAndSetLong(Object paramObject, long paramLong1, long paramLong2)\n  {\n    long l;\n    do\n      l = getLongVolatile(paramObject, paramLong1);\n    while (!compareAndSwapLong(paramObject, paramLong1, l, paramLong2));\n    return l;\n  }\n\n  public final Object getAndSetObject(Object paramObject1, long paramLong, Object paramObject2)\n  {\n    Object localObject;\n    do\n      localObject = getObjectVolatile(paramObject1, paramLong);\n    while (!compareAndSwapObject(paramObject1, paramLong, localObject, paramObject2));\n    return localObject;\n  }\n\n\n从源码中发现，内部使用自旋的方式进行CAS更新(while循环进行CAS更新，如果更新失败，则循环再次重试)。\n\n又从Unsafe类中发现，原子操作其实只支持下面三个方法。\n\npublic final native boolean compareAndSwapObject(Object paramObject1, long paramLong, Object paramObject2, Object paramObject3);\n\npublic final native boolean compareAndSwapInt(Object paramObject, long paramLong, int paramInt1, int paramInt2);\n\npublic final native boolean compareAndSwapLong(Object paramObject, long paramLong1, long paramLong2, long paramLong3);\n\n\n我们发现Unsafe只提供了3种CAS方法：compareAndSwapObject、compareAndSwapInt和compareAndSwapLong。都是native方法。\n\n\n# Unsafe底层\n\n不妨再看看Unsafe的compareAndSwap*方法来实现CAS操作，它是一个本地方法，实现位于unsafe.cpp中。\n\nUNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))\n  UnsafeWrapper("Unsafe_CompareAndSwapInt");\n  oop p = JNIHandles::resolve(obj);\n  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);\n  return (jint)(Atomic::cmpxchg(x, addr, e)) == e;\nUNSAFE_END\n\n\n可以看到它通过 Atomic::cmpxchg 来实现比较和替换操作。其中参数x是即将更新的值，参数e是原内存的值。\n\n如果是Linux的x86，Atomic::cmpxchg方法的实现如下：\n\ninline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) {\n  int mp = os::is_MP();\n  __asm__ volatile (LOCK_IF_MP(%4) "cmpxchgl %1,(%3)"\n                    : "=a" (exchange_value)\n                    : "r" (exchange_value), "a" (compare_value), "r" (dest), "r" (mp)\n                    : "cc", "memory");\n  return exchange_value;\n}\n\n\n而windows的x86的实现如下：\n\ninline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) {\n    int mp = os::isMP(); //判断是否是多处理器\n    _asm {\n        mov edx, dest\n        mov ecx, exchange_value\n        mov eax, compare_value\n        LOCK_IF_MP(mp)\n        cmpxchg dword ptr [edx], ecx\n    }\n}\n\n// Adding a lock prefix to an instruction on MP machine\n// VC++ doesn\'t like the lock prefix to be on a single line\n// so we can\'t insert a label after the lock prefix.\n// By emitting a lock prefix, we can define a label after it.\n#define LOCK_IF_MP(mp) __asm cmp mp, 0  \\\n                       __asm je L0      \\\n                       __asm _emit 0xF0 \\\n                       __asm L0:\n\n\n如果是多处理器，为cmpxchg指令添加lock前缀。反之，就省略lock前缀(单处理器会不需要lock前缀提供的内存屏障效果)。这里的lock前缀就是使用了处理器的总线锁(最新的处理器都使用缓存锁代替总线锁来提高性能)。\n\n> cmpxchg(void* ptr, int old, int new)，如果ptr和old的值一样，则把new写到ptr内存，否则返回ptr的值，整个操作是原子的。在Intel平台下，会用lock cmpxchg来实现，使用lock触发缓存锁，这样另一个线程想访问ptr的内存，就会被block住。\n\n\n# Unsafe其它功能\n\nUnsafe 提供了硬件级别的操作，比如说获取某个属性在内存中的位置，比如说修改对象的字段值，即使它是私有的。不过 Java 本身就是为了屏蔽底层的差异，对于一般的开发而言也很少会有这样的需求。\n\n举两个例子，比方说：\n\npublic native long staticFieldOffset(Field paramField);\n\n\n这个方法可以用来获取给定的 paramField 的内存地址偏移量，这个值对于给定的 field 是唯一的且是固定不变的。\n\n再比如说：\n\npublic native int arrayBaseOffset(Class paramClass);\npublic native int arrayIndexScale(Class paramClass);\n\n\n前一个方法是用来获取数组第一个元素的偏移地址，后一个方法是用来获取数组的转换因子即数组中元素的增量地址的。\n\n最后看三个方法：\n\npublic native long allocateMemory(long paramLong);\npublic native long reallocateMemory(long paramLong1, long paramLong2);\npublic native void freeMemory(long paramLong);\n\n\n分别用来分配内存，扩充内存和释放内存的。\n\n> 更多相关功能，推荐你看下这篇文章：来自美团技术团队：Java魔法类：Unsafe应用解析在新窗口打开\n\n\n# AtomicInteger\n\n\n# 使用举例\n\n以 AtomicInteger 为例，常用 API：\n\npublic final int get()：获取当前的值\npublic final int getAndSet(int newValue)：获取当前的值，并设置新的值\npublic final int getAndIncrement()：获取当前的值，并自增\npublic final int getAndDecrement()：获取当前的值，并自减\npublic final int getAndAdd(int delta)：获取当前的值，并加上预期的值\nvoid lazySet(int newValue): 最终会设置成newValue,使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。\n\n\n相比 Integer 的优势，多线程中让变量自增：\n\nprivate volatile int count = 0;\n// 若要线程安全执行执行 count++，需要加锁\npublic synchronized void increment() {\n    count++;\n}\npublic int getCount() {\n    return count;\n}\n\n\n使用 AtomicInteger 后：\n\nprivate AtomicInteger count = new AtomicInteger();\npublic void increment() {\n    count.incrementAndGet();\n}\n// 使用 AtomicInteger 后，不需要加锁，也可以实现线程安全\npublic int getCount() {\n    return count.get();\n}\n\n\n\n# 源码解析\n\npublic class AtomicInteger extends Number implements java.io.Serializable {\n    private static final Unsafe unsafe = Unsafe.getUnsafe();\n    private static final long valueOffset;\n    static {\n        try {\n            //用于获取value字段相对当前对象的“起始地址”的偏移量\n            valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField("value"));\n        } catch (Exception ex) { throw new Error(ex); }\n    }\n\n    private volatile int value;\n\n    //返回当前值\n    public final int get() {\n        return value;\n    }\n\n    //递增加detla\n    public final int getAndAdd(int delta) {\n        //三个参数，1、当前的实例 2、value实例变量的偏移量 3、当前value要加上的数(value+delta)。\n        return unsafe.getAndAddInt(this, valueOffset, delta);\n    }\n\n    //递增加1\n    public final int incrementAndGet() {\n        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;\n    }\n...\n}\n\n\n我们可以看到 AtomicInteger 底层用的是volatile的变量和CAS来进行更改数据的。\n\n * volatile保证线程的可见性，多线程并发时，一个线程修改数据，可以保证其它线程立马看到修改后的值\n * CAS 保证数据更新的原子性。\n\n\n# 延伸到所有原子类：共12个\n\n> JDK中提供了12个原子操作类。\n\n\n# 原子更新基本类型\n\n使用原子的方式更新基本类型，Atomic包提供了以下3个类。\n\n * AtomicBoolean: 原子更新布尔类型。\n * AtomicInteger: 原子更新整型。\n * AtomicLong: 原子更新长整型。\n\n以上3个类提供的方法几乎一模一样，可以参考上面AtomicInteger中的相关方法。\n\n\n# 原子更新数组\n\n通过原子的方式更新数组里的某个元素，Atomic包提供了以下的3个类：\n\n * AtomicIntegerArray: 原子更新整型数组里的元素。\n * AtomicLongArray: 原子更新长整型数组里的元素。\n * AtomicReferenceArray: 原子更新引用类型数组里的元素。\n\n这三个类的最常用的方法是如下两个方法：\n\n * get(int index)：获取索引为index的元素值。\n * compareAndSet(int i,E expect,E update): 如果当前值等于预期值，则以原子方式将数组位置i的元素设置为update值。\n\n举个AtomicIntegerArray例子：\n\nimport java.util.concurrent.atomic.AtomicIntegerArray;\n\npublic class Demo5 {\n    public static void main(String[] args) throws InterruptedException {\n        AtomicIntegerArray array = new AtomicIntegerArray(new int[] { 0, 0 });\n        System.out.println(array);\n        System.out.println(array.getAndAdd(1, 2));\n        System.out.println(array);\n    }\n}\n\n\n输出结果：\n\n\n# 原子更新引用类型\n\nAtomic包提供了以下三个类：\n\n * AtomicReference: 原子更新引用类型。\n * AtomicStampedReference: 原子更新引用类型, 内部使用Pair来存储元素值及其版本号。\n * AtomicMarkableReferce: 原子更新带有标记位的引用类型。\n\n这三个类提供的方法都差不多，首先构造一个引用对象，然后把引用对象set进Atomic类，然后调用compareAndSet等一些方法去进行原子操作，原理都是基于Unsafe实现，但AtomicReferenceFieldUpdater略有不同，更新的字段必须用volatile修饰。\n\n举个AtomicReference例子：\n\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class AtomicReferenceTest {\n    \n    public static void main(String[] args){\n\n        // 创建两个Person对象，它们的id分别是101和102。\n        Person p1 = new Person(101);\n        Person p2 = new Person(102);\n        // 新建AtomicReference对象，初始化它的值为p1对象\n        AtomicReference ar = new AtomicReference(p1);\n        // 通过CAS设置ar。如果ar的值为p1的话，则将其设置为p2。\n        ar.compareAndSet(p1, p2);\n\n        Person p3 = (Person)ar.get();\n        System.out.println("p3 is "+p3);\n        System.out.println("p3.equals(p1)="+p3.equals(p1));\n    }\n}\n\nclass Person {\n    volatile long id;\n    public Person(long id) {\n        this.id = id;\n    }\n    public String toString() {\n        return "id:"+id;\n    }\n}\n\n\n结果输出：\n\np3 is id:102\np3.equals(p1)=false\n\n\n结果说明：\n\n * 新建AtomicReference对象ar时，将它初始化为p1。\n * 紧接着，通过CAS函数对它进行设置。如果ar的值为p1的话，则将其设置为p2。\n * 最后，获取ar对应的对象，并打印结果。p3.equals(p1)的结果为false，这是因为Person并没有覆盖equals()方法，而是采用继承自Object.java的equals()方法；而Object.java中的equals()实际上是调用"=="去比较两个对象，即比较两个对象的地址是否相等。\n\n\n# 原子更新字段类\n\nAtomic包提供了四个类进行原子字段更新：\n\n * AtomicIntegerFieldUpdater: 原子更新整型的字段的更新器。\n * AtomicLongFieldUpdater: 原子更新长整型字段的更新器。\n * AtomicReferenceFieldUpdater: 上面已经说过此处不在赘述。\n\n这四个类的使用方式都差不多，是基于反射的原子更新字段的值。要想原子地更新字段类需要两步:\n\n * 第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。\n * 第二步，更新类的字段必须使用public volatile修饰。\n\n举个例子：\n\npublic class TestAtomicIntegerFieldUpdater {\n\n    public static void main(String[] args){\n        TestAtomicIntegerFieldUpdater tIA = new TestAtomicIntegerFieldUpdater();\n        tIA.doIt();\n    }\n\n    public AtomicIntegerFieldUpdater<DataDemo> updater(String name){\n        return AtomicIntegerFieldUpdater.newUpdater(DataDemo.class,name);\n\n    }\n\n    public void doIt(){\n        DataDemo data = new DataDemo();\n        System.out.println("publicVar = "+updater("publicVar").getAndAdd(data, 2));\n        /*\n            * 由于在DataDemo类中属性value2/value3,在TestAtomicIntegerFieldUpdater中不能访问\n            * */\n        //System.out.println("protectedVar = "+updater("protectedVar").getAndAdd(data,2));\n        //System.out.println("privateVar = "+updater("privateVar").getAndAdd(data,2));\n\n        //System.out.println("staticVar = "+updater("staticVar").getAndIncrement(data));//报java.lang.IllegalArgumentException\n        /*\n            * 下面报异常：must be integer\n            * */\n        //System.out.println("integerVar = "+updater("integerVar").getAndIncrement(data));\n        //System.out.println("longVar = "+updater("longVar").getAndIncrement(data));\n    }\n\n}\n\nclass DataDemo{\n    public volatile int publicVar=3;\n    protected volatile int protectedVar=4;\n    private volatile  int privateVar=5;\n\n    public volatile static int staticVar = 10;\n    //public  final int finalVar = 11;\n\n    public volatile Integer integerVar = 19;\n    public volatile Long longVar = 18L;\n\n}\n\n\n再说下对于AtomicIntegerFieldUpdater 的使用稍微有一些限制和约束，约束如下：\n\n * 字段必须是volatile类型的，在线程之间共享变量时保证立即可见.eg:volatile int value = 3\n\n * 字段的描述类型(修饰符public/protected/default/private)是与调用者与操作对象字段的关系一致。也就是说调用者能够直接操作对象字段，那么就可以反射进行原子操作。但是对于父类的字段，子类是不能直接操作的，尽管子类可以访问父类的字段。\n\n * 只能是实例变量，不能是类变量，也就是说不能加static关键字。\n\n * 只能是可修改变量，不能使final变量，因为final的语义就是不可修改。实际上final的语义和volatile是有冲突的，这两个关键字不能同时存在。\n\n * 对于AtomicIntegerFieldUpdater和AtomicLongFieldUpdater只能修改int/long类型的字段，不能修改其包装类型(Integer/Long)。如果要修改包装类型就需要使用AtomicReferenceFieldUpdater。\n\n\n# 再讲讲AtomicStampedReference解决CAS的ABA问题\n\n\n# AtomicStampedReference解决ABA问题\n\nAtomicStampedReference主要维护包含一个对象引用以及一个可以自动更新的整数"stamp"的pair对象来解决ABA问题。\n\npublic class AtomicStampedReference<V> {\n    private static class Pair<T> {\n        final T reference;  //维护对象引用\n        final int stamp;  //用于标志版本\n        private Pair(T reference, int stamp) {\n            this.reference = reference;\n            this.stamp = stamp;\n        }\n        static <T> Pair<T> of(T reference, int stamp) {\n            return new Pair<T>(reference, stamp);\n        }\n    }\n    private volatile Pair<V> pair;\n    ....\n    \n    /**\n      * expectedReference ：更新之前的原始值\n      * newReference : 将要更新的新值\n      * expectedStamp : 期待更新的标志版本\n      * newStamp : 将要更新的标志版本\n      */\n    public boolean compareAndSet(V   expectedReference,\n                             V   newReference,\n                             int expectedStamp,\n                             int newStamp) {\n        // 获取当前的(元素值，版本号)对\n        Pair<V> current = pair;\n        return\n            // 引用没变\n            expectedReference == current.reference &&\n            // 版本号没变\n            expectedStamp == current.stamp &&\n            // 新引用等于旧引用\n            ((newReference == current.reference &&\n            // 新版本号等于旧版本号\n            newStamp == current.stamp) ||\n            // 构造新的Pair对象并CAS更新\n            casPair(current, Pair.of(newReference, newStamp)));\n    }\n\n    private boolean casPair(Pair<V> cmp, Pair<V> val) {\n        // 调用Unsafe的compareAndSwapObject()方法CAS更新pair的引用为新引用\n        return UNSAFE.compareAndSwapObject(this, pairOffset, cmp, val);\n    }\n\n\n * 如果元素值和版本号都没有变化，并且和新的也相同，返回true；\n\n * 如果元素值和版本号都没有变化，并且和新的不完全相同，就构造一个新的Pair对象并执行CAS更新pair。\n\n可以看到，java中的实现跟我们上面讲的ABA的解决方法是一致的。\n\n * 首先，使用版本号控制；\n\n * 其次，不重复使用节点(Pair)的引用，每次都新建一个新的Pair来作为CAS比较的对象，而不是复用旧的；\n\n * 最后，外部传入元素值及版本号，而不是节点(Pair)的引用。\n\n\n# 使用举例\n\npublic class AtomicTester {\n\n    private static AtomicStampedReference<Integer> atomicStampedRef =\n            new AtomicStampedReference<>(1, 0);\n\n    public static void main(String[] args){\n        first().start();\n        second().start();\n    }\n\n    private static Thread first() {\n        return new Thread(() -> {\n            System.out.println("操作线程" + Thread.currentThread() +",初始值 a = " + atomicStampedRef.getReference());\n            int stamp = atomicStampedRef.getStamp(); //获取当前标识别\n            try {\n                Thread.sleep(1000); //等待1秒 ，以便让干扰线程执行\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            boolean isCASSuccess = atomicStampedRef.compareAndSet(1,2,stamp,stamp +1);  //此时expectedReference未发生改变，但是stamp已经被修改了,所以CAS失败\n            System.out.println("操作线程" + Thread.currentThread() +",CAS操作结果: " + isCASSuccess);\n        },"主操作线程");\n    }\n\n    private static Thread second() {\n        return new Thread(() -> {\n            Thread.yield(); // 确保thread-first 优先执行\n            atomicStampedRef.compareAndSet(1,2,atomicStampedRef.getStamp(),atomicStampedRef.getStamp() +1);\n            System.out.println("操作线程" + Thread.currentThread() +",【increment】 ,值 = "+ atomicStampedRef.getReference());\n            atomicStampedRef.compareAndSet(2,1,atomicStampedRef.getStamp(),atomicStampedRef.getStamp() +1);\n            System.out.println("操作线程" + Thread.currentThread() +",【decrement】 ,值 = "+ atomicStampedRef.getReference());\n        },"干扰线程");\n    }\n}\n\n\n输出结果：\n\n操作线程Thread[主操作线程,5,main],初始值 a = 1\n操作线程Thread[干扰线程,5,main],【increment】 ,值 = 2\n操作线程Thread[干扰线程,5,main],【decrement】 ,值 = 1\n操作线程Thread[主操作线程,5,main],CAS操作结果: false\n\n\n\n# java中还有哪些类可以解决ABA的问题?\n\nAtomicMarkableReference，它不是维护一个版本号，而是维护一个boolean类型的标记，标记值有修改，了解一下。\n\n\n# 参考文章\n\n * https://benjaminwhx.com/2018/05/03/%E3%80%90%E7%BB%86%E8%B0%88Java%E5%B9%B6%E5%8F%91%E3%80%91%E8%B0%88%E8%B0%88CAS/\n * https://www.jianshu.com/p/9a1e6940987a\n * https://www.jianshu.com/p/a533cbb740c6\n * https://blog.csdn.net/qq_36236890/article/details/81914871\n * https://www.cnblogs.com/lodor/p/7492805.html\n * https://blog.csdn.net/u010412719/article/details/52068888\n * https://www.jianshu.com/p/18dfc5fa0171\n * https://www.jianshu.com/p/8b227a8adbc1\n * https://www.jianshu.com/p/77f75b398be9\n * https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-AtomicInteger.html',normalizedContent:'# juc原子类: cas, unsafe和原子类详解\n\n> juc中多数类是通过volatile和cas来实现的，cas本质上提供的是一种无锁方案，而synchronized和lock是互斥锁方案; java原子类本质上使用的是cas，而cas底层是通过unsafe类实现的。所以本章将对cas, unsafe和原子类详解。\n\n * juc原子类: cas, unsafe和原子类详解\n   * 带着bat大厂的面试问题去理解\n   * cas\n     * 什么是cas\n     * cas使用示例\n     * cas 问题\n       * aba问题\n       * 循环时间长开销大\n       * 只能保证一个共享变量的原子操作\n   * unsafe类详解\n     * unsafe与cas\n     * unsafe底层\n     * unsafe其它功能\n   * atomicinteger\n     * 使用举例\n     * 源码解析\n   * 延伸到所有原子类：共13个\n     * 原子更新基本类型\n     * 原子更新数组\n     * 原子更新引用类型\n     * 原子更新字段类\n   * 再讲讲atomicstampedreference解决cas的aba问题\n     * atomicstampedreference解决aba问题\n     * 使用举例\n     * java中还有哪些类可以解决aba的问题?\n   * 参考文章\n\n\n# 带着bat大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 线程安全的实现方法有哪些?\n * 什么是cas?\n * cas使用示例，结合atomicinteger给出示例?\n * cas会有哪些问题?\n * 针对这这些问题，java提供了哪几个解决的?\n * atomicinteger底层实现? cas+volatile\n * 请阐述你对unsafe类的理解?\n * 说说你对java原子类的理解? 包含13个，4组分类，说说作用和使用场景。\n * atomicstampedreference是什么?\n * atomicstampedreference是怎么解决aba的? 内部使用pair来存储元素值及其版本号\n * java中还有哪些类可以解决aba的问题? atomicmarkablereference\n\n\n# cas\n\n前面我们说到，线程安全的实现方法包含:\n\n * 互斥同步: synchronized 和 reentrantlock\n * 非阻塞同步: cas, atomicxxxx\n * 无同步方案: 栈封闭，thread local，可重入代码\n\n具体可以参看：线程安全的实现方法，这里我们将对cas重点阐释。\n\n\n# 什么是cas\n\ncas的全称为compare-and-swap，直译就是对比交换。是一条cpu的原子指令，其作用是让cpu先进行比较两个值是否相等，然后原子地更新某个位置的值，经过调查发现，其实现方式是基于硬件平台的汇编指令，就是说cas是靠硬件实现的，jvm只是封装了汇编调用，那些atomicinteger类便是使用了这些封装后的接口。   简单解释：cas操作需要输入两个数值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较下在旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。\n\ncas操作是原子性的，所以多线程并发使用cas更新数据时，可以不使用锁。jdk中大量使用了cas来更新数据而防止加锁(synchronized 重量级锁)来保持原子更新。\n\n相信sql大家都熟悉，类似sql中的条件更新一样：update set id=3 from table where id=2。因为单条sql执行具有原子性，如果有多个线程同时执行此sql语句，只有一条能更新成功。\n\n\n# cas使用示例\n\n如果不使用cas，在高并发下，多线程同时修改一个变量的值我们需要synchronized加锁(可能有人说可以用lock加锁，lock底层的aqs也是基于cas进行获取锁的)。\n\npublic class test {\n    private int i=0;\n    public synchronized int add(){\n        return i++;\n    }\n}\n\n\njava中为我们提供了atomicinteger 原子类(底层基于cas进行更新数据的)，不需要加锁就在多线程并发场景下实现数据的一致性。\n\npublic class test {\n    private  atomicinteger i = new atomicinteger(0);\n    public int add(){\n        return i.addandget(1);\n    }\n}\n\n\n\n# cas 问题\n\ncas 方式为乐观锁，synchronized 为悲观锁。因此使用 cas 解决并发问题通常情况下性能更优。\n\n但使用 cas 方式也会有几个问题：\n\n# aba问题\n\n因为cas需要在操作值的时候，检查值有没有发生变化，比如没有发生变化则更新，但是如果一个值原来是a，变成了b，又变成了a，那么使用cas进行检查时则会发现它的值没有发生变化，但是实际上却变化了。\n\naba问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么a->b->a就会变成1a->2b->3a。\n\n从java 1.5开始，jdk的atomic包里提供了一个类atomicstampedreference来解决aba问题。这个类的compareandset方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。\n\n# 循环时间长开销大\n\n自旋cas如果长时间不成功，会给cpu带来非常大的执行开销。如果jvm能支持处理器提供的pause指令，那么效率会有一定的提升。pause指令有两个作用：第一，它可以延迟流水线执行命令(de-pipeline)，使cpu不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；第二，它可以避免在退出循环的时候因内存顺序冲突(memory order violation)而引起cpu流水线被清空(cpu pipeline flush)，从而提高cpu的执行效率。\n\n# 只能保证一个共享变量的原子操作\n\n当对一个共享变量执行操作时，我们可以使用循环cas的方式来保证原子操作，但是对多个共享变量操作时，循环cas就无法保证操作的原子性，这个时候就可以用锁。\n\n还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i = 2，j = a，合并一下ij = 2a，然后用cas来操作ij。\n\n从java 1.5开始，jdk提供了atomicreference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行cas操作。\n\n\n# unsafe类详解\n\n> 上文我们了解到java原子类是通过unsafe类实现的，这节主要分析下unsafe类。unsafe类在j.u.c中cas操作有很广泛的应用。\n\nunsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升java运行效率、增强java语言底层资源操作能力方面起到了很大的作用。但由于unsafe类使java语言拥有了类似c语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用unsafe类会使得程序出错的概率变大，使得java这种安全的语言变得不再“安全”，因此对unsafe的使用一定要慎重。\n\n这个类尽管里面的方法都是 public 的，但是并没有办法使用它们，jdk api 文档也没有提供任何关于这个类的方法的解释。总而言之，对于 unsafe 类的使用都是受限制的，只有授信的代码才能获得该类的实例，当然 jdk 库里面的类是可以随意使用的。\n\n先来看下这张图，对unsafe类总体功能：\n\n\n\n如上图所示，unsafe提供的api大致可分为内存操作、cas、class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类，下面将对其相关方法和应用场景进行详细介绍。\n\n\n# unsafe与cas\n\n反编译出来的代码：\n\npublic final int getandaddint(object paramobject, long paramlong, int paramint)\n  {\n    int i;\n    do\n      i = getintvolatile(paramobject, paramlong);\n    while (!compareandswapint(paramobject, paramlong, i, i + paramint));\n    return i;\n  }\n\n  public final long getandaddlong(object paramobject, long paramlong1, long paramlong2)\n  {\n    long l;\n    do\n      l = getlongvolatile(paramobject, paramlong1);\n    while (!compareandswaplong(paramobject, paramlong1, l, l + paramlong2));\n    return l;\n  }\n\n  public final int getandsetint(object paramobject, long paramlong, int paramint)\n  {\n    int i;\n    do\n      i = getintvolatile(paramobject, paramlong);\n    while (!compareandswapint(paramobject, paramlong, i, paramint));\n    return i;\n  }\n\n  public final long getandsetlong(object paramobject, long paramlong1, long paramlong2)\n  {\n    long l;\n    do\n      l = getlongvolatile(paramobject, paramlong1);\n    while (!compareandswaplong(paramobject, paramlong1, l, paramlong2));\n    return l;\n  }\n\n  public final object getandsetobject(object paramobject1, long paramlong, object paramobject2)\n  {\n    object localobject;\n    do\n      localobject = getobjectvolatile(paramobject1, paramlong);\n    while (!compareandswapobject(paramobject1, paramlong, localobject, paramobject2));\n    return localobject;\n  }\n\n\n从源码中发现，内部使用自旋的方式进行cas更新(while循环进行cas更新，如果更新失败，则循环再次重试)。\n\n又从unsafe类中发现，原子操作其实只支持下面三个方法。\n\npublic final native boolean compareandswapobject(object paramobject1, long paramlong, object paramobject2, object paramobject3);\n\npublic final native boolean compareandswapint(object paramobject, long paramlong, int paramint1, int paramint2);\n\npublic final native boolean compareandswaplong(object paramobject, long paramlong1, long paramlong2, long paramlong3);\n\n\n我们发现unsafe只提供了3种cas方法：compareandswapobject、compareandswapint和compareandswaplong。都是native方法。\n\n\n# unsafe底层\n\n不妨再看看unsafe的compareandswap*方法来实现cas操作，它是一个本地方法，实现位于unsafe.cpp中。\n\nunsafe_entry(jboolean, unsafe_compareandswapint(jnienv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))\n  unsafewrapper("unsafe_compareandswapint");\n  oop p = jnihandles::resolve(obj);\n  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);\n  return (jint)(atomic::cmpxchg(x, addr, e)) == e;\nunsafe_end\n\n\n可以看到它通过 atomic::cmpxchg 来实现比较和替换操作。其中参数x是即将更新的值，参数e是原内存的值。\n\n如果是linux的x86，atomic::cmpxchg方法的实现如下：\n\ninline jint atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) {\n  int mp = os::is_mp();\n  __asm__ volatile (lock_if_mp(%4) "cmpxchgl %1,(%3)"\n                    : "=a" (exchange_value)\n                    : "r" (exchange_value), "a" (compare_value), "r" (dest), "r" (mp)\n                    : "cc", "memory");\n  return exchange_value;\n}\n\n\n而windows的x86的实现如下：\n\ninline jint atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) {\n    int mp = os::ismp(); //判断是否是多处理器\n    _asm {\n        mov edx, dest\n        mov ecx, exchange_value\n        mov eax, compare_value\n        lock_if_mp(mp)\n        cmpxchg dword ptr [edx], ecx\n    }\n}\n\n// adding a lock prefix to an instruction on mp machine\n// vc++ doesn\'t like the lock prefix to be on a single line\n// so we can\'t insert a label after the lock prefix.\n// by emitting a lock prefix, we can define a label after it.\n#define lock_if_mp(mp) __asm cmp mp, 0  \\\n                       __asm je l0      \\\n                       __asm _emit 0xf0 \\\n                       __asm l0:\n\n\n如果是多处理器，为cmpxchg指令添加lock前缀。反之，就省略lock前缀(单处理器会不需要lock前缀提供的内存屏障效果)。这里的lock前缀就是使用了处理器的总线锁(最新的处理器都使用缓存锁代替总线锁来提高性能)。\n\n> cmpxchg(void* ptr, int old, int new)，如果ptr和old的值一样，则把new写到ptr内存，否则返回ptr的值，整个操作是原子的。在intel平台下，会用lock cmpxchg来实现，使用lock触发缓存锁，这样另一个线程想访问ptr的内存，就会被block住。\n\n\n# unsafe其它功能\n\nunsafe 提供了硬件级别的操作，比如说获取某个属性在内存中的位置，比如说修改对象的字段值，即使它是私有的。不过 java 本身就是为了屏蔽底层的差异，对于一般的开发而言也很少会有这样的需求。\n\n举两个例子，比方说：\n\npublic native long staticfieldoffset(field paramfield);\n\n\n这个方法可以用来获取给定的 paramfield 的内存地址偏移量，这个值对于给定的 field 是唯一的且是固定不变的。\n\n再比如说：\n\npublic native int arraybaseoffset(class paramclass);\npublic native int arrayindexscale(class paramclass);\n\n\n前一个方法是用来获取数组第一个元素的偏移地址，后一个方法是用来获取数组的转换因子即数组中元素的增量地址的。\n\n最后看三个方法：\n\npublic native long allocatememory(long paramlong);\npublic native long reallocatememory(long paramlong1, long paramlong2);\npublic native void freememory(long paramlong);\n\n\n分别用来分配内存，扩充内存和释放内存的。\n\n> 更多相关功能，推荐你看下这篇文章：来自美团技术团队：java魔法类：unsafe应用解析在新窗口打开\n\n\n# atomicinteger\n\n\n# 使用举例\n\n以 atomicinteger 为例，常用 api：\n\npublic final int get()：获取当前的值\npublic final int getandset(int newvalue)：获取当前的值，并设置新的值\npublic final int getandincrement()：获取当前的值，并自增\npublic final int getanddecrement()：获取当前的值，并自减\npublic final int getandadd(int delta)：获取当前的值，并加上预期的值\nvoid lazyset(int newvalue): 最终会设置成newvalue,使用lazyset设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。\n\n\n相比 integer 的优势，多线程中让变量自增：\n\nprivate volatile int count = 0;\n// 若要线程安全执行执行 count++，需要加锁\npublic synchronized void increment() {\n    count++;\n}\npublic int getcount() {\n    return count;\n}\n\n\n使用 atomicinteger 后：\n\nprivate atomicinteger count = new atomicinteger();\npublic void increment() {\n    count.incrementandget();\n}\n// 使用 atomicinteger 后，不需要加锁，也可以实现线程安全\npublic int getcount() {\n    return count.get();\n}\n\n\n\n# 源码解析\n\npublic class atomicinteger extends number implements java.io.serializable {\n    private static final unsafe unsafe = unsafe.getunsafe();\n    private static final long valueoffset;\n    static {\n        try {\n            //用于获取value字段相对当前对象的“起始地址”的偏移量\n            valueoffset = unsafe.objectfieldoffset(atomicinteger.class.getdeclaredfield("value"));\n        } catch (exception ex) { throw new error(ex); }\n    }\n\n    private volatile int value;\n\n    //返回当前值\n    public final int get() {\n        return value;\n    }\n\n    //递增加detla\n    public final int getandadd(int delta) {\n        //三个参数，1、当前的实例 2、value实例变量的偏移量 3、当前value要加上的数(value+delta)。\n        return unsafe.getandaddint(this, valueoffset, delta);\n    }\n\n    //递增加1\n    public final int incrementandget() {\n        return unsafe.getandaddint(this, valueoffset, 1) + 1;\n    }\n...\n}\n\n\n我们可以看到 atomicinteger 底层用的是volatile的变量和cas来进行更改数据的。\n\n * volatile保证线程的可见性，多线程并发时，一个线程修改数据，可以保证其它线程立马看到修改后的值\n * cas 保证数据更新的原子性。\n\n\n# 延伸到所有原子类：共12个\n\n> jdk中提供了12个原子操作类。\n\n\n# 原子更新基本类型\n\n使用原子的方式更新基本类型，atomic包提供了以下3个类。\n\n * atomicboolean: 原子更新布尔类型。\n * atomicinteger: 原子更新整型。\n * atomiclong: 原子更新长整型。\n\n以上3个类提供的方法几乎一模一样，可以参考上面atomicinteger中的相关方法。\n\n\n# 原子更新数组\n\n通过原子的方式更新数组里的某个元素，atomic包提供了以下的3个类：\n\n * atomicintegerarray: 原子更新整型数组里的元素。\n * atomiclongarray: 原子更新长整型数组里的元素。\n * atomicreferencearray: 原子更新引用类型数组里的元素。\n\n这三个类的最常用的方法是如下两个方法：\n\n * get(int index)：获取索引为index的元素值。\n * compareandset(int i,e expect,e update): 如果当前值等于预期值，则以原子方式将数组位置i的元素设置为update值。\n\n举个atomicintegerarray例子：\n\nimport java.util.concurrent.atomic.atomicintegerarray;\n\npublic class demo5 {\n    public static void main(string[] args) throws interruptedexception {\n        atomicintegerarray array = new atomicintegerarray(new int[] { 0, 0 });\n        system.out.println(array);\n        system.out.println(array.getandadd(1, 2));\n        system.out.println(array);\n    }\n}\n\n\n输出结果：\n\n\n# 原子更新引用类型\n\natomic包提供了以下三个类：\n\n * atomicreference: 原子更新引用类型。\n * atomicstampedreference: 原子更新引用类型, 内部使用pair来存储元素值及其版本号。\n * atomicmarkablereferce: 原子更新带有标记位的引用类型。\n\n这三个类提供的方法都差不多，首先构造一个引用对象，然后把引用对象set进atomic类，然后调用compareandset等一些方法去进行原子操作，原理都是基于unsafe实现，但atomicreferencefieldupdater略有不同，更新的字段必须用volatile修饰。\n\n举个atomicreference例子：\n\nimport java.util.concurrent.atomic.atomicreference;\n\npublic class atomicreferencetest {\n    \n    public static void main(string[] args){\n\n        // 创建两个person对象，它们的id分别是101和102。\n        person p1 = new person(101);\n        person p2 = new person(102);\n        // 新建atomicreference对象，初始化它的值为p1对象\n        atomicreference ar = new atomicreference(p1);\n        // 通过cas设置ar。如果ar的值为p1的话，则将其设置为p2。\n        ar.compareandset(p1, p2);\n\n        person p3 = (person)ar.get();\n        system.out.println("p3 is "+p3);\n        system.out.println("p3.equals(p1)="+p3.equals(p1));\n    }\n}\n\nclass person {\n    volatile long id;\n    public person(long id) {\n        this.id = id;\n    }\n    public string tostring() {\n        return "id:"+id;\n    }\n}\n\n\n结果输出：\n\np3 is id:102\np3.equals(p1)=false\n\n\n结果说明：\n\n * 新建atomicreference对象ar时，将它初始化为p1。\n * 紧接着，通过cas函数对它进行设置。如果ar的值为p1的话，则将其设置为p2。\n * 最后，获取ar对应的对象，并打印结果。p3.equals(p1)的结果为false，这是因为person并没有覆盖equals()方法，而是采用继承自object.java的equals()方法；而object.java中的equals()实际上是调用"=="去比较两个对象，即比较两个对象的地址是否相等。\n\n\n# 原子更新字段类\n\natomic包提供了四个类进行原子字段更新：\n\n * atomicintegerfieldupdater: 原子更新整型的字段的更新器。\n * atomiclongfieldupdater: 原子更新长整型字段的更新器。\n * atomicreferencefieldupdater: 上面已经说过此处不在赘述。\n\n这四个类的使用方式都差不多，是基于反射的原子更新字段的值。要想原子地更新字段类需要两步:\n\n * 第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newupdater()创建一个更新器，并且需要设置想要更新的类和属性。\n * 第二步，更新类的字段必须使用public volatile修饰。\n\n举个例子：\n\npublic class testatomicintegerfieldupdater {\n\n    public static void main(string[] args){\n        testatomicintegerfieldupdater tia = new testatomicintegerfieldupdater();\n        tia.doit();\n    }\n\n    public atomicintegerfieldupdater<datademo> updater(string name){\n        return atomicintegerfieldupdater.newupdater(datademo.class,name);\n\n    }\n\n    public void doit(){\n        datademo data = new datademo();\n        system.out.println("publicvar = "+updater("publicvar").getandadd(data, 2));\n        /*\n            * 由于在datademo类中属性value2/value3,在testatomicintegerfieldupdater中不能访问\n            * */\n        //system.out.println("protectedvar = "+updater("protectedvar").getandadd(data,2));\n        //system.out.println("privatevar = "+updater("privatevar").getandadd(data,2));\n\n        //system.out.println("staticvar = "+updater("staticvar").getandincrement(data));//报java.lang.illegalargumentexception\n        /*\n            * 下面报异常：must be integer\n            * */\n        //system.out.println("integervar = "+updater("integervar").getandincrement(data));\n        //system.out.println("longvar = "+updater("longvar").getandincrement(data));\n    }\n\n}\n\nclass datademo{\n    public volatile int publicvar=3;\n    protected volatile int protectedvar=4;\n    private volatile  int privatevar=5;\n\n    public volatile static int staticvar = 10;\n    //public  final int finalvar = 11;\n\n    public volatile integer integervar = 19;\n    public volatile long longvar = 18l;\n\n}\n\n\n再说下对于atomicintegerfieldupdater 的使用稍微有一些限制和约束，约束如下：\n\n * 字段必须是volatile类型的，在线程之间共享变量时保证立即可见.eg:volatile int value = 3\n\n * 字段的描述类型(修饰符public/protected/default/private)是与调用者与操作对象字段的关系一致。也就是说调用者能够直接操作对象字段，那么就可以反射进行原子操作。但是对于父类的字段，子类是不能直接操作的，尽管子类可以访问父类的字段。\n\n * 只能是实例变量，不能是类变量，也就是说不能加static关键字。\n\n * 只能是可修改变量，不能使final变量，因为final的语义就是不可修改。实际上final的语义和volatile是有冲突的，这两个关键字不能同时存在。\n\n * 对于atomicintegerfieldupdater和atomiclongfieldupdater只能修改int/long类型的字段，不能修改其包装类型(integer/long)。如果要修改包装类型就需要使用atomicreferencefieldupdater。\n\n\n# 再讲讲atomicstampedreference解决cas的aba问题\n\n\n# atomicstampedreference解决aba问题\n\natomicstampedreference主要维护包含一个对象引用以及一个可以自动更新的整数"stamp"的pair对象来解决aba问题。\n\npublic class atomicstampedreference<v> {\n    private static class pair<t> {\n        final t reference;  //维护对象引用\n        final int stamp;  //用于标志版本\n        private pair(t reference, int stamp) {\n            this.reference = reference;\n            this.stamp = stamp;\n        }\n        static <t> pair<t> of(t reference, int stamp) {\n            return new pair<t>(reference, stamp);\n        }\n    }\n    private volatile pair<v> pair;\n    ....\n    \n    /**\n      * expectedreference ：更新之前的原始值\n      * newreference : 将要更新的新值\n      * expectedstamp : 期待更新的标志版本\n      * newstamp : 将要更新的标志版本\n      */\n    public boolean compareandset(v   expectedreference,\n                             v   newreference,\n                             int expectedstamp,\n                             int newstamp) {\n        // 获取当前的(元素值，版本号)对\n        pair<v> current = pair;\n        return\n            // 引用没变\n            expectedreference == current.reference &&\n            // 版本号没变\n            expectedstamp == current.stamp &&\n            // 新引用等于旧引用\n            ((newreference == current.reference &&\n            // 新版本号等于旧版本号\n            newstamp == current.stamp) ||\n            // 构造新的pair对象并cas更新\n            caspair(current, pair.of(newreference, newstamp)));\n    }\n\n    private boolean caspair(pair<v> cmp, pair<v> val) {\n        // 调用unsafe的compareandswapobject()方法cas更新pair的引用为新引用\n        return unsafe.compareandswapobject(this, pairoffset, cmp, val);\n    }\n\n\n * 如果元素值和版本号都没有变化，并且和新的也相同，返回true；\n\n * 如果元素值和版本号都没有变化，并且和新的不完全相同，就构造一个新的pair对象并执行cas更新pair。\n\n可以看到，java中的实现跟我们上面讲的aba的解决方法是一致的。\n\n * 首先，使用版本号控制；\n\n * 其次，不重复使用节点(pair)的引用，每次都新建一个新的pair来作为cas比较的对象，而不是复用旧的；\n\n * 最后，外部传入元素值及版本号，而不是节点(pair)的引用。\n\n\n# 使用举例\n\npublic class atomictester {\n\n    private static atomicstampedreference<integer> atomicstampedref =\n            new atomicstampedreference<>(1, 0);\n\n    public static void main(string[] args){\n        first().start();\n        second().start();\n    }\n\n    private static thread first() {\n        return new thread(() -> {\n            system.out.println("操作线程" + thread.currentthread() +",初始值 a = " + atomicstampedref.getreference());\n            int stamp = atomicstampedref.getstamp(); //获取当前标识别\n            try {\n                thread.sleep(1000); //等待1秒 ，以便让干扰线程执行\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n            boolean iscassuccess = atomicstampedref.compareandset(1,2,stamp,stamp +1);  //此时expectedreference未发生改变，但是stamp已经被修改了,所以cas失败\n            system.out.println("操作线程" + thread.currentthread() +",cas操作结果: " + iscassuccess);\n        },"主操作线程");\n    }\n\n    private static thread second() {\n        return new thread(() -> {\n            thread.yield(); // 确保thread-first 优先执行\n            atomicstampedref.compareandset(1,2,atomicstampedref.getstamp(),atomicstampedref.getstamp() +1);\n            system.out.println("操作线程" + thread.currentthread() +",【increment】 ,值 = "+ atomicstampedref.getreference());\n            atomicstampedref.compareandset(2,1,atomicstampedref.getstamp(),atomicstampedref.getstamp() +1);\n            system.out.println("操作线程" + thread.currentthread() +",【decrement】 ,值 = "+ atomicstampedref.getreference());\n        },"干扰线程");\n    }\n}\n\n\n输出结果：\n\n操作线程thread[主操作线程,5,main],初始值 a = 1\n操作线程thread[干扰线程,5,main],【increment】 ,值 = 2\n操作线程thread[干扰线程,5,main],【decrement】 ,值 = 1\n操作线程thread[主操作线程,5,main],cas操作结果: false\n\n\n\n# java中还有哪些类可以解决aba的问题?\n\natomicmarkablereference，它不是维护一个版本号，而是维护一个boolean类型的标记，标记值有修改，了解一下。\n\n\n# 参考文章\n\n * https://benjaminwhx.com/2018/05/03/%e3%80%90%e7%bb%86%e8%b0%88java%e5%b9%b6%e5%8f%91%e3%80%91%e8%b0%88%e8%b0%88cas/\n * https://www.jianshu.com/p/9a1e6940987a\n * https://www.jianshu.com/p/a533cbb740c6\n * https://blog.csdn.net/qq_36236890/article/details/81914871\n * https://www.cnblogs.com/lodor/p/7492805.html\n * https://blog.csdn.net/u010412719/article/details/52068888\n * https://www.jianshu.com/p/18dfc5fa0171\n * https://www.jianshu.com/p/8b227a8adbc1\n * https://www.jianshu.com/p/77f75b398be9\n * https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-atomicinteger.html',charsets:{cjk:!0}},{title:"JUC集合: BlockingQueue详解",frontmatter:{},regularPath:"/java/thread/java-thread-x-juc-collection-BlockingQueue.html",relativePath:"java/thread/java-thread-x-juc-collection-BlockingQueue.md",key:"v-4c4bcd8c",path:"/java/thread/java-thread-x-juc-collection-BlockingQueue.html",headers:[{level:2,title:"JUC集合: BlockingQueue详解",slug:"juc集合-blockingqueue详解",normalizedTitle:"juc集合: blockingqueue详解",charIndex:2},{level:2,title:"带着BAT大厂的面试问题去理解",slug:"带着bat大厂的面试问题去理解",normalizedTitle:"带着bat大厂的面试问题去理解",charIndex:166},{level:2,title:"BlockingQueue和BlockingDeque",slug:"blockingqueue和blockingdeque",normalizedTitle:"blockingqueue和blockingdeque",charIndex:187},{level:3,title:"BlockingQueue",slug:"blockingqueue",normalizedTitle:"blockingqueue",charIndex:9},{level:3,title:"BlockingQueue 的方法",slug:"blockingqueue-的方法",normalizedTitle:"blockingqueue 的方法",charIndex:243},{level:3,title:"BlockingDeque",slug:"blockingdeque",normalizedTitle:"blockingdeque",charIndex:201},{level:3,title:"BlockingDeque 的方法",slug:"blockingdeque-的方法",normalizedTitle:"blockingdeque 的方法",charIndex:289},{level:3,title:"BlockingDeque 与BlockingQueue关系",slug:"blockingdeque-与blockingqueue关系",normalizedTitle:"blockingdeque 与blockingqueue关系",charIndex:314},{level:2,title:"BlockingQueue 的例子",slug:"blockingqueue-的例子",normalizedTitle:"blockingqueue 的例子",charIndex:350},{level:3,title:"数组阻塞队列 ArrayBlockingQueue",slug:"数组阻塞队列-arrayblockingqueue",normalizedTitle:"数组阻塞队列 arrayblockingqueue",charIndex:375},{level:3,title:"延迟队列 DelayQueue",slug:"延迟队列-delayqueue",normalizedTitle:"延迟队列 delayqueue",charIndex:408},{level:3,title:"链阻塞队列 LinkedBlockingQueue",slug:"链阻塞队列-linkedblockingqueue",normalizedTitle:"链阻塞队列 linkedblockingqueue",charIndex:431},{level:3,title:"具有优先级的阻塞队列 PriorityBlockingQueue",slug:"具有优先级的阻塞队列-priorityblockingqueue",normalizedTitle:"具有优先级的阻塞队列 priorityblockingqueue",charIndex:464},{level:3,title:"同步队列 SynchronousQueue",slug:"同步队列-synchronousqueue",normalizedTitle:"同步队列 synchronousqueue",charIndex:504},{level:2,title:"BlockingDeque 的例子",slug:"blockingdeque-的例子",normalizedTitle:"blockingdeque 的例子",charIndex:531},{level:3,title:"链阻塞双端队列 LinkedBlockingDeque",slug:"链阻塞双端队列-linkedblockingdeque",normalizedTitle:"链阻塞双端队列 linkedblockingdeque",charIndex:556},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:589}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"JUC集合: BlockingQueue详解 带着BAT大厂的面试问题去理解 BlockingQueue和BlockingDeque BlockingQueue BlockingQueue 的方法 BlockingDeque BlockingDeque 的方法 BlockingDeque 与BlockingQueue关系 BlockingQueue 的例子 数组阻塞队列 ArrayBlockingQueue 延迟队列 DelayQueue 链阻塞队列 LinkedBlockingQueue 具有优先级的阻塞队列 PriorityBlockingQueue 同步队列 SynchronousQueue BlockingDeque 的例子 链阻塞双端队列 LinkedBlockingDeque 参考文章",content:'# JUC集合: BlockingQueue详解\n\n> JUC里的 BlockingQueue 接口表示一个线程安放入和提取实例的队列。本文将给你演示如何使用这个 BlockingQueue，不会讨论如何在 Java 中实现一个你自己的 BlockingQueue。\n\n * JUC集合: BlockingQueue详解\n   * 带着BAT大厂的面试问题去理解\n   * BlockingQueue和BlockingDeque\n     * BlockingQueue\n     * BlockingQueue 的方法\n     * BlockingDeque\n     * BlockingDeque 的方法\n     * BlockingDeque 与BlockingQueue关系\n   * BlockingQueue 的例子\n     * 数组阻塞队列 ArrayBlockingQueue\n     * 延迟队列 DelayQueue\n     * 链阻塞队列 LinkedBlockingQueue\n     * 具有优先级的阻塞队列 PriorityBlockingQueue\n     * 同步队列 SynchronousQueue\n   * BlockingDeque 的例子\n     * 链阻塞双端队列 LinkedBlockingDeque\n   * 参考文章\n\n\n# 带着BAT大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 什么是BlockingDeque?\n * BlockingQueue大家族有哪些? ArrayBlockingQueue, DelayQueue, LinkedBlockingQueue, SynchronousQueue...\n * BlockingQueue适合用在什么样的场景?\n * BlockingQueue常用的方法?\n * BlockingQueue插入方法有哪些? 这些方法(add(o),offer(o),put(o),offer(o, timeout, timeunit))的区别是什么?\n * BlockingDeque 与BlockingQueue有何关系，请对比下它们的方法?\n * BlockingDeque适合用在什么样的场景?\n * BlockingDeque大家族有哪些?\n * BlockingDeque 与BlockingQueue实现例子?\n\n\n# BlockingQueue和BlockingDeque\n\n\n# BlockingQueue\n\nBlockingQueue 通常用于一个线程生产对象，而另外一个线程消费这些对象的场景。下图是对这个原理的阐述:\n\n\n\n一个线程往里边放，另外一个线程从里边取的一个 BlockingQueue。\n\n一个线程将会持续生产新对象并将其插入到队列之中，直到队列达到它所能容纳的临界点。也就是说，它是有限的。如果该阻塞队列到达了其临界点，负责生产的线程将会在往里边插入新对象时发生阻塞。它会一直处于阻塞之中，直到负责消费的线程从队列中拿走一个对象。 负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到一个生产线程把一个对象丢进队列。\n\n\n# BlockingQueue 的方法\n\nBlockingQueue 具有 4 组不同的方法用于插入、移除以及对队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下:\n\n     抛异常         特定值        阻塞       超时\n插入   add(o)      offer(o)   put(o)   offer(o, timeout, timeunit)\n移除   remove()    poll()     take()   poll(timeout, timeunit)\n检查   element()   peek()              \n\n四组不同的行为方式解释:\n\n * 抛异常: 如果试图的操作无法立即执行，抛一个异常。\n * 特定值: 如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。\n * 阻塞: 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。\n * 超时: 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。\n\n无法向一个 BlockingQueue 中插入 null。如果你试图插入 null，BlockingQueue 将会抛出一个 NullPointerException。 可以访问到 BlockingQueue 中的所有元素，而不仅仅是开始和结束的元素。比如说，你将一个对象放入队列之中以等待处理，但你的应用想要将其取消掉。那么你可以调用诸如 remove(o) 方法来将队列之中的特定对象进行移除。但是这么干效率并不高(译者注: 基于队列的数据结构，获取除开始或结束位置的其他对象的效率不会太高)，因此你尽量不要用这一类的方法，除非你确实不得不那么做。\n\n\n# BlockingDeque\n\njava.util.concurrent 包里的 BlockingDeque 接口表示一个线程安放入和提取实例的双端队列。\n\nBlockingDeque 类是一个双端队列，在不能够插入元素时，它将阻塞住试图插入元素的线程；在不能够抽取元素时，它将阻塞住试图抽取的线程。 deque(双端队列) 是 "Double Ended Queue" 的缩写。因此，双端队列是一个你可以从任意一端插入或者抽取元素的队列。\n\n在线程既是一个队列的生产者又是这个队列的消费者的时候可以使用到 BlockingDeque。如果生产者线程需要在队列的两端都可以插入数据，消费者线程需要在队列的两端都可以移除数据，这个时候也可以使用 BlockingDeque。BlockingDeque 图解:\n\n\n\n\n# BlockingDeque 的方法\n\n一个 BlockingDeque - 线程在双端队列的两端都可以插入和提取元素。 一个线程生产元素，并把它们插入到队列的任意一端。如果双端队列已满，插入线程将被阻塞，直到一个移除线程从该队列中移出了一个元素。如果双端队列为空，移除线程将被阻塞，直到一个插入线程向该队列插入了一个新元素。\n\nBlockingDeque 具有 4 组不同的方法用于插入、移除以及对双端队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下:\n\n     抛异常              特定值             阻塞             超时\n插入   addFirst(o)      offerFirst(o)   putFirst(o)    offerFirst(o, timeout, timeunit)\n移除   removeFirst(o)   pollFirst(o)    takeFirst(o)   pollFirst(timeout, timeunit)\n检查   getFirst(o)      peekFirst(o)                   \n\n     抛异常             特定值            阻塞            超时\n插入   addLast(o)      offerLast(o)   putLast(o)    offerLast(o, timeout, timeunit)\n移除   removeLast(o)   pollLast(o)    takeLast(o)   pollLast(timeout, timeunit)\n检查   getLast(o)      peekLast(o)                  \n\n四组不同的行为方式解释:\n\n * 抛异常: 如果试图的操作无法立即执行，抛一个异常。\n * 特定值: 如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。\n * 阻塞: 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。\n * 超时: 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。\n\n\n# BlockingDeque 与BlockingQueue关系\n\nBlockingDeque 接口继承自 BlockingQueue 接口。这就意味着你可以像使用一个 BlockingQueue 那样使用 BlockingDeque。如果你这么干的话，各种插入方法将会把新元素添加到双端队列的尾端，而移除方法将会把双端队列的首端的元素移除。正如 BlockingQueue 接口的插入和移除方法一样。\n\n以下是 BlockingDeque 对 BlockingQueue 接口的方法的具体内部实现:\n\nBLOCKINGQUEUE   BLOCKINGDEQUE\nadd()           addLast()\noffer() x 2     offerLast() x 2\nput()           putLast()\nremove()        removeFirst()\npoll() x 2      pollFirst()\ntake()          takeFirst()\nelement()       getFirst()\npeek()          peekFirst()\n\n\n# BlockingQueue 的例子\n\n这里是一个 Java 中使用 BlockingQueue 的示例。本示例使用的是 BlockingQueue 接口的 ArrayBlockingQueue 实现。 首先，BlockingQueueExample 类分别在两个独立的线程中启动了一个 Producer 和 一个 Consumer。Producer 向一个共享的 BlockingQueue 中注入字符串，而 Consumer 则会从中把它们拿出来。\n\npublic class BlockingQueueExample {\n \n    public static void main(String[] args) throws Exception {\n \n        BlockingQueue queue = new ArrayBlockingQueue(1024);\n \n        Producer producer = new Producer(queue);\n        Consumer consumer = new Consumer(queue);\n \n        new Thread(producer).start();\n        new Thread(consumer).start();\n \n        Thread.sleep(4000);\n    }\n}\n\n\n以下是 Producer 类。注意它在每次 put() 调用时是如何休眠一秒钟的。这将导致 Consumer 在等待队列中对象的时候发生阻塞。\n\npublic class Producer implements Runnable{\n \n    protected BlockingQueue queue = null;\n \n    public Producer(BlockingQueue queue) {\n        this.queue = queue;\n    }\n \n    public void run() {\n        try {\n            queue.put("1");\n            Thread.sleep(1000);\n            queue.put("2");\n            Thread.sleep(1000);\n            queue.put("3");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\n以下是 Consumer 类。它只是把对象从队列中抽取出来，然后将它们打印到 System.out。\n\npublic class Consumer implements Runnable{\n \n    protected BlockingQueue queue = null;\n \n    public Consumer(BlockingQueue queue) {\n        this.queue = queue;\n    }\n \n    public void run() {\n        try {\n            System.out.println(queue.take());\n            System.out.println(queue.take());\n            System.out.println(queue.take());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\n\n# 数组阻塞队列 ArrayBlockingQueue\n\nArrayBlockingQueue 类实现了 BlockingQueue 接口。\n\nArrayBlockingQueue 是一个有界的阻塞队列，其内部实现是将对象放到一个数组里。有界也就意味着，它不能够存储无限多数量的元素。它有一个同一时间能够存储元素数量的上限。你可以在对其初始化的时候设定这个上限，但之后就无法对这个上限进行修改了(译者注: 因为它是基于数组实现的，也就具有数组的特性: 一旦初始化，大小就无法修改)。 ArrayBlockingQueue 内部以 FIFO(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾元素则是最短的那个。 以下是在使用 ArrayBlockingQueue 的时候对其初始化的一个示例:\n\nBlockingQueue queue = new ArrayBlockingQueue(1024);\nqueue.put("1");\nObject object = queue.take();\n\n\n以下是使用了 Java 泛型的一个 BlockingQueue 示例。注意其中是如何对 String 元素放入和提取的:\n\nBlockingQueue<String> queue = new ArrayBlockingQueue<String>(1024);\nqueue.put("1");\nString string = queue.take();\n\n\n\n# 延迟队列 DelayQueue\n\nDelayQueue 实现了 BlockingQueue 接口。\n\nDelayQueue 对元素进行持有直到一个特定的延迟到期。注入其中的元素必须实现 java.util.concurrent.Delayed 接口，该接口定义:\n\npublic interface Delayed extends Comparable<Delayed< {\n    public long getDelay(TimeUnit timeUnit);\n}\n\n\nDelayQueue 将会在每个元素的 getDelay() 方法返回的值的时间段之后才释放掉该元素。如果返回的是 0 或者负值，延迟将被认为过期，该元素将会在 DelayQueue 的下一次 take 被调用的时候被释放掉。\n\n传递给 getDelay 方法的 getDelay 实例是一个枚举类型，它表明了将要延迟的时间段。TimeUnit 枚举将会取以下值:\n\n * DAYS\n * HOURS\n * INUTES\n * SECONDS\n * MILLISECONDS\n * MICROSECONDS\n * NANOSECONDS\n\n正如你所看到的，Delayed 接口也继承了 java.lang.Comparable 接口，这也就意味着 Delayed 对象之间可以进行对比。这个可能在对 DelayQueue 队列中的元素进行排序时有用，因此它们可以根据过期时间进行有序释放。 以下是使用 DelayQueue 的例子:\n\npublic class DelayQueueExample {\n \n    public static void main(String[] args) {\n        DelayQueue queue = new DelayQueue();\n        Delayed element1 = new DelayedElement();\n        queue.put(element1);\n        Delayed element2 = queue.take();\n    }\n}\n\n\nDelayedElement 是我所创建的一个 DelayedElement 接口的实现类，它不在 java.util.concurrent 包里。你需要自行创建你自己的 Delayed 接口的实现以使用 DelayQueue 类。\n\n\n# 链阻塞队列 LinkedBlockingQueue\n\nLinkedBlockingQueue 类实现了 BlockingQueue 接口。\n\nLinkedBlockingQueue 内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用 Integer.MAX_VALUE 作为上限。\n\nLinkedBlockingQueue 内部以 FIFO(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾元素则是最短的那个。 以下是 LinkedBlockingQueue 的初始化和使用示例代码:\n\nBlockingQueue<String> unbounded = new LinkedBlockingQueue<String>();\nBlockingQueue<String> bounded   = new LinkedBlockingQueue<String>(1024);\nbounded.put("Value");\nString value = bounded.take();\n\n\n\n# 具有优先级的阻塞队列 PriorityBlockingQueue\n\nPriorityBlockingQueue 类实现了 BlockingQueue 接口。\n\nPriorityBlockingQueue 是一个无界的并发队列。它使用了和类 java.util.PriorityQueue 一样的排序规则。你无法向这个队列中插入 null 值。 所有插入到 PriorityBlockingQueue 的元素必须实现 java.lang.Comparable 接口。因此该队列中元素的排序就取决于你自己的 Comparable 实现。 注意 PriorityBlockingQueue 对于具有相等优先级(compare() == 0)的元素并不强制任何特定行为。\n\n同时注意，如果你从一个 PriorityBlockingQueue 获得一个 Iterator 的话，该 Iterator 并不能保证它对元素的遍历是以优先级为序的。 以下是使用 PriorityBlockingQueue 的示例:\n\nBlockingQueue queue   = new PriorityBlockingQueue();\n//String implements java.lang.Comparable\nqueue.put("Value");\nString value = queue.take();\n\n\n\n# 同步队列 SynchronousQueue\n\nSynchronousQueue 类实现了 BlockingQueue 接口。\n\nSynchronousQueue 是一个特殊的队列，它的内部同时只能够容纳单个元素。如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。 据此，把这个类称作一个队列显然是夸大其词了。它更多像是一个汇合点。\n\n\n# BlockingDeque 的例子\n\n既然 BlockingDeque 是一个接口，那么你想要使用它的话就得使用它的众多的实现类的其中一个。java.util.concurrent 包提供了以下 BlockingDeque 接口的实现类: LinkedBlockingDeque。\n\n以下是如何使用 BlockingDeque 方法的一个简短代码示例:\n\nBlockingDeque<String> deque = new LinkedBlockingDeque<String>();\ndeque.addFirst("1");\ndeque.addLast("2");\n \nString two = deque.takeLast();\nString one = deque.takeFirst();\n\n\n\n# 链阻塞双端队列 LinkedBlockingDeque\n\nLinkedBlockingDeque 类实现了 BlockingDeque 接口。\n\ndeque(双端队列) 是 "Double Ended Queue" 的缩写。因此，双端队列是一个你可以从任意一端插入或者抽取元素的队列。\n\nLinkedBlockingDeque 是一个双端队列，在它为空的时候，一个试图从中抽取数据的线程将会阻塞，无论该线程是试图从哪一端抽取数据。\n\n以下是 LinkedBlockingDeque 实例化以及使用的示例:\n\nBlockingDeque<String> deque = new LinkedBlockingDeque<String>();\ndeque.addFirst("1");\ndeque.addLast("2");\n \nString two = deque.takeLast();\nString one = deque.takeFirst();\n\n\n\n# 参考文章\n\n * https://blog.csdn.net/defonds/article/details/44021605#t7\n * http://tutorials.jenkov.com/java-concurrency/index.html\n * https://github.com/CL0610/Java-concurrency/blob/master/19.%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BBlockingQueue/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BBlockingQueue.md\n * https://www.javadoop.com/post/java-concurrent-queue\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-BlockingQueue.html',normalizedContent:'# juc集合: blockingqueue详解\n\n> juc里的 blockingqueue 接口表示一个线程安放入和提取实例的队列。本文将给你演示如何使用这个 blockingqueue，不会讨论如何在 java 中实现一个你自己的 blockingqueue。\n\n * juc集合: blockingqueue详解\n   * 带着bat大厂的面试问题去理解\n   * blockingqueue和blockingdeque\n     * blockingqueue\n     * blockingqueue 的方法\n     * blockingdeque\n     * blockingdeque 的方法\n     * blockingdeque 与blockingqueue关系\n   * blockingqueue 的例子\n     * 数组阻塞队列 arrayblockingqueue\n     * 延迟队列 delayqueue\n     * 链阻塞队列 linkedblockingqueue\n     * 具有优先级的阻塞队列 priorityblockingqueue\n     * 同步队列 synchronousqueue\n   * blockingdeque 的例子\n     * 链阻塞双端队列 linkedblockingdeque\n   * 参考文章\n\n\n# 带着bat大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 什么是blockingdeque?\n * blockingqueue大家族有哪些? arrayblockingqueue, delayqueue, linkedblockingqueue, synchronousqueue...\n * blockingqueue适合用在什么样的场景?\n * blockingqueue常用的方法?\n * blockingqueue插入方法有哪些? 这些方法(add(o),offer(o),put(o),offer(o, timeout, timeunit))的区别是什么?\n * blockingdeque 与blockingqueue有何关系，请对比下它们的方法?\n * blockingdeque适合用在什么样的场景?\n * blockingdeque大家族有哪些?\n * blockingdeque 与blockingqueue实现例子?\n\n\n# blockingqueue和blockingdeque\n\n\n# blockingqueue\n\nblockingqueue 通常用于一个线程生产对象，而另外一个线程消费这些对象的场景。下图是对这个原理的阐述:\n\n\n\n一个线程往里边放，另外一个线程从里边取的一个 blockingqueue。\n\n一个线程将会持续生产新对象并将其插入到队列之中，直到队列达到它所能容纳的临界点。也就是说，它是有限的。如果该阻塞队列到达了其临界点，负责生产的线程将会在往里边插入新对象时发生阻塞。它会一直处于阻塞之中，直到负责消费的线程从队列中拿走一个对象。 负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到一个生产线程把一个对象丢进队列。\n\n\n# blockingqueue 的方法\n\nblockingqueue 具有 4 组不同的方法用于插入、移除以及对队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下:\n\n     抛异常         特定值        阻塞       超时\n插入   add(o)      offer(o)   put(o)   offer(o, timeout, timeunit)\n移除   remove()    poll()     take()   poll(timeout, timeunit)\n检查   element()   peek()              \n\n四组不同的行为方式解释:\n\n * 抛异常: 如果试图的操作无法立即执行，抛一个异常。\n * 特定值: 如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。\n * 阻塞: 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。\n * 超时: 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。\n\n无法向一个 blockingqueue 中插入 null。如果你试图插入 null，blockingqueue 将会抛出一个 nullpointerexception。 可以访问到 blockingqueue 中的所有元素，而不仅仅是开始和结束的元素。比如说，你将一个对象放入队列之中以等待处理，但你的应用想要将其取消掉。那么你可以调用诸如 remove(o) 方法来将队列之中的特定对象进行移除。但是这么干效率并不高(译者注: 基于队列的数据结构，获取除开始或结束位置的其他对象的效率不会太高)，因此你尽量不要用这一类的方法，除非你确实不得不那么做。\n\n\n# blockingdeque\n\njava.util.concurrent 包里的 blockingdeque 接口表示一个线程安放入和提取实例的双端队列。\n\nblockingdeque 类是一个双端队列，在不能够插入元素时，它将阻塞住试图插入元素的线程；在不能够抽取元素时，它将阻塞住试图抽取的线程。 deque(双端队列) 是 "double ended queue" 的缩写。因此，双端队列是一个你可以从任意一端插入或者抽取元素的队列。\n\n在线程既是一个队列的生产者又是这个队列的消费者的时候可以使用到 blockingdeque。如果生产者线程需要在队列的两端都可以插入数据，消费者线程需要在队列的两端都可以移除数据，这个时候也可以使用 blockingdeque。blockingdeque 图解:\n\n\n\n\n# blockingdeque 的方法\n\n一个 blockingdeque - 线程在双端队列的两端都可以插入和提取元素。 一个线程生产元素，并把它们插入到队列的任意一端。如果双端队列已满，插入线程将被阻塞，直到一个移除线程从该队列中移出了一个元素。如果双端队列为空，移除线程将被阻塞，直到一个插入线程向该队列插入了一个新元素。\n\nblockingdeque 具有 4 组不同的方法用于插入、移除以及对双端队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下:\n\n     抛异常              特定值             阻塞             超时\n插入   addfirst(o)      offerfirst(o)   putfirst(o)    offerfirst(o, timeout, timeunit)\n移除   removefirst(o)   pollfirst(o)    takefirst(o)   pollfirst(timeout, timeunit)\n检查   getfirst(o)      peekfirst(o)                   \n\n     抛异常             特定值            阻塞            超时\n插入   addlast(o)      offerlast(o)   putlast(o)    offerlast(o, timeout, timeunit)\n移除   removelast(o)   polllast(o)    takelast(o)   polllast(timeout, timeunit)\n检查   getlast(o)      peeklast(o)                  \n\n四组不同的行为方式解释:\n\n * 抛异常: 如果试图的操作无法立即执行，抛一个异常。\n * 特定值: 如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。\n * 阻塞: 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。\n * 超时: 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。\n\n\n# blockingdeque 与blockingqueue关系\n\nblockingdeque 接口继承自 blockingqueue 接口。这就意味着你可以像使用一个 blockingqueue 那样使用 blockingdeque。如果你这么干的话，各种插入方法将会把新元素添加到双端队列的尾端，而移除方法将会把双端队列的首端的元素移除。正如 blockingqueue 接口的插入和移除方法一样。\n\n以下是 blockingdeque 对 blockingqueue 接口的方法的具体内部实现:\n\nblockingqueue   blockingdeque\nadd()           addlast()\noffer() x 2     offerlast() x 2\nput()           putlast()\nremove()        removefirst()\npoll() x 2      pollfirst()\ntake()          takefirst()\nelement()       getfirst()\npeek()          peekfirst()\n\n\n# blockingqueue 的例子\n\n这里是一个 java 中使用 blockingqueue 的示例。本示例使用的是 blockingqueue 接口的 arrayblockingqueue 实现。 首先，blockingqueueexample 类分别在两个独立的线程中启动了一个 producer 和 一个 consumer。producer 向一个共享的 blockingqueue 中注入字符串，而 consumer 则会从中把它们拿出来。\n\npublic class blockingqueueexample {\n \n    public static void main(string[] args) throws exception {\n \n        blockingqueue queue = new arrayblockingqueue(1024);\n \n        producer producer = new producer(queue);\n        consumer consumer = new consumer(queue);\n \n        new thread(producer).start();\n        new thread(consumer).start();\n \n        thread.sleep(4000);\n    }\n}\n\n\n以下是 producer 类。注意它在每次 put() 调用时是如何休眠一秒钟的。这将导致 consumer 在等待队列中对象的时候发生阻塞。\n\npublic class producer implements runnable{\n \n    protected blockingqueue queue = null;\n \n    public producer(blockingqueue queue) {\n        this.queue = queue;\n    }\n \n    public void run() {\n        try {\n            queue.put("1");\n            thread.sleep(1000);\n            queue.put("2");\n            thread.sleep(1000);\n            queue.put("3");\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n    }\n}\n\n\n以下是 consumer 类。它只是把对象从队列中抽取出来，然后将它们打印到 system.out。\n\npublic class consumer implements runnable{\n \n    protected blockingqueue queue = null;\n \n    public consumer(blockingqueue queue) {\n        this.queue = queue;\n    }\n \n    public void run() {\n        try {\n            system.out.println(queue.take());\n            system.out.println(queue.take());\n            system.out.println(queue.take());\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n    }\n}\n\n\n\n# 数组阻塞队列 arrayblockingqueue\n\narrayblockingqueue 类实现了 blockingqueue 接口。\n\narrayblockingqueue 是一个有界的阻塞队列，其内部实现是将对象放到一个数组里。有界也就意味着，它不能够存储无限多数量的元素。它有一个同一时间能够存储元素数量的上限。你可以在对其初始化的时候设定这个上限，但之后就无法对这个上限进行修改了(译者注: 因为它是基于数组实现的，也就具有数组的特性: 一旦初始化，大小就无法修改)。 arrayblockingqueue 内部以 fifo(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾元素则是最短的那个。 以下是在使用 arrayblockingqueue 的时候对其初始化的一个示例:\n\nblockingqueue queue = new arrayblockingqueue(1024);\nqueue.put("1");\nobject object = queue.take();\n\n\n以下是使用了 java 泛型的一个 blockingqueue 示例。注意其中是如何对 string 元素放入和提取的:\n\nblockingqueue<string> queue = new arrayblockingqueue<string>(1024);\nqueue.put("1");\nstring string = queue.take();\n\n\n\n# 延迟队列 delayqueue\n\ndelayqueue 实现了 blockingqueue 接口。\n\ndelayqueue 对元素进行持有直到一个特定的延迟到期。注入其中的元素必须实现 java.util.concurrent.delayed 接口，该接口定义:\n\npublic interface delayed extends comparable<delayed< {\n    public long getdelay(timeunit timeunit);\n}\n\n\ndelayqueue 将会在每个元素的 getdelay() 方法返回的值的时间段之后才释放掉该元素。如果返回的是 0 或者负值，延迟将被认为过期，该元素将会在 delayqueue 的下一次 take 被调用的时候被释放掉。\n\n传递给 getdelay 方法的 getdelay 实例是一个枚举类型，它表明了将要延迟的时间段。timeunit 枚举将会取以下值:\n\n * days\n * hours\n * inutes\n * seconds\n * milliseconds\n * microseconds\n * nanoseconds\n\n正如你所看到的，delayed 接口也继承了 java.lang.comparable 接口，这也就意味着 delayed 对象之间可以进行对比。这个可能在对 delayqueue 队列中的元素进行排序时有用，因此它们可以根据过期时间进行有序释放。 以下是使用 delayqueue 的例子:\n\npublic class delayqueueexample {\n \n    public static void main(string[] args) {\n        delayqueue queue = new delayqueue();\n        delayed element1 = new delayedelement();\n        queue.put(element1);\n        delayed element2 = queue.take();\n    }\n}\n\n\ndelayedelement 是我所创建的一个 delayedelement 接口的实现类，它不在 java.util.concurrent 包里。你需要自行创建你自己的 delayed 接口的实现以使用 delayqueue 类。\n\n\n# 链阻塞队列 linkedblockingqueue\n\nlinkedblockingqueue 类实现了 blockingqueue 接口。\n\nlinkedblockingqueue 内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用 integer.max_value 作为上限。\n\nlinkedblockingqueue 内部以 fifo(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾元素则是最短的那个。 以下是 linkedblockingqueue 的初始化和使用示例代码:\n\nblockingqueue<string> unbounded = new linkedblockingqueue<string>();\nblockingqueue<string> bounded   = new linkedblockingqueue<string>(1024);\nbounded.put("value");\nstring value = bounded.take();\n\n\n\n# 具有优先级的阻塞队列 priorityblockingqueue\n\npriorityblockingqueue 类实现了 blockingqueue 接口。\n\npriorityblockingqueue 是一个无界的并发队列。它使用了和类 java.util.priorityqueue 一样的排序规则。你无法向这个队列中插入 null 值。 所有插入到 priorityblockingqueue 的元素必须实现 java.lang.comparable 接口。因此该队列中元素的排序就取决于你自己的 comparable 实现。 注意 priorityblockingqueue 对于具有相等优先级(compare() == 0)的元素并不强制任何特定行为。\n\n同时注意，如果你从一个 priorityblockingqueue 获得一个 iterator 的话，该 iterator 并不能保证它对元素的遍历是以优先级为序的。 以下是使用 priorityblockingqueue 的示例:\n\nblockingqueue queue   = new priorityblockingqueue();\n//string implements java.lang.comparable\nqueue.put("value");\nstring value = queue.take();\n\n\n\n# 同步队列 synchronousqueue\n\nsynchronousqueue 类实现了 blockingqueue 接口。\n\nsynchronousqueue 是一个特殊的队列，它的内部同时只能够容纳单个元素。如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。 据此，把这个类称作一个队列显然是夸大其词了。它更多像是一个汇合点。\n\n\n# blockingdeque 的例子\n\n既然 blockingdeque 是一个接口，那么你想要使用它的话就得使用它的众多的实现类的其中一个。java.util.concurrent 包提供了以下 blockingdeque 接口的实现类: linkedblockingdeque。\n\n以下是如何使用 blockingdeque 方法的一个简短代码示例:\n\nblockingdeque<string> deque = new linkedblockingdeque<string>();\ndeque.addfirst("1");\ndeque.addlast("2");\n \nstring two = deque.takelast();\nstring one = deque.takefirst();\n\n\n\n# 链阻塞双端队列 linkedblockingdeque\n\nlinkedblockingdeque 类实现了 blockingdeque 接口。\n\ndeque(双端队列) 是 "double ended queue" 的缩写。因此，双端队列是一个你可以从任意一端插入或者抽取元素的队列。\n\nlinkedblockingdeque 是一个双端队列，在它为空的时候，一个试图从中抽取数据的线程将会阻塞，无论该线程是试图从哪一端抽取数据。\n\n以下是 linkedblockingdeque 实例化以及使用的示例:\n\nblockingdeque<string> deque = new linkedblockingdeque<string>();\ndeque.addfirst("1");\ndeque.addlast("2");\n \nstring two = deque.takelast();\nstring one = deque.takefirst();\n\n\n\n# 参考文章\n\n * https://blog.csdn.net/defonds/article/details/44021605#t7\n * http://tutorials.jenkov.com/java-concurrency/index.html\n * https://github.com/cl0610/java-concurrency/blob/master/19.%e5%b9%b6%e5%8f%91%e5%ae%b9%e5%99%a8%e4%b9%8bblockingqueue/%e5%b9%b6%e5%8f%91%e5%ae%b9%e5%99%a8%e4%b9%8bblockingqueue.md\n * https://www.javadoop.com/post/java-concurrent-queue\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-blockingqueue.html',charsets:{cjk:!0}},{title:"JUC集合: ConcurrentHashMap详解",frontmatter:{},regularPath:"/java/thread/java-thread-x-juc-collection-ConcurrentHashMap.html",relativePath:"java/thread/java-thread-x-juc-collection-ConcurrentHashMap.md",key:"v-781a7d54",path:"/java/thread/java-thread-x-juc-collection-ConcurrentHashMap.html",headers:[{level:2,title:"JUC集合: ConcurrentHashMap详解",slug:"juc集合-concurrenthashmap详解",normalizedTitle:"juc集合: concurrenthashmap详解",charIndex:2},{level:2,title:"带着BAT大厂的面试问题去理解",slug:"带着bat大厂的面试问题去理解",normalizedTitle:"带着bat大厂的面试问题去理解",charIndex:177},{level:2,title:"为什么HashTable慢",slug:"为什么hashtable慢",normalizedTitle:"为什么hashtable慢",charIndex:198},{level:2,title:"ConcurrentHashMap - JDK 1.7",slug:"concurrenthashmap-jdk-1-7",normalizedTitle:"concurrenthashmap - jdk 1.7",charIndex:217},{level:3,title:"数据结构",slug:"数据结构",normalizedTitle:"数据结构",charIndex:86},{level:3,title:"初始化",slug:"初始化",normalizedTitle:"初始化",charIndex:264},{level:3,title:"put 过程分析",slug:"put-过程分析",normalizedTitle:"put 过程分析",charIndex:275},{level:3,title:"初始化槽: ensureSegment",slug:"初始化槽-ensuresegment",normalizedTitle:"初始化槽: ensuresegment",charIndex:291},{level:3,title:"获取写入锁: scanAndLockForPut",slug:"获取写入锁-scanandlockforput",normalizedTitle:"获取写入锁: scanandlockforput",charIndex:318},{level:3,title:"扩容: rehash",slug:"扩容-rehash",normalizedTitle:"扩容: rehash",charIndex:350},{level:3,title:"get 过程分析",slug:"get-过程分析",normalizedTitle:"get 过程分析",charIndex:368},{level:3,title:"并发问题分析",slug:"并发问题分析",normalizedTitle:"并发问题分析",charIndex:384},{level:2,title:"ConcurrentHashMap - JDK 1.8",slug:"concurrenthashmap-jdk-1-8",normalizedTitle:"concurrenthashmap - jdk 1.8",charIndex:396},{level:3,title:"数据结构",slug:"数据结构-2",normalizedTitle:"数据结构",charIndex:86},{level:3,title:"初始化",slug:"初始化-2",normalizedTitle:"初始化",charIndex:264},{level:3,title:"put 过程分析",slug:"put-过程分析-2",normalizedTitle:"put 过程分析",charIndex:275},{level:3,title:"初始化数组: initTable",slug:"初始化数组-inittable",normalizedTitle:"初始化数组: inittable",charIndex:470},{level:3,title:"链表转红黑树: treeifyBin",slug:"链表转红黑树-treeifybin",normalizedTitle:"链表转红黑树: treeifybin",charIndex:494},{level:3,title:"扩容: tryPresize",slug:"扩容-trypresize",normalizedTitle:"扩容: trypresize",charIndex:520},{level:3,title:"数据迁移: transfer",slug:"数据迁移-transfer",normalizedTitle:"数据迁移: transfer",charIndex:542},{level:3,title:"get 过程分析",slug:"get-过程分析-2",normalizedTitle:"get 过程分析",charIndex:368},{level:2,title:"对比总结",slug:"对比总结",normalizedTitle:"对比总结",charIndex:578},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:588}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"JUC集合: ConcurrentHashMap详解 带着BAT大厂的面试问题去理解 为什么HashTable慢 ConcurrentHashMap - JDK 1.7 数据结构 初始化 put 过程分析 初始化槽: ensureSegment 获取写入锁: scanAndLockForPut 扩容: rehash get 过程分析 并发问题分析 ConcurrentHashMap - JDK 1.8 数据结构 初始化 put 过程分析 初始化数组: initTable 链表转红黑树: treeifyBin 扩容: tryPresize 数据迁移: transfer get 过程分析 对比总结 参考文章",content:'# JUC集合: ConcurrentHashMap详解\n\n> JDK1.7之前的ConcurrentHashMap使用分段锁机制实现，JDK1.8则使用数组+链表+红黑树数据结构和CAS原子操作实现ConcurrentHashMap；本文将分别介绍这两种方式的实现方案及其区别。\n\n * JUC集合: ConcurrentHashMap详解\n   * 带着BAT大厂的面试问题去理解\n   * 为什么HashTable慢\n   * ConcurrentHashMap - JDK 1.7\n     * 数据结构\n     * 初始化\n     * put 过程分析\n     * 初始化槽: ensureSegment\n     * 获取写入锁: scanAndLockForPut\n     * 扩容: rehash\n     * get 过程分析\n     * 并发问题分析\n   * ConcurrentHashMap - JDK 1.8\n     * 数据结构\n     * 初始化\n     * put 过程分析\n     * 初始化数组: initTable\n     * 链表转红黑树: treeifyBin\n     * 扩容: tryPresize\n     * 数据迁移: transfer\n     * get 过程分析\n   * 对比总结\n   * 参考文章\n\n\n# 带着BAT大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 为什么HashTable慢? 它的并发度是什么? 那么ConcurrentHashMap并发度是什么?\n * ConcurrentHashMap在JDK1.7和JDK1.8中实现有什么差别? JDK1.8解決了JDK1.7中什么问题\n * ConcurrentHashMap JDK1.7实现的原理是什么? 分段锁机制\n * ConcurrentHashMap JDK1.8实现的原理是什么? 数组+链表+红黑树，CAS\n * ConcurrentHashMap JDK1.7中Segment数(concurrencyLevel)默认值是多少? 为何一旦初始化就不可再扩容?\n * ConcurrentHashMap JDK1.7说说其put的机制?\n * ConcurrentHashMap JDK1.7是如何扩容的? rehash(注：segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry<K,V>[] 进行扩容)\n * ConcurrentHashMap JDK1.8是如何扩容的? tryPresize\n * ConcurrentHashMap JDK1.8链表转红黑树的时机是什么? 临界值为什么是8?\n * ConcurrentHashMap JDK1.8是如何进行数据迁移的? transfer\n\n\n# 为什么HashTable慢\n\nHashtable之所以效率低下主要是因为其实现使用了synchronized关键字对put等操作进行加锁，而synchronized关键字加锁是对整个对象进行加锁，也就是说在进行put等修改Hash表的操作时，锁住了整个Hash表，从而使得其表现的效率低下。\n\n\n# ConcurrentHashMap - JDK 1.7\n\n在JDK1.5~1.7版本，Java使用了分段锁机制实现ConcurrentHashMap.\n\n简而言之，ConcurrentHashMap在对象中保存了一个Segment数组，即将整个Hash表划分为多个分段；而每个Segment元素，即每个分段则类似于一个Hashtable；这样，在执行put操作时首先根据hash算法定位到元素属于哪个Segment，然后对该Segment加锁即可。因此，ConcurrentHashMap在多线程并发编程中可是实现多线程put操作。接下来分析JDK1.7版本中ConcurrentHashMap的实现原理。\n\n\n# 数据结构\n\n整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个 segment。\n\n简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。\n\n\n\nconcurrencyLevel: 并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。\n\n再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。\n\n\n# 初始化\n\n * initialCapacity: 初始容量，这个值指的是整个 ConcurrentHashMap 的初始容量，实际操作的时候需要平均分给每个 Segment。\n\n * loadFactor: 负载因子，之前我们说了，Segment 数组不可以扩容，所以这个负载因子是给每个 Segment 内部使用的。\n\npublic ConcurrentHashMap(int initialCapacity,\n                         float loadFactor, int concurrencyLevel) {\n    if (!(loadFactor > 0) || initialCapacity < 0 || concurrencyLevel <= 0)\n        throw new IllegalArgumentException();\n    if (concurrencyLevel > MAX_SEGMENTS)\n        concurrencyLevel = MAX_SEGMENTS;\n    // Find power-of-two sizes best matching arguments\n    int sshift = 0;\n    int ssize = 1;\n    // 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方\n    while (ssize < concurrencyLevel) {\n        ++sshift;\n        ssize <<= 1;\n    }\n    // 我们这里先不要那么烧脑，用默认值，concurrencyLevel 为 16，sshift 为 4\n    // 那么计算出 segmentShift 为 28，segmentMask 为 15，后面会用到这两个值\n    this.segmentShift = 32 - sshift;\n    this.segmentMask = ssize - 1;\n\n    if (initialCapacity > MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n\n    // initialCapacity 是设置整个 map 初始的大小，\n    // 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小\n    // 如 initialCapacity 为 64，那么每个 Segment 或称之为"槽"可以分到 4 个\n    int c = initialCapacity / ssize;\n    if (c * ssize < initialCapacity)\n        ++c;\n    // 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2，这个值也是有讲究的，因为这样的话，对于具体的槽上，\n    // 插入一个元素不至于扩容，插入第二个的时候才会扩容\n    int cap = MIN_SEGMENT_TABLE_CAPACITY; \n    while (cap < c)\n        cap <<= 1;\n\n    // 创建 Segment 数组，\n    // 并创建数组的第一个元素 segment[0]\n    Segment<K,V> s0 =\n        new Segment<K,V>(loadFactor, (int)(cap * loadFactor),\n                         (HashEntry<K,V>[])new HashEntry[cap]);\n    Segment<K,V>[] ss = (Segment<K,V>[])new Segment[ssize];\n    // 往数组写入 segment[0]\n    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]\n    this.segments = ss;\n}\n\n\n初始化完成，我们得到了一个 Segment 数组。\n\n我们就当是用 new ConcurrentHashMap() 无参构造函数进行初始化的，那么初始化完成后:\n\n * Segment 数组长度为 16，不可以扩容\n * Segment[i] 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容\n * 这里初始化了 segment[0]，其他位置还是 null，至于为什么要初始化 segment[0]，后面的代码会介绍\n * 当前 segmentShift 的值为 32 - 4 = 28，segmentMask 为 16 - 1 = 15，姑且把它们简单翻译为移位数和掩码，这两个值马上就会用到\n\n\n# put 过程分析\n\n我们先看 put 的主流程，对于其中的一些关键细节操作，后面会进行详细介绍。\n\npublic V put(K key, V value) {\n    Segment<K,V> s;\n    if (value == null)\n        throw new NullPointerException();\n    // 1. 计算 key 的 hash 值\n    int hash = hash(key);\n    // 2. 根据 hash 值找到 Segment 数组中的位置 j\n    //    hash 是 32 位，无符号右移 segmentShift(28) 位，剩下高 4 位，\n    //    然后和 segmentMask(15) 做一次与操作，也就是说 j 是 hash 值的高 4 位，也就是槽的数组下标\n    int j = (hash >>> segmentShift) & segmentMask;\n    // 刚刚说了，初始化的时候初始化了 segment[0]，但是其他位置还是 null，\n    // ensureSegment(j) 对 segment[j] 进行初始化\n    if ((s = (Segment<K,V>)UNSAFE.getObject          // nonvolatile; recheck\n         (segments, (j << SSHIFT) + SBASE)) == null) //  in ensureSegment\n        s = ensureSegment(j);\n    // 3. 插入新值到 槽 s 中\n    return s.put(key, hash, value, false);\n}\n\n\n第一层皮很简单，根据 hash 值很快就能找到相应的 Segment，之后就是 Segment 内部的 put 操作了。\n\nSegment 内部是由 数组+链表 组成的。\n\nfinal V put(K key, int hash, V value, boolean onlyIfAbsent) {\n    // 在往该 segment 写入前，需要先获取该 segment 的独占锁\n    //    先看主流程，后面还会具体介绍这部分内容\n    HashEntry<K,V> node = tryLock() ? null :\n        scanAndLockForPut(key, hash, value);\n    V oldValue;\n    try {\n        // 这个是 segment 内部的数组\n        HashEntry<K,V>[] tab = table;\n        // 再利用 hash 值，求应该放置的数组下标\n        int index = (tab.length - 1) & hash;\n        // first 是数组该位置处的链表的表头\n        HashEntry<K,V> first = entryAt(tab, index);\n\n        // 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况\n        for (HashEntry<K,V> e = first;;) {\n            if (e != null) {\n                K k;\n                if ((k = e.key) == key ||\n                    (e.hash == hash && key.equals(k))) {\n                    oldValue = e.value;\n                    if (!onlyIfAbsent) {\n                        // 覆盖旧值\n                        e.value = value;\n                        ++modCount;\n                    }\n                    break;\n                }\n                // 继续顺着链表走\n                e = e.next;\n            }\n            else {\n                // node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。\n                // 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。\n                if (node != null)\n                    node.setNext(first);\n                else\n                    node = new HashEntry<K,V>(hash, key, value, first);\n\n                int c = count + 1;\n                // 如果超过了该 segment 的阈值，这个 segment 需要扩容\n                if (c > threshold && tab.length < MAXIMUM_CAPACITY)\n                    rehash(node); // 扩容后面也会具体分析\n                else\n                    // 没有达到阈值，将 node 放到数组 tab 的 index 位置，\n                    // 其实就是将新的节点设置成原链表的表头\n                    setEntryAt(tab, index, node);\n                ++modCount;\n                count = c;\n                oldValue = null;\n                break;\n            }\n        }\n    } finally {\n        // 解锁\n        unlock();\n    }\n    return oldValue;\n}\n\n\n整体流程还是比较简单的，由于有独占锁的保护，所以 segment 内部的操作并不复杂。至于这里面的并发问题，我们稍后再进行介绍。\n\n到这里 put 操作就结束了，接下来，我们说一说其中几步关键的操作。\n\n\n# 初始化槽: ensureSegment\n\nConcurrentHashMap 初始化的时候会初始化第一个槽 segment[0]，对于其他槽来说，在插入第一个值的时候进行初始化。\n\n这里需要考虑并发，因为很可能会有多个线程同时进来初始化同一个槽 segment[k]，不过只要有一个成功了就可以。\n\nprivate Segment<K,V> ensureSegment(int k) {\n    final Segment<K,V>[] ss = this.segments;\n    long u = (k << SSHIFT) + SBASE; // raw offset\n    Segment<K,V> seg;\n    if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u)) == null) {\n        // 这里看到为什么之前要初始化 segment[0] 了，\n        // 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]\n        // 为什么要用“当前”，因为 segment[0] 可能早就扩容过了\n        Segment<K,V> proto = ss[0];\n        int cap = proto.table.length;\n        float lf = proto.loadFactor;\n        int threshold = (int)(cap * lf);\n\n        // 初始化 segment[k] 内部的数组\n        HashEntry<K,V>[] tab = (HashEntry<K,V>[])new HashEntry[cap];\n        if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u))\n            == null) { // 再次检查一遍该槽是否被其他线程初始化了。\n\n            Segment<K,V> s = new Segment<K,V>(lf, threshold, tab);\n            // 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出\n            while ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u))\n                   == null) {\n                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))\n                    break;\n            }\n        }\n    }\n    return seg;\n}\n\n\n总的来说，ensureSegment(int k) 比较简单，对于并发操作使用 CAS 进行控制。\n\n\n# 获取写入锁: scanAndLockForPut\n\n前面我们看到，在往某个 segment 中 put 的时候，首先会调用 node = tryLock() ? null : scanAndLockForPut(key, hash, value)，也就是说先进行一次 tryLock() 快速获取该 segment 的独占锁，如果失败，那么进入到 scanAndLockForPut 这个方法来获取锁。\n\n下面我们来具体分析这个方法中是怎么控制加锁的。\n\nprivate HashEntry<K,V> scanAndLockForPut(K key, int hash, V value) {\n    HashEntry<K,V> first = entryForHash(this, hash);\n    HashEntry<K,V> e = first;\n    HashEntry<K,V> node = null;\n    int retries = -1; // negative while locating node\n\n    // 循环获取锁\n    while (!tryLock()) {\n        HashEntry<K,V> f; // to recheck first below\n        if (retries < 0) {\n            if (e == null) {\n                if (node == null) // speculatively create node\n                    // 进到这里说明数组该位置的链表是空的，没有任何元素\n                    // 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置\n                    node = new HashEntry<K,V>(hash, key, value, null);\n                retries = 0;\n            }\n            else if (key.equals(e.key))\n                retries = 0;\n            else\n                // 顺着链表往下走\n                e = e.next;\n        }\n        // 重试次数如果超过 MAX_SCAN_RETRIES(单核1多核64)，那么不抢了，进入到阻塞队列等待锁\n        //    lock() 是阻塞方法，直到获取锁后返回\n        else if (++retries > MAX_SCAN_RETRIES) {\n            lock();\n            break;\n        }\n        else if ((retries & 1) == 0 &&\n                 // 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头\n                 //     所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法\n                 (f = entryForHash(this, hash)) != first) {\n            e = first = f; // re-traverse if entry changed\n            retries = -1;\n        }\n    }\n    return node;\n}\n\n\n这个方法有两个出口，一个是 tryLock() 成功了，循环终止，另一个就是重试次数超过了 MAX_SCAN_RETRIES，进到 lock() 方法，此方法会阻塞等待，直到成功拿到独占锁。\n\n这个方法就是看似复杂，但是其实就是做了一件事，那就是获取该 segment 的独占锁，如果需要的话顺便实例化了一下 node。\n\n\n# 扩容: rehash\n\n重复一下，segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry<K,V>[] 进行扩容，扩容后，容量为原来的 2 倍。\n\n首先，我们要回顾一下触发扩容的地方，put 的时候，如果判断该值的插入会导致该 segment 的元素个数超过阈值，那么先进行扩容，再插值，读者这个时候可以回去 put 方法看一眼。\n\n该方法不需要考虑并发，因为到这里的时候，是持有该 segment 的独占锁的。\n\n// 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。\nprivate void rehash(HashEntry<K,V> node) {\n    HashEntry<K,V>[] oldTable = table;\n    int oldCapacity = oldTable.length;\n    // 2 倍\n    int newCapacity = oldCapacity << 1;\n    threshold = (int)(newCapacity * loadFactor);\n    // 创建新数组\n    HashEntry<K,V>[] newTable =\n        (HashEntry<K,V>[]) new HashEntry[newCapacity];\n    // 新的掩码，如从 16 扩容到 32，那么 sizeMask 为 31，对应二进制 ‘000...00011111’\n    int sizeMask = newCapacity - 1;\n\n    // 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置\n    for (int i = 0; i < oldCapacity ; i++) {\n        // e 是链表的第一个元素\n        HashEntry<K,V> e = oldTable[i];\n        if (e != null) {\n            HashEntry<K,V> next = e.next;\n            // 计算应该放置在新数组中的位置，\n            // 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 = 19\n            int idx = e.hash & sizeMask;\n            if (next == null)   // 该位置处只有一个元素，那比较好办\n                newTable[idx] = e;\n            else { // Reuse consecutive sequence at same slot\n                // e 是链表表头\n                HashEntry<K,V> lastRun = e;\n                // idx 是当前链表的头节点 e 的新位置\n                int lastIdx = idx;\n\n                // 下面这个 for 循环会找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的\n                for (HashEntry<K,V> last = next;\n                     last != null;\n                     last = last.next) {\n                    int k = last.hash & sizeMask;\n                    if (k != lastIdx) {\n                        lastIdx = k;\n                        lastRun = last;\n                    }\n                }\n                // 将 lastRun 及其之后的所有节点组成的这个链表放到 lastIdx 这个位置\n                newTable[lastIdx] = lastRun;\n                // 下面的操作是处理 lastRun 之前的节点，\n                //    这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中\n                for (HashEntry<K,V> p = e; p != lastRun; p = p.next) {\n                    V v = p.value;\n                    int h = p.hash;\n                    int k = h & sizeMask;\n                    HashEntry<K,V> n = newTable[k];\n                    newTable[k] = new HashEntry<K,V>(h, p.key, v, n);\n                }\n            }\n        }\n    }\n    // 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部\n    int nodeIndex = node.hash & sizeMask; // add the new node\n    node.setNext(newTable[nodeIndex]);\n    newTable[nodeIndex] = node;\n    table = newTable;\n}\n\n\n这里的扩容比之前的 HashMap 要复杂一些，代码难懂一点。上面有两个挨着的 for 循环，第一个 for 有什么用呢?\n\n仔细一看发现，如果没有第一个 for 循环，也是可以工作的，但是，这个 for 循环下来，如果 lastRun 的后面还有比较多的节点，那么这次就是值得的。因为我们只需要克隆 lastRun 前面的节点，后面的一串节点跟着 lastRun 走就是了，不需要做任何操作。\n\n我觉得 Doug Lea 的这个想法也是挺有意思的，不过比较坏的情况就是每次 lastRun 都是链表的最后一个元素或者很靠后的元素，那么这次遍历就有点浪费了。不过 Doug Lea 也说了，根据统计，如果使用默认的阈值，大约只有 1/6 的节点需要克隆。\n\n\n# get 过程分析\n\n相对于 put 来说，get 就很简单了。\n\n * 计算 hash 值，找到 segment 数组中的具体位置，或我们前面用的“槽”\n * 槽中也是一个数组，根据 hash 找到数组中具体的位置\n * 到这里是链表了，顺着链表进行查找即可\n\npublic V get(Object key) {\n    Segment<K,V> s; // manually integrate access methods to reduce overhead\n    HashEntry<K,V>[] tab;\n    // 1. hash 值\n    int h = hash(key);\n    long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE;\n    // 2. 根据 hash 找到对应的 segment\n    if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) != null &&\n        (tab = s.table) != null) {\n        // 3. 找到segment 内部数组相应位置的链表，遍历\n        for (HashEntry<K,V> e = (HashEntry<K,V>) UNSAFE.getObjectVolatile\n                 (tab, ((long)(((tab.length - 1) & h)) << TSHIFT) + TBASE);\n             e != null; e = e.next) {\n            K k;\n            if ((k = e.key) == key || (e.hash == h && key.equals(k)))\n                return e.value;\n        }\n    }\n    return null;\n}\n\n\n\n# 并发问题分析\n\n现在我们已经说完了 put 过程和 get 过程，我们可以看到 get 过程中是没有加锁的，那自然我们就需要去考虑并发问题。\n\n添加节点的操作 put 和删除节点的操作 remove 都是要加 segment 上的独占锁的，所以它们之间自然不会有问题，我们需要考虑的问题就是 get 的时候在同一个 segment 中发生了 put 或 remove 操作。\n\n * put 操作的线程安全性。\n   * 初始化槽，这个我们之前就说过了，使用了 CAS 来初始化 Segment 中的数组。\n   * 添加节点到链表的操作是插入到表头的，所以，如果这个时候 get 操作在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题就是 get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个依赖于 setEntryAt 方法中使用的 UNSAFE.putOrderedObject。\n   * 扩容。扩容是新创建了数组，然后进行迁移数据，最后面将 newTable 设置给属性 table。所以，如果 get 操作此时也在进行，那么也没关系，如果 get 先行，那么就是在旧的 table 上做查询操作；而 put 先行，那么 put 操作的可见性保证就是 table 使用了 volatile 关键字。\n * remove 操作的线程安全性。\n   * remove 操作我们没有分析源码，所以这里说的读者感兴趣的话还是需要到源码中去求实一下的。\n   * get 操作需要遍历链表，但是 remove 操作会"破坏"链表。\n   * 如果 remove 破坏的节点 get 操作已经过去了，那么这里不存在任何问题。\n   * 如果 remove 先破坏了一个节点，分两种情况考虑。 1、如果此节点是头节点，那么需要将头节点的 next 设置为数组该位置的元素，table 虽然使用了 volatile 修饰，但是 volatile 并不能提供数组内部操作的可见性保证，所以源码中使用了 UNSAFE 来操作数组，请看方法 setEntryAt。2、如果要删除的节点不是头节点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是 next 属性是 volatile 的。\n\n\n# ConcurrentHashMap - JDK 1.8\n\n在JDK1.7之前，ConcurrentHashMap是通过分段锁机制来实现的，所以其最大并发度受Segment的个数限制。因此，在JDK1.8中，ConcurrentHashMap的实现原理摒弃了这种设计，而是选择了与HashMap类似的数组+链表+红黑树的方式实现，而加锁则采用CAS和synchronized实现。\n\n\n# 数据结构\n\n\n\n结构上和 Java8 的 HashMap 基本上一样，不过它要保证线程安全性，所以在源码上确实要复杂一些。\n\n\n# 初始化\n\n// 这构造函数里，什么都不干\npublic ConcurrentHashMap() {\n}\npublic ConcurrentHashMap(int initialCapacity) {\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException();\n    int cap = ((initialCapacity >= (MAXIMUM_CAPACITY >>> 1)) ?\n               MAXIMUM_CAPACITY :\n               tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1));\n    this.sizeCtl = cap;\n}\n\n\n这个初始化方法有点意思，通过提供初始容量，计算了 sizeCtl，sizeCtl = 【 (1.5 * initialCapacity + 1)，然后向上取最近的 2 的 n 次方】。如 initialCapacity 为 10，那么得到 sizeCtl 为 16，如果 initialCapacity 为 11，得到 sizeCtl 为 32。\n\nsizeCtl 这个属性使用的场景很多，不过只要跟着文章的思路来，就不会被它搞晕了。\n\n\n# put 过程分析\n\n仔细地一行一行代码看下去:\n\npublic V put(K key, V value) {\n    return putVal(key, value, false);\n}\nfinal V putVal(K key, V value, boolean onlyIfAbsent) {\n    if (key == null || value == null) throw new NullPointerException();\n    // 得到 hash 值\n    int hash = spread(key.hashCode());\n    // 用于记录相应链表的长度\n    int binCount = 0;\n    for (Node<K,V>[] tab = table;;) {\n        Node<K,V> f; int n, i, fh;\n        // 如果数组"空"，进行数组初始化\n        if (tab == null || (n = tab.length) == 0)\n            // 初始化数组，后面会详细介绍\n            tab = initTable();\n\n        // 找该 hash 值对应的数组下标，得到第一个节点 f\n        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n            // 如果数组该位置为空，\n            //    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了\n            //          如果 CAS 失败，那就是有并发操作，进到下一个循环就好了\n            if (casTabAt(tab, i, null,\n                         new Node<K,V>(hash, key, value, null)))\n                break;                   // no lock when adding to empty bin\n        }\n        // hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容\n        else if ((fh = f.hash) == MOVED)\n            // 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了\n            tab = helpTransfer(tab, f);\n\n        else { // 到这里就是说，f 是该位置的头节点，而且不为空\n\n            V oldVal = null;\n            // 获取数组该位置的头节点的监视器锁\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n                    if (fh >= 0) { // 头节点的 hash 值大于 0，说明是链表\n                        // 用于累加，记录链表的长度\n                        binCount = 1;\n                        // 遍历链表\n                        for (Node<K,V> e = f;; ++binCount) {\n                            K ek;\n                            // 如果发现了"相等"的 key，判断是否要进行值覆盖，然后也就可以 break 了\n                            if (e.hash == hash &&\n                                ((ek = e.key) == key ||\n                                 (ek != null && key.equals(ek)))) {\n                                oldVal = e.val;\n                                if (!onlyIfAbsent)\n                                    e.val = value;\n                                break;\n                            }\n                            // 到了链表的最末端，将这个新值放到链表的最后面\n                            Node<K,V> pred = e;\n                            if ((e = e.next) == null) {\n                                pred.next = new Node<K,V>(hash, key,\n                                                          value, null);\n                                break;\n                            }\n                        }\n                    }\n                    else if (f instanceof TreeBin) { // 红黑树\n                        Node<K,V> p;\n                        binCount = 2;\n                        // 调用红黑树的插值方法插入新节点\n                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                       value)) != null) {\n                            oldVal = p.val;\n                            if (!onlyIfAbsent)\n                                p.val = value;\n                        }\n                    }\n                }\n            }\n\n            if (binCount != 0) {\n                // 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8\n                if (binCount >= TREEIFY_THRESHOLD)\n                    // 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，\n                    // 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树\n                    //    具体源码我们就不看了，扩容部分后面说\n                    treeifyBin(tab, i);\n                if (oldVal != null)\n                    return oldVal;\n                break;\n            }\n        }\n    }\n    // \n    addCount(1L, binCount);\n    return null;\n}\n\n\n\n# 初始化数组: initTable\n\n这个比较简单，主要就是初始化一个合适大小的数组，然后会设置 sizeCtl。\n\n初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。\n\nprivate final Node<K,V>[] initTable() {\n    Node<K,V>[] tab; int sc;\n    while ((tab = table) == null || tab.length == 0) {\n        // 初始化的"功劳"被其他线程"抢去"了\n        if ((sc = sizeCtl) < 0)\n            Thread.yield(); // lost initialization race; just spin\n        // CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁\n        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n            try {\n                if ((tab = table) == null || tab.length == 0) {\n                    // DEFAULT_CAPACITY 默认初始容量是 16\n                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY;\n                    // 初始化数组，长度为 16 或初始化时提供的长度\n                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                    // 将这个数组赋值给 table，table 是 volatile 的\n                    table = tab = nt;\n                    // 如果 n 为 16 的话，那么这里 sc = 12\n                    // 其实就是 0.75 * n\n                    sc = n - (n >>> 2);\n                }\n            } finally {\n                // 设置 sizeCtl 为 sc，我们就当是 12 吧\n                sizeCtl = sc;\n            }\n            break;\n        }\n    }\n    return tab;\n}\n\n\n\n# 链表转红黑树: treeifyBin\n\n前面我们在 put 源码分析也说过，treeifyBin 不一定就会进行红黑树转换，也可能是仅仅做数组扩容。我们还是进行源码分析吧。\n\nprivate final void treeifyBin(Node<K,V>[] tab, int index) {\n    Node<K,V> b; int n, sc;\n    if (tab != null) {\n        // MIN_TREEIFY_CAPACITY 为 64\n        // 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容\n        if ((n = tab.length) < MIN_TREEIFY_CAPACITY)\n            // 后面我们再详细分析这个方法\n            tryPresize(n << 1);\n        // b 是头节点\n        else if ((b = tabAt(tab, index)) != null && b.hash >= 0) {\n            // 加锁\n            synchronized (b) {\n\n                if (tabAt(tab, index) == b) {\n                    // 下面就是遍历链表，建立一颗红黑树\n                    TreeNode<K,V> hd = null, tl = null;\n                    for (Node<K,V> e = b; e != null; e = e.next) {\n                        TreeNode<K,V> p =\n                            new TreeNode<K,V>(e.hash, e.key, e.val,\n                                              null, null);\n                        if ((p.prev = tl) == null)\n                            hd = p;\n                        else\n                            tl.next = p;\n                        tl = p;\n                    }\n                    // 将红黑树设置到数组相应位置中\n                    setTabAt(tab, index, new TreeBin<K,V>(hd));\n                }\n            }\n        }\n    }\n}\n\n\n\n# 扩容: tryPresize\n\n如果说 Java8 ConcurrentHashMap 的源码不简单，那么说的就是扩容操作和迁移操作。\n\n这个方法要完完全全看懂还需要看之后的 transfer 方法，读者应该提前知道这点。\n\n这里的扩容也是做翻倍扩容的，扩容后数组容量为原来的 2 倍。\n\n// 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了\nprivate final void tryPresize(int size) {\n    // c: size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。\n    int c = (size >= (MAXIMUM_CAPACITY >>> 1)) ? MAXIMUM_CAPACITY :\n        tableSizeFor(size + (size >>> 1) + 1);\n    int sc;\n    while ((sc = sizeCtl) >= 0) {\n        Node<K,V>[] tab = table; int n;\n\n        // 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码\n        if (tab == null || (n = tab.length) == 0) {\n            n = (sc > c) ? sc : c;\n            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n                try {\n                    if (table == tab) {\n                        @SuppressWarnings("unchecked")\n                        Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                        table = nt;\n                        sc = n - (n >>> 2); // 0.75 * n\n                    }\n                } finally {\n                    sizeCtl = sc;\n                }\n            }\n        }\n        else if (c <= sc || n >= MAXIMUM_CAPACITY)\n            break;\n        else if (tab == table) {\n            // 我没看懂 rs 的真正含义是什么，不过也关系不大\n            int rs = resizeStamp(n);\n\n            if (sc < 0) {\n                Node<K,V>[] nt;\n                if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||\n                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||\n                    transferIndex <= 0)\n                    break;\n                // 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法\n                //    此时 nextTab 不为 null\n                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))\n                    transfer(tab, nt);\n            }\n            // 1. 将 sizeCtl 设置为 (rs << RESIZE_STAMP_SHIFT) + 2)\n            //     我是没看懂这个值真正的意义是什么? 不过可以计算出来的是，结果是一个比较大的负数\n            //  调用 transfer 方法，此时 nextTab 参数为 null\n            else if (U.compareAndSwapInt(this, SIZECTL, sc,\n                                         (rs << RESIZE_STAMP_SHIFT) + 2))\n                transfer(tab, null);\n        }\n    }\n}\n\n\n这个方法的核心在于 sizeCtl 值的操作，首先将其设置为一个负数，然后执行 transfer(tab, null)，再下一个循环将 sizeCtl 加 1，并执行 transfer(tab, nt)，之后可能是继续 sizeCtl 加 1，并执行 transfer(tab, nt)。\n\n所以，可能的操作就是执行 1 次 transfer(tab, null) + 多次 transfer(tab, nt)，这里怎么结束循环的需要看完 transfer 源码才清楚。\n\n\n# 数据迁移: transfer\n\n下面这个方法有点长，将原来的 tab 数组的元素迁移到新的 nextTab 数组中。\n\n虽然我们之前说的 tryPresize 方法中多次调用 transfer 不涉及多线程，但是这个 transfer 方法可以在其他地方被调用，典型地，我们之前在说 put 方法的时候就说过了，请往上看 put 方法，是不是有个地方调用了 helpTransfer 方法，helpTransfer 方法会调用 transfer 方法的。\n\n此方法支持多线程执行，外围调用此方法的时候，会保证第一个发起数据迁移的线程，nextTab 参数为 null，之后再调用此方法的时候，nextTab 不会为 null。\n\n阅读源码之前，先要理解并发操作的机制。原数组长度为 n，所以我们有 n 个迁移任务，让每个线程每次负责一个小任务是最简单的，每做完一个任务再检测是否有其他没做完的任务，帮助迁移就可以了，而 Doug Lea 使用了一个 stride，简单理解就是步长，每个线程每次负责迁移其中的一部分，如每次迁移 16 个小任务。所以，我们就需要一个全局的调度者来安排哪个线程执行哪几个任务，这个就是属性 transferIndex 的作用。\n\n第一个发起数据迁移的线程会将 transferIndex 指向原数组最后的位置，然后从后往前的 stride 个任务属于第一个线程，然后将 transferIndex 指向新的位置，再往前的 stride 个任务属于第二个线程，依此类推。当然，这里说的第二个线程不是真的一定指代了第二个线程，也可以是同一个线程，这个读者应该能理解吧。其实就是将一个大的迁移任务分为了一个个任务包。\n\nprivate final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) {\n    int n = tab.length, stride;\n\n    // stride 在单核下直接等于 n，多核模式下为 (n>>>3)/NCPU，最小值是 16\n    // stride 可以理解为”步长“，有 n 个位置是需要进行迁移的，\n    //   将这 n 个任务分为多个任务包，每个任务包有 stride 个任务\n    if ((stride = (NCPU > 1) ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE)\n        stride = MIN_TRANSFER_STRIDE; // subdivide range\n\n    // 如果 nextTab 为 null，先进行一次初始化\n    //    前面我们说了，外围会保证第一个发起迁移的线程调用此方法时，参数 nextTab 为 null\n    //       之后参与迁移的线程调用此方法时，nextTab 不会为 null\n    if (nextTab == null) {\n        try {\n            // 容量翻倍\n            Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1];\n            nextTab = nt;\n        } catch (Throwable ex) {      // try to cope with OOME\n            sizeCtl = Integer.MAX_VALUE;\n            return;\n        }\n        // nextTable 是 ConcurrentHashMap 中的属性\n        nextTable = nextTab;\n        // transferIndex 也是 ConcurrentHashMap 的属性，用于控制迁移的位置\n        transferIndex = n;\n    }\n\n    int nextn = nextTab.length;\n\n    // ForwardingNode 翻译过来就是正在被迁移的 Node\n    // 这个构造方法会生成一个Node，key、value 和 next 都为 null，关键是 hash 为 MOVED\n    // 后面我们会看到，原数组中位置 i 处的节点完成迁移工作后，\n    //    就会将位置 i 处设置为这个 ForwardingNode，用来告诉其他线程该位置已经处理过了\n    //    所以它其实相当于是一个标志。\n    ForwardingNode<K,V> fwd = new ForwardingNode<K,V>(nextTab);\n\n\n    // advance 指的是做完了一个位置的迁移工作，可以准备做下一个位置的了\n    boolean advance = true;\n    boolean finishing = false; // to ensure sweep before committing nextTab\n\n    /*\n     * 下面这个 for 循环，最难理解的在前面，而要看懂它们，应该先看懂后面的，然后再倒回来看\n     * \n     */\n\n    // i 是位置索引，bound 是边界，注意是从后往前\n    for (int i = 0, bound = 0;;) {\n        Node<K,V> f; int fh;\n\n        // 下面这个 while 真的是不好理解\n        // advance 为 true 表示可以进行下一个位置的迁移了\n        //   简单理解结局: i 指向了 transferIndex，bound 指向了 transferIndex-stride\n        while (advance) {\n            int nextIndex, nextBound;\n            if (--i >= bound || finishing)\n                advance = false;\n\n            // 将 transferIndex 值赋给 nextIndex\n            // 这里 transferIndex 一旦小于等于 0，说明原数组的所有位置都有相应的线程去处理了\n            else if ((nextIndex = transferIndex) <= 0) {\n                i = -1;\n                advance = false;\n            }\n            else if (U.compareAndSwapInt\n                     (this, TRANSFERINDEX, nextIndex,\n                      nextBound = (nextIndex > stride ?\n                                   nextIndex - stride : 0))) {\n                // 看括号中的代码，nextBound 是这次迁移任务的边界，注意，是从后往前\n                bound = nextBound;\n                i = nextIndex - 1;\n                advance = false;\n            }\n        }\n        if (i < 0 || i >= n || i + n >= nextn) {\n            int sc;\n            if (finishing) {\n                // 所有的迁移操作已经完成\n                nextTable = null;\n                // 将新的 nextTab 赋值给 table 属性，完成迁移\n                table = nextTab;\n                // 重新计算 sizeCtl: n 是原数组长度，所以 sizeCtl 得出的值将是新数组长度的 0.75 倍\n                sizeCtl = (n << 1) - (n >>> 1);\n                return;\n            }\n\n            // 之前我们说过，sizeCtl 在迁移前会设置为 (rs << RESIZE_STAMP_SHIFT) + 2\n            // 然后，每有一个线程参与迁移就会将 sizeCtl 加 1，\n            // 这里使用 CAS 操作对 sizeCtl 进行减 1，代表做完了属于自己的任务\n            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {\n                // 任务结束，方法退出\n                if ((sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT)\n                    return;\n\n                // 到这里，说明 (sc - 2) == resizeStamp(n) << RESIZE_STAMP_SHIFT，\n                // 也就是说，所有的迁移任务都做完了，也就会进入到上面的 if(finishing){} 分支了\n                finishing = advance = true;\n                i = n; // recheck before commit\n            }\n        }\n        // 如果位置 i 处是空的，没有任何节点，那么放入刚刚初始化的 ForwardingNode ”空节点“\n        else if ((f = tabAt(tab, i)) == null)\n            advance = casTabAt(tab, i, null, fwd);\n        // 该位置处是一个 ForwardingNode，代表该位置已经迁移过了\n        else if ((fh = f.hash) == MOVED)\n            advance = true; // already processed\n        else {\n            // 对数组该位置处的结点加锁，开始处理数组该位置处的迁移工作\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n                    Node<K,V> ln, hn;\n                    // 头节点的 hash 大于 0，说明是链表的 Node 节点\n                    if (fh >= 0) {\n                        // 下面这一块和 Java7 中的 ConcurrentHashMap 迁移是差不多的，\n                        // 需要将链表一分为二，\n                        //   找到原链表中的 lastRun，然后 lastRun 及其之后的节点是一起进行迁移的\n                        //   lastRun 之前的节点需要进行克隆，然后分到两个链表中\n                        int runBit = fh & n;\n                        Node<K,V> lastRun = f;\n                        for (Node<K,V> p = f.next; p != null; p = p.next) {\n                            int b = p.hash & n;\n                            if (b != runBit) {\n                                runBit = b;\n                                lastRun = p;\n                            }\n                        }\n                        if (runBit == 0) {\n                            ln = lastRun;\n                            hn = null;\n                        }\n                        else {\n                            hn = lastRun;\n                            ln = null;\n                        }\n                        for (Node<K,V> p = f; p != lastRun; p = p.next) {\n                            int ph = p.hash; K pk = p.key; V pv = p.val;\n                            if ((ph & n) == 0)\n                                ln = new Node<K,V>(ph, pk, pv, ln);\n                            else\n                                hn = new Node<K,V>(ph, pk, pv, hn);\n                        }\n                        // 其中的一个链表放在新数组的位置 i\n                        setTabAt(nextTab, i, ln);\n                        // 另一个链表放在新数组的位置 i+n\n                        setTabAt(nextTab, i + n, hn);\n                        // 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，\n                        //    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了\n                        setTabAt(tab, i, fwd);\n                        // advance 设置为 true，代表该位置已经迁移完毕\n                        advance = true;\n                    }\n                    else if (f instanceof TreeBin) {\n                        // 红黑树的迁移\n                        TreeBin<K,V> t = (TreeBin<K,V>)f;\n                        TreeNode<K,V> lo = null, loTail = null;\n                        TreeNode<K,V> hi = null, hiTail = null;\n                        int lc = 0, hc = 0;\n                        for (Node<K,V> e = t.first; e != null; e = e.next) {\n                            int h = e.hash;\n                            TreeNode<K,V> p = new TreeNode<K,V>\n                                (h, e.key, e.val, null, null);\n                            if ((h & n) == 0) {\n                                if ((p.prev = loTail) == null)\n                                    lo = p;\n                                else\n                                    loTail.next = p;\n                                loTail = p;\n                                ++lc;\n                            }\n                            else {\n                                if ((p.prev = hiTail) == null)\n                                    hi = p;\n                                else\n                                    hiTail.next = p;\n                                hiTail = p;\n                                ++hc;\n                            }\n                        }\n                        // 如果一分为二后，节点数小于等于6，那么将红黑树转换回链表\n                        ln = (lc <= UNTREEIFY_THRESHOLD) ? untreeify(lo) :\n                            (hc != 0) ? new TreeBin<K,V>(lo) : t;\n                        hn = (hc <= UNTREEIFY_THRESHOLD) ? untreeify(hi) :\n                            (lc != 0) ? new TreeBin<K,V>(hi) : t;\n\n                        // 将 ln 放置在新数组的位置 i\n                        setTabAt(nextTab, i, ln);\n                        // 将 hn 放置在新数组的位置 i+n\n                        setTabAt(nextTab, i + n, hn);\n                        // 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，\n                        //    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了\n                        setTabAt(tab, i, fwd);\n                        // advance 设置为 true，代表该位置已经迁移完毕\n                        advance = true;\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n说到底，transfer 这个方法并没有实现所有的迁移任务，每次调用这个方法只实现了 transferIndex 往前 stride 个位置的迁移工作，其他的需要由外围来控制。\n\n这个时候，再回去仔细看 tryPresize 方法可能就会更加清晰一些了。\n\n\n# get 过程分析\n\nget 方法从来都是最简单的，这里也不例外:\n\n * 计算 hash 值\n * 根据 hash 值找到数组对应位置: (n - 1) & h\n * 根据该位置处结点性质进行相应查找\n   * 如果该位置为 null，那么直接返回 null 就可以了\n   * 如果该位置处的节点刚好就是我们需要的，返回该节点的值即可\n   * 如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，后面我们再介绍 find 方法\n   * 如果以上 3 条都不满足，那就是链表，进行遍历比对即可\n\npublic V get(Object key) {\n    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;\n    int h = spread(key.hashCode());\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (e = tabAt(tab, (n - 1) & h)) != null) {\n        // 判断头节点是否就是我们需要的节点\n        if ((eh = e.hash) == h) {\n            if ((ek = e.key) == key || (ek != null && key.equals(ek)))\n                return e.val;\n        }\n        // 如果头节点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树\n        else if (eh < 0)\n            // 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)\n            return (p = e.find(h, key)) != null ? p.val : null;\n\n        // 遍历链表\n        while ((e = e.next) != null) {\n            if (e.hash == h &&\n                ((ek = e.key) == key || (ek != null && key.equals(ek))))\n                return e.val;\n        }\n    }\n    return null;\n}\n\n\n简单说一句，此方法的大部分内容都很简单，只有正好碰到扩容的情况，ForwardingNode.find(int h, Object k) 稍微复杂一些，不过在了解了数据迁移的过程后，这个也就不难了，所以限于篇幅这里也不展开说了。\n\n\n# 对比总结\n\n * HashTable : 使用了synchronized关键字对put等操作进行加锁;\n * ConcurrentHashMap JDK1.7: 使用分段锁机制实现;\n * ConcurrentHashMap JDK1.8: 则使用数组+链表+红黑树数据结构和CAS原子操作实现;\n\n\n# 参考文章\n\n * https://blog.csdn.net/defonds/article/details/44021605#t7\n * http://tutorials.jenkov.com/java-concurrency/index.html\n * https://juejin.im/post/5aeeaba8f265da0b9d781d16\n * https://www.javadoop.com/post/hashmap#Java7%20ConcurrentHashMap\n * https://blog.csdn.net/Bill_Xiang_/article/details/81122044\n * https://www.cnblogs.com/leesf456/p/5453341.html\n * https://www.cnblogs.com/huaizuo/archive/2016/04/20/5413069.html\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-ConcurrentHashMap.html',normalizedContent:'# juc集合: concurrenthashmap详解\n\n> jdk1.7之前的concurrenthashmap使用分段锁机制实现，jdk1.8则使用数组+链表+红黑树数据结构和cas原子操作实现concurrenthashmap；本文将分别介绍这两种方式的实现方案及其区别。\n\n * juc集合: concurrenthashmap详解\n   * 带着bat大厂的面试问题去理解\n   * 为什么hashtable慢\n   * concurrenthashmap - jdk 1.7\n     * 数据结构\n     * 初始化\n     * put 过程分析\n     * 初始化槽: ensuresegment\n     * 获取写入锁: scanandlockforput\n     * 扩容: rehash\n     * get 过程分析\n     * 并发问题分析\n   * concurrenthashmap - jdk 1.8\n     * 数据结构\n     * 初始化\n     * put 过程分析\n     * 初始化数组: inittable\n     * 链表转红黑树: treeifybin\n     * 扩容: trypresize\n     * 数据迁移: transfer\n     * get 过程分析\n   * 对比总结\n   * 参考文章\n\n\n# 带着bat大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 为什么hashtable慢? 它的并发度是什么? 那么concurrenthashmap并发度是什么?\n * concurrenthashmap在jdk1.7和jdk1.8中实现有什么差别? jdk1.8解決了jdk1.7中什么问题\n * concurrenthashmap jdk1.7实现的原理是什么? 分段锁机制\n * concurrenthashmap jdk1.8实现的原理是什么? 数组+链表+红黑树，cas\n * concurrenthashmap jdk1.7中segment数(concurrencylevel)默认值是多少? 为何一旦初始化就不可再扩容?\n * concurrenthashmap jdk1.7说说其put的机制?\n * concurrenthashmap jdk1.7是如何扩容的? rehash(注：segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 hashentry<k,v>[] 进行扩容)\n * concurrenthashmap jdk1.8是如何扩容的? trypresize\n * concurrenthashmap jdk1.8链表转红黑树的时机是什么? 临界值为什么是8?\n * concurrenthashmap jdk1.8是如何进行数据迁移的? transfer\n\n\n# 为什么hashtable慢\n\nhashtable之所以效率低下主要是因为其实现使用了synchronized关键字对put等操作进行加锁，而synchronized关键字加锁是对整个对象进行加锁，也就是说在进行put等修改hash表的操作时，锁住了整个hash表，从而使得其表现的效率低下。\n\n\n# concurrenthashmap - jdk 1.7\n\n在jdk1.5~1.7版本，java使用了分段锁机制实现concurrenthashmap.\n\n简而言之，concurrenthashmap在对象中保存了一个segment数组，即将整个hash表划分为多个分段；而每个segment元素，即每个分段则类似于一个hashtable；这样，在执行put操作时首先根据hash算法定位到元素属于哪个segment，然后对该segment加锁即可。因此，concurrenthashmap在多线程并发编程中可是实现多线程put操作。接下来分析jdk1.7版本中concurrenthashmap的实现原理。\n\n\n# 数据结构\n\n整个 concurrenthashmap 由一个个 segment 组成，segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个 segment。\n\n简单理解就是，concurrenthashmap 是一个 segment 数组，segment 通过继承 reentrantlock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 segment 是线程安全的，也就实现了全局的线程安全。\n\n\n\nconcurrencylevel: 并行级别、并发数、segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 concurrenthashmap 有 16 个 segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。\n\n再具体到每个 segment 内部，其实每个 segment 很像之前介绍的 hashmap，不过它要保证线程安全，所以处理起来要麻烦些。\n\n\n# 初始化\n\n * initialcapacity: 初始容量，这个值指的是整个 concurrenthashmap 的初始容量，实际操作的时候需要平均分给每个 segment。\n\n * loadfactor: 负载因子，之前我们说了，segment 数组不可以扩容，所以这个负载因子是给每个 segment 内部使用的。\n\npublic concurrenthashmap(int initialcapacity,\n                         float loadfactor, int concurrencylevel) {\n    if (!(loadfactor > 0) || initialcapacity < 0 || concurrencylevel <= 0)\n        throw new illegalargumentexception();\n    if (concurrencylevel > max_segments)\n        concurrencylevel = max_segments;\n    // find power-of-two sizes best matching arguments\n    int sshift = 0;\n    int ssize = 1;\n    // 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方\n    while (ssize < concurrencylevel) {\n        ++sshift;\n        ssize <<= 1;\n    }\n    // 我们这里先不要那么烧脑，用默认值，concurrencylevel 为 16，sshift 为 4\n    // 那么计算出 segmentshift 为 28，segmentmask 为 15，后面会用到这两个值\n    this.segmentshift = 32 - sshift;\n    this.segmentmask = ssize - 1;\n\n    if (initialcapacity > maximum_capacity)\n        initialcapacity = maximum_capacity;\n\n    // initialcapacity 是设置整个 map 初始的大小，\n    // 这里根据 initialcapacity 计算 segment 数组中每个位置可以分到的大小\n    // 如 initialcapacity 为 64，那么每个 segment 或称之为"槽"可以分到 4 个\n    int c = initialcapacity / ssize;\n    if (c * ssize < initialcapacity)\n        ++c;\n    // 默认 min_segment_table_capacity 是 2，这个值也是有讲究的，因为这样的话，对于具体的槽上，\n    // 插入一个元素不至于扩容，插入第二个的时候才会扩容\n    int cap = min_segment_table_capacity; \n    while (cap < c)\n        cap <<= 1;\n\n    // 创建 segment 数组，\n    // 并创建数组的第一个元素 segment[0]\n    segment<k,v> s0 =\n        new segment<k,v>(loadfactor, (int)(cap * loadfactor),\n                         (hashentry<k,v>[])new hashentry[cap]);\n    segment<k,v>[] ss = (segment<k,v>[])new segment[ssize];\n    // 往数组写入 segment[0]\n    unsafe.putorderedobject(ss, sbase, s0); // ordered write of segments[0]\n    this.segments = ss;\n}\n\n\n初始化完成，我们得到了一个 segment 数组。\n\n我们就当是用 new concurrenthashmap() 无参构造函数进行初始化的，那么初始化完成后:\n\n * segment 数组长度为 16，不可以扩容\n * segment[i] 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容\n * 这里初始化了 segment[0]，其他位置还是 null，至于为什么要初始化 segment[0]，后面的代码会介绍\n * 当前 segmentshift 的值为 32 - 4 = 28，segmentmask 为 16 - 1 = 15，姑且把它们简单翻译为移位数和掩码，这两个值马上就会用到\n\n\n# put 过程分析\n\n我们先看 put 的主流程，对于其中的一些关键细节操作，后面会进行详细介绍。\n\npublic v put(k key, v value) {\n    segment<k,v> s;\n    if (value == null)\n        throw new nullpointerexception();\n    // 1. 计算 key 的 hash 值\n    int hash = hash(key);\n    // 2. 根据 hash 值找到 segment 数组中的位置 j\n    //    hash 是 32 位，无符号右移 segmentshift(28) 位，剩下高 4 位，\n    //    然后和 segmentmask(15) 做一次与操作，也就是说 j 是 hash 值的高 4 位，也就是槽的数组下标\n    int j = (hash >>> segmentshift) & segmentmask;\n    // 刚刚说了，初始化的时候初始化了 segment[0]，但是其他位置还是 null，\n    // ensuresegment(j) 对 segment[j] 进行初始化\n    if ((s = (segment<k,v>)unsafe.getobject          // nonvolatile; recheck\n         (segments, (j << sshift) + sbase)) == null) //  in ensuresegment\n        s = ensuresegment(j);\n    // 3. 插入新值到 槽 s 中\n    return s.put(key, hash, value, false);\n}\n\n\n第一层皮很简单，根据 hash 值很快就能找到相应的 segment，之后就是 segment 内部的 put 操作了。\n\nsegment 内部是由 数组+链表 组成的。\n\nfinal v put(k key, int hash, v value, boolean onlyifabsent) {\n    // 在往该 segment 写入前，需要先获取该 segment 的独占锁\n    //    先看主流程，后面还会具体介绍这部分内容\n    hashentry<k,v> node = trylock() ? null :\n        scanandlockforput(key, hash, value);\n    v oldvalue;\n    try {\n        // 这个是 segment 内部的数组\n        hashentry<k,v>[] tab = table;\n        // 再利用 hash 值，求应该放置的数组下标\n        int index = (tab.length - 1) & hash;\n        // first 是数组该位置处的链表的表头\n        hashentry<k,v> first = entryat(tab, index);\n\n        // 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况\n        for (hashentry<k,v> e = first;;) {\n            if (e != null) {\n                k k;\n                if ((k = e.key) == key ||\n                    (e.hash == hash && key.equals(k))) {\n                    oldvalue = e.value;\n                    if (!onlyifabsent) {\n                        // 覆盖旧值\n                        e.value = value;\n                        ++modcount;\n                    }\n                    break;\n                }\n                // 继续顺着链表走\n                e = e.next;\n            }\n            else {\n                // node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。\n                // 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。\n                if (node != null)\n                    node.setnext(first);\n                else\n                    node = new hashentry<k,v>(hash, key, value, first);\n\n                int c = count + 1;\n                // 如果超过了该 segment 的阈值，这个 segment 需要扩容\n                if (c > threshold && tab.length < maximum_capacity)\n                    rehash(node); // 扩容后面也会具体分析\n                else\n                    // 没有达到阈值，将 node 放到数组 tab 的 index 位置，\n                    // 其实就是将新的节点设置成原链表的表头\n                    setentryat(tab, index, node);\n                ++modcount;\n                count = c;\n                oldvalue = null;\n                break;\n            }\n        }\n    } finally {\n        // 解锁\n        unlock();\n    }\n    return oldvalue;\n}\n\n\n整体流程还是比较简单的，由于有独占锁的保护，所以 segment 内部的操作并不复杂。至于这里面的并发问题，我们稍后再进行介绍。\n\n到这里 put 操作就结束了，接下来，我们说一说其中几步关键的操作。\n\n\n# 初始化槽: ensuresegment\n\nconcurrenthashmap 初始化的时候会初始化第一个槽 segment[0]，对于其他槽来说，在插入第一个值的时候进行初始化。\n\n这里需要考虑并发，因为很可能会有多个线程同时进来初始化同一个槽 segment[k]，不过只要有一个成功了就可以。\n\nprivate segment<k,v> ensuresegment(int k) {\n    final segment<k,v>[] ss = this.segments;\n    long u = (k << sshift) + sbase; // raw offset\n    segment<k,v> seg;\n    if ((seg = (segment<k,v>)unsafe.getobjectvolatile(ss, u)) == null) {\n        // 这里看到为什么之前要初始化 segment[0] 了，\n        // 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]\n        // 为什么要用“当前”，因为 segment[0] 可能早就扩容过了\n        segment<k,v> proto = ss[0];\n        int cap = proto.table.length;\n        float lf = proto.loadfactor;\n        int threshold = (int)(cap * lf);\n\n        // 初始化 segment[k] 内部的数组\n        hashentry<k,v>[] tab = (hashentry<k,v>[])new hashentry[cap];\n        if ((seg = (segment<k,v>)unsafe.getobjectvolatile(ss, u))\n            == null) { // 再次检查一遍该槽是否被其他线程初始化了。\n\n            segment<k,v> s = new segment<k,v>(lf, threshold, tab);\n            // 使用 while 循环，内部用 cas，当前线程成功设值或其他线程成功设值后，退出\n            while ((seg = (segment<k,v>)unsafe.getobjectvolatile(ss, u))\n                   == null) {\n                if (unsafe.compareandswapobject(ss, u, null, seg = s))\n                    break;\n            }\n        }\n    }\n    return seg;\n}\n\n\n总的来说，ensuresegment(int k) 比较简单，对于并发操作使用 cas 进行控制。\n\n\n# 获取写入锁: scanandlockforput\n\n前面我们看到，在往某个 segment 中 put 的时候，首先会调用 node = trylock() ? null : scanandlockforput(key, hash, value)，也就是说先进行一次 trylock() 快速获取该 segment 的独占锁，如果失败，那么进入到 scanandlockforput 这个方法来获取锁。\n\n下面我们来具体分析这个方法中是怎么控制加锁的。\n\nprivate hashentry<k,v> scanandlockforput(k key, int hash, v value) {\n    hashentry<k,v> first = entryforhash(this, hash);\n    hashentry<k,v> e = first;\n    hashentry<k,v> node = null;\n    int retries = -1; // negative while locating node\n\n    // 循环获取锁\n    while (!trylock()) {\n        hashentry<k,v> f; // to recheck first below\n        if (retries < 0) {\n            if (e == null) {\n                if (node == null) // speculatively create node\n                    // 进到这里说明数组该位置的链表是空的，没有任何元素\n                    // 当然，进到这里的另一个原因是 trylock() 失败，所以该槽存在并发，不一定是该位置\n                    node = new hashentry<k,v>(hash, key, value, null);\n                retries = 0;\n            }\n            else if (key.equals(e.key))\n                retries = 0;\n            else\n                // 顺着链表往下走\n                e = e.next;\n        }\n        // 重试次数如果超过 max_scan_retries(单核1多核64)，那么不抢了，进入到阻塞队列等待锁\n        //    lock() 是阻塞方法，直到获取锁后返回\n        else if (++retries > max_scan_retries) {\n            lock();\n            break;\n        }\n        else if ((retries & 1) == 0 &&\n                 // 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头\n                 //     所以这边的策略是，相当于重新走一遍这个 scanandlockforput 方法\n                 (f = entryforhash(this, hash)) != first) {\n            e = first = f; // re-traverse if entry changed\n            retries = -1;\n        }\n    }\n    return node;\n}\n\n\n这个方法有两个出口，一个是 trylock() 成功了，循环终止，另一个就是重试次数超过了 max_scan_retries，进到 lock() 方法，此方法会阻塞等待，直到成功拿到独占锁。\n\n这个方法就是看似复杂，但是其实就是做了一件事，那就是获取该 segment 的独占锁，如果需要的话顺便实例化了一下 node。\n\n\n# 扩容: rehash\n\n重复一下，segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 hashentry<k,v>[] 进行扩容，扩容后，容量为原来的 2 倍。\n\n首先，我们要回顾一下触发扩容的地方，put 的时候，如果判断该值的插入会导致该 segment 的元素个数超过阈值，那么先进行扩容，再插值，读者这个时候可以回去 put 方法看一眼。\n\n该方法不需要考虑并发，因为到这里的时候，是持有该 segment 的独占锁的。\n\n// 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。\nprivate void rehash(hashentry<k,v> node) {\n    hashentry<k,v>[] oldtable = table;\n    int oldcapacity = oldtable.length;\n    // 2 倍\n    int newcapacity = oldcapacity << 1;\n    threshold = (int)(newcapacity * loadfactor);\n    // 创建新数组\n    hashentry<k,v>[] newtable =\n        (hashentry<k,v>[]) new hashentry[newcapacity];\n    // 新的掩码，如从 16 扩容到 32，那么 sizemask 为 31，对应二进制 ‘000...00011111’\n    int sizemask = newcapacity - 1;\n\n    // 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldcap 两个位置\n    for (int i = 0; i < oldcapacity ; i++) {\n        // e 是链表的第一个元素\n        hashentry<k,v> e = oldtable[i];\n        if (e != null) {\n            hashentry<k,v> next = e.next;\n            // 计算应该放置在新数组中的位置，\n            // 假设原数组长度为 16，e 在 oldtable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 = 19\n            int idx = e.hash & sizemask;\n            if (next == null)   // 该位置处只有一个元素，那比较好办\n                newtable[idx] = e;\n            else { // reuse consecutive sequence at same slot\n                // e 是链表表头\n                hashentry<k,v> lastrun = e;\n                // idx 是当前链表的头节点 e 的新位置\n                int lastidx = idx;\n\n                // 下面这个 for 循环会找到一个 lastrun 节点，这个节点之后的所有元素是将要放到一起的\n                for (hashentry<k,v> last = next;\n                     last != null;\n                     last = last.next) {\n                    int k = last.hash & sizemask;\n                    if (k != lastidx) {\n                        lastidx = k;\n                        lastrun = last;\n                    }\n                }\n                // 将 lastrun 及其之后的所有节点组成的这个链表放到 lastidx 这个位置\n                newtable[lastidx] = lastrun;\n                // 下面的操作是处理 lastrun 之前的节点，\n                //    这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中\n                for (hashentry<k,v> p = e; p != lastrun; p = p.next) {\n                    v v = p.value;\n                    int h = p.hash;\n                    int k = h & sizemask;\n                    hashentry<k,v> n = newtable[k];\n                    newtable[k] = new hashentry<k,v>(h, p.key, v, n);\n                }\n            }\n        }\n    }\n    // 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部\n    int nodeindex = node.hash & sizemask; // add the new node\n    node.setnext(newtable[nodeindex]);\n    newtable[nodeindex] = node;\n    table = newtable;\n}\n\n\n这里的扩容比之前的 hashmap 要复杂一些，代码难懂一点。上面有两个挨着的 for 循环，第一个 for 有什么用呢?\n\n仔细一看发现，如果没有第一个 for 循环，也是可以工作的，但是，这个 for 循环下来，如果 lastrun 的后面还有比较多的节点，那么这次就是值得的。因为我们只需要克隆 lastrun 前面的节点，后面的一串节点跟着 lastrun 走就是了，不需要做任何操作。\n\n我觉得 doug lea 的这个想法也是挺有意思的，不过比较坏的情况就是每次 lastrun 都是链表的最后一个元素或者很靠后的元素，那么这次遍历就有点浪费了。不过 doug lea 也说了，根据统计，如果使用默认的阈值，大约只有 1/6 的节点需要克隆。\n\n\n# get 过程分析\n\n相对于 put 来说，get 就很简单了。\n\n * 计算 hash 值，找到 segment 数组中的具体位置，或我们前面用的“槽”\n * 槽中也是一个数组，根据 hash 找到数组中具体的位置\n * 到这里是链表了，顺着链表进行查找即可\n\npublic v get(object key) {\n    segment<k,v> s; // manually integrate access methods to reduce overhead\n    hashentry<k,v>[] tab;\n    // 1. hash 值\n    int h = hash(key);\n    long u = (((h >>> segmentshift) & segmentmask) << sshift) + sbase;\n    // 2. 根据 hash 找到对应的 segment\n    if ((s = (segment<k,v>)unsafe.getobjectvolatile(segments, u)) != null &&\n        (tab = s.table) != null) {\n        // 3. 找到segment 内部数组相应位置的链表，遍历\n        for (hashentry<k,v> e = (hashentry<k,v>) unsafe.getobjectvolatile\n                 (tab, ((long)(((tab.length - 1) & h)) << tshift) + tbase);\n             e != null; e = e.next) {\n            k k;\n            if ((k = e.key) == key || (e.hash == h && key.equals(k)))\n                return e.value;\n        }\n    }\n    return null;\n}\n\n\n\n# 并发问题分析\n\n现在我们已经说完了 put 过程和 get 过程，我们可以看到 get 过程中是没有加锁的，那自然我们就需要去考虑并发问题。\n\n添加节点的操作 put 和删除节点的操作 remove 都是要加 segment 上的独占锁的，所以它们之间自然不会有问题，我们需要考虑的问题就是 get 的时候在同一个 segment 中发生了 put 或 remove 操作。\n\n * put 操作的线程安全性。\n   * 初始化槽，这个我们之前就说过了，使用了 cas 来初始化 segment 中的数组。\n   * 添加节点到链表的操作是插入到表头的，所以，如果这个时候 get 操作在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题就是 get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个依赖于 setentryat 方法中使用的 unsafe.putorderedobject。\n   * 扩容。扩容是新创建了数组，然后进行迁移数据，最后面将 newtable 设置给属性 table。所以，如果 get 操作此时也在进行，那么也没关系，如果 get 先行，那么就是在旧的 table 上做查询操作；而 put 先行，那么 put 操作的可见性保证就是 table 使用了 volatile 关键字。\n * remove 操作的线程安全性。\n   * remove 操作我们没有分析源码，所以这里说的读者感兴趣的话还是需要到源码中去求实一下的。\n   * get 操作需要遍历链表，但是 remove 操作会"破坏"链表。\n   * 如果 remove 破坏的节点 get 操作已经过去了，那么这里不存在任何问题。\n   * 如果 remove 先破坏了一个节点，分两种情况考虑。 1、如果此节点是头节点，那么需要将头节点的 next 设置为数组该位置的元素，table 虽然使用了 volatile 修饰，但是 volatile 并不能提供数组内部操作的可见性保证，所以源码中使用了 unsafe 来操作数组，请看方法 setentryat。2、如果要删除的节点不是头节点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是 next 属性是 volatile 的。\n\n\n# concurrenthashmap - jdk 1.8\n\n在jdk1.7之前，concurrenthashmap是通过分段锁机制来实现的，所以其最大并发度受segment的个数限制。因此，在jdk1.8中，concurrenthashmap的实现原理摒弃了这种设计，而是选择了与hashmap类似的数组+链表+红黑树的方式实现，而加锁则采用cas和synchronized实现。\n\n\n# 数据结构\n\n\n\n结构上和 java8 的 hashmap 基本上一样，不过它要保证线程安全性，所以在源码上确实要复杂一些。\n\n\n# 初始化\n\n// 这构造函数里，什么都不干\npublic concurrenthashmap() {\n}\npublic concurrenthashmap(int initialcapacity) {\n    if (initialcapacity < 0)\n        throw new illegalargumentexception();\n    int cap = ((initialcapacity >= (maximum_capacity >>> 1)) ?\n               maximum_capacity :\n               tablesizefor(initialcapacity + (initialcapacity >>> 1) + 1));\n    this.sizectl = cap;\n}\n\n\n这个初始化方法有点意思，通过提供初始容量，计算了 sizectl，sizectl = 【 (1.5 * initialcapacity + 1)，然后向上取最近的 2 的 n 次方】。如 initialcapacity 为 10，那么得到 sizectl 为 16，如果 initialcapacity 为 11，得到 sizectl 为 32。\n\nsizectl 这个属性使用的场景很多，不过只要跟着文章的思路来，就不会被它搞晕了。\n\n\n# put 过程分析\n\n仔细地一行一行代码看下去:\n\npublic v put(k key, v value) {\n    return putval(key, value, false);\n}\nfinal v putval(k key, v value, boolean onlyifabsent) {\n    if (key == null || value == null) throw new nullpointerexception();\n    // 得到 hash 值\n    int hash = spread(key.hashcode());\n    // 用于记录相应链表的长度\n    int bincount = 0;\n    for (node<k,v>[] tab = table;;) {\n        node<k,v> f; int n, i, fh;\n        // 如果数组"空"，进行数组初始化\n        if (tab == null || (n = tab.length) == 0)\n            // 初始化数组，后面会详细介绍\n            tab = inittable();\n\n        // 找该 hash 值对应的数组下标，得到第一个节点 f\n        else if ((f = tabat(tab, i = (n - 1) & hash)) == null) {\n            // 如果数组该位置为空，\n            //    用一次 cas 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了\n            //          如果 cas 失败，那就是有并发操作，进到下一个循环就好了\n            if (castabat(tab, i, null,\n                         new node<k,v>(hash, key, value, null)))\n                break;                   // no lock when adding to empty bin\n        }\n        // hash 居然可以等于 moved，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容\n        else if ((fh = f.hash) == moved)\n            // 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了\n            tab = helptransfer(tab, f);\n\n        else { // 到这里就是说，f 是该位置的头节点，而且不为空\n\n            v oldval = null;\n            // 获取数组该位置的头节点的监视器锁\n            synchronized (f) {\n                if (tabat(tab, i) == f) {\n                    if (fh >= 0) { // 头节点的 hash 值大于 0，说明是链表\n                        // 用于累加，记录链表的长度\n                        bincount = 1;\n                        // 遍历链表\n                        for (node<k,v> e = f;; ++bincount) {\n                            k ek;\n                            // 如果发现了"相等"的 key，判断是否要进行值覆盖，然后也就可以 break 了\n                            if (e.hash == hash &&\n                                ((ek = e.key) == key ||\n                                 (ek != null && key.equals(ek)))) {\n                                oldval = e.val;\n                                if (!onlyifabsent)\n                                    e.val = value;\n                                break;\n                            }\n                            // 到了链表的最末端，将这个新值放到链表的最后面\n                            node<k,v> pred = e;\n                            if ((e = e.next) == null) {\n                                pred.next = new node<k,v>(hash, key,\n                                                          value, null);\n                                break;\n                            }\n                        }\n                    }\n                    else if (f instanceof treebin) { // 红黑树\n                        node<k,v> p;\n                        bincount = 2;\n                        // 调用红黑树的插值方法插入新节点\n                        if ((p = ((treebin<k,v>)f).puttreeval(hash, key,\n                                                       value)) != null) {\n                            oldval = p.val;\n                            if (!onlyifabsent)\n                                p.val = value;\n                        }\n                    }\n                }\n            }\n\n            if (bincount != 0) {\n                // 判断是否要将链表转换为红黑树，临界值和 hashmap 一样，也是 8\n                if (bincount >= treeify_threshold)\n                    // 这个方法和 hashmap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，\n                    // 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树\n                    //    具体源码我们就不看了，扩容部分后面说\n                    treeifybin(tab, i);\n                if (oldval != null)\n                    return oldval;\n                break;\n            }\n        }\n    }\n    // \n    addcount(1l, bincount);\n    return null;\n}\n\n\n\n# 初始化数组: inittable\n\n这个比较简单，主要就是初始化一个合适大小的数组，然后会设置 sizectl。\n\n初始化方法中的并发问题是通过对 sizectl 进行一个 cas 操作来控制的。\n\nprivate final node<k,v>[] inittable() {\n    node<k,v>[] tab; int sc;\n    while ((tab = table) == null || tab.length == 0) {\n        // 初始化的"功劳"被其他线程"抢去"了\n        if ((sc = sizectl) < 0)\n            thread.yield(); // lost initialization race; just spin\n        // cas 一下，将 sizectl 设置为 -1，代表抢到了锁\n        else if (u.compareandswapint(this, sizectl, sc, -1)) {\n            try {\n                if ((tab = table) == null || tab.length == 0) {\n                    // default_capacity 默认初始容量是 16\n                    int n = (sc > 0) ? sc : default_capacity;\n                    // 初始化数组，长度为 16 或初始化时提供的长度\n                    node<k,v>[] nt = (node<k,v>[])new node<?,?>[n];\n                    // 将这个数组赋值给 table，table 是 volatile 的\n                    table = tab = nt;\n                    // 如果 n 为 16 的话，那么这里 sc = 12\n                    // 其实就是 0.75 * n\n                    sc = n - (n >>> 2);\n                }\n            } finally {\n                // 设置 sizectl 为 sc，我们就当是 12 吧\n                sizectl = sc;\n            }\n            break;\n        }\n    }\n    return tab;\n}\n\n\n\n# 链表转红黑树: treeifybin\n\n前面我们在 put 源码分析也说过，treeifybin 不一定就会进行红黑树转换，也可能是仅仅做数组扩容。我们还是进行源码分析吧。\n\nprivate final void treeifybin(node<k,v>[] tab, int index) {\n    node<k,v> b; int n, sc;\n    if (tab != null) {\n        // min_treeify_capacity 为 64\n        // 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容\n        if ((n = tab.length) < min_treeify_capacity)\n            // 后面我们再详细分析这个方法\n            trypresize(n << 1);\n        // b 是头节点\n        else if ((b = tabat(tab, index)) != null && b.hash >= 0) {\n            // 加锁\n            synchronized (b) {\n\n                if (tabat(tab, index) == b) {\n                    // 下面就是遍历链表，建立一颗红黑树\n                    treenode<k,v> hd = null, tl = null;\n                    for (node<k,v> e = b; e != null; e = e.next) {\n                        treenode<k,v> p =\n                            new treenode<k,v>(e.hash, e.key, e.val,\n                                              null, null);\n                        if ((p.prev = tl) == null)\n                            hd = p;\n                        else\n                            tl.next = p;\n                        tl = p;\n                    }\n                    // 将红黑树设置到数组相应位置中\n                    settabat(tab, index, new treebin<k,v>(hd));\n                }\n            }\n        }\n    }\n}\n\n\n\n# 扩容: trypresize\n\n如果说 java8 concurrenthashmap 的源码不简单，那么说的就是扩容操作和迁移操作。\n\n这个方法要完完全全看懂还需要看之后的 transfer 方法，读者应该提前知道这点。\n\n这里的扩容也是做翻倍扩容的，扩容后数组容量为原来的 2 倍。\n\n// 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了\nprivate final void trypresize(int size) {\n    // c: size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。\n    int c = (size >= (maximum_capacity >>> 1)) ? maximum_capacity :\n        tablesizefor(size + (size >>> 1) + 1);\n    int sc;\n    while ((sc = sizectl) >= 0) {\n        node<k,v>[] tab = table; int n;\n\n        // 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码\n        if (tab == null || (n = tab.length) == 0) {\n            n = (sc > c) ? sc : c;\n            if (u.compareandswapint(this, sizectl, sc, -1)) {\n                try {\n                    if (table == tab) {\n                        @suppresswarnings("unchecked")\n                        node<k,v>[] nt = (node<k,v>[])new node<?,?>[n];\n                        table = nt;\n                        sc = n - (n >>> 2); // 0.75 * n\n                    }\n                } finally {\n                    sizectl = sc;\n                }\n            }\n        }\n        else if (c <= sc || n >= maximum_capacity)\n            break;\n        else if (tab == table) {\n            // 我没看懂 rs 的真正含义是什么，不过也关系不大\n            int rs = resizestamp(n);\n\n            if (sc < 0) {\n                node<k,v>[] nt;\n                if ((sc >>> resize_stamp_shift) != rs || sc == rs + 1 ||\n                    sc == rs + max_resizers || (nt = nexttable) == null ||\n                    transferindex <= 0)\n                    break;\n                // 2. 用 cas 将 sizectl 加 1，然后执行 transfer 方法\n                //    此时 nexttab 不为 null\n                if (u.compareandswapint(this, sizectl, sc, sc + 1))\n                    transfer(tab, nt);\n            }\n            // 1. 将 sizectl 设置为 (rs << resize_stamp_shift) + 2)\n            //     我是没看懂这个值真正的意义是什么? 不过可以计算出来的是，结果是一个比较大的负数\n            //  调用 transfer 方法，此时 nexttab 参数为 null\n            else if (u.compareandswapint(this, sizectl, sc,\n                                         (rs << resize_stamp_shift) + 2))\n                transfer(tab, null);\n        }\n    }\n}\n\n\n这个方法的核心在于 sizectl 值的操作，首先将其设置为一个负数，然后执行 transfer(tab, null)，再下一个循环将 sizectl 加 1，并执行 transfer(tab, nt)，之后可能是继续 sizectl 加 1，并执行 transfer(tab, nt)。\n\n所以，可能的操作就是执行 1 次 transfer(tab, null) + 多次 transfer(tab, nt)，这里怎么结束循环的需要看完 transfer 源码才清楚。\n\n\n# 数据迁移: transfer\n\n下面这个方法有点长，将原来的 tab 数组的元素迁移到新的 nexttab 数组中。\n\n虽然我们之前说的 trypresize 方法中多次调用 transfer 不涉及多线程，但是这个 transfer 方法可以在其他地方被调用，典型地，我们之前在说 put 方法的时候就说过了，请往上看 put 方法，是不是有个地方调用了 helptransfer 方法，helptransfer 方法会调用 transfer 方法的。\n\n此方法支持多线程执行，外围调用此方法的时候，会保证第一个发起数据迁移的线程，nexttab 参数为 null，之后再调用此方法的时候，nexttab 不会为 null。\n\n阅读源码之前，先要理解并发操作的机制。原数组长度为 n，所以我们有 n 个迁移任务，让每个线程每次负责一个小任务是最简单的，每做完一个任务再检测是否有其他没做完的任务，帮助迁移就可以了，而 doug lea 使用了一个 stride，简单理解就是步长，每个线程每次负责迁移其中的一部分，如每次迁移 16 个小任务。所以，我们就需要一个全局的调度者来安排哪个线程执行哪几个任务，这个就是属性 transferindex 的作用。\n\n第一个发起数据迁移的线程会将 transferindex 指向原数组最后的位置，然后从后往前的 stride 个任务属于第一个线程，然后将 transferindex 指向新的位置，再往前的 stride 个任务属于第二个线程，依此类推。当然，这里说的第二个线程不是真的一定指代了第二个线程，也可以是同一个线程，这个读者应该能理解吧。其实就是将一个大的迁移任务分为了一个个任务包。\n\nprivate final void transfer(node<k,v>[] tab, node<k,v>[] nexttab) {\n    int n = tab.length, stride;\n\n    // stride 在单核下直接等于 n，多核模式下为 (n>>>3)/ncpu，最小值是 16\n    // stride 可以理解为”步长“，有 n 个位置是需要进行迁移的，\n    //   将这 n 个任务分为多个任务包，每个任务包有 stride 个任务\n    if ((stride = (ncpu > 1) ? (n >>> 3) / ncpu : n) < min_transfer_stride)\n        stride = min_transfer_stride; // subdivide range\n\n    // 如果 nexttab 为 null，先进行一次初始化\n    //    前面我们说了，外围会保证第一个发起迁移的线程调用此方法时，参数 nexttab 为 null\n    //       之后参与迁移的线程调用此方法时，nexttab 不会为 null\n    if (nexttab == null) {\n        try {\n            // 容量翻倍\n            node<k,v>[] nt = (node<k,v>[])new node<?,?>[n << 1];\n            nexttab = nt;\n        } catch (throwable ex) {      // try to cope with oome\n            sizectl = integer.max_value;\n            return;\n        }\n        // nexttable 是 concurrenthashmap 中的属性\n        nexttable = nexttab;\n        // transferindex 也是 concurrenthashmap 的属性，用于控制迁移的位置\n        transferindex = n;\n    }\n\n    int nextn = nexttab.length;\n\n    // forwardingnode 翻译过来就是正在被迁移的 node\n    // 这个构造方法会生成一个node，key、value 和 next 都为 null，关键是 hash 为 moved\n    // 后面我们会看到，原数组中位置 i 处的节点完成迁移工作后，\n    //    就会将位置 i 处设置为这个 forwardingnode，用来告诉其他线程该位置已经处理过了\n    //    所以它其实相当于是一个标志。\n    forwardingnode<k,v> fwd = new forwardingnode<k,v>(nexttab);\n\n\n    // advance 指的是做完了一个位置的迁移工作，可以准备做下一个位置的了\n    boolean advance = true;\n    boolean finishing = false; // to ensure sweep before committing nexttab\n\n    /*\n     * 下面这个 for 循环，最难理解的在前面，而要看懂它们，应该先看懂后面的，然后再倒回来看\n     * \n     */\n\n    // i 是位置索引，bound 是边界，注意是从后往前\n    for (int i = 0, bound = 0;;) {\n        node<k,v> f; int fh;\n\n        // 下面这个 while 真的是不好理解\n        // advance 为 true 表示可以进行下一个位置的迁移了\n        //   简单理解结局: i 指向了 transferindex，bound 指向了 transferindex-stride\n        while (advance) {\n            int nextindex, nextbound;\n            if (--i >= bound || finishing)\n                advance = false;\n\n            // 将 transferindex 值赋给 nextindex\n            // 这里 transferindex 一旦小于等于 0，说明原数组的所有位置都有相应的线程去处理了\n            else if ((nextindex = transferindex) <= 0) {\n                i = -1;\n                advance = false;\n            }\n            else if (u.compareandswapint\n                     (this, transferindex, nextindex,\n                      nextbound = (nextindex > stride ?\n                                   nextindex - stride : 0))) {\n                // 看括号中的代码，nextbound 是这次迁移任务的边界，注意，是从后往前\n                bound = nextbound;\n                i = nextindex - 1;\n                advance = false;\n            }\n        }\n        if (i < 0 || i >= n || i + n >= nextn) {\n            int sc;\n            if (finishing) {\n                // 所有的迁移操作已经完成\n                nexttable = null;\n                // 将新的 nexttab 赋值给 table 属性，完成迁移\n                table = nexttab;\n                // 重新计算 sizectl: n 是原数组长度，所以 sizectl 得出的值将是新数组长度的 0.75 倍\n                sizectl = (n << 1) - (n >>> 1);\n                return;\n            }\n\n            // 之前我们说过，sizectl 在迁移前会设置为 (rs << resize_stamp_shift) + 2\n            // 然后，每有一个线程参与迁移就会将 sizectl 加 1，\n            // 这里使用 cas 操作对 sizectl 进行减 1，代表做完了属于自己的任务\n            if (u.compareandswapint(this, sizectl, sc = sizectl, sc - 1)) {\n                // 任务结束，方法退出\n                if ((sc - 2) != resizestamp(n) << resize_stamp_shift)\n                    return;\n\n                // 到这里，说明 (sc - 2) == resizestamp(n) << resize_stamp_shift，\n                // 也就是说，所有的迁移任务都做完了，也就会进入到上面的 if(finishing){} 分支了\n                finishing = advance = true;\n                i = n; // recheck before commit\n            }\n        }\n        // 如果位置 i 处是空的，没有任何节点，那么放入刚刚初始化的 forwardingnode ”空节点“\n        else if ((f = tabat(tab, i)) == null)\n            advance = castabat(tab, i, null, fwd);\n        // 该位置处是一个 forwardingnode，代表该位置已经迁移过了\n        else if ((fh = f.hash) == moved)\n            advance = true; // already processed\n        else {\n            // 对数组该位置处的结点加锁，开始处理数组该位置处的迁移工作\n            synchronized (f) {\n                if (tabat(tab, i) == f) {\n                    node<k,v> ln, hn;\n                    // 头节点的 hash 大于 0，说明是链表的 node 节点\n                    if (fh >= 0) {\n                        // 下面这一块和 java7 中的 concurrenthashmap 迁移是差不多的，\n                        // 需要将链表一分为二，\n                        //   找到原链表中的 lastrun，然后 lastrun 及其之后的节点是一起进行迁移的\n                        //   lastrun 之前的节点需要进行克隆，然后分到两个链表中\n                        int runbit = fh & n;\n                        node<k,v> lastrun = f;\n                        for (node<k,v> p = f.next; p != null; p = p.next) {\n                            int b = p.hash & n;\n                            if (b != runbit) {\n                                runbit = b;\n                                lastrun = p;\n                            }\n                        }\n                        if (runbit == 0) {\n                            ln = lastrun;\n                            hn = null;\n                        }\n                        else {\n                            hn = lastrun;\n                            ln = null;\n                        }\n                        for (node<k,v> p = f; p != lastrun; p = p.next) {\n                            int ph = p.hash; k pk = p.key; v pv = p.val;\n                            if ((ph & n) == 0)\n                                ln = new node<k,v>(ph, pk, pv, ln);\n                            else\n                                hn = new node<k,v>(ph, pk, pv, hn);\n                        }\n                        // 其中的一个链表放在新数组的位置 i\n                        settabat(nexttab, i, ln);\n                        // 另一个链表放在新数组的位置 i+n\n                        settabat(nexttab, i + n, hn);\n                        // 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，\n                        //    其他线程一旦看到该位置的 hash 值为 moved，就不会进行迁移了\n                        settabat(tab, i, fwd);\n                        // advance 设置为 true，代表该位置已经迁移完毕\n                        advance = true;\n                    }\n                    else if (f instanceof treebin) {\n                        // 红黑树的迁移\n                        treebin<k,v> t = (treebin<k,v>)f;\n                        treenode<k,v> lo = null, lotail = null;\n                        treenode<k,v> hi = null, hitail = null;\n                        int lc = 0, hc = 0;\n                        for (node<k,v> e = t.first; e != null; e = e.next) {\n                            int h = e.hash;\n                            treenode<k,v> p = new treenode<k,v>\n                                (h, e.key, e.val, null, null);\n                            if ((h & n) == 0) {\n                                if ((p.prev = lotail) == null)\n                                    lo = p;\n                                else\n                                    lotail.next = p;\n                                lotail = p;\n                                ++lc;\n                            }\n                            else {\n                                if ((p.prev = hitail) == null)\n                                    hi = p;\n                                else\n                                    hitail.next = p;\n                                hitail = p;\n                                ++hc;\n                            }\n                        }\n                        // 如果一分为二后，节点数小于等于6，那么将红黑树转换回链表\n                        ln = (lc <= untreeify_threshold) ? untreeify(lo) :\n                            (hc != 0) ? new treebin<k,v>(lo) : t;\n                        hn = (hc <= untreeify_threshold) ? untreeify(hi) :\n                            (lc != 0) ? new treebin<k,v>(hi) : t;\n\n                        // 将 ln 放置在新数组的位置 i\n                        settabat(nexttab, i, ln);\n                        // 将 hn 放置在新数组的位置 i+n\n                        settabat(nexttab, i + n, hn);\n                        // 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，\n                        //    其他线程一旦看到该位置的 hash 值为 moved，就不会进行迁移了\n                        settabat(tab, i, fwd);\n                        // advance 设置为 true，代表该位置已经迁移完毕\n                        advance = true;\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n说到底，transfer 这个方法并没有实现所有的迁移任务，每次调用这个方法只实现了 transferindex 往前 stride 个位置的迁移工作，其他的需要由外围来控制。\n\n这个时候，再回去仔细看 trypresize 方法可能就会更加清晰一些了。\n\n\n# get 过程分析\n\nget 方法从来都是最简单的，这里也不例外:\n\n * 计算 hash 值\n * 根据 hash 值找到数组对应位置: (n - 1) & h\n * 根据该位置处结点性质进行相应查找\n   * 如果该位置为 null，那么直接返回 null 就可以了\n   * 如果该位置处的节点刚好就是我们需要的，返回该节点的值即可\n   * 如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，后面我们再介绍 find 方法\n   * 如果以上 3 条都不满足，那就是链表，进行遍历比对即可\n\npublic v get(object key) {\n    node<k,v>[] tab; node<k,v> e, p; int n, eh; k ek;\n    int h = spread(key.hashcode());\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (e = tabat(tab, (n - 1) & h)) != null) {\n        // 判断头节点是否就是我们需要的节点\n        if ((eh = e.hash) == h) {\n            if ((ek = e.key) == key || (ek != null && key.equals(ek)))\n                return e.val;\n        }\n        // 如果头节点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树\n        else if (eh < 0)\n            // 参考 forwardingnode.find(int h, object k) 和 treebin.find(int h, object k)\n            return (p = e.find(h, key)) != null ? p.val : null;\n\n        // 遍历链表\n        while ((e = e.next) != null) {\n            if (e.hash == h &&\n                ((ek = e.key) == key || (ek != null && key.equals(ek))))\n                return e.val;\n        }\n    }\n    return null;\n}\n\n\n简单说一句，此方法的大部分内容都很简单，只有正好碰到扩容的情况，forwardingnode.find(int h, object k) 稍微复杂一些，不过在了解了数据迁移的过程后，这个也就不难了，所以限于篇幅这里也不展开说了。\n\n\n# 对比总结\n\n * hashtable : 使用了synchronized关键字对put等操作进行加锁;\n * concurrenthashmap jdk1.7: 使用分段锁机制实现;\n * concurrenthashmap jdk1.8: 则使用数组+链表+红黑树数据结构和cas原子操作实现;\n\n\n# 参考文章\n\n * https://blog.csdn.net/defonds/article/details/44021605#t7\n * http://tutorials.jenkov.com/java-concurrency/index.html\n * https://juejin.im/post/5aeeaba8f265da0b9d781d16\n * https://www.javadoop.com/post/hashmap#java7%20concurrenthashmap\n * https://blog.csdn.net/bill_xiang_/article/details/81122044\n * https://www.cnblogs.com/leesf456/p/5453341.html\n * https://www.cnblogs.com/huaizuo/archive/2016/04/20/5413069.html\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-concurrenthashmap.html',charsets:{cjk:!0}},{title:"JUC集合: ConcurrentLinkedQueue详解",frontmatter:{},regularPath:"/java/thread/java-thread-x-juc-collection-ConcurrentLinkedQueue.html",relativePath:"java/thread/java-thread-x-juc-collection-ConcurrentLinkedQueue.md",key:"v-2cb56542",path:"/java/thread/java-thread-x-juc-collection-ConcurrentLinkedQueue.html",headers:[{level:2,title:"JUC集合: ConcurrentLinkedQueue详解",slug:"juc集合-concurrentlinkedqueue详解",normalizedTitle:"juc集合: concurrentlinkedqueue详解",charIndex:2},{level:2,title:"带着BAT大厂的面试问题去理解",slug:"带着bat大厂的面试问题去理解",normalizedTitle:"带着bat大厂的面试问题去理解",charIndex:278},{level:2,title:"ConcurrentLinkedQueue数据结构",slug:"concurrentlinkedqueue数据结构",normalizedTitle:"concurrentlinkedqueue数据结构",charIndex:299},{level:2,title:"ConcurrentLinkedQueue源码分析",slug:"concurrentlinkedqueue源码分析",normalizedTitle:"concurrentlinkedqueue源码分析",charIndex:330},{level:3,title:"类的继承关系",slug:"类的继承关系",normalizedTitle:"类的继承关系",charIndex:363},{level:3,title:"类的内部类",slug:"类的内部类",normalizedTitle:"类的内部类",charIndex:377},{level:3,title:"类的属性",slug:"类的属性",normalizedTitle:"类的属性",charIndex:390},{level:3,title:"类的构造函数",slug:"类的构造函数",normalizedTitle:"类的构造函数",charIndex:402},{level:3,title:"核心函数分析",slug:"核心函数分析",normalizedTitle:"核心函数分析",charIndex:416},{level:2,title:"ConcurrentLinkedQueue示例",slug:"concurrentlinkedqueue示例",normalizedTitle:"concurrentlinkedqueue示例",charIndex:495},{level:2,title:"再深入理解",slug:"再深入理解",normalizedTitle:"再深入理解",charIndex:524},{level:3,title:"HOPS(延迟更新的策略)的设计",slug:"hops-延迟更新的策略-的设计",normalizedTitle:"hops(延迟更新的策略)的设计",charIndex:537},{level:3,title:"ConcurrentLinkedQueue适合的场景",slug:"concurrentlinkedqueue适合的场景",normalizedTitle:"concurrentlinkedqueue适合的场景",charIndex:561},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:593}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"JUC集合: ConcurrentLinkedQueue详解 带着BAT大厂的面试问题去理解 ConcurrentLinkedQueue数据结构 ConcurrentLinkedQueue源码分析 类的继承关系 类的内部类 类的属性 类的构造函数 核心函数分析 ConcurrentLinkedQueue示例 再深入理解 HOPS(延迟更新的策略)的设计 ConcurrentLinkedQueue适合的场景 参考文章",content:'# JUC集合: ConcurrentLinkedQueue详解\n\n> ConcurerntLinkedQueue一个基于链接节点的无界线程安全队列。此队列按照 FIFO(先进先出)原则对元素进行排序。队列的头部是队列中时间最长的元素。队列的尾部 是队列中时间最短的元素。新的元素插入到队列的尾部，队列获取操作从队列头部获得元素。当多个线程共享访问一个公共 collection 时，ConcurrentLinkedQueue是一个恰当的选择。此队列不允许使用null元素。\n\n * JUC集合: ConcurrentLinkedQueue详解\n   * 带着BAT大厂的面试问题去理解\n   * ConcurrentLinkedQueue数据结构\n   * ConcurrentLinkedQueue源码分析\n     * 类的继承关系\n     * 类的内部类\n     * 类的属性\n     * 类的构造函数\n     * 核心函数分析\n       * offer函数\n       * poll函数\n       * remove函数\n       * size函数\n   * ConcurrentLinkedQueue示例\n   * 再深入理解\n     * HOPS(延迟更新的策略)的设计\n     * ConcurrentLinkedQueue适合的场景\n   * 参考文章\n\n\n# 带着BAT大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 要想用线程安全的队列有哪些选择? Vector，Collections.synchronizedList(List<T> list), ConcurrentLinkedQueue等\n * ConcurrentLinkedQueue实现的数据结构?\n * ConcurrentLinkedQueue底层原理? 全程无锁(CAS)\n * ConcurrentLinkedQueue的核心方法有哪些? offer()，poll()，peek()，isEmpty()等队列常用方法\n * 说说ConcurrentLinkedQueue的HOPS(延迟更新的策略)的设计?\n * ConcurrentLinkedQueue适合什么样的使用场景?\n\n\n# ConcurrentLinkedQueue数据结构\n\n通过源码分析可知，ConcurrentLinkedQueue的数据结构与LinkedBlockingQueue的数据结构相同，都是使用的链表结构。ConcurrentLinkedQueue的数据结构如下:\n\n\n\n说明: ConcurrentLinkedQueue采用的链表结构，并且包含有一个头节点和一个尾结点。\n\n\n# ConcurrentLinkedQueue源码分析\n\n\n# 类的继承关系\n\npublic class ConcurrentLinkedQueue<E> extends AbstractQueue<E>\n        implements Queue<E>, java.io.Serializable {}\n\n\n说明: ConcurrentLinkedQueue继承了抽象类AbstractQueue，AbstractQueue定义了对队列的基本操作；同时实现了Queue接口，Queue定义了对队列的基本操作，同时，还实现了Serializable接口，表示可以被序列化。\n\n\n# 类的内部类\n\nprivate static class Node<E> {\n    // 元素\n    volatile E item;\n    // next域\n    volatile Node<E> next;\n\n    /**\n        * Constructs a new node.  Uses relaxed write because item can\n        * only be seen after publication via casNext.\n        */\n    // 构造函数\n    Node(E item) {\n        // 设置item的值\n        UNSAFE.putObject(this, itemOffset, item);\n    }\n    // 比较并替换item值\n    boolean casItem(E cmp, E val) {\n        return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val);\n    }\n    \n    void lazySetNext(Node<E> val) {\n        // 设置next域的值，并不会保证修改对其他线程立即可见\n        UNSAFE.putOrderedObject(this, nextOffset, val);\n    }\n    // 比较并替换next域的值\n    boolean casNext(Node<E> cmp, Node<E> val) {\n        return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);\n    }\n\n    // Unsafe mechanics\n    // 反射机制\n    private static final sun.misc.Unsafe UNSAFE;\n    // item域的偏移量\n    private static final long itemOffset;\n    // next域的偏移量\n    private static final long nextOffset;\n\n    static {\n        try {\n            UNSAFE = sun.misc.Unsafe.getUnsafe();\n            Class<?> k = Node.class;\n            itemOffset = UNSAFE.objectFieldOffset\n                (k.getDeclaredField("item"));\n            nextOffset = UNSAFE.objectFieldOffset\n                (k.getDeclaredField("next"));\n        } catch (Exception e) {\n            throw new Error(e);\n        }\n    }\n}\n\n\n说明: Node类表示链表结点，用于存放元素，包含item域和next域，item域表示元素，next域表示下一个结点，其利用反射机制和CAS机制来更新item域和next域，保证原子性。\n\n\n# 类的属性\n\npublic class ConcurrentLinkedQueue<E> extends AbstractQueue<E>\n        implements Queue<E>, java.io.Serializable {\n    // 版本序列号        \n    private static final long serialVersionUID = 196745693267521676L;\n    // 反射机制\n    private static final sun.misc.Unsafe UNSAFE;\n    // head域的偏移量\n    private static final long headOffset;\n    // tail域的偏移量\n    private static final long tailOffset;\n    static {\n        try {\n            UNSAFE = sun.misc.Unsafe.getUnsafe();\n            Class<?> k = ConcurrentLinkedQueue.class;\n            headOffset = UNSAFE.objectFieldOffset\n                (k.getDeclaredField("head"));\n            tailOffset = UNSAFE.objectFieldOffset\n                (k.getDeclaredField("tail"));\n        } catch (Exception e) {\n            throw new Error(e);\n        }\n    }\n    \n    // 头节点\n    private transient volatile Node<E> head;\n    // 尾结点\n    private transient volatile Node<E> tail;\n}\n\n\n说明: 属性中包含了head域和tail域，表示链表的头节点和尾结点，同时，ConcurrentLinkedQueue也使用了反射机制和CAS机制来更新头节点和尾结点，保证原子性。\n\n\n# 类的构造函数\n\n * ConcurrentLinkedQueue()型构造函数\n\npublic ConcurrentLinkedQueue() {\n    // 初始化头节点与尾结点\n    head = tail = new Node<E>(null);\n}\n\n\n说明: 该构造函数用于创建一个最初为空的 ConcurrentLinkedQueue，头节点与尾结点指向同一个结点，该结点的item域为null，next域也为null。\n\n * ConcurrentLinkedQueue(Collection<? extends E>)型构造函数\n\npublic ConcurrentLinkedQueue(Collection<? extends E> c) {\n    Node<E> h = null, t = null;\n    for (E e : c) { // 遍历c集合\n        // 保证元素不为空\n        checkNotNull(e);\n        // 新生一个结点\n        Node<E> newNode = new Node<E>(e);\n        if (h == null) // 头节点为null\n            // 赋值头节点与尾结点\n            h = t = newNode;\n        else {\n            // 直接头节点的next域\n            t.lazySetNext(newNode);\n            // 重新赋值头节点\n            t = newNode;\n        }\n    }\n    if (h == null) // 头节点为null\n        // 新生头节点与尾结点\n        h = t = new Node<E>(null);\n    // 赋值头节点\n    head = h;\n    // 赋值尾结点\n    tail = t;\n}\n\n\n说明: 该构造函数用于创建一个最初包含给定 collection 元素的 ConcurrentLinkedQueue，按照此 collection 迭代器的遍历顺序来添加元素。\n\n\n# 核心函数分析\n\n# offer函数\n\npublic boolean offer(E e) {\n    // 元素不为null\n    checkNotNull(e);\n    // 新生一个结点\n    final Node<E> newNode = new Node<E>(e);\n\n    for (Node<E> t = tail, p = t;;) { // 无限循环\n        // q为p结点的下一个结点\n        Node<E> q = p.next;\n        if (q == null) { // q结点为null\n            // p is last node\n            if (p.casNext(null, newNode)) { // 比较并进行替换p结点的next域\n                // Successful CAS is the linearization point\n                // for e to become an element of this queue,\n                // and for newNode to become "live".\n                if (p != t) // p不等于t结点，不一致    // hop two nodes at a time\n                    // 比较并替换尾结点\n                    casTail(t, newNode);  // Failure is OK.\n                // 返回\n                return true;\n            }\n            // Lost CAS race to another thread; re-read next\n        }\n        else if (p == q) // p结点等于q结点\n            // We have fallen off list.  If tail is unchanged, it\n            // will also be off-list, in which case we need to\n            // jump to head, from which all live nodes are always\n            // reachable.  Else the new tail is a better bet.\n            // 原来的尾结点与现在的尾结点是否相等，若相等，则p赋值为head，否则，赋值为现在的尾结点\n            p = (t != (t = tail)) ? t : head;\n        else\n            // Check for tail updates after two hops.\n            // 重新赋值p结点\n            p = (p != t && t != (t = tail)) ? t : q;\n    }\n}\n\n\n说明: offer函数用于将指定元素插入此队列的尾部。下面模拟offer函数的操作，队列状态的变化(假设单线程添加元素，连续添加10、20两个元素)。\n\n\n\n * 若ConcurrentLinkedQueue的初始状态如上图所示，即队列为空。单线程添加元素，此时，添加元素10，则状态如下所示\n\n\n\n * 如上图所示，添加元素10后，tail没有变化，还是指向之前的结点，继续添加元素20，则状态如下所示\n\n\n\n * 如上图所示，添加元素20后，tail指向了最新添加的结点。\n\n# poll函数\n\npublic E poll() {\n    restartFromHead:\n    for (;;) { // 无限循环\n        for (Node<E> h = head, p = h, q;;) { // 保存头节点\n            // item项\n            E item = p.item;\n\n            if (item != null && p.casItem(item, null)) { // item不为null并且比较并替换item成功\n                // Successful CAS is the linearization point\n                // for item to be removed from this queue.\n                if (p != h) // p不等于h    // hop two nodes at a time\n                    // 更新头节点\n                    updateHead(h, ((q = p.next) != null) ? q : p); \n                // 返回item\n                return item;\n            }\n            else if ((q = p.next) == null) { // q结点为null\n                // 更新头节点\n                updateHead(h, p);\n                return null;\n            }\n            else if (p == q) // p等于q\n                // 继续循环\n                continue restartFromHead;\n            else\n                // p赋值为q\n                p = q;\n        }\n    }\n}\n\n\n说明: 此函数用于获取并移除此队列的头，如果此队列为空，则返回null。下面模拟poll函数的操作，队列状态的变化(假设单线程操作，状态为之前offer10、20后的状态，poll两次)。\n\n\n\n * 队列初始状态如上图所示，在poll操作后，队列的状态如下图所示\n\n\n\n * 如上图可知，poll操作后，head改变了，并且head所指向的结点的item变为了null。再进行一次poll操作，队列的状态如下图所示。\n\n\n\n * 如上图可知，poll操作后，head结点没有变化，只是指示的结点的item域变成了null。\n\n# remove函数\n\npublic boolean remove(Object o) {\n    // 元素为null，返回\n    if (o == null) return false;\n    Node<E> pred = null;\n    for (Node<E> p = first(); p != null; p = succ(p)) { // 获取第一个存活的结点\n        // 第一个存活结点的item值\n        E item = p.item;\n        if (item != null &&\n            o.equals(item) &&\n            p.casItem(item, null)) { // 找到item相等的结点，并且将该结点的item设置为null\n            // p的后继结点\n            Node<E> next = succ(p);\n            if (pred != null && next != null) // pred不为null并且next不为null\n                // 比较并替换next域\n                pred.casNext(p, next);\n            return true;\n        }\n        // pred赋值为p\n        pred = p;\n    }\n    return false;\n}\n\n\n说明: 此函数用于从队列中移除指定元素的单个实例(如果存在)。其中，会调用到first函数和succ函数，first函数的源码如下\n\nNode<E> first() {\n    restartFromHead:\n    for (;;) { // 无限循环，确保成功\n        for (Node<E> h = head, p = h, q;;) {\n            // p结点的item域是否为null\n            boolean hasItem = (p.item != null);\n            if (hasItem || (q = p.next) == null) { // item不为null或者next域为null\n                // 更新头节点\n                updateHead(h, p);\n                // 返回结点\n                return hasItem ? p : null;\n            }\n            else if (p == q) // p等于q\n                // 继续从头节点开始\n                continue restartFromHead;\n            else\n                // p赋值为q\n                p = q;\n        }\n    }\n}\n\n\n说明: first函数用于找到链表中第一个存活的结点。succ函数源码如下\n\nfinal Node<E> succ(Node<E> p) {\n    // p结点的next域\n    Node<E> next = p.next;\n    // 如果next域为自身，则返回头节点，否则，返回next\n    return (p == next) ? head : next;\n}\n\n\n说明: succ用于获取结点的下一个结点。如果结点的next域指向自身，则返回head头节点，否则，返回next结点。下面模拟remove函数的操作，队列状态的变化(假设单线程操作，状态为之前offer10、20后的状态，执行remove(10)、remove(20)操作)。\n\n\n\n * 如上图所示，为ConcurrentLinkedQueue的初始状态，remove(10)后的状态如下图所示\n\n\n\n * 如上图所示，当执行remove(10)后，head指向了head结点之前指向的结点的下一个结点，并且head结点的item域置为null。继续执行remove(20)，状态如下图所示\n\n\n\n * 如上图所示，执行remove(20)后，head与tail指向同一个结点，item域为null。\n\n# size函数\n\npublic int size() {\n    // 计数\n    int count = 0;\n    for (Node<E> p = first(); p != null; p = succ(p)) // 从第一个存活的结点开始往后遍历\n        if (p.item != null) // 结点的item域不为null\n            // Collection.size() spec says to max out\n            if (++count == Integer.MAX_VALUE) // 增加计数，若达到最大值，则跳出循环\n                break;\n    // 返回大小\n    return count;\n}\n\n\n说明: 此函数用于返回ConcurrenLinkedQueue的大小，从第一个存活的结点(first)开始，往后遍历链表，当结点的item域不为null时，增加计数，之后返回大小。\n\n\n# ConcurrentLinkedQueue示例\n\n下面通过一个示例来了解ConcurrentLinkedQueue的使用\n\nimport java.util.concurrent.ConcurrentLinkedQueue;\n\nclass PutThread extends Thread {\n    private ConcurrentLinkedQueue<Integer> clq;\n    public PutThread(ConcurrentLinkedQueue<Integer> clq) {\n        this.clq = clq;\n    }\n    \n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            try {\n                System.out.println("add " + i);\n                clq.add(i);\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\nclass GetThread extends Thread {\n    private ConcurrentLinkedQueue<Integer> clq;\n    public GetThread(ConcurrentLinkedQueue<Integer> clq) {\n        this.clq = clq;\n    }\n    \n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            try {\n                System.out.println("poll " + clq.poll());\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\npublic class ConcurrentLinkedQueueDemo {\n    public static void main(String[] args) {\n        ConcurrentLinkedQueue<Integer> clq = new ConcurrentLinkedQueue<Integer>();\n        PutThread p1 = new PutThread(clq);\n        GetThread g1 = new GetThread(clq);\n        \n        p1.start();\n        g1.start();\n        \n    }\n}\n\n\n运行结果(某一次):\n\nadd 0\npoll null\nadd 1\npoll 0\nadd 2\npoll 1\nadd 3\npoll 2\nadd 4\npoll 3\nadd 5\npoll 4\npoll 5\nadd 6\nadd 7\npoll 6\npoll 7\nadd 8\nadd 9\npoll 8\n\n\n说明: GetThread线程不会因为ConcurrentLinkedQueue队列为空而等待，而是直接返回null，所以当实现队列不空时，等待时，则需要用户自己实现等待逻辑。\n\n\n# 再深入理解\n\n\n# HOPS(延迟更新的策略)的设计\n\n通过上面对offer和poll方法的分析，我们发现tail和head是延迟更新的，两者更新触发时机为：\n\n * tail更新触发时机：当tail指向的节点的下一个节点不为null的时候，会执行定位队列真正的队尾节点的操作，找到队尾节点后完成插入之后才会通过casTail进行tail更新；当tail指向的节点的下一个节点为null的时候，只插入节点不更新tail。\n\n * head更新触发时机：当head指向的节点的item域为null的时候，会执行定位队列真正的队头节点的操作，找到队头节点后完成删除之后才会通过updateHead进行head更新；当head指向的节点的item域不为null的时候，只删除节点不更新head。\n\n并且在更新操作时，源码中会有注释为：hop two nodes at a time。所以这种延迟更新的策略就被叫做HOPS的大概原因是这个(猜的 😃)，从上面更新时的状态图可以看出，head和tail的更新是“跳着的”即中间总是间隔了一个。那么这样设计的意图是什么呢?\n\n如果让tail永远作为队列的队尾节点，实现的代码量会更少，而且逻辑更易懂。但是，这样做有一个缺点，如果大量的入队操作，每次都要执行CAS进行tail的更新，汇总起来对性能也会是大大的损耗。如果能减少CAS更新的操作，无疑可以大大提升入队的操作效率，所以doug lea大师每间隔1次(tail和队尾节点的距离为1)进行才利用CAS更新tail。对head的更新也是同样的道理，虽然，这样设计会多出在循环中定位队尾节点，但总体来说读的操作效率要远远高于写的性能，因此，多出来的在循环中定位尾节点的操作的性能损耗相对而言是很小的。\n\n\n# ConcurrentLinkedQueue适合的场景\n\nConcurrentLinkedQueue通过无锁来做到了更高的并发量，是个高性能的队列，但是使用场景相对不如阻塞队列常见，毕竟取数据也要不停的去循环，不如阻塞的逻辑好设计，但是在并发量特别大的情况下，是个不错的选择，性能上好很多，而且这个队列的设计也是特别费力，尤其的使用的改良算法和对哨兵的处理。整体的思路都是比较严谨的，这个也是使用了无锁造成的，我们自己使用无锁的条件的话，这个队列是个不错的参考。\n\n\n# 参考文章\n\n * 文章主要参考自leesf的https://www.cnblogs.com/leesf456/p/5539142.html，在此基础上做了增改。\n * https://blog.csdn.net/u011521203/article/details/80214968\n * https://blog.csdn.net/u014493323/article/details/81177194\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-ConcurrentLinkedQueue.html',normalizedContent:'# juc集合: concurrentlinkedqueue详解\n\n> concurerntlinkedqueue一个基于链接节点的无界线程安全队列。此队列按照 fifo(先进先出)原则对元素进行排序。队列的头部是队列中时间最长的元素。队列的尾部 是队列中时间最短的元素。新的元素插入到队列的尾部，队列获取操作从队列头部获得元素。当多个线程共享访问一个公共 collection 时，concurrentlinkedqueue是一个恰当的选择。此队列不允许使用null元素。\n\n * juc集合: concurrentlinkedqueue详解\n   * 带着bat大厂的面试问题去理解\n   * concurrentlinkedqueue数据结构\n   * concurrentlinkedqueue源码分析\n     * 类的继承关系\n     * 类的内部类\n     * 类的属性\n     * 类的构造函数\n     * 核心函数分析\n       * offer函数\n       * poll函数\n       * remove函数\n       * size函数\n   * concurrentlinkedqueue示例\n   * 再深入理解\n     * hops(延迟更新的策略)的设计\n     * concurrentlinkedqueue适合的场景\n   * 参考文章\n\n\n# 带着bat大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 要想用线程安全的队列有哪些选择? vector，collections.synchronizedlist(list<t> list), concurrentlinkedqueue等\n * concurrentlinkedqueue实现的数据结构?\n * concurrentlinkedqueue底层原理? 全程无锁(cas)\n * concurrentlinkedqueue的核心方法有哪些? offer()，poll()，peek()，isempty()等队列常用方法\n * 说说concurrentlinkedqueue的hops(延迟更新的策略)的设计?\n * concurrentlinkedqueue适合什么样的使用场景?\n\n\n# concurrentlinkedqueue数据结构\n\n通过源码分析可知，concurrentlinkedqueue的数据结构与linkedblockingqueue的数据结构相同，都是使用的链表结构。concurrentlinkedqueue的数据结构如下:\n\n\n\n说明: concurrentlinkedqueue采用的链表结构，并且包含有一个头节点和一个尾结点。\n\n\n# concurrentlinkedqueue源码分析\n\n\n# 类的继承关系\n\npublic class concurrentlinkedqueue<e> extends abstractqueue<e>\n        implements queue<e>, java.io.serializable {}\n\n\n说明: concurrentlinkedqueue继承了抽象类abstractqueue，abstractqueue定义了对队列的基本操作；同时实现了queue接口，queue定义了对队列的基本操作，同时，还实现了serializable接口，表示可以被序列化。\n\n\n# 类的内部类\n\nprivate static class node<e> {\n    // 元素\n    volatile e item;\n    // next域\n    volatile node<e> next;\n\n    /**\n        * constructs a new node.  uses relaxed write because item can\n        * only be seen after publication via casnext.\n        */\n    // 构造函数\n    node(e item) {\n        // 设置item的值\n        unsafe.putobject(this, itemoffset, item);\n    }\n    // 比较并替换item值\n    boolean casitem(e cmp, e val) {\n        return unsafe.compareandswapobject(this, itemoffset, cmp, val);\n    }\n    \n    void lazysetnext(node<e> val) {\n        // 设置next域的值，并不会保证修改对其他线程立即可见\n        unsafe.putorderedobject(this, nextoffset, val);\n    }\n    // 比较并替换next域的值\n    boolean casnext(node<e> cmp, node<e> val) {\n        return unsafe.compareandswapobject(this, nextoffset, cmp, val);\n    }\n\n    // unsafe mechanics\n    // 反射机制\n    private static final sun.misc.unsafe unsafe;\n    // item域的偏移量\n    private static final long itemoffset;\n    // next域的偏移量\n    private static final long nextoffset;\n\n    static {\n        try {\n            unsafe = sun.misc.unsafe.getunsafe();\n            class<?> k = node.class;\n            itemoffset = unsafe.objectfieldoffset\n                (k.getdeclaredfield("item"));\n            nextoffset = unsafe.objectfieldoffset\n                (k.getdeclaredfield("next"));\n        } catch (exception e) {\n            throw new error(e);\n        }\n    }\n}\n\n\n说明: node类表示链表结点，用于存放元素，包含item域和next域，item域表示元素，next域表示下一个结点，其利用反射机制和cas机制来更新item域和next域，保证原子性。\n\n\n# 类的属性\n\npublic class concurrentlinkedqueue<e> extends abstractqueue<e>\n        implements queue<e>, java.io.serializable {\n    // 版本序列号        \n    private static final long serialversionuid = 196745693267521676l;\n    // 反射机制\n    private static final sun.misc.unsafe unsafe;\n    // head域的偏移量\n    private static final long headoffset;\n    // tail域的偏移量\n    private static final long tailoffset;\n    static {\n        try {\n            unsafe = sun.misc.unsafe.getunsafe();\n            class<?> k = concurrentlinkedqueue.class;\n            headoffset = unsafe.objectfieldoffset\n                (k.getdeclaredfield("head"));\n            tailoffset = unsafe.objectfieldoffset\n                (k.getdeclaredfield("tail"));\n        } catch (exception e) {\n            throw new error(e);\n        }\n    }\n    \n    // 头节点\n    private transient volatile node<e> head;\n    // 尾结点\n    private transient volatile node<e> tail;\n}\n\n\n说明: 属性中包含了head域和tail域，表示链表的头节点和尾结点，同时，concurrentlinkedqueue也使用了反射机制和cas机制来更新头节点和尾结点，保证原子性。\n\n\n# 类的构造函数\n\n * concurrentlinkedqueue()型构造函数\n\npublic concurrentlinkedqueue() {\n    // 初始化头节点与尾结点\n    head = tail = new node<e>(null);\n}\n\n\n说明: 该构造函数用于创建一个最初为空的 concurrentlinkedqueue，头节点与尾结点指向同一个结点，该结点的item域为null，next域也为null。\n\n * concurrentlinkedqueue(collection<? extends e>)型构造函数\n\npublic concurrentlinkedqueue(collection<? extends e> c) {\n    node<e> h = null, t = null;\n    for (e e : c) { // 遍历c集合\n        // 保证元素不为空\n        checknotnull(e);\n        // 新生一个结点\n        node<e> newnode = new node<e>(e);\n        if (h == null) // 头节点为null\n            // 赋值头节点与尾结点\n            h = t = newnode;\n        else {\n            // 直接头节点的next域\n            t.lazysetnext(newnode);\n            // 重新赋值头节点\n            t = newnode;\n        }\n    }\n    if (h == null) // 头节点为null\n        // 新生头节点与尾结点\n        h = t = new node<e>(null);\n    // 赋值头节点\n    head = h;\n    // 赋值尾结点\n    tail = t;\n}\n\n\n说明: 该构造函数用于创建一个最初包含给定 collection 元素的 concurrentlinkedqueue，按照此 collection 迭代器的遍历顺序来添加元素。\n\n\n# 核心函数分析\n\n# offer函数\n\npublic boolean offer(e e) {\n    // 元素不为null\n    checknotnull(e);\n    // 新生一个结点\n    final node<e> newnode = new node<e>(e);\n\n    for (node<e> t = tail, p = t;;) { // 无限循环\n        // q为p结点的下一个结点\n        node<e> q = p.next;\n        if (q == null) { // q结点为null\n            // p is last node\n            if (p.casnext(null, newnode)) { // 比较并进行替换p结点的next域\n                // successful cas is the linearization point\n                // for e to become an element of this queue,\n                // and for newnode to become "live".\n                if (p != t) // p不等于t结点，不一致    // hop two nodes at a time\n                    // 比较并替换尾结点\n                    castail(t, newnode);  // failure is ok.\n                // 返回\n                return true;\n            }\n            // lost cas race to another thread; re-read next\n        }\n        else if (p == q) // p结点等于q结点\n            // we have fallen off list.  if tail is unchanged, it\n            // will also be off-list, in which case we need to\n            // jump to head, from which all live nodes are always\n            // reachable.  else the new tail is a better bet.\n            // 原来的尾结点与现在的尾结点是否相等，若相等，则p赋值为head，否则，赋值为现在的尾结点\n            p = (t != (t = tail)) ? t : head;\n        else\n            // check for tail updates after two hops.\n            // 重新赋值p结点\n            p = (p != t && t != (t = tail)) ? t : q;\n    }\n}\n\n\n说明: offer函数用于将指定元素插入此队列的尾部。下面模拟offer函数的操作，队列状态的变化(假设单线程添加元素，连续添加10、20两个元素)。\n\n\n\n * 若concurrentlinkedqueue的初始状态如上图所示，即队列为空。单线程添加元素，此时，添加元素10，则状态如下所示\n\n\n\n * 如上图所示，添加元素10后，tail没有变化，还是指向之前的结点，继续添加元素20，则状态如下所示\n\n\n\n * 如上图所示，添加元素20后，tail指向了最新添加的结点。\n\n# poll函数\n\npublic e poll() {\n    restartfromhead:\n    for (;;) { // 无限循环\n        for (node<e> h = head, p = h, q;;) { // 保存头节点\n            // item项\n            e item = p.item;\n\n            if (item != null && p.casitem(item, null)) { // item不为null并且比较并替换item成功\n                // successful cas is the linearization point\n                // for item to be removed from this queue.\n                if (p != h) // p不等于h    // hop two nodes at a time\n                    // 更新头节点\n                    updatehead(h, ((q = p.next) != null) ? q : p); \n                // 返回item\n                return item;\n            }\n            else if ((q = p.next) == null) { // q结点为null\n                // 更新头节点\n                updatehead(h, p);\n                return null;\n            }\n            else if (p == q) // p等于q\n                // 继续循环\n                continue restartfromhead;\n            else\n                // p赋值为q\n                p = q;\n        }\n    }\n}\n\n\n说明: 此函数用于获取并移除此队列的头，如果此队列为空，则返回null。下面模拟poll函数的操作，队列状态的变化(假设单线程操作，状态为之前offer10、20后的状态，poll两次)。\n\n\n\n * 队列初始状态如上图所示，在poll操作后，队列的状态如下图所示\n\n\n\n * 如上图可知，poll操作后，head改变了，并且head所指向的结点的item变为了null。再进行一次poll操作，队列的状态如下图所示。\n\n\n\n * 如上图可知，poll操作后，head结点没有变化，只是指示的结点的item域变成了null。\n\n# remove函数\n\npublic boolean remove(object o) {\n    // 元素为null，返回\n    if (o == null) return false;\n    node<e> pred = null;\n    for (node<e> p = first(); p != null; p = succ(p)) { // 获取第一个存活的结点\n        // 第一个存活结点的item值\n        e item = p.item;\n        if (item != null &&\n            o.equals(item) &&\n            p.casitem(item, null)) { // 找到item相等的结点，并且将该结点的item设置为null\n            // p的后继结点\n            node<e> next = succ(p);\n            if (pred != null && next != null) // pred不为null并且next不为null\n                // 比较并替换next域\n                pred.casnext(p, next);\n            return true;\n        }\n        // pred赋值为p\n        pred = p;\n    }\n    return false;\n}\n\n\n说明: 此函数用于从队列中移除指定元素的单个实例(如果存在)。其中，会调用到first函数和succ函数，first函数的源码如下\n\nnode<e> first() {\n    restartfromhead:\n    for (;;) { // 无限循环，确保成功\n        for (node<e> h = head, p = h, q;;) {\n            // p结点的item域是否为null\n            boolean hasitem = (p.item != null);\n            if (hasitem || (q = p.next) == null) { // item不为null或者next域为null\n                // 更新头节点\n                updatehead(h, p);\n                // 返回结点\n                return hasitem ? p : null;\n            }\n            else if (p == q) // p等于q\n                // 继续从头节点开始\n                continue restartfromhead;\n            else\n                // p赋值为q\n                p = q;\n        }\n    }\n}\n\n\n说明: first函数用于找到链表中第一个存活的结点。succ函数源码如下\n\nfinal node<e> succ(node<e> p) {\n    // p结点的next域\n    node<e> next = p.next;\n    // 如果next域为自身，则返回头节点，否则，返回next\n    return (p == next) ? head : next;\n}\n\n\n说明: succ用于获取结点的下一个结点。如果结点的next域指向自身，则返回head头节点，否则，返回next结点。下面模拟remove函数的操作，队列状态的变化(假设单线程操作，状态为之前offer10、20后的状态，执行remove(10)、remove(20)操作)。\n\n\n\n * 如上图所示，为concurrentlinkedqueue的初始状态，remove(10)后的状态如下图所示\n\n\n\n * 如上图所示，当执行remove(10)后，head指向了head结点之前指向的结点的下一个结点，并且head结点的item域置为null。继续执行remove(20)，状态如下图所示\n\n\n\n * 如上图所示，执行remove(20)后，head与tail指向同一个结点，item域为null。\n\n# size函数\n\npublic int size() {\n    // 计数\n    int count = 0;\n    for (node<e> p = first(); p != null; p = succ(p)) // 从第一个存活的结点开始往后遍历\n        if (p.item != null) // 结点的item域不为null\n            // collection.size() spec says to max out\n            if (++count == integer.max_value) // 增加计数，若达到最大值，则跳出循环\n                break;\n    // 返回大小\n    return count;\n}\n\n\n说明: 此函数用于返回concurrenlinkedqueue的大小，从第一个存活的结点(first)开始，往后遍历链表，当结点的item域不为null时，增加计数，之后返回大小。\n\n\n# concurrentlinkedqueue示例\n\n下面通过一个示例来了解concurrentlinkedqueue的使用\n\nimport java.util.concurrent.concurrentlinkedqueue;\n\nclass putthread extends thread {\n    private concurrentlinkedqueue<integer> clq;\n    public putthread(concurrentlinkedqueue<integer> clq) {\n        this.clq = clq;\n    }\n    \n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            try {\n                system.out.println("add " + i);\n                clq.add(i);\n                thread.sleep(100);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }\n    }\n}\n\nclass getthread extends thread {\n    private concurrentlinkedqueue<integer> clq;\n    public getthread(concurrentlinkedqueue<integer> clq) {\n        this.clq = clq;\n    }\n    \n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            try {\n                system.out.println("poll " + clq.poll());\n                thread.sleep(100);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }\n    }\n}\n\npublic class concurrentlinkedqueuedemo {\n    public static void main(string[] args) {\n        concurrentlinkedqueue<integer> clq = new concurrentlinkedqueue<integer>();\n        putthread p1 = new putthread(clq);\n        getthread g1 = new getthread(clq);\n        \n        p1.start();\n        g1.start();\n        \n    }\n}\n\n\n运行结果(某一次):\n\nadd 0\npoll null\nadd 1\npoll 0\nadd 2\npoll 1\nadd 3\npoll 2\nadd 4\npoll 3\nadd 5\npoll 4\npoll 5\nadd 6\nadd 7\npoll 6\npoll 7\nadd 8\nadd 9\npoll 8\n\n\n说明: getthread线程不会因为concurrentlinkedqueue队列为空而等待，而是直接返回null，所以当实现队列不空时，等待时，则需要用户自己实现等待逻辑。\n\n\n# 再深入理解\n\n\n# hops(延迟更新的策略)的设计\n\n通过上面对offer和poll方法的分析，我们发现tail和head是延迟更新的，两者更新触发时机为：\n\n * tail更新触发时机：当tail指向的节点的下一个节点不为null的时候，会执行定位队列真正的队尾节点的操作，找到队尾节点后完成插入之后才会通过castail进行tail更新；当tail指向的节点的下一个节点为null的时候，只插入节点不更新tail。\n\n * head更新触发时机：当head指向的节点的item域为null的时候，会执行定位队列真正的队头节点的操作，找到队头节点后完成删除之后才会通过updatehead进行head更新；当head指向的节点的item域不为null的时候，只删除节点不更新head。\n\n并且在更新操作时，源码中会有注释为：hop two nodes at a time。所以这种延迟更新的策略就被叫做hops的大概原因是这个(猜的 😃)，从上面更新时的状态图可以看出，head和tail的更新是“跳着的”即中间总是间隔了一个。那么这样设计的意图是什么呢?\n\n如果让tail永远作为队列的队尾节点，实现的代码量会更少，而且逻辑更易懂。但是，这样做有一个缺点，如果大量的入队操作，每次都要执行cas进行tail的更新，汇总起来对性能也会是大大的损耗。如果能减少cas更新的操作，无疑可以大大提升入队的操作效率，所以doug lea大师每间隔1次(tail和队尾节点的距离为1)进行才利用cas更新tail。对head的更新也是同样的道理，虽然，这样设计会多出在循环中定位队尾节点，但总体来说读的操作效率要远远高于写的性能，因此，多出来的在循环中定位尾节点的操作的性能损耗相对而言是很小的。\n\n\n# concurrentlinkedqueue适合的场景\n\nconcurrentlinkedqueue通过无锁来做到了更高的并发量，是个高性能的队列，但是使用场景相对不如阻塞队列常见，毕竟取数据也要不停的去循环，不如阻塞的逻辑好设计，但是在并发量特别大的情况下，是个不错的选择，性能上好很多，而且这个队列的设计也是特别费力，尤其的使用的改良算法和对哨兵的处理。整体的思路都是比较严谨的，这个也是使用了无锁造成的，我们自己使用无锁的条件的话，这个队列是个不错的参考。\n\n\n# 参考文章\n\n * 文章主要参考自leesf的https://www.cnblogs.com/leesf456/p/5539142.html，在此基础上做了增改。\n * https://blog.csdn.net/u011521203/article/details/80214968\n * https://blog.csdn.net/u014493323/article/details/81177194\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-concurrentlinkedqueue.html',charsets:{cjk:!0}},{title:"JUC集合: CopyOnWriteArrayList详解",frontmatter:{},regularPath:"/java/thread/java-thread-x-juc-collection-CopyOnWriteArrayList.html",relativePath:"java/thread/java-thread-x-juc-collection-CopyOnWriteArrayList.md",key:"v-2f00794e",path:"/java/thread/java-thread-x-juc-collection-CopyOnWriteArrayList.html",headers:[{level:2,title:"JUC集合: CopyOnWriteArrayList详解",slug:"juc集合-copyonwritearraylist详解",normalizedTitle:"juc集合: copyonwritearraylist详解",charIndex:2},{level:2,title:"带着BAT大厂的面试问题去理解",slug:"带着bat大厂的面试问题去理解",normalizedTitle:"带着bat大厂的面试问题去理解",charIndex:168},{level:2,title:"CopyOnWriteArrayList源码分析",slug:"copyonwritearraylist源码分析",normalizedTitle:"copyonwritearraylist源码分析",charIndex:189},{level:3,title:"类的继承关系",slug:"类的继承关系",normalizedTitle:"类的继承关系",charIndex:221},{level:3,title:"类的内部类",slug:"类的内部类",normalizedTitle:"类的内部类",charIndex:235},{level:3,title:"类的属性",slug:"类的属性",normalizedTitle:"类的属性",charIndex:248},{level:3,title:"类的构造函数",slug:"类的构造函数",normalizedTitle:"类的构造函数",charIndex:260},{level:3,title:"核心函数分析",slug:"核心函数分析",normalizedTitle:"核心函数分析",charIndex:274},{level:2,title:"CopyOnWriteArrayList示例",slug:"copyonwritearraylist示例",normalizedTitle:"copyonwritearraylist示例",charIndex:375},{level:2,title:"更深入理解",slug:"更深入理解",normalizedTitle:"更深入理解",charIndex:403},{level:3,title:"CopyOnWriteArrayList的缺陷和使用场景",slug:"copyonwritearraylist的缺陷和使用场景",normalizedTitle:"copyonwritearraylist的缺陷和使用场景",charIndex:416},{level:3,title:"CopyOnWriteArrayList为什么并发安全且性能比Vector好?",slug:"copyonwritearraylist为什么并发安全且性能比vector好",normalizedTitle:"copyonwritearraylist为什么并发安全且性能比vector好?",charIndex:452},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:497}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"JUC集合: CopyOnWriteArrayList详解 带着BAT大厂的面试问题去理解 CopyOnWriteArrayList源码分析 类的继承关系 类的内部类 类的属性 类的构造函数 核心函数分析 CopyOnWriteArrayList示例 更深入理解 CopyOnWriteArrayList的缺陷和使用场景 CopyOnWriteArrayList为什么并发安全且性能比Vector好? 参考文章",content:'# JUC集合: CopyOnWriteArrayList详解\n\n> CopyOnWriteArrayList是ArrayList 的一个线程安全的变体，其中所有可变操作(add、set 等等)都是通过对底层数组进行一次新的拷贝来实现的。COW模式的体现。\n\n * JUC集合: CopyOnWriteArrayList详解\n   * 带着BAT大厂的面试问题去理解\n   * CopyOnWriteArrayList源码分析\n     * 类的继承关系\n     * 类的内部类\n     * 类的属性\n     * 类的构造函数\n     * 核心函数分析\n       * copyOf函数\n       * add函数\n       * addIfAbsent方法\n       * set函数\n       * remove函数\n   * CopyOnWriteArrayList示例\n   * 更深入理解\n     * CopyOnWriteArrayList的缺陷和使用场景\n     * CopyOnWriteArrayList为什么并发安全且性能比Vector好?\n   * 参考文章\n\n\n# 带着BAT大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 请先说说非并发集合中Fail-fast机制?\n * 再为什么说ArrayList查询快而增删慢?\n * 对比ArrayList说说CopyOnWriteArrayList的增删改查实现原理? COW基于拷贝\n * 再说下弱一致性的迭代器原理是怎么样的? COWIterator<E>\n * CopyOnWriteArrayList为什么并发安全且性能比Vector好?\n * CopyOnWriteArrayList有何缺陷，说说其应用场景?\n\n\n# CopyOnWriteArrayList源码分析\n\n\n# 类的继承关系\n\nCopyOnWriteArrayList实现了List接口，List接口定义了对列表的基本操作；同时实现了RandomAccess接口，表示可以随机访问(数组具有随机访问的特性)；同时实现了Cloneable接口，表示可克隆；同时也实现了Serializable接口，表示可被序列化。\n\npublic class CopyOnWriteArrayList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable {}\n\n\n\n# 类的内部类\n\n * COWIterator类\n\nCOWIterator表示迭代器，其也有一个Object类型的数组作为CopyOnWriteArrayList数组的快照，这种快照风格的迭代器方法在创建迭代器时使用了对当时数组状态的引用。此数组在迭代器的生存期内不会更改，因此不可能发生冲突，并且迭代器保证不会抛出 ConcurrentModificationException。创建迭代器以后，迭代器就不会反映列表的添加、移除或者更改。在迭代器上进行的元素更改操作(remove、set 和 add)不受支持。这些方法将抛出 UnsupportedOperationException。\n\nstatic final class COWIterator<E> implements ListIterator<E> {\n    /** Snapshot of the array */\n    // 快照\n    private final Object[] snapshot;\n    /** Index of element to be returned by subsequent call to next.  */\n    // 游标\n    private int cursor;\n    // 构造函数\n    private COWIterator(Object[] elements, int initialCursor) {\n        cursor = initialCursor;\n        snapshot = elements;\n    }\n    // 是否还有下一项\n    public boolean hasNext() {\n        return cursor < snapshot.length;\n    }\n    // 是否有上一项\n    public boolean hasPrevious() {\n        return cursor > 0;\n    }\n    // next项\n    @SuppressWarnings("unchecked")\n    public E next() {\n        if (! hasNext()) // 不存在下一项，抛出异常\n            throw new NoSuchElementException();\n        // 返回下一项\n        return (E) snapshot[cursor++];\n    }\n\n    @SuppressWarnings("unchecked")\n    public E previous() {\n        if (! hasPrevious())\n            throw new NoSuchElementException();\n        return (E) snapshot[--cursor];\n    }\n    \n    // 下一项索引\n    public int nextIndex() {\n        return cursor;\n    }\n    \n    // 上一项索引\n    public int previousIndex() {\n        return cursor-1;\n    }\n\n    /**\n        * Not supported. Always throws UnsupportedOperationException.\n        * @throws UnsupportedOperationException always; {@code remove}\n        *         is not supported by this iterator.\n        */\n    // 不支持remove操作\n    public void remove() {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n        * Not supported. Always throws UnsupportedOperationException.\n        * @throws UnsupportedOperationException always; {@code set}\n        *         is not supported by this iterator.\n        */\n    // 不支持set操作\n    public void set(E e) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n        * Not supported. Always throws UnsupportedOperationException.\n        * @throws UnsupportedOperationException always; {@code add}\n        *         is not supported by this iterator.\n        */\n    // 不支持add操作\n    public void add(E e) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void forEachRemaining(Consumer<? super E> action) {\n        Objects.requireNonNull(action);\n        Object[] elements = snapshot;\n        final int size = elements.length;\n        for (int i = cursor; i < size; i++) {\n            @SuppressWarnings("unchecked") E e = (E) elements[i];\n            action.accept(e);\n        }\n        cursor = size;\n    }\n}\n\n\n\n# 类的属性\n\n属性中有一个可重入锁，用来保证线程安全访问，还有一个Object类型的数组，用来存放具体的元素。当然，也使用到了反射机制和CAS来保证原子性的修改lock域。\n\npublic class CopyOnWriteArrayList<E>\n    implements List<E>, RandomAccess, Cloneable, java.io.Serializable {\n    // 版本序列号\n    private static final long serialVersionUID = 8673264195747942595L;\n    // 可重入锁\n    final transient ReentrantLock lock = new ReentrantLock();\n    // 对象数组，用于存放元素\n    private transient volatile Object[] array;\n    // 反射机制\n    private static final sun.misc.Unsafe UNSAFE;\n    // lock域的内存偏移量\n    private static final long lockOffset;\n    static {\n        try {\n            UNSAFE = sun.misc.Unsafe.getUnsafe();\n            Class<?> k = CopyOnWriteArrayList.class;\n            lockOffset = UNSAFE.objectFieldOffset\n                (k.getDeclaredField("lock"));\n        } catch (Exception e) {\n            throw new Error(e);\n        }\n    }\n}\n\n\n\n# 类的构造函数\n\n * 默认构造函数\n\npublic CopyOnWriteArrayList() {\n    // 设置数组\n    setArray(new Object[0]);\n}\n\n\n * CopyOnWriteArrayList(Collection<? extends E>)型构造函数　 该构造函数用于创建一个按 collection 的迭代器返回元素的顺序包含指定 collection 元素的列表。\n\npublic CopyOnWriteArrayList(Collection<? extends E> c) {\n    Object[] elements;\n    if (c.getClass() == CopyOnWriteArrayList.class) // 类型相同\n        // 获取c集合的数组\n        elements = ((CopyOnWriteArrayList<?>)c).getArray();\n    else { // 类型不相同\n        // 将c集合转化为数组并赋值给elements\n        elements = c.toArray();\n        // c.toArray might (incorrectly) not return Object[] (see 6260652)\n        if (elements.getClass() != Object[].class) // elements类型不为Object[]类型\n            // 将elements数组转化为Object[]类型的数组\n            elements = Arrays.copyOf(elements, elements.length, Object[].class);\n    }\n    // 设置数组\n    setArray(elements);\n}\n\n\n该构造函数的处理流程如下\n\n * 判断传入的集合c的类型是否为CopyOnWriteArrayList类型，若是，则获取该集合类型的底层数组(Object[])，并且设置当前CopyOnWriteArrayList的数组(Object[]数组)，进入步骤③；否则，进入步骤②\n\n * 将传入的集合转化为数组elements，判断elements的类型是否为Object[]类型(toArray方法可能不会返回Object类型的数组)，若不是，则将elements转化为Object类型的数组。进入步骤③\n\n * 设置当前CopyOnWriteArrayList的Object[]为elements。\n\n * CopyOnWriteArrayList(E[])型构造函数\n\n该构造函数用于创建一个保存给定数组的副本的列表。\n\npublic CopyOnWriteArrayList(E[] toCopyIn) {\n    // 将toCopyIn转化为Object[]类型数组，然后设置当前数组\n    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));\n}\n\n\n\n# 核心函数分析\n\n对于CopyOnWriteArrayList的函数分析，主要明白Arrays.copyOf方法即可理解CopyOnWriteArrayList其他函数的意义。\n\n# copyOf函数\n\n该函数用于复制指定的数组，截取或用 null 填充(如有必要)，以使副本具有指定的长度。\n\npublic static <T,U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {\n    @SuppressWarnings("unchecked")\n    // 确定copy的类型(将newType转化为Object类型，将Object[].class转化为Object类型，判断两者是否相等，若相等，则生成指定长度的Object数组\n    // 否则,生成指定长度的新类型的数组)\n    T[] copy = ((Object)newType == (Object)Object[].class)\n        ? (T[]) new Object[newLength]\n        : (T[]) Array.newInstance(newType.getComponentType(), newLength);\n    // 将original数组从下标0开始，复制长度为(original.length和newLength的较小者),复制到copy数组中(也从下标0开始)\n    System.arraycopy(original, 0, copy, 0,\n                        Math.min(original.length, newLength));\n    return copy;\n}\n\n\n# add函数\n\npublic boolean add(E e) {\n    // 可重入锁\n    final ReentrantLock lock = this.lock;\n    // 获取锁\n    lock.lock();\n    try {\n        // 元素数组\n        Object[] elements = getArray();\n        // 数组长度\n        int len = elements.length;\n        // 复制数组\n        Object[] newElements = Arrays.copyOf(elements, len + 1);\n        // 存放元素e\n        newElements[len] = e;\n        // 设置数组\n        setArray(newElements);\n        return true;\n    } finally {\n        // 释放锁\n        lock.unlock();\n    }\n}\n\n\n此函数用于将指定元素添加到此列表的尾部，处理流程如下\n\n * 获取锁(保证多线程的安全访问)，获取当前的Object数组，获取Object数组的长度为length，进入步骤②。\n\n * 根据Object数组复制一个长度为length+1的Object数组为newElements(此时，newElements[length]为null)，进入下一步骤。\n\n * 将下标为length的数组元素newElements[length]设置为元素e，再设置当前Object[]为newElements，释放锁，返回。这样就完成了元素的添加。\n\n# addIfAbsent方法\n\n该函数用于添加元素(如果数组中不存在，则添加；否则，不添加，直接返回)，可以保证多线程环境下不会重复添加元素。\n\nprivate boolean addIfAbsent(E e, Object[] snapshot) {\n    // 重入锁\n    final ReentrantLock lock = this.lock;\n    // 获取锁\n    lock.lock();\n    try {\n        // 获取数组\n        Object[] current = getArray();\n        // 数组长度\n        int len = current.length;\n        if (snapshot != current) { // 快照不等于当前数组，对数组进行了修改\n            // Optimize for lost race to another addXXX operation\n            // 取较小者\n            int common = Math.min(snapshot.length, len);\n            for (int i = 0; i < common; i++) // 遍历\n                if (current[i] != snapshot[i] && eq(e, current[i])) // 当前数组的元素与快照的元素不相等并且e与当前元素相等\n                    // 表示在snapshot与current之间修改了数组，并且设置了数组某一元素为e，已经存在\n                    // 返回\n                    return false;\n            if (indexOf(e, current, common, len) >= 0) // 在当前数组中找到e元素\n                    // 返回\n                    return false;\n        }\n        // 复制数组\n        Object[] newElements = Arrays.copyOf(current, len + 1);\n        // 对数组len索引的元素赋值为e\n        newElements[len] = e;\n        // 设置数组\n        setArray(newElements);\n        return true;\n    } finally {\n        // 释放锁\n        lock.unlock();\n    }\n}\n\n\n该函数的流程如下:\n\n① 获取锁，获取当前数组为current，current长度为len，判断数组之前的快照snapshot是否等于当前数组current，若不相等，则进入步骤②；否则，进入步骤④\n\n② 不相等，表示在snapshot与current之间，对数组进行了修改(如进行了add、set、remove等操作)，获取长度(snapshot与current之间的较小者)，对current进行遍历操作，若遍历过程发现snapshot与current的元素不相等并且current的元素与指定元素相等(可能进行了set操作)，进入步骤⑤，否则，进入步骤③\n\n③ 在当前数组中索引指定元素，若能够找到，进入步骤⑤，否则，进入步骤④\n\n④ 复制当前数组current为newElements，长度为len+1，此时newElements[len]为null。再设置newElements[len]为指定元素e，再设置数组，进入步骤⑤\n\n⑤ 释放锁，返回。\n\n# set函数\n\n此函数用于用指定的元素替代此列表指定位置上的元素，也是基于数组的复制来实现的。\n\npublic E set(int index, E element) {\n    // 可重入锁\n    final ReentrantLock lock = this.lock;\n    // 获取锁\n    lock.lock();\n    try {\n        // 获取数组\n        Object[] elements = getArray();\n        // 获取index索引的元素\n        E oldValue = get(elements, index);\n\n        if (oldValue != element) { // 旧值等于element\n            // 数组长度\n            int len = elements.length;\n            // 复制数组\n            Object[] newElements = Arrays.copyOf(elements, len);\n            // 重新赋值index索引的值\n            newElements[index] = element;\n            // 设置数组\n            setArray(newElements);\n        } else {\n            // Not quite a no-op; ensures volatile write semantics\n            // 设置数组\n            setArray(elements);\n        }\n        // 返回旧值\n        return oldValue;\n    } finally {\n        // 释放锁\n        lock.unlock();\n    }\n}\n\n\n# remove函数\n\n此函数用于移除此列表指定位置上的元素。\n\npublic E remove(int index) {\n    // 可重入锁\n    final ReentrantLock lock = this.lock;\n    // 获取锁\n    lock.lock();\n    try {\n        // 获取数组\n        Object[] elements = getArray();\n        // 数组长度\n        int len = elements.length;\n        // 获取旧值\n        E oldValue = get(elements, index);\n        // 需要移动的元素个数\n        int numMoved = len - index - 1;\n        if (numMoved == 0) // 移动个数为0\n            // 复制后设置数组\n            setArray(Arrays.copyOf(elements, len - 1));\n        else { // 移动个数不为0\n            // 新生数组\n            Object[] newElements = new Object[len - 1];\n            // 复制index索引之前的元素\n            System.arraycopy(elements, 0, newElements, 0, index);\n            // 复制index索引之后的元素\n            System.arraycopy(elements, index + 1, newElements, index,\n                                numMoved);\n            // 设置索引\n            setArray(newElements);\n        }\n        // 返回旧值\n        return oldValue;\n    } finally {\n        // 释放锁\n        lock.unlock();\n    }\n}\n\n\n处理流程如下\n\n① 获取锁，获取数组elements，数组长度为length，获取索引的值elements[index]，计算需要移动的元素个数(length - index - 1),若个数为0，则表示移除的是数组的最后一个元素，复制elements数组，复制长度为length-1，然后设置数组，进入步骤③；否则，进入步骤②\n\n② 先复制index索引前的元素，再复制index索引后的元素，然后设置数组。\n\n③ 释放锁，返回旧值。\n\n\n# CopyOnWriteArrayList示例\n\n下面通过一个示例来了解CopyOnWriteArrayList的使用: 在程序中，有一个PutThread线程会每隔50ms就向CopyOnWriteArrayList中添加一个元素，并且两次使用了迭代器，迭代器输出的内容都是生成迭代器时，CopyOnWriteArrayList的Object数组的快照的内容，在迭代的过程中，往CopyOnWriteArrayList中添加元素也不会抛出异常。\n\nimport java.util.Iterator;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nclass PutThread extends Thread {\n    private CopyOnWriteArrayList<Integer> cowal;\n\n    public PutThread(CopyOnWriteArrayList<Integer> cowal) {\n        this.cowal = cowal;\n    }\n\n    public void run() {\n        try {\n            for (int i = 100; i < 110; i++) {\n                cowal.add(i);\n                Thread.sleep(50);\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\npublic class CopyOnWriteArrayListDemo {\n    public static void main(String[] args) {\n        CopyOnWriteArrayList<Integer> cowal = new CopyOnWriteArrayList<Integer>();\n        for (int i = 0; i < 10; i++) {\n            cowal.add(i);\n        }\n        PutThread p1 = new PutThread(cowal);\n        p1.start();\n        Iterator<Integer> iterator = cowal.iterator();\n        while (iterator.hasNext()) {\n            System.out.print(iterator.next() + " ");\n        }\n        System.out.println();\n        try {\n            Thread.sleep(200);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        \n        iterator = cowal.iterator();\n        while (iterator.hasNext()) {\n            System.out.print(iterator.next() + " ");\n        }\n    }\n}\n\n\n运行结果(某一次)\n\n0 1 2 3 4 5 6 7 8 9 100 \n0 1 2 3 4 5 6 7 8 9 100 101 102 103 \n\n\n\n# 更深入理解\n\n\n# CopyOnWriteArrayList的缺陷和使用场景\n\nCopyOnWriteArrayList 有几个缺点：\n\n * 由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致young gc或者full gc\n\n * 不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个set操作后，读取到数据可能还是旧的,虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求；\n\nCopyOnWriteArrayList 合适读多写少的场景，不过这类慎用\n\n因为谁也没法保证CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次add/set都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。\n\n\n# CopyOnWriteArrayList为什么并发安全且性能比Vector好?\n\nVector对单独的add，remove等方法都是在方法上加了synchronized; 并且如果一个线程A调用size时，另一个线程B 执行了remove，然后size的值就不是最新的，然后线程A调用remove就会越界(这时就需要再加一个Synchronized)。这样就导致有了双重锁，效率大大降低，何必呢。于是vector废弃了，要用就用CopyOnWriteArrayList 吧。\n\n\n# 参考文章\n\n * 文章主要参考自leesf的https://www.cnblogs.com/leesf456/p/5547853.html，在此基础上做了增改。\n * https://blog.csdn.net/LuoZheng4698729/article/details/102824923\n * https://blog.csdn.net/chuanyingcao2675/article/details/101048889\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-CopyOnWriteArrayList.html',normalizedContent:'# juc集合: copyonwritearraylist详解\n\n> copyonwritearraylist是arraylist 的一个线程安全的变体，其中所有可变操作(add、set 等等)都是通过对底层数组进行一次新的拷贝来实现的。cow模式的体现。\n\n * juc集合: copyonwritearraylist详解\n   * 带着bat大厂的面试问题去理解\n   * copyonwritearraylist源码分析\n     * 类的继承关系\n     * 类的内部类\n     * 类的属性\n     * 类的构造函数\n     * 核心函数分析\n       * copyof函数\n       * add函数\n       * addifabsent方法\n       * set函数\n       * remove函数\n   * copyonwritearraylist示例\n   * 更深入理解\n     * copyonwritearraylist的缺陷和使用场景\n     * copyonwritearraylist为什么并发安全且性能比vector好?\n   * 参考文章\n\n\n# 带着bat大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 请先说说非并发集合中fail-fast机制?\n * 再为什么说arraylist查询快而增删慢?\n * 对比arraylist说说copyonwritearraylist的增删改查实现原理? cow基于拷贝\n * 再说下弱一致性的迭代器原理是怎么样的? cowiterator<e>\n * copyonwritearraylist为什么并发安全且性能比vector好?\n * copyonwritearraylist有何缺陷，说说其应用场景?\n\n\n# copyonwritearraylist源码分析\n\n\n# 类的继承关系\n\ncopyonwritearraylist实现了list接口，list接口定义了对列表的基本操作；同时实现了randomaccess接口，表示可以随机访问(数组具有随机访问的特性)；同时实现了cloneable接口，表示可克隆；同时也实现了serializable接口，表示可被序列化。\n\npublic class copyonwritearraylist<e> implements list<e>, randomaccess, cloneable, java.io.serializable {}\n\n\n\n# 类的内部类\n\n * cowiterator类\n\ncowiterator表示迭代器，其也有一个object类型的数组作为copyonwritearraylist数组的快照，这种快照风格的迭代器方法在创建迭代器时使用了对当时数组状态的引用。此数组在迭代器的生存期内不会更改，因此不可能发生冲突，并且迭代器保证不会抛出 concurrentmodificationexception。创建迭代器以后，迭代器就不会反映列表的添加、移除或者更改。在迭代器上进行的元素更改操作(remove、set 和 add)不受支持。这些方法将抛出 unsupportedoperationexception。\n\nstatic final class cowiterator<e> implements listiterator<e> {\n    /** snapshot of the array */\n    // 快照\n    private final object[] snapshot;\n    /** index of element to be returned by subsequent call to next.  */\n    // 游标\n    private int cursor;\n    // 构造函数\n    private cowiterator(object[] elements, int initialcursor) {\n        cursor = initialcursor;\n        snapshot = elements;\n    }\n    // 是否还有下一项\n    public boolean hasnext() {\n        return cursor < snapshot.length;\n    }\n    // 是否有上一项\n    public boolean hasprevious() {\n        return cursor > 0;\n    }\n    // next项\n    @suppresswarnings("unchecked")\n    public e next() {\n        if (! hasnext()) // 不存在下一项，抛出异常\n            throw new nosuchelementexception();\n        // 返回下一项\n        return (e) snapshot[cursor++];\n    }\n\n    @suppresswarnings("unchecked")\n    public e previous() {\n        if (! hasprevious())\n            throw new nosuchelementexception();\n        return (e) snapshot[--cursor];\n    }\n    \n    // 下一项索引\n    public int nextindex() {\n        return cursor;\n    }\n    \n    // 上一项索引\n    public int previousindex() {\n        return cursor-1;\n    }\n\n    /**\n        * not supported. always throws unsupportedoperationexception.\n        * @throws unsupportedoperationexception always; {@code remove}\n        *         is not supported by this iterator.\n        */\n    // 不支持remove操作\n    public void remove() {\n        throw new unsupportedoperationexception();\n    }\n\n    /**\n        * not supported. always throws unsupportedoperationexception.\n        * @throws unsupportedoperationexception always; {@code set}\n        *         is not supported by this iterator.\n        */\n    // 不支持set操作\n    public void set(e e) {\n        throw new unsupportedoperationexception();\n    }\n\n    /**\n        * not supported. always throws unsupportedoperationexception.\n        * @throws unsupportedoperationexception always; {@code add}\n        *         is not supported by this iterator.\n        */\n    // 不支持add操作\n    public void add(e e) {\n        throw new unsupportedoperationexception();\n    }\n\n    @override\n    public void foreachremaining(consumer<? super e> action) {\n        objects.requirenonnull(action);\n        object[] elements = snapshot;\n        final int size = elements.length;\n        for (int i = cursor; i < size; i++) {\n            @suppresswarnings("unchecked") e e = (e) elements[i];\n            action.accept(e);\n        }\n        cursor = size;\n    }\n}\n\n\n\n# 类的属性\n\n属性中有一个可重入锁，用来保证线程安全访问，还有一个object类型的数组，用来存放具体的元素。当然，也使用到了反射机制和cas来保证原子性的修改lock域。\n\npublic class copyonwritearraylist<e>\n    implements list<e>, randomaccess, cloneable, java.io.serializable {\n    // 版本序列号\n    private static final long serialversionuid = 8673264195747942595l;\n    // 可重入锁\n    final transient reentrantlock lock = new reentrantlock();\n    // 对象数组，用于存放元素\n    private transient volatile object[] array;\n    // 反射机制\n    private static final sun.misc.unsafe unsafe;\n    // lock域的内存偏移量\n    private static final long lockoffset;\n    static {\n        try {\n            unsafe = sun.misc.unsafe.getunsafe();\n            class<?> k = copyonwritearraylist.class;\n            lockoffset = unsafe.objectfieldoffset\n                (k.getdeclaredfield("lock"));\n        } catch (exception e) {\n            throw new error(e);\n        }\n    }\n}\n\n\n\n# 类的构造函数\n\n * 默认构造函数\n\npublic copyonwritearraylist() {\n    // 设置数组\n    setarray(new object[0]);\n}\n\n\n * copyonwritearraylist(collection<? extends e>)型构造函数　 该构造函数用于创建一个按 collection 的迭代器返回元素的顺序包含指定 collection 元素的列表。\n\npublic copyonwritearraylist(collection<? extends e> c) {\n    object[] elements;\n    if (c.getclass() == copyonwritearraylist.class) // 类型相同\n        // 获取c集合的数组\n        elements = ((copyonwritearraylist<?>)c).getarray();\n    else { // 类型不相同\n        // 将c集合转化为数组并赋值给elements\n        elements = c.toarray();\n        // c.toarray might (incorrectly) not return object[] (see 6260652)\n        if (elements.getclass() != object[].class) // elements类型不为object[]类型\n            // 将elements数组转化为object[]类型的数组\n            elements = arrays.copyof(elements, elements.length, object[].class);\n    }\n    // 设置数组\n    setarray(elements);\n}\n\n\n该构造函数的处理流程如下\n\n * 判断传入的集合c的类型是否为copyonwritearraylist类型，若是，则获取该集合类型的底层数组(object[])，并且设置当前copyonwritearraylist的数组(object[]数组)，进入步骤③；否则，进入步骤②\n\n * 将传入的集合转化为数组elements，判断elements的类型是否为object[]类型(toarray方法可能不会返回object类型的数组)，若不是，则将elements转化为object类型的数组。进入步骤③\n\n * 设置当前copyonwritearraylist的object[]为elements。\n\n * copyonwritearraylist(e[])型构造函数\n\n该构造函数用于创建一个保存给定数组的副本的列表。\n\npublic copyonwritearraylist(e[] tocopyin) {\n    // 将tocopyin转化为object[]类型数组，然后设置当前数组\n    setarray(arrays.copyof(tocopyin, tocopyin.length, object[].class));\n}\n\n\n\n# 核心函数分析\n\n对于copyonwritearraylist的函数分析，主要明白arrays.copyof方法即可理解copyonwritearraylist其他函数的意义。\n\n# copyof函数\n\n该函数用于复制指定的数组，截取或用 null 填充(如有必要)，以使副本具有指定的长度。\n\npublic static <t,u> t[] copyof(u[] original, int newlength, class<? extends t[]> newtype) {\n    @suppresswarnings("unchecked")\n    // 确定copy的类型(将newtype转化为object类型，将object[].class转化为object类型，判断两者是否相等，若相等，则生成指定长度的object数组\n    // 否则,生成指定长度的新类型的数组)\n    t[] copy = ((object)newtype == (object)object[].class)\n        ? (t[]) new object[newlength]\n        : (t[]) array.newinstance(newtype.getcomponenttype(), newlength);\n    // 将original数组从下标0开始，复制长度为(original.length和newlength的较小者),复制到copy数组中(也从下标0开始)\n    system.arraycopy(original, 0, copy, 0,\n                        math.min(original.length, newlength));\n    return copy;\n}\n\n\n# add函数\n\npublic boolean add(e e) {\n    // 可重入锁\n    final reentrantlock lock = this.lock;\n    // 获取锁\n    lock.lock();\n    try {\n        // 元素数组\n        object[] elements = getarray();\n        // 数组长度\n        int len = elements.length;\n        // 复制数组\n        object[] newelements = arrays.copyof(elements, len + 1);\n        // 存放元素e\n        newelements[len] = e;\n        // 设置数组\n        setarray(newelements);\n        return true;\n    } finally {\n        // 释放锁\n        lock.unlock();\n    }\n}\n\n\n此函数用于将指定元素添加到此列表的尾部，处理流程如下\n\n * 获取锁(保证多线程的安全访问)，获取当前的object数组，获取object数组的长度为length，进入步骤②。\n\n * 根据object数组复制一个长度为length+1的object数组为newelements(此时，newelements[length]为null)，进入下一步骤。\n\n * 将下标为length的数组元素newelements[length]设置为元素e，再设置当前object[]为newelements，释放锁，返回。这样就完成了元素的添加。\n\n# addifabsent方法\n\n该函数用于添加元素(如果数组中不存在，则添加；否则，不添加，直接返回)，可以保证多线程环境下不会重复添加元素。\n\nprivate boolean addifabsent(e e, object[] snapshot) {\n    // 重入锁\n    final reentrantlock lock = this.lock;\n    // 获取锁\n    lock.lock();\n    try {\n        // 获取数组\n        object[] current = getarray();\n        // 数组长度\n        int len = current.length;\n        if (snapshot != current) { // 快照不等于当前数组，对数组进行了修改\n            // optimize for lost race to another addxxx operation\n            // 取较小者\n            int common = math.min(snapshot.length, len);\n            for (int i = 0; i < common; i++) // 遍历\n                if (current[i] != snapshot[i] && eq(e, current[i])) // 当前数组的元素与快照的元素不相等并且e与当前元素相等\n                    // 表示在snapshot与current之间修改了数组，并且设置了数组某一元素为e，已经存在\n                    // 返回\n                    return false;\n            if (indexof(e, current, common, len) >= 0) // 在当前数组中找到e元素\n                    // 返回\n                    return false;\n        }\n        // 复制数组\n        object[] newelements = arrays.copyof(current, len + 1);\n        // 对数组len索引的元素赋值为e\n        newelements[len] = e;\n        // 设置数组\n        setarray(newelements);\n        return true;\n    } finally {\n        // 释放锁\n        lock.unlock();\n    }\n}\n\n\n该函数的流程如下:\n\n① 获取锁，获取当前数组为current，current长度为len，判断数组之前的快照snapshot是否等于当前数组current，若不相等，则进入步骤②；否则，进入步骤④\n\n② 不相等，表示在snapshot与current之间，对数组进行了修改(如进行了add、set、remove等操作)，获取长度(snapshot与current之间的较小者)，对current进行遍历操作，若遍历过程发现snapshot与current的元素不相等并且current的元素与指定元素相等(可能进行了set操作)，进入步骤⑤，否则，进入步骤③\n\n③ 在当前数组中索引指定元素，若能够找到，进入步骤⑤，否则，进入步骤④\n\n④ 复制当前数组current为newelements，长度为len+1，此时newelements[len]为null。再设置newelements[len]为指定元素e，再设置数组，进入步骤⑤\n\n⑤ 释放锁，返回。\n\n# set函数\n\n此函数用于用指定的元素替代此列表指定位置上的元素，也是基于数组的复制来实现的。\n\npublic e set(int index, e element) {\n    // 可重入锁\n    final reentrantlock lock = this.lock;\n    // 获取锁\n    lock.lock();\n    try {\n        // 获取数组\n        object[] elements = getarray();\n        // 获取index索引的元素\n        e oldvalue = get(elements, index);\n\n        if (oldvalue != element) { // 旧值等于element\n            // 数组长度\n            int len = elements.length;\n            // 复制数组\n            object[] newelements = arrays.copyof(elements, len);\n            // 重新赋值index索引的值\n            newelements[index] = element;\n            // 设置数组\n            setarray(newelements);\n        } else {\n            // not quite a no-op; ensures volatile write semantics\n            // 设置数组\n            setarray(elements);\n        }\n        // 返回旧值\n        return oldvalue;\n    } finally {\n        // 释放锁\n        lock.unlock();\n    }\n}\n\n\n# remove函数\n\n此函数用于移除此列表指定位置上的元素。\n\npublic e remove(int index) {\n    // 可重入锁\n    final reentrantlock lock = this.lock;\n    // 获取锁\n    lock.lock();\n    try {\n        // 获取数组\n        object[] elements = getarray();\n        // 数组长度\n        int len = elements.length;\n        // 获取旧值\n        e oldvalue = get(elements, index);\n        // 需要移动的元素个数\n        int nummoved = len - index - 1;\n        if (nummoved == 0) // 移动个数为0\n            // 复制后设置数组\n            setarray(arrays.copyof(elements, len - 1));\n        else { // 移动个数不为0\n            // 新生数组\n            object[] newelements = new object[len - 1];\n            // 复制index索引之前的元素\n            system.arraycopy(elements, 0, newelements, 0, index);\n            // 复制index索引之后的元素\n            system.arraycopy(elements, index + 1, newelements, index,\n                                nummoved);\n            // 设置索引\n            setarray(newelements);\n        }\n        // 返回旧值\n        return oldvalue;\n    } finally {\n        // 释放锁\n        lock.unlock();\n    }\n}\n\n\n处理流程如下\n\n① 获取锁，获取数组elements，数组长度为length，获取索引的值elements[index]，计算需要移动的元素个数(length - index - 1),若个数为0，则表示移除的是数组的最后一个元素，复制elements数组，复制长度为length-1，然后设置数组，进入步骤③；否则，进入步骤②\n\n② 先复制index索引前的元素，再复制index索引后的元素，然后设置数组。\n\n③ 释放锁，返回旧值。\n\n\n# copyonwritearraylist示例\n\n下面通过一个示例来了解copyonwritearraylist的使用: 在程序中，有一个putthread线程会每隔50ms就向copyonwritearraylist中添加一个元素，并且两次使用了迭代器，迭代器输出的内容都是生成迭代器时，copyonwritearraylist的object数组的快照的内容，在迭代的过程中，往copyonwritearraylist中添加元素也不会抛出异常。\n\nimport java.util.iterator;\nimport java.util.concurrent.copyonwritearraylist;\n\nclass putthread extends thread {\n    private copyonwritearraylist<integer> cowal;\n\n    public putthread(copyonwritearraylist<integer> cowal) {\n        this.cowal = cowal;\n    }\n\n    public void run() {\n        try {\n            for (int i = 100; i < 110; i++) {\n                cowal.add(i);\n                thread.sleep(50);\n            }\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n    }\n}\n\npublic class copyonwritearraylistdemo {\n    public static void main(string[] args) {\n        copyonwritearraylist<integer> cowal = new copyonwritearraylist<integer>();\n        for (int i = 0; i < 10; i++) {\n            cowal.add(i);\n        }\n        putthread p1 = new putthread(cowal);\n        p1.start();\n        iterator<integer> iterator = cowal.iterator();\n        while (iterator.hasnext()) {\n            system.out.print(iterator.next() + " ");\n        }\n        system.out.println();\n        try {\n            thread.sleep(200);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n        \n        iterator = cowal.iterator();\n        while (iterator.hasnext()) {\n            system.out.print(iterator.next() + " ");\n        }\n    }\n}\n\n\n运行结果(某一次)\n\n0 1 2 3 4 5 6 7 8 9 100 \n0 1 2 3 4 5 6 7 8 9 100 101 102 103 \n\n\n\n# 更深入理解\n\n\n# copyonwritearraylist的缺陷和使用场景\n\ncopyonwritearraylist 有几个缺点：\n\n * 由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致young gc或者full gc\n\n * 不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个set操作后，读取到数据可能还是旧的,虽然copyonwritearraylist 能做到最终一致性,但是还是没法满足实时性要求；\n\ncopyonwritearraylist 合适读多写少的场景，不过这类慎用\n\n因为谁也没法保证copyonwritearraylist 到底要放置多少数据，万一数据稍微有点多，每次add/set都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。\n\n\n# copyonwritearraylist为什么并发安全且性能比vector好?\n\nvector对单独的add，remove等方法都是在方法上加了synchronized; 并且如果一个线程a调用size时，另一个线程b 执行了remove，然后size的值就不是最新的，然后线程a调用remove就会越界(这时就需要再加一个synchronized)。这样就导致有了双重锁，效率大大降低，何必呢。于是vector废弃了，要用就用copyonwritearraylist 吧。\n\n\n# 参考文章\n\n * 文章主要参考自leesf的https://www.cnblogs.com/leesf456/p/5547853.html，在此基础上做了增改。\n * https://blog.csdn.net/luozheng4698729/article/details/102824923\n * https://blog.csdn.net/chuanyingcao2675/article/details/101048889\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-copyonwritearraylist.html',charsets:{cjk:!0}},{title:"JUC线程池: FutureTask详解",frontmatter:{},regularPath:"/java/thread/java-thread-x-juc-executor-FutureTask.html",relativePath:"java/thread/java-thread-x-juc-executor-FutureTask.md",key:"v-6690af24",path:"/java/thread/java-thread-x-juc-executor-FutureTask.html",headers:[{level:2,title:"JUC线程池: FutureTask详解",slug:"juc线程池-futuretask详解",normalizedTitle:"juc线程池: futuretask详解",charIndex:2},{level:2,title:"带着BAT大厂的面试问题去理解FutureTask",slug:"带着bat大厂的面试问题去理解futuretask",normalizedTitle:"带着bat大厂的面试问题去理解futuretask",charIndex:177},{level:2,title:"FutureTask简介",slug:"futuretask简介",normalizedTitle:"futuretask简介",charIndex:208},{level:2,title:"FutureTask类关系",slug:"futuretask类关系",normalizedTitle:"futuretask类关系",charIndex:226},{level:2,title:"FutureTask源码解析",slug:"futuretask源码解析",normalizedTitle:"futuretask源码解析",charIndex:245},{level:3,title:"Callable接口",slug:"callable接口",normalizedTitle:"callable接口",charIndex:267},{level:3,title:"Future接口",slug:"future接口",normalizedTitle:"future接口",charIndex:285},{level:3,title:"核心属性",slug:"核心属性",normalizedTitle:"核心属性",charIndex:301},{level:3,title:"构造函数",slug:"构造函数",normalizedTitle:"构造函数",charIndex:313},{level:3,title:"核心方法 - run()",slug:"核心方法-run",normalizedTitle:"核心方法 - run()",charIndex:325},{level:3,title:"核心方法 - get()",slug:"核心方法-get",normalizedTitle:"核心方法 - get()",charIndex:345},{level:3,title:"核心方法 - awaitDone(boolean timed, long nanos)",slug:"核心方法-awaitdone-boolean-timed-long-nanos",normalizedTitle:"核心方法 - awaitdone(boolean timed, long nanos)",charIndex:365},{level:3,title:"核心方法 - cancel(boolean mayInterruptIfRunning)",slug:"核心方法-cancel-boolean-mayinterruptifrunning",normalizedTitle:"核心方法 - cancel(boolean mayinterruptifrunning)",charIndex:416},{level:2,title:"FutureTask示例",slug:"futuretask示例",normalizedTitle:"futuretask示例",charIndex:466},{level:3,title:"Future使用示例",slug:"future使用示例",normalizedTitle:"future使用示例",charIndex:486},{level:3,title:"FutureTask+Thread例子",slug:"futuretask-thread例子",normalizedTitle:"futuretask+thread例子",charIndex:504},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:529}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"JUC线程池: FutureTask详解 带着BAT大厂的面试问题去理解FutureTask FutureTask简介 FutureTask类关系 FutureTask源码解析 Callable接口 Future接口 核心属性 构造函数 核心方法 - run() 核心方法 - get() 核心方法 - awaitDone(boolean timed, long nanos) 核心方法 - cancel(boolean mayInterruptIfRunning) FutureTask示例 Future使用示例 FutureTask+Thread例子 参考文章",content:'# JUC线程池: FutureTask详解\n\n> Future 表示了一个任务的生命周期，是一个可取消的异步运算，可以把它看作是一个异步操作的结果的占位符，它将在未来的某个时刻完成，并提供对其结果的访问。在并发包中许多异步任务类都继承自Future，其中最典型的就是 FutureTask。\n\n * JUC线程池: FutureTask详解\n   * 带着BAT大厂的面试问题去理解FutureTask\n   * FutureTask简介\n   * FutureTask类关系\n   * FutureTask源码解析\n     * Callable接口\n     * Future接口\n     * 核心属性\n     * 构造函数\n     * 核心方法 - run()\n     * 核心方法 - get()\n     * 核心方法 - awaitDone(boolean timed, long nanos)\n     * 核心方法 - cancel(boolean mayInterruptIfRunning)\n   * FutureTask示例\n     * Future使用示例\n     * FutureTask+Thread例子\n   * 参考文章\n\n\n# 带着BAT大厂的面试问题去理解FutureTask\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解FutureTask。\n\n * FutureTask用来解决什么问题的? 为什么会出现?\n * FutureTask类结构关系怎么样的?\n * FutureTask的线程安全是由什么保证的?\n * FutureTask结果返回机制?\n * FutureTask内部运行状态的转变?\n * FutureTask通常会怎么用? 举例说明。\n\n\n# FutureTask简介\n\nFutureTask 为 Future 提供了基础实现，如获取任务执行结果(get)和取消任务(cancel)等。如果任务尚未完成，获取任务执行结果时将会阻塞。一旦执行结束，任务就不能被重启或取消(除非使用runAndReset执行计算)。FutureTask 常用来封装 Callable 和 Runnable，也可以作为一个任务提交到线程池中执行。除了作为一个独立的类之外，此类也提供了一些功能性函数供我们创建自定义 task 类使用。FutureTask 的线程安全由CAS来保证。\n\n\n# FutureTask类关系\n\n\n\n可以看到,FutureTask实现了RunnableFuture接口，则RunnableFuture接口继承了Runnable接口和Future接口，所以FutureTask既能当做一个Runnable直接被Thread执行，也能作为Future用来得到Callable的计算结果。\n\n\n# FutureTask源码解析\n\n\n# Callable接口\n\nCallable是个泛型接口，泛型V就是要call()方法返回的类型。对比Runnable接口，Runnable不会返回数据也不能抛出异常。\n\npublic interface Callable<V> {\n    /**\n     * Computes a result, or throws an exception if unable to do so.\n     *\n     * @return computed result\n     * @throws Exception if unable to compute a result\n     */\n    V call() throws Exception;\n}\n\n\n\n# Future接口\n\nFuture接口代表异步计算的结果，通过Future接口提供的方法可以查看异步计算是否执行完成，或者等待执行结果并获取执行结果，同时还可以取消执行。Future接口的定义如下:\n\npublic interface Future<V> {\n    boolean cancel(boolean mayInterruptIfRunning);\n    boolean isCancelled();\n    boolean isDone();\n    V get() throws InterruptedException, ExecutionException;\n    V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException;\n}\n\n\n * cancel():cancel()方法用来取消异步任务的执行。如果异步任务已经完成或者已经被取消，或者由于某些原因不能取消，则会返回false。如果任务还没有被执行，则会返回true并且异步任务不会被执行。如果任务已经开始执行了但是还没有执行完成，若mayInterruptIfRunning为true，则会立即中断执行任务的线程并返回true，若mayInterruptIfRunning为false，则会返回true且不会中断任务执行线程。\n * isCanceled():判断任务是否被取消，如果任务在结束(正常执行结束或者执行异常结束)前被取消则返回true，否则返回false。\n * isDone():判断任务是否已经完成，如果完成则返回true，否则返回false。需要注意的是：任务执行过程中发生异常、任务被取消也属于任务已完成，也会返回true。\n * get():获取任务执行结果，如果任务还没完成则会阻塞等待直到任务执行完成。如果任务被取消则会抛出CancellationException异常，如果任务执行过程发生异常则会抛出ExecutionException异常，如果阻塞等待过程中被中断则会抛出InterruptedException异常。\n * get(long timeout,Timeunit unit):带超时时间的get()版本，如果阻塞等待过程中超时则会抛出TimeoutException异常。\n\n\n# 核心属性\n\n\n//内部持有的callable任务，运行完毕后置空\nprivate Callable<V> callable;\n\n//从get()中返回的结果或抛出的异常\nprivate Object outcome; // non-volatile, protected by state reads/writes\n\n//运行callable的线程\nprivate volatile Thread runner;\n\n//使用Treiber栈保存等待线程\nprivate volatile WaitNode waiters;\n\n//任务状态\nprivate volatile int state;\nprivate static final int NEW          = 0;\nprivate static final int COMPLETING   = 1;\nprivate static final int NORMAL       = 2;\nprivate static final int EXCEPTIONAL  = 3;\nprivate static final int CANCELLED    = 4;\nprivate static final int INTERRUPTING = 5;\nprivate static final int INTERRUPTED  = 6;\n\n\n其中需要注意的是state是volatile类型的，也就是说只要有任何一个线程修改了这个变量，那么其他所有的线程都会知道最新的值。7种状态具体表示：\n\n * NEW:表示是个新的任务或者还没被执行完的任务。这是初始状态。\n * COMPLETING:任务已经执行完成或者执行任务的时候发生异常，但是任务执行结果或者异常原因还没有保存到outcome字段(outcome字段用来保存任务执行结果，如果发生异常，则用来保存异常原因)的时候，状态会从NEW变更到COMPLETING。但是这个状态会时间会比较短，属于中间状态。\n * NORMAL:任务已经执行完成并且任务执行结果已经保存到outcome字段，状态会从COMPLETING转换到NORMAL。这是一个最终态。\n * EXCEPTIONAL:任务执行发生异常并且异常原因已经保存到outcome字段中后，状态会从COMPLETING转换到EXCEPTIONAL。这是一个最终态。\n * CANCELLED:任务还没开始执行或者已经开始执行但是还没有执行完成的时候，用户调用了cancel(false)方法取消任务且不中断任务执行线程，这个时候状态会从NEW转化为CANCELLED状态。这是一个最终态。\n * INTERRUPTING: 任务还没开始执行或者已经执行但是还没有执行完成的时候，用户调用了cancel(true)方法取消任务并且要中断任务执行线程但是还没有中断任务执行线程之前，状态会从NEW转化为INTERRUPTING。这是一个中间状态。\n * INTERRUPTED:调用interrupt()中断任务执行线程之后状态会从INTERRUPTING转换到INTERRUPTED。这是一个最终态。 有一点需要注意的是，所有值大于COMPLETING的状态都表示任务已经执行完成(任务正常执行完成，任务执行异常或者任务被取消)。\n\n各个状态之间的可能转换关系如下图所示:\n\n\n\n\n# 构造函数\n\n * FutureTask(Callable<V> callable)\n\npublic FutureTask(Callable<V> callable) {\n    if (callable == null)\n        throw new NullPointerException();\n    this.callable = callable;\n    this.state = NEW;       // ensure visibility of callable\n}\n\n\n这个构造函数会把传入的Callable变量保存在this.callable字段中，该字段定义为private Callable<V> callable;用来保存底层的调用，在被执行完成以后会指向null,接着会初始化state字段为NEW。\n\n * FutureTask(Runnable runnable, V result)\n\npublic FutureTask(Runnable runnable, V result) {\n    this.callable = Executors.callable(runnable, result);\n    this.state = NEW;       // ensure visibility of callable\n}\n\n\n这个构造函数会把传入的Runnable封装成一个Callable对象保存在callable字段中，同时如果任务执行成功的话就会返回传入的result。这种情况下如果不需要返回值的话可以传入一个null。\n\n顺带看下Executors.callable()这个方法，这个方法的功能是把Runnable转换成Callable，代码如下:\n\npublic static <T> Callable<T> callable(Runnable task, T result) {\n    if (task == null)\n       throw new NullPointerException();\n    return new RunnableAdapter<T>(task, result);\n}\n\n\n可以看到这里采用的是适配器模式，调用RunnableAdapter<T>(task, result)方法来适配，实现如下:\n\nstatic final class RunnableAdapter<T> implements Callable<T> {\n    final Runnable task;\n    final T result;\n    RunnableAdapter(Runnable task, T result) {\n        this.task = task;\n        this.result = result;\n    }\n    public T call() {\n        task.run();\n        return result;\n    }\n}\n\n\n这个适配器很简单，就是简单的实现了Callable接口，在call()实现中调用Runnable.run()方法，然后把传入的result作为任务的结果返回。\n\n在new了一个FutureTask对象之后，接下来就是在另一个线程中执行这个Task,无论是通过直接new一个Thread还是通过线程池，执行的都是run()方法，接下来就看看run()方法的实现。\n\n\n# 核心方法 - run()\n\npublic void run() {\n    //新建任务，CAS替换runner为当前线程\n    if (state != NEW ||\n        !UNSAFE.compareAndSwapObject(this, runnerOffset,\n                                     null, Thread.currentThread()))\n        return;\n    try {\n        Callable<V> c = callable;\n        if (c != null && state == NEW) {\n            V result;\n            boolean ran;\n            try {\n                result = c.call();\n                ran = true;\n            } catch (Throwable ex) {\n                result = null;\n                ran = false;\n                setException(ex);\n            }\n            if (ran)\n                set(result);//设置执行结果\n        }\n    } finally {\n        // runner must be non-null until state is settled to\n        // prevent concurrent calls to run()\n        runner = null;\n        // state must be re-read after nulling runner to prevent\n        // leaked interrupts\n        int s = state;\n        if (s >= INTERRUPTING)\n            handlePossibleCancellationInterrupt(s);//处理中断逻辑\n    }\n}\n\n\n说明：\n\n * 运行任务，如果任务状态为NEW状态，则利用CAS修改为当前线程。执行完毕调用set(result)方法设置执行结果。set(result)源码如下：\n\nprotected void set(V v) {\n    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n        outcome = v;\n        UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state\n        finishCompletion();//执行完毕，唤醒等待线程\n    }\n}\n\n\n * 首先利用cas修改state状态为COMPLETING，设置返回结果，然后使用 lazySet(UNSAFE.putOrderedInt)的方式设置state状态为NORMAL。结果设置完毕后，调用finishCompletion()方法唤醒等待线程，源码如下：\n\nprivate void finishCompletion() {\n    // assert state > COMPLETING;\n    for (WaitNode q; (q = waiters) != null;) {\n        if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {//移除等待线程\n            for (;;) {//自旋遍历等待线程\n                Thread t = q.thread;\n                if (t != null) {\n                    q.thread = null;\n                    LockSupport.unpark(t);//唤醒等待线程\n                }\n                WaitNode next = q.next;\n                if (next == null)\n                    break;\n                q.next = null; // unlink to help gc\n                q = next;\n            }\n            break;\n        }\n    }\n    //任务完成后调用函数，自定义扩展\n    done();\n\n    callable = null;        // to reduce footprint\n}\n\n\n * 回到run方法，如果在 run 期间被中断，此时需要调用handlePossibleCancellationInterrupt方法来处理中断逻辑，确保任何中断(例如cancel(true))只停留在当前run或runAndReset的任务中，源码如下：\n\nprivate void handlePossibleCancellationInterrupt(int s) {\n    //在中断者中断线程之前可能会延迟，所以我们只需要让出CPU时间片自旋等待\n    if (s == INTERRUPTING)\n        while (state == INTERRUPTING)\n            Thread.yield(); // wait out pending interrupt\n}\n\n\n\n# 核心方法 - get()\n\n//获取执行结果\npublic V get() throws InterruptedException, ExecutionException {\n    int s = state;\n    if (s <= COMPLETING)\n        s = awaitDone(false, 0L);\n    return report(s);\n}\n\n\n说明：FutureTask 通过get()方法获取任务执行结果。如果任务处于未完成的状态(state <= COMPLETING)，就调用awaitDone方法(后面单独讲解)等待任务完成。任务完成后，通过report方法获取执行结果或抛出执行期间的异常。report源码如下：\n\n//返回执行结果或抛出异常\nprivate V report(int s) throws ExecutionException {\n    Object x = outcome;\n    if (s == NORMAL)\n        return (V)x;\n    if (s >= CANCELLED)\n        throw new CancellationException();\n    throw new ExecutionException((Throwable)x);\n}\n\n\n\n# 核心方法 - awaitDone(boolean timed, long nanos)\n\nprivate int awaitDone(boolean timed, long nanos)\n    throws InterruptedException {\n    final long deadline = timed ? System.nanoTime() + nanos : 0L;\n    WaitNode q = null;\n    boolean queued = false;\n    for (;;) {//自旋\n        if (Thread.interrupted()) {//获取并清除中断状态\n            removeWaiter(q);//移除等待WaitNode\n            throw new InterruptedException();\n        }\n\n        int s = state;\n        if (s > COMPLETING) {\n            if (q != null)\n                q.thread = null;//置空等待节点的线程\n            return s;\n        }\n        else if (s == COMPLETING) // cannot time out yet\n            Thread.yield();\n        else if (q == null)\n            q = new WaitNode();\n        else if (!queued)\n            //CAS修改waiter\n            queued = UNSAFE.compareAndSwapObject(this, waitersOffset,\n                                                 q.next = waiters, q);\n        else if (timed) {\n            nanos = deadline - System.nanoTime();\n            if (nanos <= 0L) {\n                removeWaiter(q);//超时，移除等待节点\n                return state;\n            }\n            LockSupport.parkNanos(this, nanos);//阻塞当前线程\n        }\n        else\n            LockSupport.park(this);//阻塞当前线程\n    }\n}\n\n\n说明：awaitDone用于等待任务完成，或任务因为中断或超时而终止。返回任务的完成状态。函数执行逻辑如下：\n\n如果线程被中断，首先清除中断状态，调用removeWaiter移除等待节点，然后抛出InterruptedException。removeWaiter源码如下：\n\nprivate void removeWaiter(WaitNode node) {\n    if (node != null) {\n        node.thread = null;//首先置空线程\n        retry:\n        for (;;) {          // restart on removeWaiter race\n            //依次遍历查找\n            for (WaitNode pred = null, q = waiters, s; q != null; q = s) {\n                s = q.next;\n                if (q.thread != null)\n                    pred = q;\n                else if (pred != null) {\n                    pred.next = s;\n                    if (pred.thread == null) // check for race\n                        continue retry;\n                }\n                else if (!UNSAFE.compareAndSwapObject(this, waitersOffset,q, s)) //cas替换\n                    continue retry;\n            }\n            break;\n        }\n    }\n}\n\n\n * 如果当前状态为结束状态(state>COMPLETING),则根据需要置空等待节点的线程，并返回 Future 状态；\n * 如果当前状态为正在完成(COMPLETING)，说明此时 Future 还不能做出超时动作，为任务让出CPU执行时间片；\n * 如果state为NEW，先新建一个WaitNode，然后CAS修改当前waiters；\n * 如果等待超时，则调用removeWaiter移除等待节点，返回任务状态；如果设置了超时时间但是尚未超时，则park阻塞当前线程；\n * 其他情况直接阻塞当前线程。\n\n\n# 核心方法 - cancel(boolean mayInterruptIfRunning)\n\npublic boolean cancel(boolean mayInterruptIfRunning) {\n    //如果当前Future状态为NEW，根据参数修改Future状态为INTERRUPTING或CANCELLED\n    if (!(state == NEW &&\n          UNSAFE.compareAndSwapInt(this, stateOffset, NEW,\n              mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))\n        return false;\n    try {    // in case call to interrupt throws exception\n        if (mayInterruptIfRunning) {//可以在运行时中断\n            try {\n                Thread t = runner;\n                if (t != null)\n                    t.interrupt();\n            } finally { // final state\n                UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);\n            }\n        }\n    } finally {\n        finishCompletion();//移除并唤醒所有等待线程\n    }\n    return true;\n}\n\n\n说明：尝试取消任务。如果任务已经完成或已经被取消，此操作会失败。\n\n * 如果当前Future状态为NEW，根据参数修改Future状态为INTERRUPTING或CANCELLED。\n * 如果当前状态不为NEW，则根据参数mayInterruptIfRunning决定是否在任务运行中也可以中断。中断操作完成后，调用finishCompletion移除并唤醒所有等待线程。\n\n\n# FutureTask示例\n\n常用使用方式：\n\n * 第一种方式: Future + ExecutorService\n * 第二种方式: FutureTask + ExecutorService\n * 第三种方式: FutureTask + Thread\n\n\n# Future使用示例\n\npublic class FutureDemo {\n      public static void main(String[] args) {\n          ExecutorService executorService = Executors.newCachedThreadPool();\n          Future future = executorService.submit(new Callable<Object>() {\n              @Override\n              public Object call() throws Exception {\n                  Long start = System.currentTimeMillis();\n                  while (true) {\n                      Long current = System.currentTimeMillis();\n                     if ((current - start) > 1000) {\n                         return 1;\n                     }\n                 }\n             }\n         });\n  \n         try {\n             Integer result = (Integer)future.get();\n             System.out.println(result);\n         }catch (Exception e){\n             e.printStackTrace();\n         }\n     }\n}\n\n\n\n# FutureTask+Thread例子\n\nimport java.util.concurrent.*;\n \npublic class CallDemo {\n \n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n \n        /**\n         * 第一种方式:Future + ExecutorService\n         * Task task = new Task();\n         * ExecutorService service = Executors.newCachedThreadPool();\n         * Future<Integer> future = service.submit(task1);\n         * service.shutdown();\n         */\n \n \n        /**\n         * 第二种方式: FutureTask + ExecutorService\n         * ExecutorService executor = Executors.newCachedThreadPool();\n         * Task task = new Task();\n         * FutureTask<Integer> futureTask = new FutureTask<Integer>(task);\n         * executor.submit(futureTask);\n         * executor.shutdown();\n         */\n \n        /**\n         * 第三种方式:FutureTask + Thread\n         */\n \n        // 2. 新建FutureTask,需要一个实现了Callable接口的类的实例作为构造函数参数\n        FutureTask<Integer> futureTask = new FutureTask<Integer>(new Task());\n        // 3. 新建Thread对象并启动\n        Thread thread = new Thread(futureTask);\n        thread.setName("Task thread");\n        thread.start();\n \n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n \n        System.out.println("Thread [" + Thread.currentThread().getName() + "] is running");\n \n        // 4. 调用isDone()判断任务是否结束\n        if(!futureTask.isDone()) {\n            System.out.println("Task is not done");\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        int result = 0;\n        try {\n            // 5. 调用get()方法获取任务结果,如果任务没有执行完成则阻塞等待\n            result = futureTask.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n \n        System.out.println("result is " + result);\n \n    }\n \n    // 1. 继承Callable接口,实现call()方法,泛型参数为要返回的类型\n    static class Task  implements Callable<Integer> {\n \n        @Override\n        public Integer call() throws Exception {\n            System.out.println("Thread [" + Thread.currentThread().getName() + "] is running");\n            int result = 0;\n            for(int i = 0; i < 100;++i) {\n                result += i;\n            }\n \n            Thread.sleep(3000);\n            return result;\n        }\n    }\n}\n\n\n\n# 参考文章\n\n * 本文主要参考了https://www.cnblogs.com/linghu-java/p/8991824.html以及https://www.jianshu.com/p/d61d7ffa6abc，在此基础上增改\n * https://blog.csdn.net/xingzhong128/article/details/80553789\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-executor-FutureTask.html',normalizedContent:'# juc线程池: futuretask详解\n\n> future 表示了一个任务的生命周期，是一个可取消的异步运算，可以把它看作是一个异步操作的结果的占位符，它将在未来的某个时刻完成，并提供对其结果的访问。在并发包中许多异步任务类都继承自future，其中最典型的就是 futuretask。\n\n * juc线程池: futuretask详解\n   * 带着bat大厂的面试问题去理解futuretask\n   * futuretask简介\n   * futuretask类关系\n   * futuretask源码解析\n     * callable接口\n     * future接口\n     * 核心属性\n     * 构造函数\n     * 核心方法 - run()\n     * 核心方法 - get()\n     * 核心方法 - awaitdone(boolean timed, long nanos)\n     * 核心方法 - cancel(boolean mayinterruptifrunning)\n   * futuretask示例\n     * future使用示例\n     * futuretask+thread例子\n   * 参考文章\n\n\n# 带着bat大厂的面试问题去理解futuretask\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解futuretask。\n\n * futuretask用来解决什么问题的? 为什么会出现?\n * futuretask类结构关系怎么样的?\n * futuretask的线程安全是由什么保证的?\n * futuretask结果返回机制?\n * futuretask内部运行状态的转变?\n * futuretask通常会怎么用? 举例说明。\n\n\n# futuretask简介\n\nfuturetask 为 future 提供了基础实现，如获取任务执行结果(get)和取消任务(cancel)等。如果任务尚未完成，获取任务执行结果时将会阻塞。一旦执行结束，任务就不能被重启或取消(除非使用runandreset执行计算)。futuretask 常用来封装 callable 和 runnable，也可以作为一个任务提交到线程池中执行。除了作为一个独立的类之外，此类也提供了一些功能性函数供我们创建自定义 task 类使用。futuretask 的线程安全由cas来保证。\n\n\n# futuretask类关系\n\n\n\n可以看到,futuretask实现了runnablefuture接口，则runnablefuture接口继承了runnable接口和future接口，所以futuretask既能当做一个runnable直接被thread执行，也能作为future用来得到callable的计算结果。\n\n\n# futuretask源码解析\n\n\n# callable接口\n\ncallable是个泛型接口，泛型v就是要call()方法返回的类型。对比runnable接口，runnable不会返回数据也不能抛出异常。\n\npublic interface callable<v> {\n    /**\n     * computes a result, or throws an exception if unable to do so.\n     *\n     * @return computed result\n     * @throws exception if unable to compute a result\n     */\n    v call() throws exception;\n}\n\n\n\n# future接口\n\nfuture接口代表异步计算的结果，通过future接口提供的方法可以查看异步计算是否执行完成，或者等待执行结果并获取执行结果，同时还可以取消执行。future接口的定义如下:\n\npublic interface future<v> {\n    boolean cancel(boolean mayinterruptifrunning);\n    boolean iscancelled();\n    boolean isdone();\n    v get() throws interruptedexception, executionexception;\n    v get(long timeout, timeunit unit)\n        throws interruptedexception, executionexception, timeoutexception;\n}\n\n\n * cancel():cancel()方法用来取消异步任务的执行。如果异步任务已经完成或者已经被取消，或者由于某些原因不能取消，则会返回false。如果任务还没有被执行，则会返回true并且异步任务不会被执行。如果任务已经开始执行了但是还没有执行完成，若mayinterruptifrunning为true，则会立即中断执行任务的线程并返回true，若mayinterruptifrunning为false，则会返回true且不会中断任务执行线程。\n * iscanceled():判断任务是否被取消，如果任务在结束(正常执行结束或者执行异常结束)前被取消则返回true，否则返回false。\n * isdone():判断任务是否已经完成，如果完成则返回true，否则返回false。需要注意的是：任务执行过程中发生异常、任务被取消也属于任务已完成，也会返回true。\n * get():获取任务执行结果，如果任务还没完成则会阻塞等待直到任务执行完成。如果任务被取消则会抛出cancellationexception异常，如果任务执行过程发生异常则会抛出executionexception异常，如果阻塞等待过程中被中断则会抛出interruptedexception异常。\n * get(long timeout,timeunit unit):带超时时间的get()版本，如果阻塞等待过程中超时则会抛出timeoutexception异常。\n\n\n# 核心属性\n\n\n//内部持有的callable任务，运行完毕后置空\nprivate callable<v> callable;\n\n//从get()中返回的结果或抛出的异常\nprivate object outcome; // non-volatile, protected by state reads/writes\n\n//运行callable的线程\nprivate volatile thread runner;\n\n//使用treiber栈保存等待线程\nprivate volatile waitnode waiters;\n\n//任务状态\nprivate volatile int state;\nprivate static final int new          = 0;\nprivate static final int completing   = 1;\nprivate static final int normal       = 2;\nprivate static final int exceptional  = 3;\nprivate static final int cancelled    = 4;\nprivate static final int interrupting = 5;\nprivate static final int interrupted  = 6;\n\n\n其中需要注意的是state是volatile类型的，也就是说只要有任何一个线程修改了这个变量，那么其他所有的线程都会知道最新的值。7种状态具体表示：\n\n * new:表示是个新的任务或者还没被执行完的任务。这是初始状态。\n * completing:任务已经执行完成或者执行任务的时候发生异常，但是任务执行结果或者异常原因还没有保存到outcome字段(outcome字段用来保存任务执行结果，如果发生异常，则用来保存异常原因)的时候，状态会从new变更到completing。但是这个状态会时间会比较短，属于中间状态。\n * normal:任务已经执行完成并且任务执行结果已经保存到outcome字段，状态会从completing转换到normal。这是一个最终态。\n * exceptional:任务执行发生异常并且异常原因已经保存到outcome字段中后，状态会从completing转换到exceptional。这是一个最终态。\n * cancelled:任务还没开始执行或者已经开始执行但是还没有执行完成的时候，用户调用了cancel(false)方法取消任务且不中断任务执行线程，这个时候状态会从new转化为cancelled状态。这是一个最终态。\n * interrupting: 任务还没开始执行或者已经执行但是还没有执行完成的时候，用户调用了cancel(true)方法取消任务并且要中断任务执行线程但是还没有中断任务执行线程之前，状态会从new转化为interrupting。这是一个中间状态。\n * interrupted:调用interrupt()中断任务执行线程之后状态会从interrupting转换到interrupted。这是一个最终态。 有一点需要注意的是，所有值大于completing的状态都表示任务已经执行完成(任务正常执行完成，任务执行异常或者任务被取消)。\n\n各个状态之间的可能转换关系如下图所示:\n\n\n\n\n# 构造函数\n\n * futuretask(callable<v> callable)\n\npublic futuretask(callable<v> callable) {\n    if (callable == null)\n        throw new nullpointerexception();\n    this.callable = callable;\n    this.state = new;       // ensure visibility of callable\n}\n\n\n这个构造函数会把传入的callable变量保存在this.callable字段中，该字段定义为private callable<v> callable;用来保存底层的调用，在被执行完成以后会指向null,接着会初始化state字段为new。\n\n * futuretask(runnable runnable, v result)\n\npublic futuretask(runnable runnable, v result) {\n    this.callable = executors.callable(runnable, result);\n    this.state = new;       // ensure visibility of callable\n}\n\n\n这个构造函数会把传入的runnable封装成一个callable对象保存在callable字段中，同时如果任务执行成功的话就会返回传入的result。这种情况下如果不需要返回值的话可以传入一个null。\n\n顺带看下executors.callable()这个方法，这个方法的功能是把runnable转换成callable，代码如下:\n\npublic static <t> callable<t> callable(runnable task, t result) {\n    if (task == null)\n       throw new nullpointerexception();\n    return new runnableadapter<t>(task, result);\n}\n\n\n可以看到这里采用的是适配器模式，调用runnableadapter<t>(task, result)方法来适配，实现如下:\n\nstatic final class runnableadapter<t> implements callable<t> {\n    final runnable task;\n    final t result;\n    runnableadapter(runnable task, t result) {\n        this.task = task;\n        this.result = result;\n    }\n    public t call() {\n        task.run();\n        return result;\n    }\n}\n\n\n这个适配器很简单，就是简单的实现了callable接口，在call()实现中调用runnable.run()方法，然后把传入的result作为任务的结果返回。\n\n在new了一个futuretask对象之后，接下来就是在另一个线程中执行这个task,无论是通过直接new一个thread还是通过线程池，执行的都是run()方法，接下来就看看run()方法的实现。\n\n\n# 核心方法 - run()\n\npublic void run() {\n    //新建任务，cas替换runner为当前线程\n    if (state != new ||\n        !unsafe.compareandswapobject(this, runneroffset,\n                                     null, thread.currentthread()))\n        return;\n    try {\n        callable<v> c = callable;\n        if (c != null && state == new) {\n            v result;\n            boolean ran;\n            try {\n                result = c.call();\n                ran = true;\n            } catch (throwable ex) {\n                result = null;\n                ran = false;\n                setexception(ex);\n            }\n            if (ran)\n                set(result);//设置执行结果\n        }\n    } finally {\n        // runner must be non-null until state is settled to\n        // prevent concurrent calls to run()\n        runner = null;\n        // state must be re-read after nulling runner to prevent\n        // leaked interrupts\n        int s = state;\n        if (s >= interrupting)\n            handlepossiblecancellationinterrupt(s);//处理中断逻辑\n    }\n}\n\n\n说明：\n\n * 运行任务，如果任务状态为new状态，则利用cas修改为当前线程。执行完毕调用set(result)方法设置执行结果。set(result)源码如下：\n\nprotected void set(v v) {\n    if (unsafe.compareandswapint(this, stateoffset, new, completing)) {\n        outcome = v;\n        unsafe.putorderedint(this, stateoffset, normal); // final state\n        finishcompletion();//执行完毕，唤醒等待线程\n    }\n}\n\n\n * 首先利用cas修改state状态为completing，设置返回结果，然后使用 lazyset(unsafe.putorderedint)的方式设置state状态为normal。结果设置完毕后，调用finishcompletion()方法唤醒等待线程，源码如下：\n\nprivate void finishcompletion() {\n    // assert state > completing;\n    for (waitnode q; (q = waiters) != null;) {\n        if (unsafe.compareandswapobject(this, waitersoffset, q, null)) {//移除等待线程\n            for (;;) {//自旋遍历等待线程\n                thread t = q.thread;\n                if (t != null) {\n                    q.thread = null;\n                    locksupport.unpark(t);//唤醒等待线程\n                }\n                waitnode next = q.next;\n                if (next == null)\n                    break;\n                q.next = null; // unlink to help gc\n                q = next;\n            }\n            break;\n        }\n    }\n    //任务完成后调用函数，自定义扩展\n    done();\n\n    callable = null;        // to reduce footprint\n}\n\n\n * 回到run方法，如果在 run 期间被中断，此时需要调用handlepossiblecancellationinterrupt方法来处理中断逻辑，确保任何中断(例如cancel(true))只停留在当前run或runandreset的任务中，源码如下：\n\nprivate void handlepossiblecancellationinterrupt(int s) {\n    //在中断者中断线程之前可能会延迟，所以我们只需要让出cpu时间片自旋等待\n    if (s == interrupting)\n        while (state == interrupting)\n            thread.yield(); // wait out pending interrupt\n}\n\n\n\n# 核心方法 - get()\n\n//获取执行结果\npublic v get() throws interruptedexception, executionexception {\n    int s = state;\n    if (s <= completing)\n        s = awaitdone(false, 0l);\n    return report(s);\n}\n\n\n说明：futuretask 通过get()方法获取任务执行结果。如果任务处于未完成的状态(state <= completing)，就调用awaitdone方法(后面单独讲解)等待任务完成。任务完成后，通过report方法获取执行结果或抛出执行期间的异常。report源码如下：\n\n//返回执行结果或抛出异常\nprivate v report(int s) throws executionexception {\n    object x = outcome;\n    if (s == normal)\n        return (v)x;\n    if (s >= cancelled)\n        throw new cancellationexception();\n    throw new executionexception((throwable)x);\n}\n\n\n\n# 核心方法 - awaitdone(boolean timed, long nanos)\n\nprivate int awaitdone(boolean timed, long nanos)\n    throws interruptedexception {\n    final long deadline = timed ? system.nanotime() + nanos : 0l;\n    waitnode q = null;\n    boolean queued = false;\n    for (;;) {//自旋\n        if (thread.interrupted()) {//获取并清除中断状态\n            removewaiter(q);//移除等待waitnode\n            throw new interruptedexception();\n        }\n\n        int s = state;\n        if (s > completing) {\n            if (q != null)\n                q.thread = null;//置空等待节点的线程\n            return s;\n        }\n        else if (s == completing) // cannot time out yet\n            thread.yield();\n        else if (q == null)\n            q = new waitnode();\n        else if (!queued)\n            //cas修改waiter\n            queued = unsafe.compareandswapobject(this, waitersoffset,\n                                                 q.next = waiters, q);\n        else if (timed) {\n            nanos = deadline - system.nanotime();\n            if (nanos <= 0l) {\n                removewaiter(q);//超时，移除等待节点\n                return state;\n            }\n            locksupport.parknanos(this, nanos);//阻塞当前线程\n        }\n        else\n            locksupport.park(this);//阻塞当前线程\n    }\n}\n\n\n说明：awaitdone用于等待任务完成，或任务因为中断或超时而终止。返回任务的完成状态。函数执行逻辑如下：\n\n如果线程被中断，首先清除中断状态，调用removewaiter移除等待节点，然后抛出interruptedexception。removewaiter源码如下：\n\nprivate void removewaiter(waitnode node) {\n    if (node != null) {\n        node.thread = null;//首先置空线程\n        retry:\n        for (;;) {          // restart on removewaiter race\n            //依次遍历查找\n            for (waitnode pred = null, q = waiters, s; q != null; q = s) {\n                s = q.next;\n                if (q.thread != null)\n                    pred = q;\n                else if (pred != null) {\n                    pred.next = s;\n                    if (pred.thread == null) // check for race\n                        continue retry;\n                }\n                else if (!unsafe.compareandswapobject(this, waitersoffset,q, s)) //cas替换\n                    continue retry;\n            }\n            break;\n        }\n    }\n}\n\n\n * 如果当前状态为结束状态(state>completing),则根据需要置空等待节点的线程，并返回 future 状态；\n * 如果当前状态为正在完成(completing)，说明此时 future 还不能做出超时动作，为任务让出cpu执行时间片；\n * 如果state为new，先新建一个waitnode，然后cas修改当前waiters；\n * 如果等待超时，则调用removewaiter移除等待节点，返回任务状态；如果设置了超时时间但是尚未超时，则park阻塞当前线程；\n * 其他情况直接阻塞当前线程。\n\n\n# 核心方法 - cancel(boolean mayinterruptifrunning)\n\npublic boolean cancel(boolean mayinterruptifrunning) {\n    //如果当前future状态为new，根据参数修改future状态为interrupting或cancelled\n    if (!(state == new &&\n          unsafe.compareandswapint(this, stateoffset, new,\n              mayinterruptifrunning ? interrupting : cancelled)))\n        return false;\n    try {    // in case call to interrupt throws exception\n        if (mayinterruptifrunning) {//可以在运行时中断\n            try {\n                thread t = runner;\n                if (t != null)\n                    t.interrupt();\n            } finally { // final state\n                unsafe.putorderedint(this, stateoffset, interrupted);\n            }\n        }\n    } finally {\n        finishcompletion();//移除并唤醒所有等待线程\n    }\n    return true;\n}\n\n\n说明：尝试取消任务。如果任务已经完成或已经被取消，此操作会失败。\n\n * 如果当前future状态为new，根据参数修改future状态为interrupting或cancelled。\n * 如果当前状态不为new，则根据参数mayinterruptifrunning决定是否在任务运行中也可以中断。中断操作完成后，调用finishcompletion移除并唤醒所有等待线程。\n\n\n# futuretask示例\n\n常用使用方式：\n\n * 第一种方式: future + executorservice\n * 第二种方式: futuretask + executorservice\n * 第三种方式: futuretask + thread\n\n\n# future使用示例\n\npublic class futuredemo {\n      public static void main(string[] args) {\n          executorservice executorservice = executors.newcachedthreadpool();\n          future future = executorservice.submit(new callable<object>() {\n              @override\n              public object call() throws exception {\n                  long start = system.currenttimemillis();\n                  while (true) {\n                      long current = system.currenttimemillis();\n                     if ((current - start) > 1000) {\n                         return 1;\n                     }\n                 }\n             }\n         });\n  \n         try {\n             integer result = (integer)future.get();\n             system.out.println(result);\n         }catch (exception e){\n             e.printstacktrace();\n         }\n     }\n}\n\n\n\n# futuretask+thread例子\n\nimport java.util.concurrent.*;\n \npublic class calldemo {\n \n    public static void main(string[] args) throws executionexception, interruptedexception {\n \n        /**\n         * 第一种方式:future + executorservice\n         * task task = new task();\n         * executorservice service = executors.newcachedthreadpool();\n         * future<integer> future = service.submit(task1);\n         * service.shutdown();\n         */\n \n \n        /**\n         * 第二种方式: futuretask + executorservice\n         * executorservice executor = executors.newcachedthreadpool();\n         * task task = new task();\n         * futuretask<integer> futuretask = new futuretask<integer>(task);\n         * executor.submit(futuretask);\n         * executor.shutdown();\n         */\n \n        /**\n         * 第三种方式:futuretask + thread\n         */\n \n        // 2. 新建futuretask,需要一个实现了callable接口的类的实例作为构造函数参数\n        futuretask<integer> futuretask = new futuretask<integer>(new task());\n        // 3. 新建thread对象并启动\n        thread thread = new thread(futuretask);\n        thread.setname("task thread");\n        thread.start();\n \n        try {\n            thread.sleep(1000);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n \n        system.out.println("thread [" + thread.currentthread().getname() + "] is running");\n \n        // 4. 调用isdone()判断任务是否结束\n        if(!futuretask.isdone()) {\n            system.out.println("task is not done");\n            try {\n                thread.sleep(2000);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }\n        int result = 0;\n        try {\n            // 5. 调用get()方法获取任务结果,如果任务没有执行完成则阻塞等待\n            result = futuretask.get();\n        } catch (exception e) {\n            e.printstacktrace();\n        }\n \n        system.out.println("result is " + result);\n \n    }\n \n    // 1. 继承callable接口,实现call()方法,泛型参数为要返回的类型\n    static class task  implements callable<integer> {\n \n        @override\n        public integer call() throws exception {\n            system.out.println("thread [" + thread.currentthread().getname() + "] is running");\n            int result = 0;\n            for(int i = 0; i < 100;++i) {\n                result += i;\n            }\n \n            thread.sleep(3000);\n            return result;\n        }\n    }\n}\n\n\n\n# 参考文章\n\n * 本文主要参考了https://www.cnblogs.com/linghu-java/p/8991824.html以及https://www.jianshu.com/p/d61d7ffa6abc，在此基础上增改\n * https://blog.csdn.net/xingzhong128/article/details/80553789\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-executor-futuretask.html',charsets:{cjk:!0}},{title:"JUC线程池: ScheduledThreadPoolExecutor详解",frontmatter:{},regularPath:"/java/thread/java-thread-x-juc-executor-ScheduledThreadPoolExecutor.html",relativePath:"java/thread/java-thread-x-juc-executor-ScheduledThreadPoolExecutor.md",key:"v-039b744e",path:"/java/thread/java-thread-x-juc-executor-ScheduledThreadPoolExecutor.html",headers:[{level:2,title:"JUC线程池: ScheduledThreadPoolExecutor详解",slug:"juc线程池-scheduledthreadpoolexecutor详解",normalizedTitle:"juc线程池: scheduledthreadpoolexecutor详解",charIndex:2},{level:2,title:"带着BAT大厂的面试问题去理解ScheduledThreadPoolExecutor",slug:"带着bat大厂的面试问题去理解scheduledthreadpoolexecutor",normalizedTitle:"带着bat大厂的面试问题去理解scheduledthreadpoolexecutor",charIndex:328},{level:2,title:"ScheduledThreadPoolExecutor简介",slug:"scheduledthreadpoolexecutor简介",normalizedTitle:"scheduledthreadpoolexecutor简介",charIndex:376},{level:2,title:"ScheduledThreadPoolExecutor数据结构",slug:"scheduledthreadpoolexecutor数据结构",normalizedTitle:"scheduledthreadpoolexecutor数据结构",charIndex:411},{level:2,title:"ScheduledThreadPoolExecutor源码解析",slug:"scheduledthreadpoolexecutor源码解析",normalizedTitle:"scheduledthreadpoolexecutor源码解析",charIndex:448},{level:3,title:"内部类ScheduledFutureTask",slug:"内部类scheduledfuturetask",normalizedTitle:"内部类scheduledfuturetask",charIndex:487},{level:3,title:"核心属性",slug:"核心属性",normalizedTitle:"核心属性",charIndex:566},{level:3,title:"构造函数",slug:"构造函数",normalizedTitle:"构造函数",charIndex:578},{level:3,title:"核心方法:Schedule",slug:"核心方法-schedule",normalizedTitle:"核心方法:schedule",charIndex:590},{level:3,title:"核心方法:scheduleAtFixedRate 和 scheduleWithFixedDelay",slug:"核心方法-scheduleatfixedrate-和-schedulewithfixeddelay",normalizedTitle:"核心方法:scheduleatfixedrate 和 schedulewithfixeddelay",charIndex:611},{level:3,title:"核心方法:shutdown()",slug:"核心方法-shutdown",normalizedTitle:"核心方法:shutdown()",charIndex:668},{level:2,title:"再深入理解",slug:"再深入理解",normalizedTitle:"再深入理解",charIndex:689},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:700}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"JUC线程池: ScheduledThreadPoolExecutor详解 带着BAT大厂的面试问题去理解ScheduledThreadPoolExecutor ScheduledThreadPoolExecutor简介 ScheduledThreadPoolExecutor数据结构 ScheduledThreadPoolExecutor源码解析 内部类ScheduledFutureTask 核心属性 构造函数 核心方法:Schedule 核心方法:scheduleAtFixedRate 和 scheduleWithFixedDelay 核心方法:shutdown() 再深入理解 参考文章",content:"# JUC线程池: ScheduledThreadPoolExecutor详解\n\n> 在很多业务场景中，我们可能需要周期性的运行某项任务来获取结果，比如周期数据统计，定时发送数据等。在并发包出现之前，Java 早在1.3就提供了 Timer 类(只需要了解，目前已渐渐被 ScheduledThreadPoolExecutor 代替)来适应这些业务场景。随着业务量的不断增大，我们可能需要多个工作线程运行任务来尽可能的增加产品性能，或者是需要更高的灵活性来控制和监控这些周期业务。这些都是 ScheduledThreadPoolExecutor 诞生的必然性。\n\n * JUC线程池: ScheduledThreadPoolExecutor详解\n   * 带着BAT大厂的面试问题去理解ScheduledThreadPoolExecutor\n   * ScheduledThreadPoolExecutor简介\n   * ScheduledThreadPoolExecutor数据结构\n   * ScheduledThreadPoolExecutor源码解析\n     * 内部类ScheduledFutureTask\n       * 属性\n       * 核心方法run()\n       * cancel方法\n     * 核心属性\n     * 构造函数\n     * 核心方法:Schedule\n     * 核心方法:scheduleAtFixedRate 和 scheduleWithFixedDelay\n     * 核心方法:shutdown()\n   * 再深入理解\n   * 参考文章\n\n\n# 带着BAT大厂的面试问题去理解ScheduledThreadPoolExecutor\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解ScheduledThreadPoolExecutor。\n\n * ScheduledThreadPoolExecutor要解决什么样的问题?\n * ScheduledThreadPoolExecutor相比ThreadPoolExecutor有哪些特性?\n * ScheduledThreadPoolExecutor有什么样的数据结构，核心内部类和抽象类?\n * ScheduledThreadPoolExecutor有哪两个关闭策略? 区别是什么?\n * ScheduledThreadPoolExecutor中scheduleAtFixedRate 和 scheduleWithFixedDelay区别是什么?\n * 为什么ThreadPoolExecutor 的调整策略却不适用于 ScheduledThreadPoolExecutor?\n * Executors 提供了几种方法来构造 ScheduledThreadPoolExecutor?\n\n\n# ScheduledThreadPoolExecutor简介\n\nScheduledThreadPoolExecutor继承自 ThreadPoolExecutor，为任务提供延迟或周期执行，属于线程池的一种。和 ThreadPoolExecutor 相比，它还具有以下几种特性:\n\n * 使用专门的任务类型—ScheduledFutureTask 来执行周期任务，也可以接收不需要时间调度的任务(这些任务通过 ExecutorService 来执行)。\n * 使用专门的存储队列—DelayedWorkQueue 来存储任务，DelayedWorkQueue 是无界延迟队列DelayQueue 的一种。相比ThreadPoolExecutor也简化了执行机制(delayedExecute方法，后面单独分析)。\n * 支持可选的run-after-shutdown参数，在池被关闭(shutdown)之后支持可选的逻辑来决定是否继续运行周期或延迟任务。并且当任务(重新)提交操作与 shutdown 操作重叠时，复查逻辑也不相同。\n\n\n# ScheduledThreadPoolExecutor数据结构\n\n\n\nScheduledThreadPoolExecutor继承自 ThreadPoolExecutor:\n\n * 详情请参考: JUC线程池: ThreadPoolExecutor详解\n\nScheduledThreadPoolExecutor 内部构造了两个内部类 ScheduledFutureTask 和 DelayedWorkQueue:\n\n * ScheduledFutureTask: 继承了FutureTask，说明是一个异步运算任务；最上层分别实现了Runnable、Future、Delayed接口，说明它是一个可以延迟执行的异步运算任务。\n\n * DelayedWorkQueue: 这是 ScheduledThreadPoolExecutor 为存储周期或延迟任务专门定义的一个延迟队列，继承了 AbstractQueue，为了契合 ThreadPoolExecutor 也实现了 BlockingQueue 接口。它内部只允许存储 RunnableScheduledFuture 类型的任务。与 DelayQueue 的不同之处就是它只允许存放 RunnableScheduledFuture 对象，并且自己实现了二叉堆(DelayQueue 是利用了 PriorityQueue 的二叉堆结构)。\n\n\n# ScheduledThreadPoolExecutor源码解析\n\n> 以下源码的解析是基于你已经理解了FutureTask。\n\n\n# 内部类ScheduledFutureTask\n\n# 属性\n\n//为相同延时任务提供的顺序编号\nprivate final long sequenceNumber;\n\n//任务可以执行的时间，纳秒级\nprivate long time;\n\n//重复任务的执行周期时间，纳秒级。\nprivate final long period;\n\n//重新入队的任务\nRunnableScheduledFuture<V> outerTask = this;\n\n//延迟队列的索引，以支持更快的取消操作\nint heapIndex;\n\n\n * sequenceNumber: 当两个任务有相同的延迟时间时，按照 FIFO 的顺序入队。sequenceNumber 就是为相同延时任务提供的顺序编号。\n * time: 任务可以执行时的时间，纳秒级，通过triggerTime方法计算得出。\n * period: 任务的执行周期时间，纳秒级。正数表示固定速率执行(为scheduleAtFixedRate提供服务)，负数表示固定延迟执行(为scheduleWithFixedDelay提供服务)，0表示不重复任务。\n * outerTask: 重新入队的任务，通过reExecutePeriodic方法入队重新排序。\n\n# 核心方法run()\n\npublic void run() {\n    boolean periodic = isPeriodic();//是否为周期任务\n    if (!canRunInCurrentRunState(periodic))//当前状态是否可以执行\n        cancel(false);\n    else if (!periodic)\n        //不是周期任务，直接执行\n        ScheduledFutureTask.super.run();\n    else if (ScheduledFutureTask.super.runAndReset()) {\n        setNextRunTime();//设置下一次运行时间\n        reExecutePeriodic(outerTask);//重排序一个周期任务\n    }\n}\n\n\n说明: ScheduledFutureTask 的run方法重写了 FutureTask 的版本，以便执行周期任务时重置/重排序任务。任务的执行通过父类 FutureTask 的run实现。内部有两个针对周期任务的方法:\n\n * setNextRunTime(): 用来设置下一次运行的时间，源码如下:\n\n//设置下一次执行任务的时间\nprivate void setNextRunTime() {\n    long p = period;\n    if (p > 0)  //固定速率执行，scheduleAtFixedRate\n        time += p;\n    else\n        time = triggerTime(-p);  //固定延迟执行，scheduleWithFixedDelay\n}\n//计算固定延迟任务的执行时间\nlong triggerTime(long delay) {\n    return now() +\n        ((delay < (Long.MAX_VALUE >> 1)) ? delay : overflowFree(delay));\n}\n\n\n * reExecutePeriodic(): 周期任务重新入队等待下一次执行，源码如下:\n\n//重排序一个周期任务\nvoid reExecutePeriodic(RunnableScheduledFuture<?> task) {\n    if (canRunInCurrentRunState(true)) {//池关闭后可继续执行\n        super.getQueue().add(task);//任务入列\n        //重新检查run-after-shutdown参数，如果不能继续运行就移除队列任务，并取消任务的执行\n        if (!canRunInCurrentRunState(true) && remove(task))\n            task.cancel(false);\n        else\n            ensurePrestart();//启动一个新的线程等待任务\n    }\n}\n\n\nreExecutePeriodic与delayedExecute的执行策略一致，只不过reExecutePeriodic不会执行拒绝策略而是直接丢掉任务。\n\n# cancel方法\n\npublic boolean cancel(boolean mayInterruptIfRunning) {\n    boolean cancelled = super.cancel(mayInterruptIfRunning);\n    if (cancelled && removeOnCancel && heapIndex >= 0)\n        remove(this);\n    return cancelled;\n}\n\n\nScheduledFutureTask.cancel本质上由其父类 FutureTask.cancel 实现。取消任务成功后会根据removeOnCancel参数决定是否从队列中移除此任务。\n\n\n# 核心属性\n\n//关闭后继续执行已经存在的周期任务 \nprivate volatile boolean continueExistingPeriodicTasksAfterShutdown;\n\n//关闭后继续执行已经存在的延时任务 \nprivate volatile boolean executeExistingDelayedTasksAfterShutdown = true;\n\n//取消任务后移除 \nprivate volatile boolean removeOnCancel = false;\n\n//为相同延时的任务提供的顺序编号，保证任务之间的FIFO顺序\nprivate static final AtomicLong sequencer = new AtomicLong();\n\n\n\n * continueExistingPeriodicTasksAfterShutdown和executeExistingDelayedTasksAfterShutdown是 ScheduledThreadPoolExecutor 定义的 run-after-shutdown 参数，用来控制池关闭之后的任务执行逻辑。\n\n * removeOnCancel用来控制任务取消后是否从队列中移除。当一个已经提交的周期或延迟任务在运行之前被取消，那么它之后将不会运行。默认配置下，这种已经取消的任务在届期之前不会被移除。 通过这种机制，可以方便检查和监控线程池状态，但也可能导致已经取消的任务无限滞留。为了避免这种情况的发生，我们可以通过setRemoveOnCancelPolicy方法设置移除策略，把参数removeOnCancel设为true可以在任务取消后立即从队列中移除。\n\n * sequencer是为相同延时的任务提供的顺序编号，保证任务之间的 FIFO 顺序。与 ScheduledFutureTask 内部的sequenceNumber参数作用一致。\n\n\n# 构造函数\n\n首先看下构造函数，ScheduledThreadPoolExecutor 内部有四个构造函数，这里我们只看这个最大构造灵活度的:\n\npublic ScheduledThreadPoolExecutor(int corePoolSize,\n                                   ThreadFactory threadFactory,\n                                   RejectedExecutionHandler handler) {\n    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n          new DelayedWorkQueue(), threadFactory, handler);\n}\n\n\n构造函数都是通过super调用了ThreadPoolExecutor的构造，并且使用特定等待队列DelayedWorkQueue。\n\n\n# 核心方法:Schedule\n\npublic <V> ScheduledFuture<V> schedule(Callable<V> callable,\n                                       long delay,\n                                       TimeUnit unit) {\n    if (callable == null || unit == null)\n        throw new NullPointerException();\n    RunnableScheduledFuture<V> t = decorateTask(callable,\n        new ScheduledFutureTask<V>(callable, triggerTime(delay, unit)));//构造ScheduledFutureTask任务\n    delayedExecute(t);//任务执行主方法\n    return t;\n}\n\n\n说明: schedule主要用于执行一次性(延迟)任务。函数执行逻辑分两步:\n\n * 封装 Callable/Runnable: 首先通过triggerTime计算任务的延迟执行时间，然后通过 ScheduledFutureTask 的构造函数把 Runnable/Callable 任务构造为ScheduledThreadPoolExecutor可以执行的任务类型，最后调用decorateTask方法执行用户自定义的逻辑；decorateTask是一个用户可自定义扩展的方法，默认实现下直接返回封装的RunnableScheduledFuture任务，源码如下:\n\nprotected <V> RunnableScheduledFuture<V> decorateTask(\n    Runnable runnable, RunnableScheduledFuture<V> task) {\n    return task;\n}\n\n\n * 执行任务: 通过delayedExecute实现。下面我们来详细分析。\n\nprivate void delayedExecute(RunnableScheduledFuture<?> task) {\n    if (isShutdown())\n        reject(task);//池已关闭，执行拒绝策略\n    else {\n        super.getQueue().add(task);//任务入队\n        if (isShutdown() &&\n            !canRunInCurrentRunState(task.isPeriodic()) &&//判断run-after-shutdown参数\n            remove(task))//移除任务\n            task.cancel(false);\n        else\n            ensurePrestart();//启动一个新的线程等待任务\n    }\n}\n\n\n说明: delayedExecute是执行任务的主方法，方法执行逻辑如下:\n\n * 如果池已关闭(ctl >= SHUTDOWN)，执行任务拒绝策略；\n * 池正在运行，首先把任务入队排序；然后重新检查池的关闭状态，执行如下逻辑:\n\nA: 如果池正在运行，或者 run-after-shutdown 参数值为true，则调用父类方法ensurePrestart启动一个新的线程等待执行任务。ensurePrestart源码如下:\n\nvoid ensurePrestart() {\n    int wc = workerCountOf(ctl.get());\n    if (wc < corePoolSize)\n        addWorker(null, true);\n    else if (wc == 0)\n        addWorker(null, false);\n}\n\n\nensurePrestart是父类 ThreadPoolExecutor 的方法，用于启动一个新的工作线程等待执行任务，即使corePoolSize为0也会安排一个新线程。\n\nB: 如果池已经关闭，并且 run-after-shutdown 参数值为false，则执行父类(ThreadPoolExecutor)方法remove移除队列中的指定任务，成功移除后调用ScheduledFutureTask.cancel取消任务\n\n\n# 核心方法:scheduleAtFixedRate 和 scheduleWithFixedDelay\n\n/**\n * 创建一个周期执行的任务，第一次执行延期时间为initialDelay，\n * 之后每隔period执行一次，不等待第一次执行完成就开始计时\n */\npublic ScheduledFuture<?> scheduleAtFixedRate(Runnable command,\n                                              long initialDelay,\n                                              long period,\n                                              TimeUnit unit) {\n    if (command == null || unit == null)\n        throw new NullPointerException();\n    if (period <= 0)\n        throw new IllegalArgumentException();\n    //构建RunnableScheduledFuture任务类型\n    ScheduledFutureTask<Void> sft =\n        new ScheduledFutureTask<Void>(command,\n                                      null,\n                                      triggerTime(initialDelay, unit),//计算任务的延迟时间\n                                      unit.toNanos(period));//计算任务的执行周期\n    RunnableScheduledFuture<Void> t = decorateTask(command, sft);//执行用户自定义逻辑\n    sft.outerTask = t;//赋值给outerTask，准备重新入队等待下一次执行\n    delayedExecute(t);//执行任务\n    return t;\n}\n\n/**\n * 创建一个周期执行的任务，第一次执行延期时间为initialDelay，\n * 在第一次执行完之后延迟delay后开始下一次执行\n */\npublic ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,\n                                                 long initialDelay,\n                                                 long delay,\n                                                 TimeUnit unit) {\n    if (command == null || unit == null)\n        throw new NullPointerException();\n    if (delay <= 0)\n        throw new IllegalArgumentException();\n    //构建RunnableScheduledFuture任务类型\n    ScheduledFutureTask<Void> sft =\n        new ScheduledFutureTask<Void>(command,\n                                      null,\n                                      triggerTime(initialDelay, unit),//计算任务的延迟时间\n                                      unit.toNanos(-delay));//计算任务的执行周期\n    RunnableScheduledFuture<Void> t = decorateTask(command, sft);//执行用户自定义逻辑\n    sft.outerTask = t;//赋值给outerTask，准备重新入队等待下一次执行\n    delayedExecute(t);//执行任务\n    return t;\n}\n\n\n说明: scheduleAtFixedRate和scheduleWithFixedDelay方法的逻辑与schedule类似。\n\n注意scheduleAtFixedRate和scheduleWithFixedDelay的区别: 乍一看两个方法一模一样，其实，在unit.toNanos这一行代码中还是有区别的。没错，scheduleAtFixedRate传的是正值，而scheduleWithFixedDelay传的则是负值，这个值就是 ScheduledFutureTask 的period属性。\n\n\n# 核心方法:shutdown()\n\npublic void shutdown() {\n    super.shutdown();\n}\n//取消并清除由于关闭策略不应该运行的所有任务\n@Override void onShutdown() {\n    BlockingQueue<Runnable> q = super.getQueue();\n    //获取run-after-shutdown参数\n    boolean keepDelayed =\n        getExecuteExistingDelayedTasksAfterShutdownPolicy();\n    boolean keepPeriodic =\n        getContinueExistingPeriodicTasksAfterShutdownPolicy();\n    if (!keepDelayed && !keepPeriodic) {//池关闭后不保留任务\n        //依次取消任务\n        for (Object e : q.toArray())\n            if (e instanceof RunnableScheduledFuture<?>)\n                ((RunnableScheduledFuture<?>) e).cancel(false);\n        q.clear();//清除等待队列\n    }\n    else {//池关闭后保留任务\n        // Traverse snapshot to avoid iterator exceptions\n        //遍历快照以避免迭代器异常\n        for (Object e : q.toArray()) {\n            if (e instanceof RunnableScheduledFuture) {\n                RunnableScheduledFuture<?> t =\n                    (RunnableScheduledFuture<?>)e;\n                if ((t.isPeriodic() ? !keepPeriodic : !keepDelayed) ||\n                    t.isCancelled()) { // also remove if already cancelled\n                    //如果任务已经取消，移除队列中的任务\n                    if (q.remove(t))\n                        t.cancel(false);\n                }\n            }\n        }\n    }\n    tryTerminate(); //终止线程池\n}\n\n\n说明: 池关闭方法调用了父类ThreadPoolExecutor的shutdown，具体分析见 ThreadPoolExecutor 篇。这里主要介绍以下在shutdown方法中调用的关闭钩子onShutdown方法，它的主要作用是在关闭线程池后取消并清除由于关闭策略不应该运行的所有任务，这里主要是根据 run-after-shutdown 参数(continueExistingPeriodicTasksAfterShutdown和executeExistingDelayedTasksAfterShutdown)来决定线程池关闭后是否关闭已经存在的任务。\n\n\n# 再深入理解\n\n * 为什么ThreadPoolExecutor 的调整策略却不适用于 ScheduledThreadPoolExecutor？\n\n例如: 由于 ScheduledThreadPoolExecutor 是一个固定核心线程数大小的线程池，并且使用了一个无界队列，所以调整maximumPoolSize对其没有任何影响(所以 ScheduledThreadPoolExecutor 没有提供可以调整最大线程数的构造函数，默认最大线程数固定为Integer.MAX_VALUE)。此外，设置corePoolSize为0或者设置核心线程空闲后清除(allowCoreThreadTimeOut)同样也不是一个好的策略，因为一旦周期任务到达某一次运行周期时，可能导致线程池内没有线程去处理这些任务。\n\n * Executors 提供了哪几种方法来构造 ScheduledThreadPoolExecutor？\n   * newScheduledThreadPool: 可指定核心线程数的线程池。\n   * newSingleThreadScheduledExecutor: 只有一个工作线程的线程池。如果内部工作线程由于执行周期任务异常而被终止，则会新建一个线程替代它的位置。\n\n注意: newScheduledThreadPool(1, threadFactory) 不等价于newSingleThreadScheduledExecutor。newSingleThreadScheduledExecutor创建的线程池保证内部只有一个线程执行任务，并且线程数不可扩展；而通过newScheduledThreadPool(1, threadFactory)创建的线程池可以通过setCorePoolSize方法来修改核心线程数。\n\n\n# 参考文章\n\n * 文章主要参考自泰迪的bagwell的https://www.jianshu.com/p/8c97953f2751，在此基础上做了增改。\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-executor-ScheduledThreadPoolExecutor.html",normalizedContent:"# juc线程池: scheduledthreadpoolexecutor详解\n\n> 在很多业务场景中，我们可能需要周期性的运行某项任务来获取结果，比如周期数据统计，定时发送数据等。在并发包出现之前，java 早在1.3就提供了 timer 类(只需要了解，目前已渐渐被 scheduledthreadpoolexecutor 代替)来适应这些业务场景。随着业务量的不断增大，我们可能需要多个工作线程运行任务来尽可能的增加产品性能，或者是需要更高的灵活性来控制和监控这些周期业务。这些都是 scheduledthreadpoolexecutor 诞生的必然性。\n\n * juc线程池: scheduledthreadpoolexecutor详解\n   * 带着bat大厂的面试问题去理解scheduledthreadpoolexecutor\n   * scheduledthreadpoolexecutor简介\n   * scheduledthreadpoolexecutor数据结构\n   * scheduledthreadpoolexecutor源码解析\n     * 内部类scheduledfuturetask\n       * 属性\n       * 核心方法run()\n       * cancel方法\n     * 核心属性\n     * 构造函数\n     * 核心方法:schedule\n     * 核心方法:scheduleatfixedrate 和 schedulewithfixeddelay\n     * 核心方法:shutdown()\n   * 再深入理解\n   * 参考文章\n\n\n# 带着bat大厂的面试问题去理解scheduledthreadpoolexecutor\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解scheduledthreadpoolexecutor。\n\n * scheduledthreadpoolexecutor要解决什么样的问题?\n * scheduledthreadpoolexecutor相比threadpoolexecutor有哪些特性?\n * scheduledthreadpoolexecutor有什么样的数据结构，核心内部类和抽象类?\n * scheduledthreadpoolexecutor有哪两个关闭策略? 区别是什么?\n * scheduledthreadpoolexecutor中scheduleatfixedrate 和 schedulewithfixeddelay区别是什么?\n * 为什么threadpoolexecutor 的调整策略却不适用于 scheduledthreadpoolexecutor?\n * executors 提供了几种方法来构造 scheduledthreadpoolexecutor?\n\n\n# scheduledthreadpoolexecutor简介\n\nscheduledthreadpoolexecutor继承自 threadpoolexecutor，为任务提供延迟或周期执行，属于线程池的一种。和 threadpoolexecutor 相比，它还具有以下几种特性:\n\n * 使用专门的任务类型—scheduledfuturetask 来执行周期任务，也可以接收不需要时间调度的任务(这些任务通过 executorservice 来执行)。\n * 使用专门的存储队列—delayedworkqueue 来存储任务，delayedworkqueue 是无界延迟队列delayqueue 的一种。相比threadpoolexecutor也简化了执行机制(delayedexecute方法，后面单独分析)。\n * 支持可选的run-after-shutdown参数，在池被关闭(shutdown)之后支持可选的逻辑来决定是否继续运行周期或延迟任务。并且当任务(重新)提交操作与 shutdown 操作重叠时，复查逻辑也不相同。\n\n\n# scheduledthreadpoolexecutor数据结构\n\n\n\nscheduledthreadpoolexecutor继承自 threadpoolexecutor:\n\n * 详情请参考: juc线程池: threadpoolexecutor详解\n\nscheduledthreadpoolexecutor 内部构造了两个内部类 scheduledfuturetask 和 delayedworkqueue:\n\n * scheduledfuturetask: 继承了futuretask，说明是一个异步运算任务；最上层分别实现了runnable、future、delayed接口，说明它是一个可以延迟执行的异步运算任务。\n\n * delayedworkqueue: 这是 scheduledthreadpoolexecutor 为存储周期或延迟任务专门定义的一个延迟队列，继承了 abstractqueue，为了契合 threadpoolexecutor 也实现了 blockingqueue 接口。它内部只允许存储 runnablescheduledfuture 类型的任务。与 delayqueue 的不同之处就是它只允许存放 runnablescheduledfuture 对象，并且自己实现了二叉堆(delayqueue 是利用了 priorityqueue 的二叉堆结构)。\n\n\n# scheduledthreadpoolexecutor源码解析\n\n> 以下源码的解析是基于你已经理解了futuretask。\n\n\n# 内部类scheduledfuturetask\n\n# 属性\n\n//为相同延时任务提供的顺序编号\nprivate final long sequencenumber;\n\n//任务可以执行的时间，纳秒级\nprivate long time;\n\n//重复任务的执行周期时间，纳秒级。\nprivate final long period;\n\n//重新入队的任务\nrunnablescheduledfuture<v> outertask = this;\n\n//延迟队列的索引，以支持更快的取消操作\nint heapindex;\n\n\n * sequencenumber: 当两个任务有相同的延迟时间时，按照 fifo 的顺序入队。sequencenumber 就是为相同延时任务提供的顺序编号。\n * time: 任务可以执行时的时间，纳秒级，通过triggertime方法计算得出。\n * period: 任务的执行周期时间，纳秒级。正数表示固定速率执行(为scheduleatfixedrate提供服务)，负数表示固定延迟执行(为schedulewithfixeddelay提供服务)，0表示不重复任务。\n * outertask: 重新入队的任务，通过reexecuteperiodic方法入队重新排序。\n\n# 核心方法run()\n\npublic void run() {\n    boolean periodic = isperiodic();//是否为周期任务\n    if (!canrunincurrentrunstate(periodic))//当前状态是否可以执行\n        cancel(false);\n    else if (!periodic)\n        //不是周期任务，直接执行\n        scheduledfuturetask.super.run();\n    else if (scheduledfuturetask.super.runandreset()) {\n        setnextruntime();//设置下一次运行时间\n        reexecuteperiodic(outertask);//重排序一个周期任务\n    }\n}\n\n\n说明: scheduledfuturetask 的run方法重写了 futuretask 的版本，以便执行周期任务时重置/重排序任务。任务的执行通过父类 futuretask 的run实现。内部有两个针对周期任务的方法:\n\n * setnextruntime(): 用来设置下一次运行的时间，源码如下:\n\n//设置下一次执行任务的时间\nprivate void setnextruntime() {\n    long p = period;\n    if (p > 0)  //固定速率执行，scheduleatfixedrate\n        time += p;\n    else\n        time = triggertime(-p);  //固定延迟执行，schedulewithfixeddelay\n}\n//计算固定延迟任务的执行时间\nlong triggertime(long delay) {\n    return now() +\n        ((delay < (long.max_value >> 1)) ? delay : overflowfree(delay));\n}\n\n\n * reexecuteperiodic(): 周期任务重新入队等待下一次执行，源码如下:\n\n//重排序一个周期任务\nvoid reexecuteperiodic(runnablescheduledfuture<?> task) {\n    if (canrunincurrentrunstate(true)) {//池关闭后可继续执行\n        super.getqueue().add(task);//任务入列\n        //重新检查run-after-shutdown参数，如果不能继续运行就移除队列任务，并取消任务的执行\n        if (!canrunincurrentrunstate(true) && remove(task))\n            task.cancel(false);\n        else\n            ensureprestart();//启动一个新的线程等待任务\n    }\n}\n\n\nreexecuteperiodic与delayedexecute的执行策略一致，只不过reexecuteperiodic不会执行拒绝策略而是直接丢掉任务。\n\n# cancel方法\n\npublic boolean cancel(boolean mayinterruptifrunning) {\n    boolean cancelled = super.cancel(mayinterruptifrunning);\n    if (cancelled && removeoncancel && heapindex >= 0)\n        remove(this);\n    return cancelled;\n}\n\n\nscheduledfuturetask.cancel本质上由其父类 futuretask.cancel 实现。取消任务成功后会根据removeoncancel参数决定是否从队列中移除此任务。\n\n\n# 核心属性\n\n//关闭后继续执行已经存在的周期任务 \nprivate volatile boolean continueexistingperiodictasksaftershutdown;\n\n//关闭后继续执行已经存在的延时任务 \nprivate volatile boolean executeexistingdelayedtasksaftershutdown = true;\n\n//取消任务后移除 \nprivate volatile boolean removeoncancel = false;\n\n//为相同延时的任务提供的顺序编号，保证任务之间的fifo顺序\nprivate static final atomiclong sequencer = new atomiclong();\n\n\n\n * continueexistingperiodictasksaftershutdown和executeexistingdelayedtasksaftershutdown是 scheduledthreadpoolexecutor 定义的 run-after-shutdown 参数，用来控制池关闭之后的任务执行逻辑。\n\n * removeoncancel用来控制任务取消后是否从队列中移除。当一个已经提交的周期或延迟任务在运行之前被取消，那么它之后将不会运行。默认配置下，这种已经取消的任务在届期之前不会被移除。 通过这种机制，可以方便检查和监控线程池状态，但也可能导致已经取消的任务无限滞留。为了避免这种情况的发生，我们可以通过setremoveoncancelpolicy方法设置移除策略，把参数removeoncancel设为true可以在任务取消后立即从队列中移除。\n\n * sequencer是为相同延时的任务提供的顺序编号，保证任务之间的 fifo 顺序。与 scheduledfuturetask 内部的sequencenumber参数作用一致。\n\n\n# 构造函数\n\n首先看下构造函数，scheduledthreadpoolexecutor 内部有四个构造函数，这里我们只看这个最大构造灵活度的:\n\npublic scheduledthreadpoolexecutor(int corepoolsize,\n                                   threadfactory threadfactory,\n                                   rejectedexecutionhandler handler) {\n    super(corepoolsize, integer.max_value, 0, nanoseconds,\n          new delayedworkqueue(), threadfactory, handler);\n}\n\n\n构造函数都是通过super调用了threadpoolexecutor的构造，并且使用特定等待队列delayedworkqueue。\n\n\n# 核心方法:schedule\n\npublic <v> scheduledfuture<v> schedule(callable<v> callable,\n                                       long delay,\n                                       timeunit unit) {\n    if (callable == null || unit == null)\n        throw new nullpointerexception();\n    runnablescheduledfuture<v> t = decoratetask(callable,\n        new scheduledfuturetask<v>(callable, triggertime(delay, unit)));//构造scheduledfuturetask任务\n    delayedexecute(t);//任务执行主方法\n    return t;\n}\n\n\n说明: schedule主要用于执行一次性(延迟)任务。函数执行逻辑分两步:\n\n * 封装 callable/runnable: 首先通过triggertime计算任务的延迟执行时间，然后通过 scheduledfuturetask 的构造函数把 runnable/callable 任务构造为scheduledthreadpoolexecutor可以执行的任务类型，最后调用decoratetask方法执行用户自定义的逻辑；decoratetask是一个用户可自定义扩展的方法，默认实现下直接返回封装的runnablescheduledfuture任务，源码如下:\n\nprotected <v> runnablescheduledfuture<v> decoratetask(\n    runnable runnable, runnablescheduledfuture<v> task) {\n    return task;\n}\n\n\n * 执行任务: 通过delayedexecute实现。下面我们来详细分析。\n\nprivate void delayedexecute(runnablescheduledfuture<?> task) {\n    if (isshutdown())\n        reject(task);//池已关闭，执行拒绝策略\n    else {\n        super.getqueue().add(task);//任务入队\n        if (isshutdown() &&\n            !canrunincurrentrunstate(task.isperiodic()) &&//判断run-after-shutdown参数\n            remove(task))//移除任务\n            task.cancel(false);\n        else\n            ensureprestart();//启动一个新的线程等待任务\n    }\n}\n\n\n说明: delayedexecute是执行任务的主方法，方法执行逻辑如下:\n\n * 如果池已关闭(ctl >= shutdown)，执行任务拒绝策略；\n * 池正在运行，首先把任务入队排序；然后重新检查池的关闭状态，执行如下逻辑:\n\na: 如果池正在运行，或者 run-after-shutdown 参数值为true，则调用父类方法ensureprestart启动一个新的线程等待执行任务。ensureprestart源码如下:\n\nvoid ensureprestart() {\n    int wc = workercountof(ctl.get());\n    if (wc < corepoolsize)\n        addworker(null, true);\n    else if (wc == 0)\n        addworker(null, false);\n}\n\n\nensureprestart是父类 threadpoolexecutor 的方法，用于启动一个新的工作线程等待执行任务，即使corepoolsize为0也会安排一个新线程。\n\nb: 如果池已经关闭，并且 run-after-shutdown 参数值为false，则执行父类(threadpoolexecutor)方法remove移除队列中的指定任务，成功移除后调用scheduledfuturetask.cancel取消任务\n\n\n# 核心方法:scheduleatfixedrate 和 schedulewithfixeddelay\n\n/**\n * 创建一个周期执行的任务，第一次执行延期时间为initialdelay，\n * 之后每隔period执行一次，不等待第一次执行完成就开始计时\n */\npublic scheduledfuture<?> scheduleatfixedrate(runnable command,\n                                              long initialdelay,\n                                              long period,\n                                              timeunit unit) {\n    if (command == null || unit == null)\n        throw new nullpointerexception();\n    if (period <= 0)\n        throw new illegalargumentexception();\n    //构建runnablescheduledfuture任务类型\n    scheduledfuturetask<void> sft =\n        new scheduledfuturetask<void>(command,\n                                      null,\n                                      triggertime(initialdelay, unit),//计算任务的延迟时间\n                                      unit.tonanos(period));//计算任务的执行周期\n    runnablescheduledfuture<void> t = decoratetask(command, sft);//执行用户自定义逻辑\n    sft.outertask = t;//赋值给outertask，准备重新入队等待下一次执行\n    delayedexecute(t);//执行任务\n    return t;\n}\n\n/**\n * 创建一个周期执行的任务，第一次执行延期时间为initialdelay，\n * 在第一次执行完之后延迟delay后开始下一次执行\n */\npublic scheduledfuture<?> schedulewithfixeddelay(runnable command,\n                                                 long initialdelay,\n                                                 long delay,\n                                                 timeunit unit) {\n    if (command == null || unit == null)\n        throw new nullpointerexception();\n    if (delay <= 0)\n        throw new illegalargumentexception();\n    //构建runnablescheduledfuture任务类型\n    scheduledfuturetask<void> sft =\n        new scheduledfuturetask<void>(command,\n                                      null,\n                                      triggertime(initialdelay, unit),//计算任务的延迟时间\n                                      unit.tonanos(-delay));//计算任务的执行周期\n    runnablescheduledfuture<void> t = decoratetask(command, sft);//执行用户自定义逻辑\n    sft.outertask = t;//赋值给outertask，准备重新入队等待下一次执行\n    delayedexecute(t);//执行任务\n    return t;\n}\n\n\n说明: scheduleatfixedrate和schedulewithfixeddelay方法的逻辑与schedule类似。\n\n注意scheduleatfixedrate和schedulewithfixeddelay的区别: 乍一看两个方法一模一样，其实，在unit.tonanos这一行代码中还是有区别的。没错，scheduleatfixedrate传的是正值，而schedulewithfixeddelay传的则是负值，这个值就是 scheduledfuturetask 的period属性。\n\n\n# 核心方法:shutdown()\n\npublic void shutdown() {\n    super.shutdown();\n}\n//取消并清除由于关闭策略不应该运行的所有任务\n@override void onshutdown() {\n    blockingqueue<runnable> q = super.getqueue();\n    //获取run-after-shutdown参数\n    boolean keepdelayed =\n        getexecuteexistingdelayedtasksaftershutdownpolicy();\n    boolean keepperiodic =\n        getcontinueexistingperiodictasksaftershutdownpolicy();\n    if (!keepdelayed && !keepperiodic) {//池关闭后不保留任务\n        //依次取消任务\n        for (object e : q.toarray())\n            if (e instanceof runnablescheduledfuture<?>)\n                ((runnablescheduledfuture<?>) e).cancel(false);\n        q.clear();//清除等待队列\n    }\n    else {//池关闭后保留任务\n        // traverse snapshot to avoid iterator exceptions\n        //遍历快照以避免迭代器异常\n        for (object e : q.toarray()) {\n            if (e instanceof runnablescheduledfuture) {\n                runnablescheduledfuture<?> t =\n                    (runnablescheduledfuture<?>)e;\n                if ((t.isperiodic() ? !keepperiodic : !keepdelayed) ||\n                    t.iscancelled()) { // also remove if already cancelled\n                    //如果任务已经取消，移除队列中的任务\n                    if (q.remove(t))\n                        t.cancel(false);\n                }\n            }\n        }\n    }\n    tryterminate(); //终止线程池\n}\n\n\n说明: 池关闭方法调用了父类threadpoolexecutor的shutdown，具体分析见 threadpoolexecutor 篇。这里主要介绍以下在shutdown方法中调用的关闭钩子onshutdown方法，它的主要作用是在关闭线程池后取消并清除由于关闭策略不应该运行的所有任务，这里主要是根据 run-after-shutdown 参数(continueexistingperiodictasksaftershutdown和executeexistingdelayedtasksaftershutdown)来决定线程池关闭后是否关闭已经存在的任务。\n\n\n# 再深入理解\n\n * 为什么threadpoolexecutor 的调整策略却不适用于 scheduledthreadpoolexecutor？\n\n例如: 由于 scheduledthreadpoolexecutor 是一个固定核心线程数大小的线程池，并且使用了一个无界队列，所以调整maximumpoolsize对其没有任何影响(所以 scheduledthreadpoolexecutor 没有提供可以调整最大线程数的构造函数，默认最大线程数固定为integer.max_value)。此外，设置corepoolsize为0或者设置核心线程空闲后清除(allowcorethreadtimeout)同样也不是一个好的策略，因为一旦周期任务到达某一次运行周期时，可能导致线程池内没有线程去处理这些任务。\n\n * executors 提供了哪几种方法来构造 scheduledthreadpoolexecutor？\n   * newscheduledthreadpool: 可指定核心线程数的线程池。\n   * newsinglethreadscheduledexecutor: 只有一个工作线程的线程池。如果内部工作线程由于执行周期任务异常而被终止，则会新建一个线程替代它的位置。\n\n注意: newscheduledthreadpool(1, threadfactory) 不等价于newsinglethreadscheduledexecutor。newsinglethreadscheduledexecutor创建的线程池保证内部只有一个线程执行任务，并且线程数不可扩展；而通过newscheduledthreadpool(1, threadfactory)创建的线程池可以通过setcorepoolsize方法来修改核心线程数。\n\n\n# 参考文章\n\n * 文章主要参考自泰迪的bagwell的https://www.jianshu.com/p/8c97953f2751，在此基础上做了增改。\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-executor-scheduledthreadpoolexecutor.html",charsets:{cjk:!0}},{title:"JUC线程池: Fork/Join框架详解",frontmatter:{},regularPath:"/java/thread/java-thread-x-juc-executor-ForkJoinPool.html",relativePath:"java/thread/java-thread-x-juc-executor-ForkJoinPool.md",key:"v-695fc26e",path:"/java/thread/java-thread-x-juc-executor-ForkJoinPool.html",headers:[{level:2,title:"JUC线程池: Fork/Join框架详解",slug:"juc线程池-fork-join框架详解",normalizedTitle:"juc线程池: fork/join框架详解",charIndex:2},{level:2,title:"带着BAT大厂的面试问题去理解Fork/Join框架",slug:"带着bat大厂的面试问题去理解fork-join框架",normalizedTitle:"带着bat大厂的面试问题去理解fork/join框架",charIndex:202},{level:2,title:"Fork/Join框架简介",slug:"fork-join框架简介",normalizedTitle:"fork/join框架简介",charIndex:234},{level:3,title:"三个模块及关系",slug:"三个模块及关系",normalizedTitle:"三个模块及关系",charIndex:255},{level:3,title:"核心思想: 分治算法(Divide-and-Conquer)",slug:"核心思想-分治算法-divide-and-conquer",normalizedTitle:"核心思想: 分治算法(divide-and-conquer)",charIndex:270},{level:3,title:"核心思想: work-stealing(工作窃取)算法",slug:"核心思想-work-stealing-工作窃取-算法",normalizedTitle:"核心思想: work-stealing(工作窃取)算法",charIndex:308},{level:3,title:"Fork/Join 框架的执行流程",slug:"fork-join-框架的执行流程",normalizedTitle:"fork/join 框架的执行流程",charIndex:343},{level:2,title:"Fork/Join类关系",slug:"fork-join类关系",normalizedTitle:"fork/join类关系",charIndex:366},{level:3,title:"ForkJoinPool继承关系",slug:"forkjoinpool继承关系",normalizedTitle:"forkjoinpool继承关系",charIndex:386},{level:3,title:"ForkJoinTask继承关系",slug:"forkjointask继承关系",normalizedTitle:"forkjointask继承关系",charIndex:410},{level:2,title:"Fork/Join框架源码解析",slug:"fork-join框架源码解析",normalizedTitle:"fork/join框架源码解析",charIndex:432},{level:3,title:"ForkJoinPool",slug:"forkjoinpool",normalizedTitle:"forkjoinpool",charIndex:27},{level:3,title:"ForkJoinTask",slug:"forkjointask",normalizedTitle:"forkjointask",charIndex:410},{level:2,title:"Fork/Join框架源码解析",slug:"fork-join框架源码解析-2",normalizedTitle:"fork/join框架源码解析",charIndex:432},{level:3,title:"构造函数",slug:"构造函数",normalizedTitle:"构造函数",charIndex:584},{level:3,title:"执行流程 - 外部任务(external/submissions task)提交",slug:"执行流程-外部任务-external-submissions-task-提交",normalizedTitle:"执行流程 - 外部任务(external/submissions task)提交",charIndex:596},{level:3,title:"执行流程: 子任务(Worker task)提交",slug:"执行流程-子任务-worker-task-提交",normalizedTitle:"执行流程: 子任务(worker task)提交",charIndex:875},{level:3,title:"执行流程: 任务执行",slug:"执行流程-任务执行",normalizedTitle:"执行流程: 任务执行",charIndex:987},{level:3,title:"获取任务结果 - ForkJoinTask.join() / ForkJoinTask.invoke()",slug:"获取任务结果-forkjointask-join-forkjointask-invoke",normalizedTitle:"获取任务结果 - forkjointask.join() / forkjointask.invoke()",charIndex:1304},{level:2,title:"Fork/Join的陷阱与注意事项",slug:"fork-join的陷阱与注意事项",normalizedTitle:"fork/join的陷阱与注意事项",charIndex:1614},{level:3,title:"避免不必要的fork()",slug:"避免不必要的fork",normalizedTitle:"避免不必要的fork()",charIndex:1639},{level:3,title:"注意fork()、compute()、join()的顺序",slug:"注意fork-、compute-、join-的顺序",normalizedTitle:"注意fork()、compute()、join()的顺序",charIndex:1659},{level:3,title:"选择合适的子任务粒度",slug:"选择合适的子任务粒度",normalizedTitle:"选择合适的子任务粒度",charIndex:1695},{level:3,title:"避免重量级任务划分与结果合并",slug:"避免重量级任务划分与结果合并",normalizedTitle:"避免重量级任务划分与结果合并",charIndex:1713},{level:2,title:"再深入理解",slug:"再深入理解",normalizedTitle:"再深入理解",charIndex:1733},{level:3,title:"有哪些JDK源码中使用了Fork/Join思想?",slug:"有哪些jdk源码中使用了fork-join思想",normalizedTitle:"有哪些jdk源码中使用了fork/join思想?",charIndex:1746},{level:3,title:"使用Executors工具类创建ForkJoinPool",slug:"使用executors工具类创建forkjoinpool",normalizedTitle:"使用executors工具类创建forkjoinpool",charIndex:1778},{level:3,title:"关于Fork/Join异常处理",slug:"关于fork-join异常处理",normalizedTitle:"关于fork/join异常处理",charIndex:1814},{level:2,title:"一些Fork/Join例子",slug:"一些fork-join例子",normalizedTitle:"一些fork/join例子",charIndex:1835},{level:3,title:"采用Fork/Join来异步计算1+2+3+…+10000的结果",slug:"采用fork-join来异步计算1-2-3-10000的结果",normalizedTitle:"采用fork/join来异步计算1+2+3+…+10000的结果",charIndex:1856},{level:3,title:"实现斐波那契数列",slug:"实现斐波那契数列",normalizedTitle:"实现斐波那契数列",charIndex:1896},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:1910}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"JUC线程池: Fork/Join框架详解 带着BAT大厂的面试问题去理解Fork/Join框架 Fork/Join框架简介 三个模块及关系 核心思想: 分治算法(Divide-and-Conquer) 核心思想: work-stealing(工作窃取)算法 Fork/Join 框架的执行流程 Fork/Join类关系 ForkJoinPool继承关系 ForkJoinTask继承关系 Fork/Join框架源码解析 ForkJoinPool ForkJoinTask Fork/Join框架源码解析 构造函数 执行流程 - 外部任务(external/submissions task)提交 执行流程: 子任务(Worker task)提交 执行流程: 任务执行 获取任务结果 - ForkJoinTask.join() / ForkJoinTask.invoke() Fork/Join的陷阱与注意事项 避免不必要的fork() 注意fork()、compute()、join()的顺序 选择合适的子任务粒度 避免重量级任务划分与结果合并 再深入理解 有哪些JDK源码中使用了Fork/Join思想? 使用Executors工具类创建ForkJoinPool 关于Fork/Join异常处理 一些Fork/Join例子 采用Fork/Join来异步计算1+2+3+…+10000的结果 实现斐波那契数列 参考文章",content:'# JUC线程池: Fork/Join框架详解\n\n> ForkJoinPool 是JDK 7加入的一个线程池类。Fork/Join 技术是分治算法(Divide-and-Conquer)的并行实现，它是一项可以获得良好的并行性能的简单且高效的设计技术。目的是为了帮助我们更好地利用多处理器带来的好处，使用所有可用的运算能力来提升应用的性能。\n\n * JUC线程池: Fork/Join框架详解\n   * 带着BAT大厂的面试问题去理解Fork/Join框架\n   * Fork/Join框架简介\n     * 三个模块及关系\n     * 核心思想: 分治算法(Divide-and-Conquer)\n     * 核心思想: work-stealing(工作窃取)算法\n     * Fork/Join 框架的执行流程\n   * Fork/Join类关系\n     * ForkJoinPool继承关系\n     * ForkJoinTask继承关系\n   * Fork/Join框架源码解析\n     * ForkJoinPool\n       * 核心参数\n       * ForkJoinPool.WorkQueue 中的相关属性:\n     * ForkJoinTask\n       * 核心参数\n   * Fork/Join框架源码解析\n     * 构造函数\n     * 执行流程 - 外部任务(external/submissions task)提交\n       * externalPush(ForkJoinTask<?> task)\n       * externalSubmit(ForkJoinTask<?> task)\n       * signalWork(WorkQueue[] ws, WorkQueue q)\n       * tryAddWorker(long c)\n       * createWorker()\n       * registerWorker()\n       * 小结\n     * 执行流程: 子任务(Worker task)提交\n       * ForkJoinTask.fork()\n       * ForkJoinPool.WorkQueue.push()\n       * 小结\n     * 执行流程: 任务执行\n       * ForkJoinWorkerThread.run()\n       * ForkJoinPool.runWorker(WorkQueue w)\n       * ForkJoinPool.scan(WorkQueue w, int r)\n       * ForkJoinPool.awaitWork(WorkQueue w, int r)\n       * WorkQueue.runTask()\n       * ForkJoinPool.deregisterWorker(ForkJoinWorkerThread wt, Throwable ex)\n       * 小结\n     * 获取任务结果 - ForkJoinTask.join() / ForkJoinTask.invoke()\n       * ForkJoinTask.externalAwaitDone()\n       * ForkJoinPool.awaitJoin()\n       * WorkQueue.tryRemoveAndExec(ForkJoinTask<?> task)\n       * ForkJoinPool.helpStealer(WorkQueue w, ForkJoinTask<?> task)\n       * ForkJoinPool.tryCompensate(WorkQueue w)\n   * Fork/Join的陷阱与注意事项\n     * 避免不必要的fork()\n     * 注意fork()、compute()、join()的顺序\n     * 选择合适的子任务粒度\n     * 避免重量级任务划分与结果合并\n   * 再深入理解\n     * 有哪些JDK源码中使用了Fork/Join思想?\n     * 使用Executors工具类创建ForkJoinPool\n     * 关于Fork/Join异常处理\n   * 一些Fork/Join例子\n     * 采用Fork/Join来异步计算1+2+3+…+10000的结果\n     * 实现斐波那契数列\n   * 参考文章\n\n\n# 带着BAT大厂的面试问题去理解Fork/Join框架\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解Fork/Join框架。\n\n * Fork/Join主要用来解决什么样的问题?\n * Fork/Join框架是在哪个JDK版本中引入的?\n * Fork/Join框架主要包含哪三个模块? 模块之间的关系是怎么样的?\n * ForkJoinPool类继承关系?\n * ForkJoinTask抽象类继承关系? 在实际运用中，我们一般都会继承 RecursiveTask 、RecursiveAction 或 CountedCompleter 来实现我们的业务需求，而不会直接继承 ForkJoinTask 类。\n * 整个Fork/Join 框架的执行流程/运行机制是怎么样的?\n * 具体阐述Fork/Join的分治思想和work-stealing 实现方式?\n * 有哪些JDK源码中使用了Fork/Join思想?\n * 如何使用Executors工具类创建ForkJoinPool?\n * 写一个例子: 用ForkJoin方式实现1+2+3+...+100000?\n * Fork/Join在使用时有哪些注意事项? 结合JDK中的斐波那契数列实例具体说明。\n\n\n# Fork/Join框架简介\n\nFork/Join框架是Java并发工具包中的一种可以将一个大任务拆分为很多小任务来异步执行的工具，自JDK1.7引入。\n\n\n# 三个模块及关系\n\nFork/Join框架主要包含三个模块:\n\n * 任务对象: ForkJoinTask (包括RecursiveTask、RecursiveAction 和 CountedCompleter)\n * 执行Fork/Join任务的线程: ForkJoinWorkerThread\n * 线程池: ForkJoinPool\n\n这三者的关系是: ForkJoinPool可以通过池中的ForkJoinWorkerThread来处理ForkJoinTask任务。\n\n// from 《A Java Fork/Join Framework》Dong Lea\nResult solve(Problem problem) {\n\tif (problem is small)\n \t\tdirectly solve problem\n \telse {\n \t\tsplit problem into independent parts\n \t\tfork new subtasks to solve each part\n \t\tjoin all subtasks\n \t\tcompose result from subresults\n\t}\n}\n\n\nForkJoinPool 只接收 ForkJoinTask 任务(在实际使用中，也可以接收 Runnable/Callable 任务，但在真正运行时，也会把这些任务封装成 ForkJoinTask 类型的任务)，RecursiveTask 是 ForkJoinTask 的子类，是一个可以递归执行的 ForkJoinTask，RecursiveAction 是一个无返回值的 RecursiveTask，CountedCompleter 在任务完成执行后会触发执行一个自定义的钩子函数。\n\n在实际运用中，我们一般都会继承 RecursiveTask 、RecursiveAction 或 CountedCompleter 来实现我们的业务需求，而不会直接继承 ForkJoinTask 类。\n\n\n# 核心思想: 分治算法(Divide-and-Conquer)\n\n分治算法(Divide-and-Conquer)把任务递归的拆分为各个子任务，这样可以更好的利用系统资源，尽可能的使用所有可用的计算能力来提升应用性能。首先看一下 Fork/Join 框架的任务运行机制:\n\n\n\n * 这里也可以一并看下: 算法思想 - 分治算法\n\n\n# 核心思想: work-stealing(工作窃取)算法\n\nwork-stealing(工作窃取)算法: 线程池内的所有工作线程都尝试找到并执行已经提交的任务，或者是被其他活动任务创建的子任务(如果不存在就阻塞等待)。这种特性使得 ForkJoinPool 在运行多个可以产生子任务的任务，或者是提交的许多小任务时效率更高。尤其是构建异步模型的 ForkJoinPool 时，对不需要合并(join)的事件类型任务也非常适用。\n\n在 ForkJoinPool 中，线程池中每个工作线程(ForkJoinWorkerThread)都对应一个任务队列(WorkQueue)，工作线程优先处理来自自身队列的任务(LIFO或FIFO顺序，参数 mode 决定)，然后以FIFO的顺序随机窃取其他队列中的任务。\n\n具体思路如下:\n\n * 每个线程都有自己的一个WorkQueue，该工作队列是一个双端队列。\n * 队列支持三个功能push、pop、poll\n * push/pop只能被队列的所有者线程调用，而poll可以被其他线程调用。\n * 划分的子任务调用fork时，都会被push到自己的队列中。\n * 默认情况下，工作线程从自己的双端队列获出任务并执行。\n * 当自己的队列为空时，线程随机从另一个线程的队列末尾调用poll方法窃取任务。\n\n\n\n\n# Fork/Join 框架的执行流程\n\n上图可以看出ForkJoinPool 中的任务执行分两种:\n\n * 直接通过 FJP 提交的外部任务(external/submissions task)，存放在 workQueues 的偶数槽位；\n * 通过内部 fork 分割的子任务(Worker task)，存放在 workQueues 的奇数槽位。\n\n那Fork/Join 框架的执行流程是什么样的?\n\n\n\n> 后续的源码解析将围绕上图进行。\n\n\n# Fork/Join类关系\n\n\n# ForkJoinPool继承关系\n\n\n\n内部类介绍:\n\n * ForkJoinWorkerThreadFactory: 内部线程工厂接口，用于创建工作线程ForkJoinWorkerThread\n\n * DefaultForkJoinWorkerThreadFactory: ForkJoinWorkerThreadFactory 的默认实现类\n\n * InnocuousForkJoinWorkerThreadFactory: 实现了 ForkJoinWorkerThreadFactory，无许可线程工厂，当系统变量中有系统安全管理相关属性时，默认使用这个工厂创建工作线程。\n\n * EmptyTask: 内部占位类，用于替换队列中 join 的任务。\n\n * ManagedBlocker: 为 ForkJoinPool 中的任务提供扩展管理并行数的接口，一般用在可能会阻塞的任务(如在 Phaser 中用于等待 phase 到下一个generation)。\n\n * WorkQueue: ForkJoinPool 的核心数据结构，本质上是work-stealing 模式的双端任务队列，内部存放 ForkJoinTask 对象任务，使用 @Contented 注解修饰防止伪共享。\n   \n   * 工作线程在运行中产生新的任务(通常是因为调用了 fork())时，此时可以把 WorkQueue 的数据结构视为一个栈，新的任务会放入栈顶(top 位)；工作线程在处理自己工作队列的任务时，按照 LIFO 的顺序。\n   * 工作线程在处理自己的工作队列同时，会尝试窃取一个任务(可能是来自于刚刚提交到 pool 的任务，或是来自于其他工作线程的队列任务)，此时可以把 WorkQueue 的数据结构视为一个 FIFO 的队列，窃取的任务位于其他线程的工作队列的队首(base位)。\n\n * 伪共享状态: 缓存系统中是以缓存行(cache line)为单位存储的。缓存行是2的整数幂个连续字节，一般为32-256个字节。最常见的缓存行大小是64个字节。当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。\n\n\n# ForkJoinTask继承关系\n\n\n\nForkJoinTask 实现了 Future 接口，说明它也是一个可取消的异步运算任务，实际上ForkJoinTask 是 Future 的轻量级实现，主要用在纯粹是计算的函数式任务或者操作完全独立的对象计算任务。fork 是主运行方法，用于异步执行；而 join 方法在任务结果计算完毕之后才会运行，用来合并或返回计算结果。 其内部类都比较简单，ExceptionNode 是用于存储任务执行期间的异常信息的单向链表；其余四个类是为 Runnable/Callable 任务提供的适配器类，用于把 Runnable/Callable 转化为 ForkJoinTask 类型的任务(因为 ForkJoinPool 只可以运行 ForkJoinTask 类型的任务)。\n\n\n# Fork/Join框架源码解析\n\n> 分析思路: 在对类层次结构有了解以后，我们先看下内部核心参数，然后分析上述流程图。会分4个部分:\n\n * 首先介绍任务的提交流程 - 外部任务(external/submissions task)提交\n * 然后介绍任务的提交流程 - 子任务(Worker task)提交\n * 再分析任务的执行过程(ForkJoinWorkerThread.run()到ForkJoinTask.doExec()这一部分)；\n * 最后介绍任务的结果获取(ForkJoinTask.join()和ForkJoinTask.invoke())\n\n\n# ForkJoinPool\n\n# 核心参数\n\n在后面的源码解析中，我们会看到大量的位运算，这些位运算都是通过我们接下来介绍的一些常量参数来计算的。\n\n例如，如果要更新活跃线程数，使用公式(UC_MASK & (c + AC_UNIT)) | (SP_MASK & c)；c 代表当前 ctl，UC_MASK 和 SP_MASK 分别是高位和低位掩码，AC_UNIT 为活跃线程的增量数，使用(UC_MASK & (c + AC_UNIT))就可以计算出高32位，然后再加上低32位(SP_MASK & c)，就拼接成了一个新的ctl。\n\n这些运算的可读性很差，看起来有些复杂。在后面源码解析中有位运算的地方我都会加上注释，大家只需要了解它们的作用即可。\n\nForkJoinPool 与 内部类 WorkQueue 共享的一些常量:\n\n// Constants shared across ForkJoinPool and WorkQueue\n\n// 限定参数\nstatic final int SMASK = 0xffff;        //  低位掩码，也是最大索引位\nstatic final int MAX_CAP = 0x7fff;        //  工作线程最大容量\nstatic final int EVENMASK = 0xfffe;        //  偶数低位掩码\nstatic final int SQMASK = 0x007e;        //  workQueues 数组最多64个槽位\n\n// ctl 子域和 WorkQueue.scanState 的掩码和标志位\nstatic final int SCANNING = 1;             // 标记是否正在运行任务\nstatic final int INACTIVE = 1 << 31;       // 失活状态  负数\nstatic final int SS_SEQ = 1 << 16;       // 版本戳，防止ABA问题\n\n// ForkJoinPool.config 和 WorkQueue.config 的配置信息标记\nstatic final int MODE_MASK = 0xffff << 16;  // 模式掩码\nstatic final int LIFO_QUEUE = 0; //LIFO队列\nstatic final int FIFO_QUEUE = 1 << 16;//FIFO队列\nstatic final int SHARED_QUEUE = 1 << 31;       // 共享模式队列，负数\n\n\nForkJoinPool 中的相关常量和实例字段:\n\n//  低位和高位掩码\nprivate static final long SP_MASK = 0xffffffffL;\nprivate static final long UC_MASK = ~SP_MASK;\n\n// 活跃线程数\nprivate static final int AC_SHIFT = 48;\nprivate static final long AC_UNIT = 0x0001L << AC_SHIFT; //活跃线程数增量\nprivate static final long AC_MASK = 0xffffL << AC_SHIFT; //活跃线程数掩码\n\n// 工作线程数\nprivate static final int TC_SHIFT = 32;\nprivate static final long TC_UNIT = 0x0001L << TC_SHIFT; //工作线程数增量\nprivate static final long TC_MASK = 0xffffL << TC_SHIFT; //掩码\nprivate static final long ADD_WORKER = 0x0001L << (TC_SHIFT + 15);  // 创建工作线程标志\n\n// 池状态\nprivate static final int RSLOCK = 1;\nprivate static final int RSIGNAL = 1 << 1;\nprivate static final int STARTED = 1 << 2;\nprivate static final int STOP = 1 << 29;\nprivate static final int TERMINATED = 1 << 30;\nprivate static final int SHUTDOWN = 1 << 31;\n\n// 实例字段\nvolatile long ctl;                   // 主控制参数\nvolatile int runState;               // 运行状态锁\nfinal int config;                    // 并行度|模式\nint indexSeed;                       // 用于生成工作线程索引\nvolatile WorkQueue[] workQueues;     // 主对象注册信息，workQueue\nfinal ForkJoinWorkerThreadFactory factory;// 线程工厂\nfinal UncaughtExceptionHandler ueh;  // 每个工作线程的异常信息\nfinal String workerNamePrefix;       // 用于创建工作线程的名称\nvolatile AtomicLong stealCounter;    // 偷取任务总数，也可作为同步监视器\n\n/** 静态初始化字段 */\n//线程工厂\npublic static final ForkJoinWorkerThreadFactory defaultForkJoinWorkerThreadFactory;\n//启动或杀死线程的方法调用者的权限\nprivate static final RuntimePermission modifyThreadPermission;\n// 公共静态pool\nstatic final ForkJoinPool common;\n//并行度，对应内部common池\nstatic final int commonParallelism;\n//备用线程数，在tryCompensate中使用\nprivate static int commonMaxSpares;\n//创建workerNamePrefix(工作线程名称前缀)时的序号\nprivate static int poolNumberSequence;\n//线程阻塞等待新的任务的超时值(以纳秒为单位)，默认2秒\nprivate static final long IDLE_TIMEOUT = 2000L * 1000L * 1000L; // 2sec\n//空闲超时时间，防止timer未命中\nprivate static final long TIMEOUT_SLOP = 20L * 1000L * 1000L;  // 20ms\n//默认备用线程数\nprivate static final int DEFAULT_COMMON_MAX_SPARES = 256;\n//阻塞前自旋的次数，用在在awaitRunStateLock和awaitWork中\nprivate static final int SPINS  = 0;\n//indexSeed的增量\nprivate static final int SEED_INCREMENT = 0x9e3779b9;\n\n\n说明: ForkJoinPool 的内部状态都是通过一个64位的 long 型 变量ctl来存储，它由四个16位的子域组成:\n\n * AC: 正在运行工作线程数减去目标并行度，高16位\n * TC: 总工作线程数减去目标并行度，中高16位\n * SS: 栈顶等待线程的版本计数和状态，中低16位\n * ID: 栈顶 WorkQueue 在池中的索引(poolIndex)，低16位\n\n在后面的源码解析中，某些地方也提取了ctl的低32位(sp=(int)ctl)来检查工作线程状态，例如，当sp不为0时说明当前还有空闲工作线程。\n\n# ForkJoinPool.WorkQueue 中的相关属性:\n\n//初始队列容量，2的幂\nstatic final int INITIAL_QUEUE_CAPACITY = 1 << 13;\n//最大队列容量\nstatic final int MAXIMUM_QUEUE_CAPACITY = 1 << 26; // 64M\n\n// 实例字段\nvolatile int scanState;    // Woker状态, <0: inactive; odd:scanning\nint stackPred;             // 记录前一个栈顶的ctl\nint nsteals;               // 偷取任务数\nint hint;                  // 记录偷取者索引，初始为随机索引\nint config;                // 池索引和模式\nvolatile int qlock;        // 1: locked, < 0: terminate; else 0\nvolatile int base;         //下一个poll操作的索引(栈底/队列头)\nint top;                   //  下一个push操作的索引(栈顶/队列尾)\nForkJoinTask<?>[] array;   // 任务数组\nfinal ForkJoinPool pool;   // the containing pool (may be null)\nfinal ForkJoinWorkerThread owner; // 当前工作队列的工作线程，共享模式下为null\nvolatile Thread parker;    // 调用park阻塞期间为owner，其他情况为null\nvolatile ForkJoinTask<?> currentJoin;  // 记录被join过来的任务\nvolatile ForkJoinTask<?> currentSteal; // 记录从其他工作队列偷取过来的任务\n\n\n\n# ForkJoinTask\n\n# 核心参数\n\n/** 任务运行状态 */\nvolatile int status; // 任务运行状态\nstatic final int DONE_MASK   = 0xf0000000;  // 任务完成状态标志位\nstatic final int NORMAL      = 0xf0000000;  // must be negative\nstatic final int CANCELLED   = 0xc0000000;  // must be < NORMAL\nstatic final int EXCEPTIONAL = 0x80000000;  // must be < CANCELLED\nstatic final int SIGNAL      = 0x00010000;  // must be >= 1 << 16 等待信号\nstatic final int SMASK       = 0x0000ffff;  //  低位掩码\n\n\n\n# Fork/Join框架源码解析\n\n\n# 构造函数\n\npublic ForkJoinPool(int parallelism,\n                    ForkJoinWorkerThreadFactory factory,\n                    UncaughtExceptionHandler handler,\n                    boolean asyncMode) {\n    this(checkParallelism(parallelism),\n            checkFactory(factory),\n            handler,\n            asyncMode ? FIFO_QUEUE : LIFO_QUEUE,\n            "ForkJoinPool-" + nextPoolId() + "-worker-");\n    checkPermission();\n}\n\n\n说明: 在 ForkJoinPool 中我们可以自定义四个参数:\n\n * parallelism: 并行度，默认为CPU数，最小为1\n * factory: 工作线程工厂；\n * handler: 处理工作线程运行任务时的异常情况类，默认为null；\n * asyncMode: 是否为异步模式，默认为 false。如果为true，表示子任务的执行遵循 FIFO 顺序并且任务不能被合并(join)，这种模式适用于工作线程只运行事件类型的异步任务。\n\n在多数场景使用时，如果没有太强的业务需求，我们一般直接使用 ForkJoinPool 中的common池，在JDK1.8之后提供了ForkJoinPool.commonPool()方法可以直接使用common池，来看一下它的构造:\n\nprivate static ForkJoinPool makeCommonPool() {\n    int parallelism = -1;\n    ForkJoinWorkerThreadFactory factory = null;\n    UncaughtExceptionHandler handler = null;\n    try {  // ignore exceptions in accessing/parsing\n        String pp = System.getProperty\n                ("java.util.concurrent.ForkJoinPool.common.parallelism");//并行度\n        String fp = System.getProperty\n                ("java.util.concurrent.ForkJoinPool.common.threadFactory");//线程工厂\n        String hp = System.getProperty\n                ("java.util.concurrent.ForkJoinPool.common.exceptionHandler");//异常处理类\n        if (pp != null)\n            parallelism = Integer.parseInt(pp);\n        if (fp != null)\n            factory = ((ForkJoinWorkerThreadFactory) ClassLoader.\n                    getSystemClassLoader().loadClass(fp).newInstance());\n        if (hp != null)\n            handler = ((UncaughtExceptionHandler) ClassLoader.\n                    getSystemClassLoader().loadClass(hp).newInstance());\n    } catch (Exception ignore) {\n    }\n    if (factory == null) {\n        if (System.getSecurityManager() == null)\n            factory = defaultForkJoinWorkerThreadFactory;\n        else // use security-managed default\n            factory = new InnocuousForkJoinWorkerThreadFactory();\n    }\n    if (parallelism < 0 && // default 1 less than #cores\n            (parallelism = Runtime.getRuntime().availableProcessors() - 1) <= 0)\n        parallelism = 1;//默认并行度为1\n    if (parallelism > MAX_CAP)\n        parallelism = MAX_CAP;\n    return new ForkJoinPool(parallelism, factory, handler, LIFO_QUEUE,\n            "ForkJoinPool.commonPool-worker-");\n}\n\n\n使用common pool的优点就是我们可以通过指定系统参数的方式定义“并行度、线程工厂和异常处理类”；并且它使用的是同步模式，也就是说可以支持任务合并(join)。\n\n\n# 执行流程 - 外部任务(external/submissions task)提交\n\n向 ForkJoinPool 提交任务有三种方式:\n\n * invoke()会等待任务计算完毕并返回计算结果；\n * execute()是直接向池提交一个任务来异步执行，无返回结果；\n * submit()也是异步执行，但是会返回提交的任务，在适当的时候可通过task.get()获取执行结果。\n\n这三种提交方式都都是调用externalPush()方法来完成，所以接下来我们将从externalPush()方法开始逐步分析外部任务的执行过程。\n\n# externalPush(ForkJoinTask<?> task)\n\n//添加给定任务到submission队列中\nfinal void externalPush(ForkJoinTask<?> task) {\n    WorkQueue[] ws;\n    WorkQueue q;\n    int m;\n    int r = ThreadLocalRandom.getProbe();//探针值，用于计算WorkQueue槽位索引\n    int rs = runState;\n    if ((ws = workQueues) != null && (m = (ws.length - 1)) >= 0 &&\n            (q = ws[m & r & SQMASK]) != null && r != 0 && rs > 0 && //获取随机偶数槽位的workQueue\n            U.compareAndSwapInt(q, QLOCK, 0, 1)) {//锁定workQueue\n        ForkJoinTask<?>[] a;\n        int am, n, s;\n        if ((a = q.array) != null &&\n                (am = a.length - 1) > (n = (s = q.top) - q.base)) {\n            int j = ((am & s) << ASHIFT) + ABASE;//计算任务索引位置\n            U.putOrderedObject(a, j, task);//任务入列\n            U.putOrderedInt(q, QTOP, s + 1);//更新push slot\n            U.putIntVolatile(q, QLOCK, 0);//解除锁定\n            if (n <= 1)\n                signalWork(ws, q);//任务数小于1时尝试创建或激活一个工作线程\n            return;\n        }\n        U.compareAndSwapInt(q, QLOCK, 1, 0);//解除锁定\n    }\n    externalSubmit(task);//初始化workQueues及相关属性\n}\n\n\n首先说明一下externalPush和externalSubmit两个方法的联系: 它们的作用都是把任务放到队列中等待执行。不同的是，externalSubmit可以说是完整版的externalPush，在任务首次提交时，需要初始化workQueues及其他相关属性，这个初始化操作就是externalSubmit来完成的；而后再向池中提交的任务都是通过简化版的externalSubmit-externalPush来完成。\n\nexternalPush的执行流程很简单: 首先找到一个随机偶数槽位的 workQueue，然后把任务放入这个 workQueue 的任务数组中，并更新top位。如果队列的剩余任务数小于1，则尝试创建或激活一个工作线程来运行任务(防止在externalSubmit初始化时发生异常导致工作线程创建失败)。\n\n# externalSubmit(ForkJoinTask<?> task)\n\n//任务提交\nprivate void externalSubmit(ForkJoinTask<?> task) {\n    //初始化调用线程的探针值，用于计算WorkQueue索引\n    int r;                                    // initialize caller\'s probe\n    if ((r = ThreadLocalRandom.getProbe()) == 0) {\n        ThreadLocalRandom.localInit();\n        r = ThreadLocalRandom.getProbe();\n    }\n    for (; ; ) {\n        WorkQueue[] ws;\n        WorkQueue q;\n        int rs, m, k;\n        boolean move = false;\n        if ((rs = runState) < 0) {// 池已关闭\n            tryTerminate(false, false);     // help terminate\n            throw new RejectedExecutionException();\n        }\n        //初始化workQueues\n        else if ((rs & STARTED) == 0 ||     // initialize\n                ((ws = workQueues) == null || (m = ws.length - 1) < 0)) {\n            int ns = 0;\n            rs = lockRunState();//锁定runState\n            try {\n                //初始化\n                if ((rs & STARTED) == 0) {\n                    //初始化stealCounter\n                    U.compareAndSwapObject(this, STEALCOUNTER, null,\n                            new AtomicLong());\n                    //创建workQueues，容量为2的幂次方\n                    // create workQueues array with size a power of two\n                    int p = config & SMASK; // ensure at least 2 slots\n                    int n = (p > 1) ? p - 1 : 1;\n                    n |= n >>> 1;\n                    n |= n >>> 2;\n                    n |= n >>> 4;\n                    n |= n >>> 8;\n                    n |= n >>> 16;\n                    n = (n + 1) << 1;\n                    workQueues = new WorkQueue[n];\n                    ns = STARTED;\n                }\n            } finally {\n                unlockRunState(rs, (rs & ~RSLOCK) | ns);//解锁并更新runState\n            }\n        } else if ((q = ws[k = r & m & SQMASK]) != null) {//获取随机偶数槽位的workQueue\n            if (q.qlock == 0 && U.compareAndSwapInt(q, QLOCK, 0, 1)) {//锁定 workQueue\n                ForkJoinTask<?>[] a = q.array;//当前workQueue的全部任务\n                int s = q.top;\n                boolean submitted = false; // initial submission or resizing\n                try {                      // locked version of push\n                    if ((a != null && a.length > s + 1 - q.base) ||\n                            (a = q.growArray()) != null) {//扩容\n                        int j = (((a.length - 1) & s) << ASHIFT) + ABASE;\n                        U.putOrderedObject(a, j, task);//放入给定任务\n                        U.putOrderedInt(q, QTOP, s + 1);//修改push slot\n                        submitted = true;\n                    }\n                } finally {\n                    U.compareAndSwapInt(q, QLOCK, 1, 0);//解除锁定\n                }\n                if (submitted) {//任务提交成功，创建或激活工作线程\n                    signalWork(ws, q);//创建或激活一个工作线程来运行任务\n                    return;\n                }\n            }\n            move = true;                   // move on failure 操作失败，重新获取探针值\n        } else if (((rs = runState) & RSLOCK) == 0) { // create new queue\n            q = new WorkQueue(this, null);\n            q.hint = r;\n            q.config = k | SHARED_QUEUE;\n            q.scanState = INACTIVE;\n            rs = lockRunState();           // publish index\n            if (rs > 0 && (ws = workQueues) != null &&\n                    k < ws.length && ws[k] == null)\n                ws[k] = q;                 // 更新索引k位值的workQueue\n            //else terminated\n            unlockRunState(rs, rs & ~RSLOCK);\n        } else\n            move = true;                   // move if busy\n        if (move)\n            r = ThreadLocalRandom.advanceProbe(r);//重新获取线程探针值\n    }\n}\n\n\n说明: externalSubmit是externalPush的完整版本，主要用于第一次提交任务时初始化workQueues及相关属性，并且提交给定任务到队列中。具体执行步骤如下:\n\n * 如果池为终止状态(runState<0)，调用tryTerminate来终止线程池，并抛出任务拒绝异常；\n * 如果尚未初始化，就为 FJP 执行初始化操作: 初始化stealCounter、创建workerQueues，然后继续自旋；\n * 初始化完成后，执行在externalPush中相同的操作: 获取 workQueue，放入指定任务。任务提交成功后调用signalWork方法创建或激活线程；\n * 如果在步骤3中获取到的 workQueue 为null，会在这一步中创建一个 workQueue，创建成功继续自旋执行第三步操作；\n * 如果非上述情况，或者有线程争用资源导致获取锁失败，就重新获取线程探针值继续自旋。\n\n# signalWork(WorkQueue[] ws, WorkQueue q)\n\nfinal void signalWork(WorkQueue[] ws, WorkQueue q) {\n    long c;\n    int sp, i;\n    WorkQueue v;\n    Thread p;\n    while ((c = ctl) < 0L) {                       // too few active\n        if ((sp = (int) c) == 0) {                  // no idle workers\n            if ((c & ADD_WORKER) != 0L)            // too few workers\n                tryAddWorker(c);//工作线程太少，添加新的工作线程\n            break;\n        }\n        if (ws == null)                            // unstarted/terminated\n            break;\n        if (ws.length <= (i = sp & SMASK))         // terminated\n            break;\n        if ((v = ws[i]) == null)                   // terminating\n            break;\n        //计算ctl，加上版本戳SS_SEQ避免ABA问题\n        int vs = (sp + SS_SEQ) & ~INACTIVE;        // next scanState\n        int d = sp - v.scanState;                  // screen CAS\n        //计算活跃线程数(高32位)并更新为下一个栈顶的scanState(低32位)\n        long nc = (UC_MASK & (c + AC_UNIT)) | (SP_MASK & v.stackPred);\n        if (d == 0 && U.compareAndSwapLong(this, CTL, c, nc)) {\n            v.scanState = vs;                      // activate v\n            if ((p = v.parker) != null)\n                U.unpark(p);//唤醒阻塞线程\n            break;\n        }\n        if (q != null && q.base == q.top)          // no more work\n            break;\n    }\n}\n\n\n说明: 新建或唤醒一个工作线程，在externalPush、externalSubmit、workQueue.push、scan中调用。如果还有空闲线程，则尝试唤醒索引到的 WorkQueue 的parker线程；如果工作线程过少((ctl & ADD_WORKER) != 0L)，则调用tryAddWorker添加一个新的工作线程。\n\n# tryAddWorker(long c)\n\nprivate void tryAddWorker(long c) {\n    boolean add = false;\n    do {\n        long nc = ((AC_MASK & (c + AC_UNIT)) |\n                   (TC_MASK & (c + TC_UNIT)));\n        if (ctl == c) {\n            int rs, stop;                 // check if terminating\n            if ((stop = (rs = lockRunState()) & STOP) == 0)\n                add = U.compareAndSwapLong(this, CTL, c, nc);\n            unlockRunState(rs, rs & ~RSLOCK);//释放锁\n            if (stop != 0)\n                break;\n            if (add) {\n                createWorker();//创建工作线程\n                break;\n            }\n        }\n    } while (((c = ctl) & ADD_WORKER) != 0L && (int)c == 0);\n}\n\n\n说明: 尝试添加一个新的工作线程，首先更新ctl中的工作线程数，然后调用createWorker()创建工作线程。\n\n# createWorker()\n\nprivate boolean createWorker() {\n    ForkJoinWorkerThreadFactory fac = factory;\n    Throwable ex = null;\n    ForkJoinWorkerThread wt = null;\n    try {\n        if (fac != null && (wt = fac.newThread(this)) != null) {\n            wt.start();\n            return true;\n        }\n    } catch (Throwable rex) {\n        ex = rex;\n    }\n    deregisterWorker(wt, ex);//线程创建失败处理\n    return false;\n}\n\n\n说明: createWorker首先通过线程工厂创一个新的ForkJoinWorkerThread，然后启动这个工作线程(wt.start())。如果期间发生异常，调用deregisterWorker处理线程创建失败的逻辑(deregisterWorker在后面再详细说明)。\n\nForkJoinWorkerThread 的构造函数如下:\n\nprotected ForkJoinWorkerThread(ForkJoinPool pool) {\n    // Use a placeholder until a useful name can be set in registerWorker\n    super("aForkJoinWorkerThread");\n    this.pool = pool;\n    this.workQueue = pool.registerWorker(this);\n}\n\n\n可以看到 ForkJoinWorkerThread 在构造时首先调用父类 Thread 的方法，然后为工作线程注册pool和workQueue，而workQueue的注册任务由ForkJoinPool.registerWorker来完成。\n\n# registerWorker()\n\nfinal WorkQueue registerWorker(ForkJoinWorkerThread wt) {\n    UncaughtExceptionHandler handler;\n    //设置为守护线程\n    wt.setDaemon(true);                           // configure thread\n    if ((handler = ueh) != null)\n        wt.setUncaughtExceptionHandler(handler);\n    WorkQueue w = new WorkQueue(this, wt);//构造新的WorkQueue\n    int i = 0;                                    // assign a pool index\n    int mode = config & MODE_MASK;\n    int rs = lockRunState();\n    try {\n        WorkQueue[] ws;\n        int n;                    // skip if no array\n        if ((ws = workQueues) != null && (n = ws.length) > 0) {\n            //生成新建WorkQueue的索引\n            int s = indexSeed += SEED_INCREMENT;  // unlikely to collide\n            int m = n - 1;\n            i = ((s << 1) | 1) & m;               // Worker任务放在奇数索引位 odd-numbered indices\n            if (ws[i] != null) {                  // collision 已存在，重新计算索引位\n                int probes = 0;                   // step by approx half n\n                int step = (n <= 4) ? 2 : ((n >>> 1) & EVENMASK) + 2;\n                //查找可用的索引位\n                while (ws[i = (i + step) & m] != null) {\n                    if (++probes >= n) {//所有索引位都被占用，对workQueues进行扩容\n                        workQueues = ws = Arrays.copyOf(ws, n <<= 1);//workQueues 扩容\n                        m = n - 1;\n                        probes = 0;\n                    }\n                }\n            }\n            w.hint = s;                           // use as random seed\n            w.config = i | mode;\n            w.scanState = i;                      // publication fence\n            ws[i] = w;\n        }\n    } finally {\n        unlockRunState(rs, rs & ~RSLOCK);\n    }\n    wt.setName(workerNamePrefix.concat(Integer.toString(i >>> 1)));\n    return w;\n}\n\n\n说明: registerWorker是 ForkJoinWorkerThread 构造器的回调函数，用于创建和记录工作线程的 WorkQueue。比较简单，就不多赘述了。注意在此为工作线程创建的 WorkQueue 是放在奇数索引的(代码行: i = ((s << 1) | 1) & m;)\n\n# 小结\n\nOK，外部任务的提交流程就先讲到这里。在createWorker()中启动工作线程后(wt.start())，当为线程分配到CPU执行时间片之后会运行 ForkJoinWorkerThread 的run方法开启线程来执行任务。工作线程执行任务的流程我们在讲完内部任务提交之后会统一讲解。\n\n\n# 执行流程: 子任务(Worker task)提交\n\n子任务的提交相对比较简单，由任务的fork()方法完成。通过上面的流程图可以看到任务被分割(fork)之后调用了ForkJoinPool.WorkQueue.push()方法直接把任务放到队列中等待被执行。\n\n# ForkJoinTask.fork()\n\npublic final ForkJoinTask<V> fork() {\n    Thread t;\n    if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)\n        ((ForkJoinWorkerThread)t).workQueue.push(this);\n    else\n        ForkJoinPool.common.externalPush(this);\n    return this;\n}\n\n\n说明: 如果当前线程是 Worker 线程，说明当前任务是fork分割的子任务，通过ForkJoinPool.workQueue.push()方法直接把任务放到自己的等待队列中；否则调用ForkJoinPool.externalPush()提交到一个随机的等待队列中(外部任务)。\n\n# ForkJoinPool.WorkQueue.push()\n\nfinal void push(ForkJoinTask<?> task) {\n    ForkJoinTask<?>[] a;\n    ForkJoinPool p;\n    int b = base, s = top, n;\n    if ((a = array) != null) {    // ignore if queue removed\n        int m = a.length - 1;     // fenced write for task visibility\n        U.putOrderedObject(a, ((m & s) << ASHIFT) + ABASE, task);\n        U.putOrderedInt(this, QTOP, s + 1);\n        if ((n = s - b) <= 1) {//首次提交，创建或唤醒一个工作线程\n            if ((p = pool) != null)\n                p.signalWork(p.workQueues, this);\n        } else if (n >= m)\n            growArray();\n    }\n}\n\n\n说明: 首先把任务放入等待队列并更新top位；如果当前 WorkQueue 为新建的等待队列(top-base<=1)，则调用signalWork方法为当前 WorkQueue 新建或唤醒一个工作线程；如果 WorkQueue 中的任务数组容量过小，则调用growArray()方法对其进行两倍扩容，growArray()方法源码如下:\n\nfinal ForkJoinTask<?>[] growArray() {\n    ForkJoinTask<?>[] oldA = array;//获取内部任务列表\n    int size = oldA != null ? oldA.length << 1 : INITIAL_QUEUE_CAPACITY;\n    if (size > MAXIMUM_QUEUE_CAPACITY)\n        throw new RejectedExecutionException("Queue capacity exceeded");\n    int oldMask, t, b;\n    //新建一个两倍容量的任务数组\n    ForkJoinTask<?>[] a = array = new ForkJoinTask<?>[size];\n    if (oldA != null && (oldMask = oldA.length - 1) >= 0 &&\n            (t = top) - (b = base) > 0) {\n        int mask = size - 1;\n        //从老数组中拿出数据，放到新的数组中\n        do { // emulate poll from old array, push to new array\n            ForkJoinTask<?> x;\n            int oldj = ((b & oldMask) << ASHIFT) + ABASE;\n            int j = ((b & mask) << ASHIFT) + ABASE;\n            x = (ForkJoinTask<?>) U.getObjectVolatile(oldA, oldj);\n            if (x != null &&\n                    U.compareAndSwapObject(oldA, oldj, x, null))\n                U.putObjectVolatile(a, j, x);\n        } while (++b != t);\n    }\n    return a;\n}\n\n\n# 小结\n\n到此，两种任务的提交流程都已经解析完毕，下一节我们来一起看看任务提交之后是如何被运行的。\n\n\n# 执行流程: 任务执行\n\n回到我们开始时的流程图，在ForkJoinPool .createWorker()方法中创建工作线程后，会启动工作线程，系统为工作线程分配到CPU执行时间片之后会执行 ForkJoinWorkerThread 的run()方法正式开始执行任务。\n\n# ForkJoinWorkerThread.run()\n\npublic void run() {\n    if (workQueue.array == null) { // only run once\n        Throwable exception = null;\n        try {\n            onStart();//钩子方法，可自定义扩展\n            pool.runWorker(workQueue);\n        } catch (Throwable ex) {\n            exception = ex;\n        } finally {\n            try {\n                onTermination(exception);//钩子方法，可自定义扩展\n            } catch (Throwable ex) {\n                if (exception == null)\n                    exception = ex;\n            } finally {\n                pool.deregisterWorker(this, exception);//处理异常\n            }\n        }\n    }\n}\n\n\n说明: 方法很简单，在工作线程运行前后会调用自定义钩子函数(onStart和onTermination)，任务的运行则是调用了ForkJoinPool.runWorker()。如果全部任务执行完毕或者期间遭遇异常，则通过ForkJoinPool.deregisterWorker关闭工作线程并处理异常信息(deregisterWorker方法我们后面会详细讲解)。\n\n# ForkJoinPool.runWorker(WorkQueue w)\n\nfinal void runWorker(WorkQueue w) {\n    w.growArray();                   // allocate queue\n    int seed = w.hint;               // initially holds randomization hint\n    int r = (seed == 0) ? 1 : seed;  // avoid 0 for xorShift\n    for (ForkJoinTask<?> t; ; ) {\n        if ((t = scan(w, r)) != null)//扫描任务执行\n            w.runTask(t);\n        else if (!awaitWork(w, r))\n            break;\n        r ^= r << 13;\n        r ^= r >>> 17;\n        r ^= r << 5; // xorshift\n    }\n}\n\n\n说明: runWorker是 ForkJoinWorkerThread 的主运行方法，用来依次执行当前工作线程中的任务。函数流程很简单: 调用scan方法依次获取任务，然后调用WorkQueue .runTask运行任务；如果未扫描到任务，则调用awaitWork等待，直到工作线程/线程池终止或等待超时。\n\n# ForkJoinPool.scan(WorkQueue w, int r)\n\nprivate ForkJoinTask<?> scan(WorkQueue w, int r) {\n    WorkQueue[] ws;\n    int m;\n    if ((ws = workQueues) != null && (m = ws.length - 1) > 0 && w != null) {\n        int ss = w.scanState;                     // initially non-negative\n        //初始扫描起点，自旋扫描\n        for (int origin = r & m, k = origin, oldSum = 0, checkSum = 0; ; ) {\n            WorkQueue q;\n            ForkJoinTask<?>[] a;\n            ForkJoinTask<?> t;\n            int b, n;\n            long c;\n            if ((q = ws[k]) != null) {//获取workQueue\n                if ((n = (b = q.base) - q.top) < 0 &&\n                        (a = q.array) != null) {      // non-empty\n                    //计算偏移量\n                    long i = (((a.length - 1) & b) << ASHIFT) + ABASE;\n                    if ((t = ((ForkJoinTask<?>)\n                            U.getObjectVolatile(a, i))) != null && //取base位置任务\n                            q.base == b) {//stable\n                        if (ss >= 0) {  //scanning\n                            if (U.compareAndSwapObject(a, i, t, null)) {//\n                                q.base = b + 1;//更新base位\n                                if (n < -1)       // signal others\n                                    signalWork(ws, q);//创建或唤醒工作线程来运行任务\n                                return t;\n                            }\n                        } else if (oldSum == 0 &&   // try to activate 尝试激活工作线程\n                                w.scanState < 0)\n                            tryRelease(c = ctl, ws[m & (int) c], AC_UNIT);//唤醒栈顶工作线程\n                    }\n                    //base位置任务为空或base位置偏移，随机移位重新扫描\n                    if (ss < 0)                   // refresh\n                        ss = w.scanState;\n                    r ^= r << 1;\n                    r ^= r >>> 3;\n                    r ^= r << 10;\n                    origin = k = r & m;           // move and rescan\n                    oldSum = checkSum = 0;\n                    continue;\n                }\n                checkSum += b;//队列任务为空，记录base位\n            }\n            //更新索引k 继续向后查找\n            if ((k = (k + 1) & m) == origin) {    // continue until stable\n                //运行到这里说明已经扫描了全部的 workQueues，但并未扫描到任务\n\n                if ((ss >= 0 || (ss == (ss = w.scanState))) &&\n                        oldSum == (oldSum = checkSum)) {\n                    if (ss < 0 || w.qlock < 0)    // already inactive\n                        break;// 已经被灭活或终止,跳出循环\n\n                    //对当前WorkQueue进行灭活操作\n                    int ns = ss | INACTIVE;       // try to inactivate\n                    long nc = ((SP_MASK & ns) |\n                            (UC_MASK & ((c = ctl) - AC_UNIT)));//计算ctl为INACTIVE状态并减少活跃线程数\n                    w.stackPred = (int) c;         // hold prev stack top\n                    U.putInt(w, QSCANSTATE, ns);//修改scanState为inactive状态\n                    if (U.compareAndSwapLong(this, CTL, c, nc))//更新scanState为灭活状态\n                        ss = ns;\n                    else\n                        w.scanState = ss;         // back out\n                }\n                checkSum = 0;//重置checkSum，继续循环\n            }\n        }\n    }\n    return null;\n}\n\n\n说明: 扫描并尝试偷取一个任务。使用w.hint进行随机索引 WorkQueue，也就是说并不一定会执行当前 WorkQueue 中的任务，而是偷取别的Worker的任务来执行。\n\n函数的大概执行流程如下:\n\n * 取随机位置的一个 WorkQueue；\n\n * 获取base位的 ForkJoinTask，成功取到后更新base位并返回任务；如果取到的 WorkQueue 中任务数大于1，则调用signalWork创建或唤醒其他工作线程；\n\n * 如果当前工作线程处于不活跃状态(INACTIVE)，则调用tryRelease尝试唤醒栈顶工作线程来执行。\n   \n   tryRelease源码如下:\n   \n   private boolean tryRelease(long c, WorkQueue v, long inc) {\n       int sp = (int) c, vs = (sp + SS_SEQ) & ~INACTIVE;\n       Thread p;\n       //ctl低32位等于scanState，说明可以唤醒parker线程\n       if (v != null && v.scanState == sp) {          // v is at top of stack\n           //计算活跃线程数(高32位)并更新为下一个栈顶的scanState(低32位)\n           long nc = (UC_MASK & (c + inc)) | (SP_MASK & v.stackPred);\n           if (U.compareAndSwapLong(this, CTL, c, nc)) {\n               v.scanState = vs;\n               if ((p = v.parker) != null)\n                   U.unpark(p);//唤醒线程\n               return true;\n           }\n       }\n       return false;\n   }\n   \n\n * 如果base位任务为空或发生偏移，则对索引位进行随机移位，然后重新扫描；\n\n * 如果扫描整个workQueues之后没有获取到任务，则设置当前工作线程为INACTIVE状态；然后重置checkSum，再次扫描一圈之后如果还没有任务则跳出循环返回null。\n\n# ForkJoinPool.awaitWork(WorkQueue w, int r)\n\nprivate boolean awaitWork(WorkQueue w, int r) {\n    if (w == null || w.qlock < 0)                 // w is terminating\n        return false;\n    for (int pred = w.stackPred, spins = SPINS, ss; ; ) {\n        if ((ss = w.scanState) >= 0)//正在扫描，跳出循环\n            break;\n        else if (spins > 0) {\n            r ^= r << 6;\n            r ^= r >>> 21;\n            r ^= r << 7;\n            if (r >= 0 && --spins == 0) {         // randomize spins\n                WorkQueue v;\n                WorkQueue[] ws;\n                int s, j;\n                AtomicLong sc;\n                if (pred != 0 && (ws = workQueues) != null &&\n                        (j = pred & SMASK) < ws.length &&\n                        (v = ws[j]) != null &&        // see if pred parking\n                        (v.parker == null || v.scanState >= 0))\n                    spins = SPINS;                // continue spinning\n            }\n        } else if (w.qlock < 0)                     // 当前workQueue已经终止，返回false recheck after spins\n            return false;\n        else if (!Thread.interrupted()) {//判断线程是否被中断，并清除中断状态\n            long c, prevctl, parkTime, deadline;\n            int ac = (int) ((c = ctl) >> AC_SHIFT) + (config & SMASK);//活跃线程数\n            if ((ac <= 0 && tryTerminate(false, false)) || //无active线程，尝试终止\n                    (runState & STOP) != 0)           // pool terminating\n                return false;\n            if (ac <= 0 && ss == (int) c) {        // is last waiter\n                //计算活跃线程数(高32位)并更新为下一个栈顶的scanState(低32位)\n                prevctl = (UC_MASK & (c + AC_UNIT)) | (SP_MASK & pred);\n                int t = (short) (c >>> TC_SHIFT);  // shrink excess spares\n                if (t > 2 && U.compareAndSwapLong(this, CTL, c, prevctl))//总线程过量\n                    return false;                 // else use timed wait\n                //计算空闲超时时间\n                parkTime = IDLE_TIMEOUT * ((t >= 0) ? 1 : 1 - t);\n                deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP;\n            } else\n                prevctl = parkTime = deadline = 0L;\n            Thread wt = Thread.currentThread();\n            U.putObject(wt, PARKBLOCKER, this);   // emulate LockSupport\n            w.parker = wt;//设置parker，准备阻塞\n            if (w.scanState < 0 && ctl == c)      // recheck before park\n                U.park(false, parkTime);//阻塞指定的时间\n\n            U.putOrderedObject(w, QPARKER, null);\n            U.putObject(wt, PARKBLOCKER, null);\n            if (w.scanState >= 0)//正在扫描，说明等到任务，跳出循环\n                break;\n            if (parkTime != 0L && ctl == c &&\n                    deadline - System.nanoTime() <= 0L &&\n                    U.compareAndSwapLong(this, CTL, c, prevctl))//未等到任务，更新ctl，返回false\n                return false;                     // shrink pool\n        }\n    }\n    return true;\n}\n\n\n说明: 回到runWorker方法，如果scan方法未扫描到任务，会调用awaitWork等待获取任务。函数的具体执行流程大家看源码，这里简单说一下:\n\n * 在等待获取任务期间，如果工作线程或线程池已经终止则直接返回false。如果当前无 active 线程，尝试终止线程池并返回false，如果终止失败并且当前是最后一个等待的 Worker，就阻塞指定的时间(IDLE_TIMEOUT)；等到届期或被唤醒后如果发现自己是scanning(scanState >= 0)状态，说明已经等到任务，跳出等待返回true继续 scan，否则的更新ctl并返回false。\n\n# WorkQueue.runTask()\n\nfinal void runTask(ForkJoinTask<?> task) {\n    if (task != null) {\n        scanState &= ~SCANNING; // mark as busy\n        (currentSteal = task).doExec();//更新currentSteal并执行任务\n        U.putOrderedObject(this, QCURRENTSTEAL, null); // release for GC\n        execLocalTasks();//依次执行本地任务\n        ForkJoinWorkerThread thread = owner;\n        if (++nsteals < 0)      // collect on overflow\n            transferStealCount(pool);//增加偷取任务数\n        scanState |= SCANNING;\n        if (thread != null)\n            thread.afterTopLevelExec();//执行钩子函数\n    }\n}\n\n\n说明: 在scan方法扫描到任务之后，调用WorkQueue.runTask()来执行获取到的任务，大概流程如下:\n\n * 标记scanState为正在执行状态；\n\n * 更新currentSteal为当前获取到的任务并执行它，任务的执行调用了ForkJoinTask.doExec()方法，源码如下:\n   \n   //ForkJoinTask.doExec()\n   final int doExec() {\n       int s; boolean completed;\n       if ((s = status) >= 0) {\n           try {\n               completed = exec();//执行我们定义的任务\n           } catch (Throwable rex) {\n               return setExceptionalCompletion(rex);\n           }\n           if (completed)\n               s = setCompletion(NORMAL);\n       }\n       return s;\n   }\n   \n\n * 调用execLocalTasks依次执行当前WorkerQueue中的任务，源码如下:\n   \n   //执行并移除所有本地任务\n   final void execLocalTasks() {\n       int b = base, m, s;\n       ForkJoinTask<?>[] a = array;\n       if (b - (s = top - 1) <= 0 && a != null &&\n               (m = a.length - 1) >= 0) {\n           if ((config & FIFO_QUEUE) == 0) {//FIFO模式\n               for (ForkJoinTask<?> t; ; ) {\n                   if ((t = (ForkJoinTask<?>) U.getAndSetObject\n                           (a, ((m & s) << ASHIFT) + ABASE, null)) == null)//FIFO执行，取top任务\n                       break;\n                   U.putOrderedInt(this, QTOP, s);\n                   t.doExec();//执行\n                   if (base - (s = top - 1) > 0)\n                       break;\n               }\n           } else\n               pollAndExecAll();//LIFO模式执行，取base任务\n       }\n   }\n   \n\n * 更新偷取任务数；\n\n * 还原scanState并执行钩子函数。\n\n# ForkJoinPool.deregisterWorker(ForkJoinWorkerThread wt, Throwable ex)\n\nfinal void deregisterWorker(ForkJoinWorkerThread wt, Throwable ex) {\n    WorkQueue w = null;\n    //1.移除workQueue\n    if (wt != null && (w = wt.workQueue) != null) {//获取ForkJoinWorkerThread的等待队列\n        WorkQueue[] ws;                           // remove index from array\n        int idx = w.config & SMASK;//计算workQueue索引\n        int rs = lockRunState();//获取runState锁和当前池运行状态\n        if ((ws = workQueues) != null && ws.length > idx && ws[idx] == w)\n            ws[idx] = null;//移除workQueue\n        unlockRunState(rs, rs & ~RSLOCK);//解除runState锁\n    }\n    //2.减少CTL数\n    long c;                                       // decrement counts\n    do {} while (!U.compareAndSwapLong\n                 (this, CTL, c = ctl, ((AC_MASK & (c - AC_UNIT)) |\n                                       (TC_MASK & (c - TC_UNIT)) |\n                                       (SP_MASK & c))));\n    //3.处理被移除workQueue内部相关参数\n    if (w != null) {\n        w.qlock = -1;                             // ensure set\n        w.transferStealCount(this);\n        w.cancelAll();                            // cancel remaining tasks\n    }\n    //4.如果线程未终止，替换被移除的workQueue并唤醒内部线程\n    for (;;) {                                    // possibly replace\n        WorkQueue[] ws; int m, sp;\n        //尝试终止线程池\n        if (tryTerminate(false, false) || w == null || w.array == null ||\n            (runState & STOP) != 0 || (ws = workQueues) == null ||\n            (m = ws.length - 1) < 0)              // already terminating\n            break;\n        //唤醒被替换的线程，依赖于下一步\n        if ((sp = (int)(c = ctl)) != 0) {         // wake up replacement\n            if (tryRelease(c, ws[sp & m], AC_UNIT))\n                break;\n        }\n        //创建工作线程替换\n        else if (ex != null && (c & ADD_WORKER) != 0L) {\n            tryAddWorker(c);                      // create replacement\n            break;\n        }\n        else                                      // don\'t need replacement\n            break;\n    }\n    //5.处理异常\n    if (ex == null)                               // help clean on way out\n        ForkJoinTask.helpExpungeStaleExceptions();\n    else                                          // rethrow\n        ForkJoinTask.rethrow(ex);\n}\n\n\n说明: deregisterWorker方法用于工作线程运行完毕之后终止线程或处理工作线程异常，主要就是清除已关闭的工作线程或回滚创建线程之前的操作，并把传入的异常抛给 ForkJoinTask 来处理。具体步骤见源码注释。\n\n# 小结\n\n本节我们对任务的执行流程进行了说明，后面我们将继续介绍任务的结果获取(join/invoke)。\n\n\n# 获取任务结果 - ForkJoinTask.join() / ForkJoinTask.invoke()\n\n * join() :\n\n//合并任务结果\npublic final V join() {\n    int s;\n    if ((s = doJoin() & DONE_MASK) != NORMAL)\n        reportException(s);\n    return getRawResult();\n}\n\n//join, get, quietlyJoin的主实现方法\nprivate int doJoin() {\n    int s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;\n    return (s = status) < 0 ? s :\n        ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?\n        (w = (wt = (ForkJoinWorkerThread)t).workQueue).\n        tryUnpush(this) && (s = doExec()) < 0 ? s :\n        wt.pool.awaitJoin(w, this, 0L) :\n        externalAwaitDone();\n}\n\n\n * invoke() :\n\n//执行任务，并等待任务完成并返回结果\npublic final V invoke() {\n    int s;\n    if ((s = doInvoke() & DONE_MASK) != NORMAL)\n        reportException(s);\n    return getRawResult();\n}\n\n//invoke, quietlyInvoke的主实现方法\nprivate int doInvoke() {\n    int s; Thread t; ForkJoinWorkerThread wt;\n    return (s = doExec()) < 0 ? s :\n        ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?\n        (wt = (ForkJoinWorkerThread)t).pool.\n        awaitJoin(wt.workQueue, this, 0L) :\n        externalAwaitDone();\n}\n\n\n说明: join()方法一把是在任务fork()之后调用，用来获取(或者叫“合并”)任务的执行结果。\n\nForkJoinTask的join()和invoke()方法都可以用来获取任务的执行结果(另外还有get方法也是调用了doJoin来获取任务结果，但是会响应运行时异常)，它们对外部提交任务的执行方式一致，都是通过externalAwaitDone方法等待执行结果。不同的是invoke()方法会直接执行当前任务；而join()方法则是在当前任务在队列 top 位时(通过tryUnpush方法判断)才能执行，如果当前任务不在 top 位或者任务执行失败调用ForkJoinPool.awaitJoin方法帮助执行或阻塞当前 join 任务。(所以在官方文档中建议了我们对ForkJoinTask任务的调用顺序，一对 fork-join操作一般按照如下顺序调用: a.fork(); b.fork(); b.join(); a.join();。因为任务 b 是后面进入队列，也就是说它是在栈顶的(top 位)，在它fork()之后直接调用join()就可以直接执行而不会调用ForkJoinPool.awaitJoin方法去等待。)\n\n在这些方法中，join()相对比较全面，所以之后的讲解我们将从join()开始逐步向下分析，首先看一下join()的执行流程:\n\n\n\n后面的源码分析中，我们首先讲解比较简单的外部 join 任务(externalAwaitDone)，然后再讲解内部 join 任务(从ForkJoinPool.awaitJoin()开始)。\n\n# ForkJoinTask.externalAwaitDone()\n\nprivate int externalAwaitDone() {\n    //执行任务\n    int s = ((this instanceof CountedCompleter) ? // try helping\n             ForkJoinPool.common.externalHelpComplete(  // CountedCompleter任务\n                 (CountedCompleter<?>)this, 0) :\n             ForkJoinPool.common.tryExternalUnpush(this) ? doExec() : 0);  // ForkJoinTask任务\n    if (s >= 0 && (s = status) >= 0) {//执行失败，进入等待\n        boolean interrupted = false;\n        do {\n            if (U.compareAndSwapInt(this, STATUS, s, s | SIGNAL)) {  //更新state\n                synchronized (this) {\n                    if (status >= 0) {//SIGNAL 等待信号\n                        try {\n                            wait(0L);\n                        } catch (InterruptedException ie) {\n                            interrupted = true;\n                        }\n                    }\n                    else\n                        notifyAll();\n                }\n            }\n        } while ((s = status) >= 0);\n        if (interrupted)\n            Thread.currentThread().interrupt();\n    }\n    return s;\n}\n\n\n说明: 如果当前join为外部调用，则调用此方法执行任务，如果任务执行失败就进入等待。方法本身是很简单的，需要注意的是对不同的任务类型分两种情况:\n\n * 如果我们的任务为 CountedCompleter 类型的任务，则调用externalHelpComplete方法来执行任务。\n\n * 其他类型的 ForkJoinTask 任务调用tryExternalUnpush来执行，源码如下:\n   \n   //为外部提交者提供 tryUnpush 功能(给定任务在top位时弹出任务)\n   final boolean tryExternalUnpush(ForkJoinTask<?> task) {\n       WorkQueue[] ws;\n       WorkQueue w;\n       ForkJoinTask<?>[] a;\n       int m, s;\n       int r = ThreadLocalRandom.getProbe();\n       if ((ws = workQueues) != null && (m = ws.length - 1) >= 0 &&\n               (w = ws[m & r & SQMASK]) != null &&\n               (a = w.array) != null && (s = w.top) != w.base) {\n           long j = (((a.length - 1) & (s - 1)) << ASHIFT) + ABASE;  //取top位任务\n           if (U.compareAndSwapInt(w, QLOCK, 0, 1)) {  //加锁\n               if (w.top == s && w.array == a &&\n                       U.getObject(a, j) == task &&\n                       U.compareAndSwapObject(a, j, task, null)) {  //符合条件，弹出\n                   U.putOrderedInt(w, QTOP, s - 1);  //更新top\n                   U.putOrderedInt(w, QLOCK, 0); //解锁，返回true\n                   return true;\n               }\n               U.compareAndSwapInt(w, QLOCK, 1, 0);  //当前任务不在top位，解锁返回false\n           }\n       }\n       return false;\n   }\n   \n   \n   tryExternalUnpush的作用就是判断当前任务是否在top位，如果是则弹出任务，然后在externalAwaitDone中调用doExec()执行任务。\n\n# ForkJoinPool.awaitJoin()\n\nfinal int awaitJoin(WorkQueue w, ForkJoinTask<?> task, long deadline) {\n    int s = 0;\n    if (task != null && w != null) {\n        ForkJoinTask<?> prevJoin = w.currentJoin;  //获取给定Worker的join任务\n        U.putOrderedObject(w, QCURRENTJOIN, task);  //把currentJoin替换为给定任务\n        //判断是否为CountedCompleter类型的任务\n        CountedCompleter<?> cc = (task instanceof CountedCompleter) ?\n                (CountedCompleter<?>) task : null;\n        for (; ; ) {\n            if ((s = task.status) < 0)  //已经完成|取消|异常 跳出循环\n                break;\n\n            if (cc != null)//CountedCompleter任务由helpComplete来完成join\n                helpComplete(w, cc, 0);\n            else if (w.base == w.top || w.tryRemoveAndExec(task))  //尝试执行\n                helpStealer(w, task);  //队列为空或执行失败，任务可能被偷，帮助偷取者执行该任务\n\n            if ((s = task.status) < 0) //已经完成|取消|异常，跳出循环\n                break;\n            //计算任务等待时间\n            long ms, ns;\n            if (deadline == 0L)\n                ms = 0L;\n            else if ((ns = deadline - System.nanoTime()) <= 0L)\n                break;\n            else if ((ms = TimeUnit.NANOSECONDS.toMillis(ns)) <= 0L)\n                ms = 1L;\n\n            if (tryCompensate(w)) {//执行补偿操作\n                task.internalWait(ms);//补偿执行成功，任务等待指定时间\n                U.getAndAddLong(this, CTL, AC_UNIT);//更新活跃线程数\n            }\n        }\n        U.putOrderedObject(w, QCURRENTJOIN, prevJoin);//循环结束，替换为原来的join任务\n    }\n    return s;\n}\n\n\n说明: 如果当前 join 任务不在Worker等待队列的top位，或者任务执行失败，调用此方法来帮助执行或阻塞当前 join 的任务。函数执行流程如下:\n\n * 由于每次调用awaitJoin都会优先执行当前join的任务，所以首先会更新currentJoin为当前join任务；\n\n * 进入自旋:\n   \n   * 首先检查任务是否已经完成(通过task.status < 0判断)，如果给定任务执行完毕|取消|异常 则跳出循环返回执行状态s；\n   * 如果是 CountedCompleter 任务类型，调用helpComplete方法来完成join操作(后面笔者会开新篇来专门讲解CountedCompleter，本篇暂时不做详细解析)；\n   * 非 CountedCompleter 任务类型调用WorkQueue.tryRemoveAndExec尝试执行任务；\n   * 如果给定 WorkQueue 的等待队列为空或任务执行失败，说明任务可能被偷，调用helpStealer帮助偷取者执行任务(也就是说，偷取者帮我执行任务，我去帮偷取者执行它的任务)；\n   * 再次判断任务是否执行完毕(task.status < 0)，如果任务执行失败，计算一个等待时间准备进行补偿操作；\n   * 调用tryCompensate方法为给定 WorkQueue 尝试执行补偿操作。在执行补偿期间，如果发现 资源争用|池处于unstable状态|当前Worker已终止，则调用ForkJoinTask.internalWait()方法等待指定的时间，任务唤醒之后继续自旋，ForkJoinTask.internalWait()源码如下:\n   \n   final void internalWait(long timeout) {\n       int s;\n       if ((s = status) >= 0 && // force completer to issue notify\n           U.compareAndSwapInt(this, STATUS, s, s | SIGNAL)) {//更新任务状态为SIGNAL(等待唤醒)\n           synchronized (this) {\n               if (status >= 0)\n                   try { wait(timeout); } catch (InterruptedException ie) { }\n               else\n                   notifyAll();\n           }\n       }\n   }\n   \n\n在awaitJoin中，我们总共调用了三个比较复杂的方法: tryRemoveAndExec、helpStealer和tryCompensate，下面我们依次讲解。\n\n# WorkQueue.tryRemoveAndExec(ForkJoinTask<?> task)\n\nfinal boolean tryRemoveAndExec(ForkJoinTask<?> task) {\n    ForkJoinTask<?>[] a;\n    int m, s, b, n;\n    if ((a = array) != null && (m = a.length - 1) >= 0 &&\n            task != null) {\n        while ((n = (s = top) - (b = base)) > 0) {\n            //从top往下自旋查找\n            for (ForkJoinTask<?> t; ; ) {      // traverse from s to b\n                long j = ((--s & m) << ASHIFT) + ABASE;//计算任务索引\n                if ((t = (ForkJoinTask<?>) U.getObject(a, j)) == null) //获取索引到的任务\n                    return s + 1 == top;     // shorter than expected\n                else if (t == task) { //给定任务为索引任务\n                    boolean removed = false;\n                    if (s + 1 == top) {      // pop\n                        if (U.compareAndSwapObject(a, j, task, null)) { //弹出任务\n                            U.putOrderedInt(this, QTOP, s); //更新top\n                            removed = true;\n                        }\n                    } else if (base == b)      // replace with proxy\n                        removed = U.compareAndSwapObject(\n                                a, j, task, new EmptyTask()); //join任务已经被移除，替换为一个占位任务\n                    if (removed)\n                        task.doExec(); //执行\n                    break;\n                } else if (t.status < 0 && s + 1 == top) { //给定任务不是top任务\n                    if (U.compareAndSwapObject(a, j, t, null)) //弹出任务\n                        U.putOrderedInt(this, QTOP, s);//更新top\n                    break;                  // was cancelled\n                }\n                if (--n == 0) //遍历结束\n                    return false;\n            }\n            if (task.status < 0) //任务执行完毕\n                return false;\n        }\n    }\n    return true;\n}\n\n\n说明: 从top位开始自旋向下找到给定任务，如果找到把它从当前 Worker 的任务队列中移除并执行它。注意返回的参数: 如果任务队列为空或者任务未执行完毕返回true；任务执行完毕返回false。\n\n# ForkJoinPool.helpStealer(WorkQueue w, ForkJoinTask<?> task)\n\nprivate void helpStealer(WorkQueue w, ForkJoinTask<?> task) {\n    WorkQueue[] ws = workQueues;\n    int oldSum = 0, checkSum, m;\n    if (ws != null && (m = ws.length - 1) >= 0 && w != null &&\n            task != null) {\n        do {                                       // restart point\n            checkSum = 0;                          // for stability check\n            ForkJoinTask<?> subtask;\n            WorkQueue j = w, v;                    // v is subtask stealer\n            descent:\n            for (subtask = task; subtask.status >= 0; ) {\n                //1. 找到给定WorkQueue的偷取者v\n                for (int h = j.hint | 1, k = 0, i; ; k += 2) {//跳两个索引，因为Worker在奇数索引位\n                    if (k > m)                     // can\'t find stealer\n                        break descent;\n                    if ((v = ws[i = (h + k) & m]) != null) {\n                        if (v.currentSteal == subtask) {//定位到偷取者\n                            j.hint = i;//更新stealer索引\n                            break;\n                        }\n                        checkSum += v.base;\n                    }\n                }\n                //2. 帮助偷取者v执行任务\n                for (; ; ) {                         // help v or descend\n                    ForkJoinTask<?>[] a;            //偷取者内部的任务\n                    int b;\n                    checkSum += (b = v.base);\n                    ForkJoinTask<?> next = v.currentJoin;//获取偷取者的join任务\n                    if (subtask.status < 0 || j.currentJoin != subtask ||\n                            v.currentSteal != subtask) // stale\n                        break descent; // stale，跳出descent循环重来\n                    if (b - v.top >= 0 || (a = v.array) == null) {\n                        if ((subtask = next) == null)   //偷取者的join任务为null，跳出descent循环\n                            break descent;\n                        j = v;\n                        break; //偷取者内部任务为空，可能任务也被偷走了；跳出本次循环，查找偷取者的偷取者\n                    }\n                    int i = (((a.length - 1) & b) << ASHIFT) + ABASE;//获取base偏移地址\n                    ForkJoinTask<?> t = ((ForkJoinTask<?>)\n                            U.getObjectVolatile(a, i));//获取偷取者的base任务\n                    if (v.base == b) {\n                        if (t == null)             // stale\n                            break descent; // stale，跳出descent循环重来\n                        if (U.compareAndSwapObject(a, i, t, null)) {//弹出任务\n                            v.base = b + 1;         //更新偷取者的base位\n                            ForkJoinTask<?> ps = w.currentSteal;//获取调用者偷来的任务\n                            int top = w.top;\n                            //首先更新给定workQueue的currentSteal为偷取者的base任务，然后执行该任务\n                            //然后通过检查top来判断给定workQueue是否有自己的任务，如果有，\n                            // 则依次弹出任务(LIFO)->更新currentSteal->执行该任务(注意这里是自己偷自己的任务执行)\n                            do {\n                                U.putOrderedObject(w, QCURRENTSTEAL, t);\n                                t.doExec();        // clear local tasks too\n                            } while (task.status >= 0 &&\n                                    w.top != top && //内部有自己的任务，依次弹出执行\n                                    (t = w.pop()) != null);\n                            U.putOrderedObject(w, QCURRENTSTEAL, ps);//还原给定workQueue的currentSteal\n                            if (w.base != w.top)//给定workQueue有自己的任务了，帮助结束，返回\n                                return;            // can\'t further help\n                        }\n                    }\n                }\n            }\n        } while (task.status >= 0 && oldSum != (oldSum = checkSum));\n    }\n}\n\n\n说明: 如果队列为空或任务执行失败，说明任务可能被偷，调用此方法来帮助偷取者执行任务。基本思想是: 偷取者帮助我执行任务，我去帮助偷取者执行它的任务。 函数执行流程如下:\n\n循环定位偷取者，由于Worker是在奇数索引位，所以每次会跳两个索引位。定位到偷取者之后，更新调用者 WorkQueue 的hint为偷取者的索引，方便下次定位； 定位到偷取者后，开始帮助偷取者执行任务。从偷取者的base索引开始，每次偷取一个任务执行。在帮助偷取者执行任务后，如果调用者发现本身已经有任务(w.top != top)，则依次弹出自己的任务(LIFO顺序)并执行(也就是说自己偷自己的任务执行)。\n\n# ForkJoinPool.tryCompensate(WorkQueue w)\n\n//执行补偿操作: 尝试缩减活动线程量，可能释放或创建一个补偿线程来准备阻塞\nprivate boolean tryCompensate(WorkQueue w) {\n    boolean canBlock;\n    WorkQueue[] ws;\n    long c;\n    int m, pc, sp;\n    if (w == null || w.qlock < 0 ||           // caller terminating\n            (ws = workQueues) == null || (m = ws.length - 1) <= 0 ||\n            (pc = config & SMASK) == 0)           // parallelism disabled\n        canBlock = false; //调用者已终止\n    else if ((sp = (int) (c = ctl)) != 0)      // release idle worker\n        canBlock = tryRelease(c, ws[sp & m], 0L);//唤醒等待的工作线程\n    else {//没有空闲线程\n        int ac = (int) (c >> AC_SHIFT) + pc; //活跃线程数\n        int tc = (short) (c >> TC_SHIFT) + pc;//总线程数\n        int nbusy = 0;                        // validate saturation\n        for (int i = 0; i <= m; ++i) {        // two passes of odd indices\n            WorkQueue v;\n            if ((v = ws[((i << 1) | 1) & m]) != null) {//取奇数索引位\n                if ((v.scanState & SCANNING) != 0)//没有正在运行任务，跳出\n                    break;\n                ++nbusy;//正在运行任务，添加标记\n            }\n        }\n        if (nbusy != (tc << 1) || ctl != c)\n            canBlock = false;                 // unstable or stale\n        else if (tc >= pc && ac > 1 && w.isEmpty()) {//总线程数大于并行度 && 活动线程数大于1 && 调用者任务队列为空，不需要补偿\n            long nc = ((AC_MASK & (c - AC_UNIT)) |\n                    (~AC_MASK & c));       // uncompensated\n            canBlock = U.compareAndSwapLong(this, CTL, c, nc);//更新活跃线程数\n        } else if (tc >= MAX_CAP ||\n                (this == common && tc >= pc + commonMaxSpares))//超出最大线程数\n            throw new RejectedExecutionException(\n                    "Thread limit exceeded replacing blocked worker");\n        else {                                // similar to tryAddWorker\n            boolean add = false;\n            int rs;      // CAS within lock\n            long nc = ((AC_MASK & c) |\n                    (TC_MASK & (c + TC_UNIT)));//计算总线程数\n            if (((rs = lockRunState()) & STOP) == 0)\n                add = U.compareAndSwapLong(this, CTL, c, nc);//更新总线程数\n            unlockRunState(rs, rs & ~RSLOCK);\n            //运行到这里说明活跃工作线程数不足，需要创建一个新的工作线程来补偿\n            canBlock = add && createWorker(); // throws on exception\n        }\n    }\n    return canBlock;\n}\n\n\n说明: 具体的执行看源码及注释，这里我们简单总结一下需要和不需要补偿的几种情况:\n\n需要补偿 :\n\n * 调用者队列不为空，并且有空闲工作线程，这种情况会唤醒空闲线程(调用tryRelease方法)\n * 池尚未停止，活跃线程数不足，这时会新建一个工作线程(调用createWorker方法)\n\n不需要补偿 :\n\n * 调用者已终止或池处于不稳定状态\n * 总线程数大于并行度 && 活动线程数大于1 && 调用者任务队列为空\n\n\n# Fork/Join的陷阱与注意事项\n\n使用Fork/Join框架时，需要注意一些陷阱, 在下面 斐波那契数列例子中你将看到示例:\n\n\n# 避免不必要的fork()\n\n划分成两个子任务后，不要同时调用两个子任务的fork()方法。\n\n表面上看上去两个子任务都fork()，然后join()两次似乎更自然。但事实证明，直接调用compute()效率更高。因为直接调用子任务的compute()方法实际上就是在当前的工作线程进行了计算(线程重用)，这比“将子任务提交到工作队列，线程又从工作队列中拿任务”快得多。\n\n> 当一个大任务被划分成两个以上的子任务时，尽可能使用前面说到的三个衍生的invokeAll方法，因为使用它们能避免不必要的fork()。\n\n\n# 注意fork()、compute()、join()的顺序\n\n为了两个任务并行，三个方法的调用顺序需要万分注意。\n\nright.fork(); // 计算右边的任务\nlong leftAns = left.compute(); // 计算左边的任务(同时右边任务也在计算)\nlong rightAns = right.join(); // 等待右边的结果\nreturn leftAns + rightAns;\n\n\n如果我们写成:\n\nleft.fork(); // 计算完左边的任务\nlong leftAns = left.join(); // 等待左边的计算结果\nlong rightAns = right.compute(); // 再计算右边的任务\nreturn leftAns + rightAns;\n\n\n或者\n\nlong rightAns = right.compute(); // 计算完右边的任务\nleft.fork(); // 再计算左边的任务\nlong leftAns = left.join(); // 等待左边的计算结果\nreturn leftAns + rightAns;\n\n\n这两种实际上都没有并行。\n\n\n# 选择合适的子任务粒度\n\n选择划分子任务的粒度(顺序执行的阈值)很重要，因为使用Fork/Join框架并不一定比顺序执行任务的效率高: 如果任务太大，则无法提高并行的吞吐量；如果任务太小，子任务的调度开销可能会大于并行计算的性能提升，我们还要考虑创建子任务、fork()子任务、线程调度以及合并子任务处理结果的耗时以及相应的内存消耗。\n\n官方文档给出的粗略经验是: 任务应该执行100~10000个基本的计算步骤。决定子任务的粒度的最好办法是实践，通过实际测试结果来确定这个阈值才是“上上策”。\n\n> 和其他Java代码一样，Fork/Join框架测试时需要“预热”或者说执行几遍才会被JIT(Just-in-time)编译器优化，所以测试性能之前跑几遍程序很重要。\n\n\n# 避免重量级任务划分与结果合并\n\nFork/Join的很多使用场景都用到数组或者List等数据结构，子任务在某个分区中运行，最典型的例子如并行排序和并行查找。拆分子任务以及合并处理结果的时候，应该尽量避免System.arraycopy这样耗时耗空间的操作，从而最小化任务的处理开销。\n\n\n# 再深入理解\n\n\n# 有哪些JDK源码中使用了Fork/Join思想?\n\n我们常用的数组工具类 Arrays 在JDK 8之后新增的并行排序方法(parallelSort)就运用了 ForkJoinPool 的特性，还有 ConcurrentHashMap 在JDK 8之后添加的函数式方法(如forEach等)也有运用。\n\n\n# 使用Executors工具类创建ForkJoinPool\n\nJava8在Executors工具类中新增了两个工厂方法:\n\n// parallelism定义并行级别\npublic static ExecutorService newWorkStealingPool(int parallelism);\n// 默认并行级别为JVM可用的处理器个数\n// Runtime.getRuntime().availableProcessors()\npublic static ExecutorService newWorkStealingPool();\n\n\n\n# 关于Fork/Join异常处理\n\nJava的受检异常机制一直饱受诟病，所以在ForkJoinTask的invoke()、join()方法及其衍生方法中都没有像get()方法那样抛出个ExecutionException的受检异常。\n\n所以你可以在ForkJoinTask中看到内部把受检异常转换成了运行时异常。\n\nstatic void rethrow(Throwable ex) {\n    if (ex != null)\n        ForkJoinTask.<RuntimeException>uncheckedThrow(ex);\n}\n\n@SuppressWarnings("unchecked")\nstatic <T extends Throwable> void uncheckedThrow(Throwable t) throws T {\n    throw (T)t; // rely on vacuous cast\n}\n\n\n关于Java你不知道的10件事中已经指出，JVM实际并不关心这个异常是受检异常还是运行时异常，受检异常这东西完全是给Java编译器用的: 用于警告程序员这里有个异常没有处理。\n\n但不可否认的是invoke、join()仍可能会抛出运行时异常，所以ForkJoinTask还提供了两个不提取结果和异常的方法quietlyInvoke()、quietlyJoin()，这两个方法允许你在所有任务完成后对结果和异常进行处理。\n\n使用quitelyInvoke()和quietlyJoin()时可以配合isCompletedAbnormally()和isCompletedNormally()方法使用。\n\n\n# 一些Fork/Join例子\n\n\n# 采用Fork/Join来异步计算1+2+3+…+10000的结果\n\npublic class Test {\n\tstatic final class SumTask extends RecursiveTask<Integer> {\n\t\tprivate static final long serialVersionUID = 1L;\n\t\t\n\t\tfinal int start; //开始计算的数\n\t\tfinal int end; //最后计算的数\n\t\t\n\t\tSumTask(int start, int end) {\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t}\n\n\t\t@Override\n\t\tprotected Integer compute() {\n\t\t\t//如果计算量小于1000，那么分配一个线程执行if中的代码块，并返回执行结果\n\t\t\tif(end - start < 1000) {\n\t\t\t\tSystem.out.println(Thread.currentThread().getName() + " 开始执行: " + start + "-" + end);\n\t\t\t\tint sum = 0;\n\t\t\t\tfor(int i = start; i <= end; i++)\n\t\t\t\t\tsum += i;\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t\t//如果计算量大于1000，那么拆分为两个任务\n\t\t\tSumTask task1 = new SumTask(start, (start + end) / 2);\n\t\t\tSumTask task2 = new SumTask((start + end) / 2 + 1, end);\n\t\t\t//执行任务\n\t\t\ttask1.fork();\n\t\t\ttask2.fork();\n\t\t\t//获取任务执行的结果\n\t\t\treturn task1.join() + task2.join();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws InterruptedException, ExecutionException {\n\t\tForkJoinPool pool = new ForkJoinPool();\n\t\tForkJoinTask<Integer> task = new SumTask(1, 10000);\n\t\tpool.submit(task);\n\t\tSystem.out.println(task.get());\n\t}\n}\n\n\n * 执行结果\n\nForkJoinPool-1-worker-1 开始执行: 1-625\nForkJoinPool-1-worker-7 开始执行: 6251-6875\nForkJoinPool-1-worker-6 开始执行: 5626-6250\nForkJoinPool-1-worker-10 开始执行: 3751-4375\nForkJoinPool-1-worker-13 开始执行: 2501-3125\nForkJoinPool-1-worker-8 开始执行: 626-1250\nForkJoinPool-1-worker-11 开始执行: 5001-5625\nForkJoinPool-1-worker-3 开始执行: 7501-8125\nForkJoinPool-1-worker-14 开始执行: 1251-1875\nForkJoinPool-1-worker-4 开始执行: 9376-10000\nForkJoinPool-1-worker-8 开始执行: 8126-8750\nForkJoinPool-1-worker-0 开始执行: 1876-2500\nForkJoinPool-1-worker-12 开始执行: 4376-5000\nForkJoinPool-1-worker-5 开始执行: 8751-9375\nForkJoinPool-1-worker-7 开始执行: 6876-7500\nForkJoinPool-1-worker-1 开始执行: 3126-3750\n50005000\n\n\n\n# 实现斐波那契数列\n\n> 斐波那契数列: 1、1、2、3、5、8、13、21、34、…… 公式 : F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)(n>=3，n∈N*)\n\npublic static void main(String[] args) {\n    ForkJoinPool forkJoinPool = new ForkJoinPool(4); // 最大并发数4\n    Fibonacci fibonacci = new Fibonacci(20);\n    long startTime = System.currentTimeMillis();\n    Integer result = forkJoinPool.invoke(fibonacci);\n    long endTime = System.currentTimeMillis();\n    System.out.println("Fork/join sum: " + result + " in " + (endTime - startTime) + " ms.");\n}\n//以下为官方API文档示例\nstatic  class Fibonacci extends RecursiveTask<Integer> {\n    final int n;\n    Fibonacci(int n) {\n        this.n = n;\n    }\n    @Override\n    protected Integer compute() {\n        if (n <= 1) {\n            return n;\n        }\n        Fibonacci f1 = new Fibonacci(n - 1);\n        f1.fork(); \n        Fibonacci f2 = new Fibonacci(n - 2);\n        return f2.compute() + f1.join(); \n    }\n}\n\n\n当然你也可以两个任务都fork，要注意的是两个任务都fork的情况，必须按照f1.fork()，f2.fork()， f2.join()，f1.join()这样的顺序，不然有性能问题，详见上面注意事项中的说明。\n\n官方API文档是这样写到的，所以平日用invokeAll就好了。invokeAll会把传入的任务的第一个交给当前线程来执行，其他的任务都fork加入工作队列，这样等于利用当前线程也执行任务了。\n\n{\n    // ...\n    Fibonacci f1 = new Fibonacci(n - 1);\n    Fibonacci f2 = new Fibonacci(n - 2);\n    invokeAll(f1,f2);\n    return f2.join() + f1.join();\n}\n\npublic static void invokeAll(ForkJoinTask<?>... tasks) {\n    Throwable ex = null;\n    int last = tasks.length - 1;\n    for (int i = last; i >= 0; --i) {\n        ForkJoinTask<?> t = tasks[i];\n        if (t == null) {\n            if (ex == null)\n                ex = new NullPointerException();\n        }\n        else if (i != 0)   //除了第一个都fork\n            t.fork();\n        else if (t.doInvoke() < NORMAL && ex == null)  //留一个自己执行\n            ex = t.getException();\n    }\n    for (int i = 1; i <= last; ++i) {\n        ForkJoinTask<?> t = tasks[i];\n        if (t != null) {\n            if (ex != null)\n                t.cancel(false);\n            else if (t.doJoin() < NORMAL)\n                ex = t.getException();\n        }\n    }\n    if (ex != null)\n        rethrow(ex);\n}\n\n\n\n\n# 参考文章\n\n * 首先推荐阅读ForkJoinPool的作者Doug Lea的一篇文章《A Java Fork/Join Framework》英文原文地址在新窗口打开\n * 本文主要参考自泰迪的bagwell的https://www.jianshu.com/p/32a15ef2f1bf和https://www.jianshu.com/p/6a14d0b54b8d，在此基础上参考了如下文章\n * https://blog.csdn.net/u010841296/article/details/83963637\n * https://blog.csdn.net/Holmofy/article/details/82714665\n * https://blog.csdn.net/abc123lzf/article/details/82873181\n * https://blog.csdn.net/yinwenjie/article/details/71524140\n * https://blog.csdn.net/cowbin2012/article/details/89791757\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-executor-ForkJoinPool.html',normalizedContent:'# juc线程池: fork/join框架详解\n\n> forkjoinpool 是jdk 7加入的一个线程池类。fork/join 技术是分治算法(divide-and-conquer)的并行实现，它是一项可以获得良好的并行性能的简单且高效的设计技术。目的是为了帮助我们更好地利用多处理器带来的好处，使用所有可用的运算能力来提升应用的性能。\n\n * juc线程池: fork/join框架详解\n   * 带着bat大厂的面试问题去理解fork/join框架\n   * fork/join框架简介\n     * 三个模块及关系\n     * 核心思想: 分治算法(divide-and-conquer)\n     * 核心思想: work-stealing(工作窃取)算法\n     * fork/join 框架的执行流程\n   * fork/join类关系\n     * forkjoinpool继承关系\n     * forkjointask继承关系\n   * fork/join框架源码解析\n     * forkjoinpool\n       * 核心参数\n       * forkjoinpool.workqueue 中的相关属性:\n     * forkjointask\n       * 核心参数\n   * fork/join框架源码解析\n     * 构造函数\n     * 执行流程 - 外部任务(external/submissions task)提交\n       * externalpush(forkjointask<?> task)\n       * externalsubmit(forkjointask<?> task)\n       * signalwork(workqueue[] ws, workqueue q)\n       * tryaddworker(long c)\n       * createworker()\n       * registerworker()\n       * 小结\n     * 执行流程: 子任务(worker task)提交\n       * forkjointask.fork()\n       * forkjoinpool.workqueue.push()\n       * 小结\n     * 执行流程: 任务执行\n       * forkjoinworkerthread.run()\n       * forkjoinpool.runworker(workqueue w)\n       * forkjoinpool.scan(workqueue w, int r)\n       * forkjoinpool.awaitwork(workqueue w, int r)\n       * workqueue.runtask()\n       * forkjoinpool.deregisterworker(forkjoinworkerthread wt, throwable ex)\n       * 小结\n     * 获取任务结果 - forkjointask.join() / forkjointask.invoke()\n       * forkjointask.externalawaitdone()\n       * forkjoinpool.awaitjoin()\n       * workqueue.tryremoveandexec(forkjointask<?> task)\n       * forkjoinpool.helpstealer(workqueue w, forkjointask<?> task)\n       * forkjoinpool.trycompensate(workqueue w)\n   * fork/join的陷阱与注意事项\n     * 避免不必要的fork()\n     * 注意fork()、compute()、join()的顺序\n     * 选择合适的子任务粒度\n     * 避免重量级任务划分与结果合并\n   * 再深入理解\n     * 有哪些jdk源码中使用了fork/join思想?\n     * 使用executors工具类创建forkjoinpool\n     * 关于fork/join异常处理\n   * 一些fork/join例子\n     * 采用fork/join来异步计算1+2+3+…+10000的结果\n     * 实现斐波那契数列\n   * 参考文章\n\n\n# 带着bat大厂的面试问题去理解fork/join框架\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解fork/join框架。\n\n * fork/join主要用来解决什么样的问题?\n * fork/join框架是在哪个jdk版本中引入的?\n * fork/join框架主要包含哪三个模块? 模块之间的关系是怎么样的?\n * forkjoinpool类继承关系?\n * forkjointask抽象类继承关系? 在实际运用中，我们一般都会继承 recursivetask 、recursiveaction 或 countedcompleter 来实现我们的业务需求，而不会直接继承 forkjointask 类。\n * 整个fork/join 框架的执行流程/运行机制是怎么样的?\n * 具体阐述fork/join的分治思想和work-stealing 实现方式?\n * 有哪些jdk源码中使用了fork/join思想?\n * 如何使用executors工具类创建forkjoinpool?\n * 写一个例子: 用forkjoin方式实现1+2+3+...+100000?\n * fork/join在使用时有哪些注意事项? 结合jdk中的斐波那契数列实例具体说明。\n\n\n# fork/join框架简介\n\nfork/join框架是java并发工具包中的一种可以将一个大任务拆分为很多小任务来异步执行的工具，自jdk1.7引入。\n\n\n# 三个模块及关系\n\nfork/join框架主要包含三个模块:\n\n * 任务对象: forkjointask (包括recursivetask、recursiveaction 和 countedcompleter)\n * 执行fork/join任务的线程: forkjoinworkerthread\n * 线程池: forkjoinpool\n\n这三者的关系是: forkjoinpool可以通过池中的forkjoinworkerthread来处理forkjointask任务。\n\n// from 《a java fork/join framework》dong lea\nresult solve(problem problem) {\n\tif (problem is small)\n \t\tdirectly solve problem\n \telse {\n \t\tsplit problem into independent parts\n \t\tfork new subtasks to solve each part\n \t\tjoin all subtasks\n \t\tcompose result from subresults\n\t}\n}\n\n\nforkjoinpool 只接收 forkjointask 任务(在实际使用中，也可以接收 runnable/callable 任务，但在真正运行时，也会把这些任务封装成 forkjointask 类型的任务)，recursivetask 是 forkjointask 的子类，是一个可以递归执行的 forkjointask，recursiveaction 是一个无返回值的 recursivetask，countedcompleter 在任务完成执行后会触发执行一个自定义的钩子函数。\n\n在实际运用中，我们一般都会继承 recursivetask 、recursiveaction 或 countedcompleter 来实现我们的业务需求，而不会直接继承 forkjointask 类。\n\n\n# 核心思想: 分治算法(divide-and-conquer)\n\n分治算法(divide-and-conquer)把任务递归的拆分为各个子任务，这样可以更好的利用系统资源，尽可能的使用所有可用的计算能力来提升应用性能。首先看一下 fork/join 框架的任务运行机制:\n\n\n\n * 这里也可以一并看下: 算法思想 - 分治算法\n\n\n# 核心思想: work-stealing(工作窃取)算法\n\nwork-stealing(工作窃取)算法: 线程池内的所有工作线程都尝试找到并执行已经提交的任务，或者是被其他活动任务创建的子任务(如果不存在就阻塞等待)。这种特性使得 forkjoinpool 在运行多个可以产生子任务的任务，或者是提交的许多小任务时效率更高。尤其是构建异步模型的 forkjoinpool 时，对不需要合并(join)的事件类型任务也非常适用。\n\n在 forkjoinpool 中，线程池中每个工作线程(forkjoinworkerthread)都对应一个任务队列(workqueue)，工作线程优先处理来自自身队列的任务(lifo或fifo顺序，参数 mode 决定)，然后以fifo的顺序随机窃取其他队列中的任务。\n\n具体思路如下:\n\n * 每个线程都有自己的一个workqueue，该工作队列是一个双端队列。\n * 队列支持三个功能push、pop、poll\n * push/pop只能被队列的所有者线程调用，而poll可以被其他线程调用。\n * 划分的子任务调用fork时，都会被push到自己的队列中。\n * 默认情况下，工作线程从自己的双端队列获出任务并执行。\n * 当自己的队列为空时，线程随机从另一个线程的队列末尾调用poll方法窃取任务。\n\n\n\n\n# fork/join 框架的执行流程\n\n上图可以看出forkjoinpool 中的任务执行分两种:\n\n * 直接通过 fjp 提交的外部任务(external/submissions task)，存放在 workqueues 的偶数槽位；\n * 通过内部 fork 分割的子任务(worker task)，存放在 workqueues 的奇数槽位。\n\n那fork/join 框架的执行流程是什么样的?\n\n\n\n> 后续的源码解析将围绕上图进行。\n\n\n# fork/join类关系\n\n\n# forkjoinpool继承关系\n\n\n\n内部类介绍:\n\n * forkjoinworkerthreadfactory: 内部线程工厂接口，用于创建工作线程forkjoinworkerthread\n\n * defaultforkjoinworkerthreadfactory: forkjoinworkerthreadfactory 的默认实现类\n\n * innocuousforkjoinworkerthreadfactory: 实现了 forkjoinworkerthreadfactory，无许可线程工厂，当系统变量中有系统安全管理相关属性时，默认使用这个工厂创建工作线程。\n\n * emptytask: 内部占位类，用于替换队列中 join 的任务。\n\n * managedblocker: 为 forkjoinpool 中的任务提供扩展管理并行数的接口，一般用在可能会阻塞的任务(如在 phaser 中用于等待 phase 到下一个generation)。\n\n * workqueue: forkjoinpool 的核心数据结构，本质上是work-stealing 模式的双端任务队列，内部存放 forkjointask 对象任务，使用 @contented 注解修饰防止伪共享。\n   \n   * 工作线程在运行中产生新的任务(通常是因为调用了 fork())时，此时可以把 workqueue 的数据结构视为一个栈，新的任务会放入栈顶(top 位)；工作线程在处理自己工作队列的任务时，按照 lifo 的顺序。\n   * 工作线程在处理自己的工作队列同时，会尝试窃取一个任务(可能是来自于刚刚提交到 pool 的任务，或是来自于其他工作线程的队列任务)，此时可以把 workqueue 的数据结构视为一个 fifo 的队列，窃取的任务位于其他线程的工作队列的队首(base位)。\n\n * 伪共享状态: 缓存系统中是以缓存行(cache line)为单位存储的。缓存行是2的整数幂个连续字节，一般为32-256个字节。最常见的缓存行大小是64个字节。当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。\n\n\n# forkjointask继承关系\n\n\n\nforkjointask 实现了 future 接口，说明它也是一个可取消的异步运算任务，实际上forkjointask 是 future 的轻量级实现，主要用在纯粹是计算的函数式任务或者操作完全独立的对象计算任务。fork 是主运行方法，用于异步执行；而 join 方法在任务结果计算完毕之后才会运行，用来合并或返回计算结果。 其内部类都比较简单，exceptionnode 是用于存储任务执行期间的异常信息的单向链表；其余四个类是为 runnable/callable 任务提供的适配器类，用于把 runnable/callable 转化为 forkjointask 类型的任务(因为 forkjoinpool 只可以运行 forkjointask 类型的任务)。\n\n\n# fork/join框架源码解析\n\n> 分析思路: 在对类层次结构有了解以后，我们先看下内部核心参数，然后分析上述流程图。会分4个部分:\n\n * 首先介绍任务的提交流程 - 外部任务(external/submissions task)提交\n * 然后介绍任务的提交流程 - 子任务(worker task)提交\n * 再分析任务的执行过程(forkjoinworkerthread.run()到forkjointask.doexec()这一部分)；\n * 最后介绍任务的结果获取(forkjointask.join()和forkjointask.invoke())\n\n\n# forkjoinpool\n\n# 核心参数\n\n在后面的源码解析中，我们会看到大量的位运算，这些位运算都是通过我们接下来介绍的一些常量参数来计算的。\n\n例如，如果要更新活跃线程数，使用公式(uc_mask & (c + ac_unit)) | (sp_mask & c)；c 代表当前 ctl，uc_mask 和 sp_mask 分别是高位和低位掩码，ac_unit 为活跃线程的增量数，使用(uc_mask & (c + ac_unit))就可以计算出高32位，然后再加上低32位(sp_mask & c)，就拼接成了一个新的ctl。\n\n这些运算的可读性很差，看起来有些复杂。在后面源码解析中有位运算的地方我都会加上注释，大家只需要了解它们的作用即可。\n\nforkjoinpool 与 内部类 workqueue 共享的一些常量:\n\n// constants shared across forkjoinpool and workqueue\n\n// 限定参数\nstatic final int smask = 0xffff;        //  低位掩码，也是最大索引位\nstatic final int max_cap = 0x7fff;        //  工作线程最大容量\nstatic final int evenmask = 0xfffe;        //  偶数低位掩码\nstatic final int sqmask = 0x007e;        //  workqueues 数组最多64个槽位\n\n// ctl 子域和 workqueue.scanstate 的掩码和标志位\nstatic final int scanning = 1;             // 标记是否正在运行任务\nstatic final int inactive = 1 << 31;       // 失活状态  负数\nstatic final int ss_seq = 1 << 16;       // 版本戳，防止aba问题\n\n// forkjoinpool.config 和 workqueue.config 的配置信息标记\nstatic final int mode_mask = 0xffff << 16;  // 模式掩码\nstatic final int lifo_queue = 0; //lifo队列\nstatic final int fifo_queue = 1 << 16;//fifo队列\nstatic final int shared_queue = 1 << 31;       // 共享模式队列，负数\n\n\nforkjoinpool 中的相关常量和实例字段:\n\n//  低位和高位掩码\nprivate static final long sp_mask = 0xffffffffl;\nprivate static final long uc_mask = ~sp_mask;\n\n// 活跃线程数\nprivate static final int ac_shift = 48;\nprivate static final long ac_unit = 0x0001l << ac_shift; //活跃线程数增量\nprivate static final long ac_mask = 0xffffl << ac_shift; //活跃线程数掩码\n\n// 工作线程数\nprivate static final int tc_shift = 32;\nprivate static final long tc_unit = 0x0001l << tc_shift; //工作线程数增量\nprivate static final long tc_mask = 0xffffl << tc_shift; //掩码\nprivate static final long add_worker = 0x0001l << (tc_shift + 15);  // 创建工作线程标志\n\n// 池状态\nprivate static final int rslock = 1;\nprivate static final int rsignal = 1 << 1;\nprivate static final int started = 1 << 2;\nprivate static final int stop = 1 << 29;\nprivate static final int terminated = 1 << 30;\nprivate static final int shutdown = 1 << 31;\n\n// 实例字段\nvolatile long ctl;                   // 主控制参数\nvolatile int runstate;               // 运行状态锁\nfinal int config;                    // 并行度|模式\nint indexseed;                       // 用于生成工作线程索引\nvolatile workqueue[] workqueues;     // 主对象注册信息，workqueue\nfinal forkjoinworkerthreadfactory factory;// 线程工厂\nfinal uncaughtexceptionhandler ueh;  // 每个工作线程的异常信息\nfinal string workernameprefix;       // 用于创建工作线程的名称\nvolatile atomiclong stealcounter;    // 偷取任务总数，也可作为同步监视器\n\n/** 静态初始化字段 */\n//线程工厂\npublic static final forkjoinworkerthreadfactory defaultforkjoinworkerthreadfactory;\n//启动或杀死线程的方法调用者的权限\nprivate static final runtimepermission modifythreadpermission;\n// 公共静态pool\nstatic final forkjoinpool common;\n//并行度，对应内部common池\nstatic final int commonparallelism;\n//备用线程数，在trycompensate中使用\nprivate static int commonmaxspares;\n//创建workernameprefix(工作线程名称前缀)时的序号\nprivate static int poolnumbersequence;\n//线程阻塞等待新的任务的超时值(以纳秒为单位)，默认2秒\nprivate static final long idle_timeout = 2000l * 1000l * 1000l; // 2sec\n//空闲超时时间，防止timer未命中\nprivate static final long timeout_slop = 20l * 1000l * 1000l;  // 20ms\n//默认备用线程数\nprivate static final int default_common_max_spares = 256;\n//阻塞前自旋的次数，用在在awaitrunstatelock和awaitwork中\nprivate static final int spins  = 0;\n//indexseed的增量\nprivate static final int seed_increment = 0x9e3779b9;\n\n\n说明: forkjoinpool 的内部状态都是通过一个64位的 long 型 变量ctl来存储，它由四个16位的子域组成:\n\n * ac: 正在运行工作线程数减去目标并行度，高16位\n * tc: 总工作线程数减去目标并行度，中高16位\n * ss: 栈顶等待线程的版本计数和状态，中低16位\n * id: 栈顶 workqueue 在池中的索引(poolindex)，低16位\n\n在后面的源码解析中，某些地方也提取了ctl的低32位(sp=(int)ctl)来检查工作线程状态，例如，当sp不为0时说明当前还有空闲工作线程。\n\n# forkjoinpool.workqueue 中的相关属性:\n\n//初始队列容量，2的幂\nstatic final int initial_queue_capacity = 1 << 13;\n//最大队列容量\nstatic final int maximum_queue_capacity = 1 << 26; // 64m\n\n// 实例字段\nvolatile int scanstate;    // woker状态, <0: inactive; odd:scanning\nint stackpred;             // 记录前一个栈顶的ctl\nint nsteals;               // 偷取任务数\nint hint;                  // 记录偷取者索引，初始为随机索引\nint config;                // 池索引和模式\nvolatile int qlock;        // 1: locked, < 0: terminate; else 0\nvolatile int base;         //下一个poll操作的索引(栈底/队列头)\nint top;                   //  下一个push操作的索引(栈顶/队列尾)\nforkjointask<?>[] array;   // 任务数组\nfinal forkjoinpool pool;   // the containing pool (may be null)\nfinal forkjoinworkerthread owner; // 当前工作队列的工作线程，共享模式下为null\nvolatile thread parker;    // 调用park阻塞期间为owner，其他情况为null\nvolatile forkjointask<?> currentjoin;  // 记录被join过来的任务\nvolatile forkjointask<?> currentsteal; // 记录从其他工作队列偷取过来的任务\n\n\n\n# forkjointask\n\n# 核心参数\n\n/** 任务运行状态 */\nvolatile int status; // 任务运行状态\nstatic final int done_mask   = 0xf0000000;  // 任务完成状态标志位\nstatic final int normal      = 0xf0000000;  // must be negative\nstatic final int cancelled   = 0xc0000000;  // must be < normal\nstatic final int exceptional = 0x80000000;  // must be < cancelled\nstatic final int signal      = 0x00010000;  // must be >= 1 << 16 等待信号\nstatic final int smask       = 0x0000ffff;  //  低位掩码\n\n\n\n# fork/join框架源码解析\n\n\n# 构造函数\n\npublic forkjoinpool(int parallelism,\n                    forkjoinworkerthreadfactory factory,\n                    uncaughtexceptionhandler handler,\n                    boolean asyncmode) {\n    this(checkparallelism(parallelism),\n            checkfactory(factory),\n            handler,\n            asyncmode ? fifo_queue : lifo_queue,\n            "forkjoinpool-" + nextpoolid() + "-worker-");\n    checkpermission();\n}\n\n\n说明: 在 forkjoinpool 中我们可以自定义四个参数:\n\n * parallelism: 并行度，默认为cpu数，最小为1\n * factory: 工作线程工厂；\n * handler: 处理工作线程运行任务时的异常情况类，默认为null；\n * asyncmode: 是否为异步模式，默认为 false。如果为true，表示子任务的执行遵循 fifo 顺序并且任务不能被合并(join)，这种模式适用于工作线程只运行事件类型的异步任务。\n\n在多数场景使用时，如果没有太强的业务需求，我们一般直接使用 forkjoinpool 中的common池，在jdk1.8之后提供了forkjoinpool.commonpool()方法可以直接使用common池，来看一下它的构造:\n\nprivate static forkjoinpool makecommonpool() {\n    int parallelism = -1;\n    forkjoinworkerthreadfactory factory = null;\n    uncaughtexceptionhandler handler = null;\n    try {  // ignore exceptions in accessing/parsing\n        string pp = system.getproperty\n                ("java.util.concurrent.forkjoinpool.common.parallelism");//并行度\n        string fp = system.getproperty\n                ("java.util.concurrent.forkjoinpool.common.threadfactory");//线程工厂\n        string hp = system.getproperty\n                ("java.util.concurrent.forkjoinpool.common.exceptionhandler");//异常处理类\n        if (pp != null)\n            parallelism = integer.parseint(pp);\n        if (fp != null)\n            factory = ((forkjoinworkerthreadfactory) classloader.\n                    getsystemclassloader().loadclass(fp).newinstance());\n        if (hp != null)\n            handler = ((uncaughtexceptionhandler) classloader.\n                    getsystemclassloader().loadclass(hp).newinstance());\n    } catch (exception ignore) {\n    }\n    if (factory == null) {\n        if (system.getsecuritymanager() == null)\n            factory = defaultforkjoinworkerthreadfactory;\n        else // use security-managed default\n            factory = new innocuousforkjoinworkerthreadfactory();\n    }\n    if (parallelism < 0 && // default 1 less than #cores\n            (parallelism = runtime.getruntime().availableprocessors() - 1) <= 0)\n        parallelism = 1;//默认并行度为1\n    if (parallelism > max_cap)\n        parallelism = max_cap;\n    return new forkjoinpool(parallelism, factory, handler, lifo_queue,\n            "forkjoinpool.commonpool-worker-");\n}\n\n\n使用common pool的优点就是我们可以通过指定系统参数的方式定义“并行度、线程工厂和异常处理类”；并且它使用的是同步模式，也就是说可以支持任务合并(join)。\n\n\n# 执行流程 - 外部任务(external/submissions task)提交\n\n向 forkjoinpool 提交任务有三种方式:\n\n * invoke()会等待任务计算完毕并返回计算结果；\n * execute()是直接向池提交一个任务来异步执行，无返回结果；\n * submit()也是异步执行，但是会返回提交的任务，在适当的时候可通过task.get()获取执行结果。\n\n这三种提交方式都都是调用externalpush()方法来完成，所以接下来我们将从externalpush()方法开始逐步分析外部任务的执行过程。\n\n# externalpush(forkjointask<?> task)\n\n//添加给定任务到submission队列中\nfinal void externalpush(forkjointask<?> task) {\n    workqueue[] ws;\n    workqueue q;\n    int m;\n    int r = threadlocalrandom.getprobe();//探针值，用于计算workqueue槽位索引\n    int rs = runstate;\n    if ((ws = workqueues) != null && (m = (ws.length - 1)) >= 0 &&\n            (q = ws[m & r & sqmask]) != null && r != 0 && rs > 0 && //获取随机偶数槽位的workqueue\n            u.compareandswapint(q, qlock, 0, 1)) {//锁定workqueue\n        forkjointask<?>[] a;\n        int am, n, s;\n        if ((a = q.array) != null &&\n                (am = a.length - 1) > (n = (s = q.top) - q.base)) {\n            int j = ((am & s) << ashift) + abase;//计算任务索引位置\n            u.putorderedobject(a, j, task);//任务入列\n            u.putorderedint(q, qtop, s + 1);//更新push slot\n            u.putintvolatile(q, qlock, 0);//解除锁定\n            if (n <= 1)\n                signalwork(ws, q);//任务数小于1时尝试创建或激活一个工作线程\n            return;\n        }\n        u.compareandswapint(q, qlock, 1, 0);//解除锁定\n    }\n    externalsubmit(task);//初始化workqueues及相关属性\n}\n\n\n首先说明一下externalpush和externalsubmit两个方法的联系: 它们的作用都是把任务放到队列中等待执行。不同的是，externalsubmit可以说是完整版的externalpush，在任务首次提交时，需要初始化workqueues及其他相关属性，这个初始化操作就是externalsubmit来完成的；而后再向池中提交的任务都是通过简化版的externalsubmit-externalpush来完成。\n\nexternalpush的执行流程很简单: 首先找到一个随机偶数槽位的 workqueue，然后把任务放入这个 workqueue 的任务数组中，并更新top位。如果队列的剩余任务数小于1，则尝试创建或激活一个工作线程来运行任务(防止在externalsubmit初始化时发生异常导致工作线程创建失败)。\n\n# externalsubmit(forkjointask<?> task)\n\n//任务提交\nprivate void externalsubmit(forkjointask<?> task) {\n    //初始化调用线程的探针值，用于计算workqueue索引\n    int r;                                    // initialize caller\'s probe\n    if ((r = threadlocalrandom.getprobe()) == 0) {\n        threadlocalrandom.localinit();\n        r = threadlocalrandom.getprobe();\n    }\n    for (; ; ) {\n        workqueue[] ws;\n        workqueue q;\n        int rs, m, k;\n        boolean move = false;\n        if ((rs = runstate) < 0) {// 池已关闭\n            tryterminate(false, false);     // help terminate\n            throw new rejectedexecutionexception();\n        }\n        //初始化workqueues\n        else if ((rs & started) == 0 ||     // initialize\n                ((ws = workqueues) == null || (m = ws.length - 1) < 0)) {\n            int ns = 0;\n            rs = lockrunstate();//锁定runstate\n            try {\n                //初始化\n                if ((rs & started) == 0) {\n                    //初始化stealcounter\n                    u.compareandswapobject(this, stealcounter, null,\n                            new atomiclong());\n                    //创建workqueues，容量为2的幂次方\n                    // create workqueues array with size a power of two\n                    int p = config & smask; // ensure at least 2 slots\n                    int n = (p > 1) ? p - 1 : 1;\n                    n |= n >>> 1;\n                    n |= n >>> 2;\n                    n |= n >>> 4;\n                    n |= n >>> 8;\n                    n |= n >>> 16;\n                    n = (n + 1) << 1;\n                    workqueues = new workqueue[n];\n                    ns = started;\n                }\n            } finally {\n                unlockrunstate(rs, (rs & ~rslock) | ns);//解锁并更新runstate\n            }\n        } else if ((q = ws[k = r & m & sqmask]) != null) {//获取随机偶数槽位的workqueue\n            if (q.qlock == 0 && u.compareandswapint(q, qlock, 0, 1)) {//锁定 workqueue\n                forkjointask<?>[] a = q.array;//当前workqueue的全部任务\n                int s = q.top;\n                boolean submitted = false; // initial submission or resizing\n                try {                      // locked version of push\n                    if ((a != null && a.length > s + 1 - q.base) ||\n                            (a = q.growarray()) != null) {//扩容\n                        int j = (((a.length - 1) & s) << ashift) + abase;\n                        u.putorderedobject(a, j, task);//放入给定任务\n                        u.putorderedint(q, qtop, s + 1);//修改push slot\n                        submitted = true;\n                    }\n                } finally {\n                    u.compareandswapint(q, qlock, 1, 0);//解除锁定\n                }\n                if (submitted) {//任务提交成功，创建或激活工作线程\n                    signalwork(ws, q);//创建或激活一个工作线程来运行任务\n                    return;\n                }\n            }\n            move = true;                   // move on failure 操作失败，重新获取探针值\n        } else if (((rs = runstate) & rslock) == 0) { // create new queue\n            q = new workqueue(this, null);\n            q.hint = r;\n            q.config = k | shared_queue;\n            q.scanstate = inactive;\n            rs = lockrunstate();           // publish index\n            if (rs > 0 && (ws = workqueues) != null &&\n                    k < ws.length && ws[k] == null)\n                ws[k] = q;                 // 更新索引k位值的workqueue\n            //else terminated\n            unlockrunstate(rs, rs & ~rslock);\n        } else\n            move = true;                   // move if busy\n        if (move)\n            r = threadlocalrandom.advanceprobe(r);//重新获取线程探针值\n    }\n}\n\n\n说明: externalsubmit是externalpush的完整版本，主要用于第一次提交任务时初始化workqueues及相关属性，并且提交给定任务到队列中。具体执行步骤如下:\n\n * 如果池为终止状态(runstate<0)，调用tryterminate来终止线程池，并抛出任务拒绝异常；\n * 如果尚未初始化，就为 fjp 执行初始化操作: 初始化stealcounter、创建workerqueues，然后继续自旋；\n * 初始化完成后，执行在externalpush中相同的操作: 获取 workqueue，放入指定任务。任务提交成功后调用signalwork方法创建或激活线程；\n * 如果在步骤3中获取到的 workqueue 为null，会在这一步中创建一个 workqueue，创建成功继续自旋执行第三步操作；\n * 如果非上述情况，或者有线程争用资源导致获取锁失败，就重新获取线程探针值继续自旋。\n\n# signalwork(workqueue[] ws, workqueue q)\n\nfinal void signalwork(workqueue[] ws, workqueue q) {\n    long c;\n    int sp, i;\n    workqueue v;\n    thread p;\n    while ((c = ctl) < 0l) {                       // too few active\n        if ((sp = (int) c) == 0) {                  // no idle workers\n            if ((c & add_worker) != 0l)            // too few workers\n                tryaddworker(c);//工作线程太少，添加新的工作线程\n            break;\n        }\n        if (ws == null)                            // unstarted/terminated\n            break;\n        if (ws.length <= (i = sp & smask))         // terminated\n            break;\n        if ((v = ws[i]) == null)                   // terminating\n            break;\n        //计算ctl，加上版本戳ss_seq避免aba问题\n        int vs = (sp + ss_seq) & ~inactive;        // next scanstate\n        int d = sp - v.scanstate;                  // screen cas\n        //计算活跃线程数(高32位)并更新为下一个栈顶的scanstate(低32位)\n        long nc = (uc_mask & (c + ac_unit)) | (sp_mask & v.stackpred);\n        if (d == 0 && u.compareandswaplong(this, ctl, c, nc)) {\n            v.scanstate = vs;                      // activate v\n            if ((p = v.parker) != null)\n                u.unpark(p);//唤醒阻塞线程\n            break;\n        }\n        if (q != null && q.base == q.top)          // no more work\n            break;\n    }\n}\n\n\n说明: 新建或唤醒一个工作线程，在externalpush、externalsubmit、workqueue.push、scan中调用。如果还有空闲线程，则尝试唤醒索引到的 workqueue 的parker线程；如果工作线程过少((ctl & add_worker) != 0l)，则调用tryaddworker添加一个新的工作线程。\n\n# tryaddworker(long c)\n\nprivate void tryaddworker(long c) {\n    boolean add = false;\n    do {\n        long nc = ((ac_mask & (c + ac_unit)) |\n                   (tc_mask & (c + tc_unit)));\n        if (ctl == c) {\n            int rs, stop;                 // check if terminating\n            if ((stop = (rs = lockrunstate()) & stop) == 0)\n                add = u.compareandswaplong(this, ctl, c, nc);\n            unlockrunstate(rs, rs & ~rslock);//释放锁\n            if (stop != 0)\n                break;\n            if (add) {\n                createworker();//创建工作线程\n                break;\n            }\n        }\n    } while (((c = ctl) & add_worker) != 0l && (int)c == 0);\n}\n\n\n说明: 尝试添加一个新的工作线程，首先更新ctl中的工作线程数，然后调用createworker()创建工作线程。\n\n# createworker()\n\nprivate boolean createworker() {\n    forkjoinworkerthreadfactory fac = factory;\n    throwable ex = null;\n    forkjoinworkerthread wt = null;\n    try {\n        if (fac != null && (wt = fac.newthread(this)) != null) {\n            wt.start();\n            return true;\n        }\n    } catch (throwable rex) {\n        ex = rex;\n    }\n    deregisterworker(wt, ex);//线程创建失败处理\n    return false;\n}\n\n\n说明: createworker首先通过线程工厂创一个新的forkjoinworkerthread，然后启动这个工作线程(wt.start())。如果期间发生异常，调用deregisterworker处理线程创建失败的逻辑(deregisterworker在后面再详细说明)。\n\nforkjoinworkerthread 的构造函数如下:\n\nprotected forkjoinworkerthread(forkjoinpool pool) {\n    // use a placeholder until a useful name can be set in registerworker\n    super("aforkjoinworkerthread");\n    this.pool = pool;\n    this.workqueue = pool.registerworker(this);\n}\n\n\n可以看到 forkjoinworkerthread 在构造时首先调用父类 thread 的方法，然后为工作线程注册pool和workqueue，而workqueue的注册任务由forkjoinpool.registerworker来完成。\n\n# registerworker()\n\nfinal workqueue registerworker(forkjoinworkerthread wt) {\n    uncaughtexceptionhandler handler;\n    //设置为守护线程\n    wt.setdaemon(true);                           // configure thread\n    if ((handler = ueh) != null)\n        wt.setuncaughtexceptionhandler(handler);\n    workqueue w = new workqueue(this, wt);//构造新的workqueue\n    int i = 0;                                    // assign a pool index\n    int mode = config & mode_mask;\n    int rs = lockrunstate();\n    try {\n        workqueue[] ws;\n        int n;                    // skip if no array\n        if ((ws = workqueues) != null && (n = ws.length) > 0) {\n            //生成新建workqueue的索引\n            int s = indexseed += seed_increment;  // unlikely to collide\n            int m = n - 1;\n            i = ((s << 1) | 1) & m;               // worker任务放在奇数索引位 odd-numbered indices\n            if (ws[i] != null) {                  // collision 已存在，重新计算索引位\n                int probes = 0;                   // step by approx half n\n                int step = (n <= 4) ? 2 : ((n >>> 1) & evenmask) + 2;\n                //查找可用的索引位\n                while (ws[i = (i + step) & m] != null) {\n                    if (++probes >= n) {//所有索引位都被占用，对workqueues进行扩容\n                        workqueues = ws = arrays.copyof(ws, n <<= 1);//workqueues 扩容\n                        m = n - 1;\n                        probes = 0;\n                    }\n                }\n            }\n            w.hint = s;                           // use as random seed\n            w.config = i | mode;\n            w.scanstate = i;                      // publication fence\n            ws[i] = w;\n        }\n    } finally {\n        unlockrunstate(rs, rs & ~rslock);\n    }\n    wt.setname(workernameprefix.concat(integer.tostring(i >>> 1)));\n    return w;\n}\n\n\n说明: registerworker是 forkjoinworkerthread 构造器的回调函数，用于创建和记录工作线程的 workqueue。比较简单，就不多赘述了。注意在此为工作线程创建的 workqueue 是放在奇数索引的(代码行: i = ((s << 1) | 1) & m;)\n\n# 小结\n\nok，外部任务的提交流程就先讲到这里。在createworker()中启动工作线程后(wt.start())，当为线程分配到cpu执行时间片之后会运行 forkjoinworkerthread 的run方法开启线程来执行任务。工作线程执行任务的流程我们在讲完内部任务提交之后会统一讲解。\n\n\n# 执行流程: 子任务(worker task)提交\n\n子任务的提交相对比较简单，由任务的fork()方法完成。通过上面的流程图可以看到任务被分割(fork)之后调用了forkjoinpool.workqueue.push()方法直接把任务放到队列中等待被执行。\n\n# forkjointask.fork()\n\npublic final forkjointask<v> fork() {\n    thread t;\n    if ((t = thread.currentthread()) instanceof forkjoinworkerthread)\n        ((forkjoinworkerthread)t).workqueue.push(this);\n    else\n        forkjoinpool.common.externalpush(this);\n    return this;\n}\n\n\n说明: 如果当前线程是 worker 线程，说明当前任务是fork分割的子任务，通过forkjoinpool.workqueue.push()方法直接把任务放到自己的等待队列中；否则调用forkjoinpool.externalpush()提交到一个随机的等待队列中(外部任务)。\n\n# forkjoinpool.workqueue.push()\n\nfinal void push(forkjointask<?> task) {\n    forkjointask<?>[] a;\n    forkjoinpool p;\n    int b = base, s = top, n;\n    if ((a = array) != null) {    // ignore if queue removed\n        int m = a.length - 1;     // fenced write for task visibility\n        u.putorderedobject(a, ((m & s) << ashift) + abase, task);\n        u.putorderedint(this, qtop, s + 1);\n        if ((n = s - b) <= 1) {//首次提交，创建或唤醒一个工作线程\n            if ((p = pool) != null)\n                p.signalwork(p.workqueues, this);\n        } else if (n >= m)\n            growarray();\n    }\n}\n\n\n说明: 首先把任务放入等待队列并更新top位；如果当前 workqueue 为新建的等待队列(top-base<=1)，则调用signalwork方法为当前 workqueue 新建或唤醒一个工作线程；如果 workqueue 中的任务数组容量过小，则调用growarray()方法对其进行两倍扩容，growarray()方法源码如下:\n\nfinal forkjointask<?>[] growarray() {\n    forkjointask<?>[] olda = array;//获取内部任务列表\n    int size = olda != null ? olda.length << 1 : initial_queue_capacity;\n    if (size > maximum_queue_capacity)\n        throw new rejectedexecutionexception("queue capacity exceeded");\n    int oldmask, t, b;\n    //新建一个两倍容量的任务数组\n    forkjointask<?>[] a = array = new forkjointask<?>[size];\n    if (olda != null && (oldmask = olda.length - 1) >= 0 &&\n            (t = top) - (b = base) > 0) {\n        int mask = size - 1;\n        //从老数组中拿出数据，放到新的数组中\n        do { // emulate poll from old array, push to new array\n            forkjointask<?> x;\n            int oldj = ((b & oldmask) << ashift) + abase;\n            int j = ((b & mask) << ashift) + abase;\n            x = (forkjointask<?>) u.getobjectvolatile(olda, oldj);\n            if (x != null &&\n                    u.compareandswapobject(olda, oldj, x, null))\n                u.putobjectvolatile(a, j, x);\n        } while (++b != t);\n    }\n    return a;\n}\n\n\n# 小结\n\n到此，两种任务的提交流程都已经解析完毕，下一节我们来一起看看任务提交之后是如何被运行的。\n\n\n# 执行流程: 任务执行\n\n回到我们开始时的流程图，在forkjoinpool .createworker()方法中创建工作线程后，会启动工作线程，系统为工作线程分配到cpu执行时间片之后会执行 forkjoinworkerthread 的run()方法正式开始执行任务。\n\n# forkjoinworkerthread.run()\n\npublic void run() {\n    if (workqueue.array == null) { // only run once\n        throwable exception = null;\n        try {\n            onstart();//钩子方法，可自定义扩展\n            pool.runworker(workqueue);\n        } catch (throwable ex) {\n            exception = ex;\n        } finally {\n            try {\n                ontermination(exception);//钩子方法，可自定义扩展\n            } catch (throwable ex) {\n                if (exception == null)\n                    exception = ex;\n            } finally {\n                pool.deregisterworker(this, exception);//处理异常\n            }\n        }\n    }\n}\n\n\n说明: 方法很简单，在工作线程运行前后会调用自定义钩子函数(onstart和ontermination)，任务的运行则是调用了forkjoinpool.runworker()。如果全部任务执行完毕或者期间遭遇异常，则通过forkjoinpool.deregisterworker关闭工作线程并处理异常信息(deregisterworker方法我们后面会详细讲解)。\n\n# forkjoinpool.runworker(workqueue w)\n\nfinal void runworker(workqueue w) {\n    w.growarray();                   // allocate queue\n    int seed = w.hint;               // initially holds randomization hint\n    int r = (seed == 0) ? 1 : seed;  // avoid 0 for xorshift\n    for (forkjointask<?> t; ; ) {\n        if ((t = scan(w, r)) != null)//扫描任务执行\n            w.runtask(t);\n        else if (!awaitwork(w, r))\n            break;\n        r ^= r << 13;\n        r ^= r >>> 17;\n        r ^= r << 5; // xorshift\n    }\n}\n\n\n说明: runworker是 forkjoinworkerthread 的主运行方法，用来依次执行当前工作线程中的任务。函数流程很简单: 调用scan方法依次获取任务，然后调用workqueue .runtask运行任务；如果未扫描到任务，则调用awaitwork等待，直到工作线程/线程池终止或等待超时。\n\n# forkjoinpool.scan(workqueue w, int r)\n\nprivate forkjointask<?> scan(workqueue w, int r) {\n    workqueue[] ws;\n    int m;\n    if ((ws = workqueues) != null && (m = ws.length - 1) > 0 && w != null) {\n        int ss = w.scanstate;                     // initially non-negative\n        //初始扫描起点，自旋扫描\n        for (int origin = r & m, k = origin, oldsum = 0, checksum = 0; ; ) {\n            workqueue q;\n            forkjointask<?>[] a;\n            forkjointask<?> t;\n            int b, n;\n            long c;\n            if ((q = ws[k]) != null) {//获取workqueue\n                if ((n = (b = q.base) - q.top) < 0 &&\n                        (a = q.array) != null) {      // non-empty\n                    //计算偏移量\n                    long i = (((a.length - 1) & b) << ashift) + abase;\n                    if ((t = ((forkjointask<?>)\n                            u.getobjectvolatile(a, i))) != null && //取base位置任务\n                            q.base == b) {//stable\n                        if (ss >= 0) {  //scanning\n                            if (u.compareandswapobject(a, i, t, null)) {//\n                                q.base = b + 1;//更新base位\n                                if (n < -1)       // signal others\n                                    signalwork(ws, q);//创建或唤醒工作线程来运行任务\n                                return t;\n                            }\n                        } else if (oldsum == 0 &&   // try to activate 尝试激活工作线程\n                                w.scanstate < 0)\n                            tryrelease(c = ctl, ws[m & (int) c], ac_unit);//唤醒栈顶工作线程\n                    }\n                    //base位置任务为空或base位置偏移，随机移位重新扫描\n                    if (ss < 0)                   // refresh\n                        ss = w.scanstate;\n                    r ^= r << 1;\n                    r ^= r >>> 3;\n                    r ^= r << 10;\n                    origin = k = r & m;           // move and rescan\n                    oldsum = checksum = 0;\n                    continue;\n                }\n                checksum += b;//队列任务为空，记录base位\n            }\n            //更新索引k 继续向后查找\n            if ((k = (k + 1) & m) == origin) {    // continue until stable\n                //运行到这里说明已经扫描了全部的 workqueues，但并未扫描到任务\n\n                if ((ss >= 0 || (ss == (ss = w.scanstate))) &&\n                        oldsum == (oldsum = checksum)) {\n                    if (ss < 0 || w.qlock < 0)    // already inactive\n                        break;// 已经被灭活或终止,跳出循环\n\n                    //对当前workqueue进行灭活操作\n                    int ns = ss | inactive;       // try to inactivate\n                    long nc = ((sp_mask & ns) |\n                            (uc_mask & ((c = ctl) - ac_unit)));//计算ctl为inactive状态并减少活跃线程数\n                    w.stackpred = (int) c;         // hold prev stack top\n                    u.putint(w, qscanstate, ns);//修改scanstate为inactive状态\n                    if (u.compareandswaplong(this, ctl, c, nc))//更新scanstate为灭活状态\n                        ss = ns;\n                    else\n                        w.scanstate = ss;         // back out\n                }\n                checksum = 0;//重置checksum，继续循环\n            }\n        }\n    }\n    return null;\n}\n\n\n说明: 扫描并尝试偷取一个任务。使用w.hint进行随机索引 workqueue，也就是说并不一定会执行当前 workqueue 中的任务，而是偷取别的worker的任务来执行。\n\n函数的大概执行流程如下:\n\n * 取随机位置的一个 workqueue；\n\n * 获取base位的 forkjointask，成功取到后更新base位并返回任务；如果取到的 workqueue 中任务数大于1，则调用signalwork创建或唤醒其他工作线程；\n\n * 如果当前工作线程处于不活跃状态(inactive)，则调用tryrelease尝试唤醒栈顶工作线程来执行。\n   \n   tryrelease源码如下:\n   \n   private boolean tryrelease(long c, workqueue v, long inc) {\n       int sp = (int) c, vs = (sp + ss_seq) & ~inactive;\n       thread p;\n       //ctl低32位等于scanstate，说明可以唤醒parker线程\n       if (v != null && v.scanstate == sp) {          // v is at top of stack\n           //计算活跃线程数(高32位)并更新为下一个栈顶的scanstate(低32位)\n           long nc = (uc_mask & (c + inc)) | (sp_mask & v.stackpred);\n           if (u.compareandswaplong(this, ctl, c, nc)) {\n               v.scanstate = vs;\n               if ((p = v.parker) != null)\n                   u.unpark(p);//唤醒线程\n               return true;\n           }\n       }\n       return false;\n   }\n   \n\n * 如果base位任务为空或发生偏移，则对索引位进行随机移位，然后重新扫描；\n\n * 如果扫描整个workqueues之后没有获取到任务，则设置当前工作线程为inactive状态；然后重置checksum，再次扫描一圈之后如果还没有任务则跳出循环返回null。\n\n# forkjoinpool.awaitwork(workqueue w, int r)\n\nprivate boolean awaitwork(workqueue w, int r) {\n    if (w == null || w.qlock < 0)                 // w is terminating\n        return false;\n    for (int pred = w.stackpred, spins = spins, ss; ; ) {\n        if ((ss = w.scanstate) >= 0)//正在扫描，跳出循环\n            break;\n        else if (spins > 0) {\n            r ^= r << 6;\n            r ^= r >>> 21;\n            r ^= r << 7;\n            if (r >= 0 && --spins == 0) {         // randomize spins\n                workqueue v;\n                workqueue[] ws;\n                int s, j;\n                atomiclong sc;\n                if (pred != 0 && (ws = workqueues) != null &&\n                        (j = pred & smask) < ws.length &&\n                        (v = ws[j]) != null &&        // see if pred parking\n                        (v.parker == null || v.scanstate >= 0))\n                    spins = spins;                // continue spinning\n            }\n        } else if (w.qlock < 0)                     // 当前workqueue已经终止，返回false recheck after spins\n            return false;\n        else if (!thread.interrupted()) {//判断线程是否被中断，并清除中断状态\n            long c, prevctl, parktime, deadline;\n            int ac = (int) ((c = ctl) >> ac_shift) + (config & smask);//活跃线程数\n            if ((ac <= 0 && tryterminate(false, false)) || //无active线程，尝试终止\n                    (runstate & stop) != 0)           // pool terminating\n                return false;\n            if (ac <= 0 && ss == (int) c) {        // is last waiter\n                //计算活跃线程数(高32位)并更新为下一个栈顶的scanstate(低32位)\n                prevctl = (uc_mask & (c + ac_unit)) | (sp_mask & pred);\n                int t = (short) (c >>> tc_shift);  // shrink excess spares\n                if (t > 2 && u.compareandswaplong(this, ctl, c, prevctl))//总线程过量\n                    return false;                 // else use timed wait\n                //计算空闲超时时间\n                parktime = idle_timeout * ((t >= 0) ? 1 : 1 - t);\n                deadline = system.nanotime() + parktime - timeout_slop;\n            } else\n                prevctl = parktime = deadline = 0l;\n            thread wt = thread.currentthread();\n            u.putobject(wt, parkblocker, this);   // emulate locksupport\n            w.parker = wt;//设置parker，准备阻塞\n            if (w.scanstate < 0 && ctl == c)      // recheck before park\n                u.park(false, parktime);//阻塞指定的时间\n\n            u.putorderedobject(w, qparker, null);\n            u.putobject(wt, parkblocker, null);\n            if (w.scanstate >= 0)//正在扫描，说明等到任务，跳出循环\n                break;\n            if (parktime != 0l && ctl == c &&\n                    deadline - system.nanotime() <= 0l &&\n                    u.compareandswaplong(this, ctl, c, prevctl))//未等到任务，更新ctl，返回false\n                return false;                     // shrink pool\n        }\n    }\n    return true;\n}\n\n\n说明: 回到runworker方法，如果scan方法未扫描到任务，会调用awaitwork等待获取任务。函数的具体执行流程大家看源码，这里简单说一下:\n\n * 在等待获取任务期间，如果工作线程或线程池已经终止则直接返回false。如果当前无 active 线程，尝试终止线程池并返回false，如果终止失败并且当前是最后一个等待的 worker，就阻塞指定的时间(idle_timeout)；等到届期或被唤醒后如果发现自己是scanning(scanstate >= 0)状态，说明已经等到任务，跳出等待返回true继续 scan，否则的更新ctl并返回false。\n\n# workqueue.runtask()\n\nfinal void runtask(forkjointask<?> task) {\n    if (task != null) {\n        scanstate &= ~scanning; // mark as busy\n        (currentsteal = task).doexec();//更新currentsteal并执行任务\n        u.putorderedobject(this, qcurrentsteal, null); // release for gc\n        execlocaltasks();//依次执行本地任务\n        forkjoinworkerthread thread = owner;\n        if (++nsteals < 0)      // collect on overflow\n            transferstealcount(pool);//增加偷取任务数\n        scanstate |= scanning;\n        if (thread != null)\n            thread.aftertoplevelexec();//执行钩子函数\n    }\n}\n\n\n说明: 在scan方法扫描到任务之后，调用workqueue.runtask()来执行获取到的任务，大概流程如下:\n\n * 标记scanstate为正在执行状态；\n\n * 更新currentsteal为当前获取到的任务并执行它，任务的执行调用了forkjointask.doexec()方法，源码如下:\n   \n   //forkjointask.doexec()\n   final int doexec() {\n       int s; boolean completed;\n       if ((s = status) >= 0) {\n           try {\n               completed = exec();//执行我们定义的任务\n           } catch (throwable rex) {\n               return setexceptionalcompletion(rex);\n           }\n           if (completed)\n               s = setcompletion(normal);\n       }\n       return s;\n   }\n   \n\n * 调用execlocaltasks依次执行当前workerqueue中的任务，源码如下:\n   \n   //执行并移除所有本地任务\n   final void execlocaltasks() {\n       int b = base, m, s;\n       forkjointask<?>[] a = array;\n       if (b - (s = top - 1) <= 0 && a != null &&\n               (m = a.length - 1) >= 0) {\n           if ((config & fifo_queue) == 0) {//fifo模式\n               for (forkjointask<?> t; ; ) {\n                   if ((t = (forkjointask<?>) u.getandsetobject\n                           (a, ((m & s) << ashift) + abase, null)) == null)//fifo执行，取top任务\n                       break;\n                   u.putorderedint(this, qtop, s);\n                   t.doexec();//执行\n                   if (base - (s = top - 1) > 0)\n                       break;\n               }\n           } else\n               pollandexecall();//lifo模式执行，取base任务\n       }\n   }\n   \n\n * 更新偷取任务数；\n\n * 还原scanstate并执行钩子函数。\n\n# forkjoinpool.deregisterworker(forkjoinworkerthread wt, throwable ex)\n\nfinal void deregisterworker(forkjoinworkerthread wt, throwable ex) {\n    workqueue w = null;\n    //1.移除workqueue\n    if (wt != null && (w = wt.workqueue) != null) {//获取forkjoinworkerthread的等待队列\n        workqueue[] ws;                           // remove index from array\n        int idx = w.config & smask;//计算workqueue索引\n        int rs = lockrunstate();//获取runstate锁和当前池运行状态\n        if ((ws = workqueues) != null && ws.length > idx && ws[idx] == w)\n            ws[idx] = null;//移除workqueue\n        unlockrunstate(rs, rs & ~rslock);//解除runstate锁\n    }\n    //2.减少ctl数\n    long c;                                       // decrement counts\n    do {} while (!u.compareandswaplong\n                 (this, ctl, c = ctl, ((ac_mask & (c - ac_unit)) |\n                                       (tc_mask & (c - tc_unit)) |\n                                       (sp_mask & c))));\n    //3.处理被移除workqueue内部相关参数\n    if (w != null) {\n        w.qlock = -1;                             // ensure set\n        w.transferstealcount(this);\n        w.cancelall();                            // cancel remaining tasks\n    }\n    //4.如果线程未终止，替换被移除的workqueue并唤醒内部线程\n    for (;;) {                                    // possibly replace\n        workqueue[] ws; int m, sp;\n        //尝试终止线程池\n        if (tryterminate(false, false) || w == null || w.array == null ||\n            (runstate & stop) != 0 || (ws = workqueues) == null ||\n            (m = ws.length - 1) < 0)              // already terminating\n            break;\n        //唤醒被替换的线程，依赖于下一步\n        if ((sp = (int)(c = ctl)) != 0) {         // wake up replacement\n            if (tryrelease(c, ws[sp & m], ac_unit))\n                break;\n        }\n        //创建工作线程替换\n        else if (ex != null && (c & add_worker) != 0l) {\n            tryaddworker(c);                      // create replacement\n            break;\n        }\n        else                                      // don\'t need replacement\n            break;\n    }\n    //5.处理异常\n    if (ex == null)                               // help clean on way out\n        forkjointask.helpexpungestaleexceptions();\n    else                                          // rethrow\n        forkjointask.rethrow(ex);\n}\n\n\n说明: deregisterworker方法用于工作线程运行完毕之后终止线程或处理工作线程异常，主要就是清除已关闭的工作线程或回滚创建线程之前的操作，并把传入的异常抛给 forkjointask 来处理。具体步骤见源码注释。\n\n# 小结\n\n本节我们对任务的执行流程进行了说明，后面我们将继续介绍任务的结果获取(join/invoke)。\n\n\n# 获取任务结果 - forkjointask.join() / forkjointask.invoke()\n\n * join() :\n\n//合并任务结果\npublic final v join() {\n    int s;\n    if ((s = dojoin() & done_mask) != normal)\n        reportexception(s);\n    return getrawresult();\n}\n\n//join, get, quietlyjoin的主实现方法\nprivate int dojoin() {\n    int s; thread t; forkjoinworkerthread wt; forkjoinpool.workqueue w;\n    return (s = status) < 0 ? s :\n        ((t = thread.currentthread()) instanceof forkjoinworkerthread) ?\n        (w = (wt = (forkjoinworkerthread)t).workqueue).\n        tryunpush(this) && (s = doexec()) < 0 ? s :\n        wt.pool.awaitjoin(w, this, 0l) :\n        externalawaitdone();\n}\n\n\n * invoke() :\n\n//执行任务，并等待任务完成并返回结果\npublic final v invoke() {\n    int s;\n    if ((s = doinvoke() & done_mask) != normal)\n        reportexception(s);\n    return getrawresult();\n}\n\n//invoke, quietlyinvoke的主实现方法\nprivate int doinvoke() {\n    int s; thread t; forkjoinworkerthread wt;\n    return (s = doexec()) < 0 ? s :\n        ((t = thread.currentthread()) instanceof forkjoinworkerthread) ?\n        (wt = (forkjoinworkerthread)t).pool.\n        awaitjoin(wt.workqueue, this, 0l) :\n        externalawaitdone();\n}\n\n\n说明: join()方法一把是在任务fork()之后调用，用来获取(或者叫“合并”)任务的执行结果。\n\nforkjointask的join()和invoke()方法都可以用来获取任务的执行结果(另外还有get方法也是调用了dojoin来获取任务结果，但是会响应运行时异常)，它们对外部提交任务的执行方式一致，都是通过externalawaitdone方法等待执行结果。不同的是invoke()方法会直接执行当前任务；而join()方法则是在当前任务在队列 top 位时(通过tryunpush方法判断)才能执行，如果当前任务不在 top 位或者任务执行失败调用forkjoinpool.awaitjoin方法帮助执行或阻塞当前 join 任务。(所以在官方文档中建议了我们对forkjointask任务的调用顺序，一对 fork-join操作一般按照如下顺序调用: a.fork(); b.fork(); b.join(); a.join();。因为任务 b 是后面进入队列，也就是说它是在栈顶的(top 位)，在它fork()之后直接调用join()就可以直接执行而不会调用forkjoinpool.awaitjoin方法去等待。)\n\n在这些方法中，join()相对比较全面，所以之后的讲解我们将从join()开始逐步向下分析，首先看一下join()的执行流程:\n\n\n\n后面的源码分析中，我们首先讲解比较简单的外部 join 任务(externalawaitdone)，然后再讲解内部 join 任务(从forkjoinpool.awaitjoin()开始)。\n\n# forkjointask.externalawaitdone()\n\nprivate int externalawaitdone() {\n    //执行任务\n    int s = ((this instanceof countedcompleter) ? // try helping\n             forkjoinpool.common.externalhelpcomplete(  // countedcompleter任务\n                 (countedcompleter<?>)this, 0) :\n             forkjoinpool.common.tryexternalunpush(this) ? doexec() : 0);  // forkjointask任务\n    if (s >= 0 && (s = status) >= 0) {//执行失败，进入等待\n        boolean interrupted = false;\n        do {\n            if (u.compareandswapint(this, status, s, s | signal)) {  //更新state\n                synchronized (this) {\n                    if (status >= 0) {//signal 等待信号\n                        try {\n                            wait(0l);\n                        } catch (interruptedexception ie) {\n                            interrupted = true;\n                        }\n                    }\n                    else\n                        notifyall();\n                }\n            }\n        } while ((s = status) >= 0);\n        if (interrupted)\n            thread.currentthread().interrupt();\n    }\n    return s;\n}\n\n\n说明: 如果当前join为外部调用，则调用此方法执行任务，如果任务执行失败就进入等待。方法本身是很简单的，需要注意的是对不同的任务类型分两种情况:\n\n * 如果我们的任务为 countedcompleter 类型的任务，则调用externalhelpcomplete方法来执行任务。\n\n * 其他类型的 forkjointask 任务调用tryexternalunpush来执行，源码如下:\n   \n   //为外部提交者提供 tryunpush 功能(给定任务在top位时弹出任务)\n   final boolean tryexternalunpush(forkjointask<?> task) {\n       workqueue[] ws;\n       workqueue w;\n       forkjointask<?>[] a;\n       int m, s;\n       int r = threadlocalrandom.getprobe();\n       if ((ws = workqueues) != null && (m = ws.length - 1) >= 0 &&\n               (w = ws[m & r & sqmask]) != null &&\n               (a = w.array) != null && (s = w.top) != w.base) {\n           long j = (((a.length - 1) & (s - 1)) << ashift) + abase;  //取top位任务\n           if (u.compareandswapint(w, qlock, 0, 1)) {  //加锁\n               if (w.top == s && w.array == a &&\n                       u.getobject(a, j) == task &&\n                       u.compareandswapobject(a, j, task, null)) {  //符合条件，弹出\n                   u.putorderedint(w, qtop, s - 1);  //更新top\n                   u.putorderedint(w, qlock, 0); //解锁，返回true\n                   return true;\n               }\n               u.compareandswapint(w, qlock, 1, 0);  //当前任务不在top位，解锁返回false\n           }\n       }\n       return false;\n   }\n   \n   \n   tryexternalunpush的作用就是判断当前任务是否在top位，如果是则弹出任务，然后在externalawaitdone中调用doexec()执行任务。\n\n# forkjoinpool.awaitjoin()\n\nfinal int awaitjoin(workqueue w, forkjointask<?> task, long deadline) {\n    int s = 0;\n    if (task != null && w != null) {\n        forkjointask<?> prevjoin = w.currentjoin;  //获取给定worker的join任务\n        u.putorderedobject(w, qcurrentjoin, task);  //把currentjoin替换为给定任务\n        //判断是否为countedcompleter类型的任务\n        countedcompleter<?> cc = (task instanceof countedcompleter) ?\n                (countedcompleter<?>) task : null;\n        for (; ; ) {\n            if ((s = task.status) < 0)  //已经完成|取消|异常 跳出循环\n                break;\n\n            if (cc != null)//countedcompleter任务由helpcomplete来完成join\n                helpcomplete(w, cc, 0);\n            else if (w.base == w.top || w.tryremoveandexec(task))  //尝试执行\n                helpstealer(w, task);  //队列为空或执行失败，任务可能被偷，帮助偷取者执行该任务\n\n            if ((s = task.status) < 0) //已经完成|取消|异常，跳出循环\n                break;\n            //计算任务等待时间\n            long ms, ns;\n            if (deadline == 0l)\n                ms = 0l;\n            else if ((ns = deadline - system.nanotime()) <= 0l)\n                break;\n            else if ((ms = timeunit.nanoseconds.tomillis(ns)) <= 0l)\n                ms = 1l;\n\n            if (trycompensate(w)) {//执行补偿操作\n                task.internalwait(ms);//补偿执行成功，任务等待指定时间\n                u.getandaddlong(this, ctl, ac_unit);//更新活跃线程数\n            }\n        }\n        u.putorderedobject(w, qcurrentjoin, prevjoin);//循环结束，替换为原来的join任务\n    }\n    return s;\n}\n\n\n说明: 如果当前 join 任务不在worker等待队列的top位，或者任务执行失败，调用此方法来帮助执行或阻塞当前 join 的任务。函数执行流程如下:\n\n * 由于每次调用awaitjoin都会优先执行当前join的任务，所以首先会更新currentjoin为当前join任务；\n\n * 进入自旋:\n   \n   * 首先检查任务是否已经完成(通过task.status < 0判断)，如果给定任务执行完毕|取消|异常 则跳出循环返回执行状态s；\n   * 如果是 countedcompleter 任务类型，调用helpcomplete方法来完成join操作(后面笔者会开新篇来专门讲解countedcompleter，本篇暂时不做详细解析)；\n   * 非 countedcompleter 任务类型调用workqueue.tryremoveandexec尝试执行任务；\n   * 如果给定 workqueue 的等待队列为空或任务执行失败，说明任务可能被偷，调用helpstealer帮助偷取者执行任务(也就是说，偷取者帮我执行任务，我去帮偷取者执行它的任务)；\n   * 再次判断任务是否执行完毕(task.status < 0)，如果任务执行失败，计算一个等待时间准备进行补偿操作；\n   * 调用trycompensate方法为给定 workqueue 尝试执行补偿操作。在执行补偿期间，如果发现 资源争用|池处于unstable状态|当前worker已终止，则调用forkjointask.internalwait()方法等待指定的时间，任务唤醒之后继续自旋，forkjointask.internalwait()源码如下:\n   \n   final void internalwait(long timeout) {\n       int s;\n       if ((s = status) >= 0 && // force completer to issue notify\n           u.compareandswapint(this, status, s, s | signal)) {//更新任务状态为signal(等待唤醒)\n           synchronized (this) {\n               if (status >= 0)\n                   try { wait(timeout); } catch (interruptedexception ie) { }\n               else\n                   notifyall();\n           }\n       }\n   }\n   \n\n在awaitjoin中，我们总共调用了三个比较复杂的方法: tryremoveandexec、helpstealer和trycompensate，下面我们依次讲解。\n\n# workqueue.tryremoveandexec(forkjointask<?> task)\n\nfinal boolean tryremoveandexec(forkjointask<?> task) {\n    forkjointask<?>[] a;\n    int m, s, b, n;\n    if ((a = array) != null && (m = a.length - 1) >= 0 &&\n            task != null) {\n        while ((n = (s = top) - (b = base)) > 0) {\n            //从top往下自旋查找\n            for (forkjointask<?> t; ; ) {      // traverse from s to b\n                long j = ((--s & m) << ashift) + abase;//计算任务索引\n                if ((t = (forkjointask<?>) u.getobject(a, j)) == null) //获取索引到的任务\n                    return s + 1 == top;     // shorter than expected\n                else if (t == task) { //给定任务为索引任务\n                    boolean removed = false;\n                    if (s + 1 == top) {      // pop\n                        if (u.compareandswapobject(a, j, task, null)) { //弹出任务\n                            u.putorderedint(this, qtop, s); //更新top\n                            removed = true;\n                        }\n                    } else if (base == b)      // replace with proxy\n                        removed = u.compareandswapobject(\n                                a, j, task, new emptytask()); //join任务已经被移除，替换为一个占位任务\n                    if (removed)\n                        task.doexec(); //执行\n                    break;\n                } else if (t.status < 0 && s + 1 == top) { //给定任务不是top任务\n                    if (u.compareandswapobject(a, j, t, null)) //弹出任务\n                        u.putorderedint(this, qtop, s);//更新top\n                    break;                  // was cancelled\n                }\n                if (--n == 0) //遍历结束\n                    return false;\n            }\n            if (task.status < 0) //任务执行完毕\n                return false;\n        }\n    }\n    return true;\n}\n\n\n说明: 从top位开始自旋向下找到给定任务，如果找到把它从当前 worker 的任务队列中移除并执行它。注意返回的参数: 如果任务队列为空或者任务未执行完毕返回true；任务执行完毕返回false。\n\n# forkjoinpool.helpstealer(workqueue w, forkjointask<?> task)\n\nprivate void helpstealer(workqueue w, forkjointask<?> task) {\n    workqueue[] ws = workqueues;\n    int oldsum = 0, checksum, m;\n    if (ws != null && (m = ws.length - 1) >= 0 && w != null &&\n            task != null) {\n        do {                                       // restart point\n            checksum = 0;                          // for stability check\n            forkjointask<?> subtask;\n            workqueue j = w, v;                    // v is subtask stealer\n            descent:\n            for (subtask = task; subtask.status >= 0; ) {\n                //1. 找到给定workqueue的偷取者v\n                for (int h = j.hint | 1, k = 0, i; ; k += 2) {//跳两个索引，因为worker在奇数索引位\n                    if (k > m)                     // can\'t find stealer\n                        break descent;\n                    if ((v = ws[i = (h + k) & m]) != null) {\n                        if (v.currentsteal == subtask) {//定位到偷取者\n                            j.hint = i;//更新stealer索引\n                            break;\n                        }\n                        checksum += v.base;\n                    }\n                }\n                //2. 帮助偷取者v执行任务\n                for (; ; ) {                         // help v or descend\n                    forkjointask<?>[] a;            //偷取者内部的任务\n                    int b;\n                    checksum += (b = v.base);\n                    forkjointask<?> next = v.currentjoin;//获取偷取者的join任务\n                    if (subtask.status < 0 || j.currentjoin != subtask ||\n                            v.currentsteal != subtask) // stale\n                        break descent; // stale，跳出descent循环重来\n                    if (b - v.top >= 0 || (a = v.array) == null) {\n                        if ((subtask = next) == null)   //偷取者的join任务为null，跳出descent循环\n                            break descent;\n                        j = v;\n                        break; //偷取者内部任务为空，可能任务也被偷走了；跳出本次循环，查找偷取者的偷取者\n                    }\n                    int i = (((a.length - 1) & b) << ashift) + abase;//获取base偏移地址\n                    forkjointask<?> t = ((forkjointask<?>)\n                            u.getobjectvolatile(a, i));//获取偷取者的base任务\n                    if (v.base == b) {\n                        if (t == null)             // stale\n                            break descent; // stale，跳出descent循环重来\n                        if (u.compareandswapobject(a, i, t, null)) {//弹出任务\n                            v.base = b + 1;         //更新偷取者的base位\n                            forkjointask<?> ps = w.currentsteal;//获取调用者偷来的任务\n                            int top = w.top;\n                            //首先更新给定workqueue的currentsteal为偷取者的base任务，然后执行该任务\n                            //然后通过检查top来判断给定workqueue是否有自己的任务，如果有，\n                            // 则依次弹出任务(lifo)->更新currentsteal->执行该任务(注意这里是自己偷自己的任务执行)\n                            do {\n                                u.putorderedobject(w, qcurrentsteal, t);\n                                t.doexec();        // clear local tasks too\n                            } while (task.status >= 0 &&\n                                    w.top != top && //内部有自己的任务，依次弹出执行\n                                    (t = w.pop()) != null);\n                            u.putorderedobject(w, qcurrentsteal, ps);//还原给定workqueue的currentsteal\n                            if (w.base != w.top)//给定workqueue有自己的任务了，帮助结束，返回\n                                return;            // can\'t further help\n                        }\n                    }\n                }\n            }\n        } while (task.status >= 0 && oldsum != (oldsum = checksum));\n    }\n}\n\n\n说明: 如果队列为空或任务执行失败，说明任务可能被偷，调用此方法来帮助偷取者执行任务。基本思想是: 偷取者帮助我执行任务，我去帮助偷取者执行它的任务。 函数执行流程如下:\n\n循环定位偷取者，由于worker是在奇数索引位，所以每次会跳两个索引位。定位到偷取者之后，更新调用者 workqueue 的hint为偷取者的索引，方便下次定位； 定位到偷取者后，开始帮助偷取者执行任务。从偷取者的base索引开始，每次偷取一个任务执行。在帮助偷取者执行任务后，如果调用者发现本身已经有任务(w.top != top)，则依次弹出自己的任务(lifo顺序)并执行(也就是说自己偷自己的任务执行)。\n\n# forkjoinpool.trycompensate(workqueue w)\n\n//执行补偿操作: 尝试缩减活动线程量，可能释放或创建一个补偿线程来准备阻塞\nprivate boolean trycompensate(workqueue w) {\n    boolean canblock;\n    workqueue[] ws;\n    long c;\n    int m, pc, sp;\n    if (w == null || w.qlock < 0 ||           // caller terminating\n            (ws = workqueues) == null || (m = ws.length - 1) <= 0 ||\n            (pc = config & smask) == 0)           // parallelism disabled\n        canblock = false; //调用者已终止\n    else if ((sp = (int) (c = ctl)) != 0)      // release idle worker\n        canblock = tryrelease(c, ws[sp & m], 0l);//唤醒等待的工作线程\n    else {//没有空闲线程\n        int ac = (int) (c >> ac_shift) + pc; //活跃线程数\n        int tc = (short) (c >> tc_shift) + pc;//总线程数\n        int nbusy = 0;                        // validate saturation\n        for (int i = 0; i <= m; ++i) {        // two passes of odd indices\n            workqueue v;\n            if ((v = ws[((i << 1) | 1) & m]) != null) {//取奇数索引位\n                if ((v.scanstate & scanning) != 0)//没有正在运行任务，跳出\n                    break;\n                ++nbusy;//正在运行任务，添加标记\n            }\n        }\n        if (nbusy != (tc << 1) || ctl != c)\n            canblock = false;                 // unstable or stale\n        else if (tc >= pc && ac > 1 && w.isempty()) {//总线程数大于并行度 && 活动线程数大于1 && 调用者任务队列为空，不需要补偿\n            long nc = ((ac_mask & (c - ac_unit)) |\n                    (~ac_mask & c));       // uncompensated\n            canblock = u.compareandswaplong(this, ctl, c, nc);//更新活跃线程数\n        } else if (tc >= max_cap ||\n                (this == common && tc >= pc + commonmaxspares))//超出最大线程数\n            throw new rejectedexecutionexception(\n                    "thread limit exceeded replacing blocked worker");\n        else {                                // similar to tryaddworker\n            boolean add = false;\n            int rs;      // cas within lock\n            long nc = ((ac_mask & c) |\n                    (tc_mask & (c + tc_unit)));//计算总线程数\n            if (((rs = lockrunstate()) & stop) == 0)\n                add = u.compareandswaplong(this, ctl, c, nc);//更新总线程数\n            unlockrunstate(rs, rs & ~rslock);\n            //运行到这里说明活跃工作线程数不足，需要创建一个新的工作线程来补偿\n            canblock = add && createworker(); // throws on exception\n        }\n    }\n    return canblock;\n}\n\n\n说明: 具体的执行看源码及注释，这里我们简单总结一下需要和不需要补偿的几种情况:\n\n需要补偿 :\n\n * 调用者队列不为空，并且有空闲工作线程，这种情况会唤醒空闲线程(调用tryrelease方法)\n * 池尚未停止，活跃线程数不足，这时会新建一个工作线程(调用createworker方法)\n\n不需要补偿 :\n\n * 调用者已终止或池处于不稳定状态\n * 总线程数大于并行度 && 活动线程数大于1 && 调用者任务队列为空\n\n\n# fork/join的陷阱与注意事项\n\n使用fork/join框架时，需要注意一些陷阱, 在下面 斐波那契数列例子中你将看到示例:\n\n\n# 避免不必要的fork()\n\n划分成两个子任务后，不要同时调用两个子任务的fork()方法。\n\n表面上看上去两个子任务都fork()，然后join()两次似乎更自然。但事实证明，直接调用compute()效率更高。因为直接调用子任务的compute()方法实际上就是在当前的工作线程进行了计算(线程重用)，这比“将子任务提交到工作队列，线程又从工作队列中拿任务”快得多。\n\n> 当一个大任务被划分成两个以上的子任务时，尽可能使用前面说到的三个衍生的invokeall方法，因为使用它们能避免不必要的fork()。\n\n\n# 注意fork()、compute()、join()的顺序\n\n为了两个任务并行，三个方法的调用顺序需要万分注意。\n\nright.fork(); // 计算右边的任务\nlong leftans = left.compute(); // 计算左边的任务(同时右边任务也在计算)\nlong rightans = right.join(); // 等待右边的结果\nreturn leftans + rightans;\n\n\n如果我们写成:\n\nleft.fork(); // 计算完左边的任务\nlong leftans = left.join(); // 等待左边的计算结果\nlong rightans = right.compute(); // 再计算右边的任务\nreturn leftans + rightans;\n\n\n或者\n\nlong rightans = right.compute(); // 计算完右边的任务\nleft.fork(); // 再计算左边的任务\nlong leftans = left.join(); // 等待左边的计算结果\nreturn leftans + rightans;\n\n\n这两种实际上都没有并行。\n\n\n# 选择合适的子任务粒度\n\n选择划分子任务的粒度(顺序执行的阈值)很重要，因为使用fork/join框架并不一定比顺序执行任务的效率高: 如果任务太大，则无法提高并行的吞吐量；如果任务太小，子任务的调度开销可能会大于并行计算的性能提升，我们还要考虑创建子任务、fork()子任务、线程调度以及合并子任务处理结果的耗时以及相应的内存消耗。\n\n官方文档给出的粗略经验是: 任务应该执行100~10000个基本的计算步骤。决定子任务的粒度的最好办法是实践，通过实际测试结果来确定这个阈值才是“上上策”。\n\n> 和其他java代码一样，fork/join框架测试时需要“预热”或者说执行几遍才会被jit(just-in-time)编译器优化，所以测试性能之前跑几遍程序很重要。\n\n\n# 避免重量级任务划分与结果合并\n\nfork/join的很多使用场景都用到数组或者list等数据结构，子任务在某个分区中运行，最典型的例子如并行排序和并行查找。拆分子任务以及合并处理结果的时候，应该尽量避免system.arraycopy这样耗时耗空间的操作，从而最小化任务的处理开销。\n\n\n# 再深入理解\n\n\n# 有哪些jdk源码中使用了fork/join思想?\n\n我们常用的数组工具类 arrays 在jdk 8之后新增的并行排序方法(parallelsort)就运用了 forkjoinpool 的特性，还有 concurrenthashmap 在jdk 8之后添加的函数式方法(如foreach等)也有运用。\n\n\n# 使用executors工具类创建forkjoinpool\n\njava8在executors工具类中新增了两个工厂方法:\n\n// parallelism定义并行级别\npublic static executorservice newworkstealingpool(int parallelism);\n// 默认并行级别为jvm可用的处理器个数\n// runtime.getruntime().availableprocessors()\npublic static executorservice newworkstealingpool();\n\n\n\n# 关于fork/join异常处理\n\njava的受检异常机制一直饱受诟病，所以在forkjointask的invoke()、join()方法及其衍生方法中都没有像get()方法那样抛出个executionexception的受检异常。\n\n所以你可以在forkjointask中看到内部把受检异常转换成了运行时异常。\n\nstatic void rethrow(throwable ex) {\n    if (ex != null)\n        forkjointask.<runtimeexception>uncheckedthrow(ex);\n}\n\n@suppresswarnings("unchecked")\nstatic <t extends throwable> void uncheckedthrow(throwable t) throws t {\n    throw (t)t; // rely on vacuous cast\n}\n\n\n关于java你不知道的10件事中已经指出，jvm实际并不关心这个异常是受检异常还是运行时异常，受检异常这东西完全是给java编译器用的: 用于警告程序员这里有个异常没有处理。\n\n但不可否认的是invoke、join()仍可能会抛出运行时异常，所以forkjointask还提供了两个不提取结果和异常的方法quietlyinvoke()、quietlyjoin()，这两个方法允许你在所有任务完成后对结果和异常进行处理。\n\n使用quitelyinvoke()和quietlyjoin()时可以配合iscompletedabnormally()和iscompletednormally()方法使用。\n\n\n# 一些fork/join例子\n\n\n# 采用fork/join来异步计算1+2+3+…+10000的结果\n\npublic class test {\n\tstatic final class sumtask extends recursivetask<integer> {\n\t\tprivate static final long serialversionuid = 1l;\n\t\t\n\t\tfinal int start; //开始计算的数\n\t\tfinal int end; //最后计算的数\n\t\t\n\t\tsumtask(int start, int end) {\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t}\n\n\t\t@override\n\t\tprotected integer compute() {\n\t\t\t//如果计算量小于1000，那么分配一个线程执行if中的代码块，并返回执行结果\n\t\t\tif(end - start < 1000) {\n\t\t\t\tsystem.out.println(thread.currentthread().getname() + " 开始执行: " + start + "-" + end);\n\t\t\t\tint sum = 0;\n\t\t\t\tfor(int i = start; i <= end; i++)\n\t\t\t\t\tsum += i;\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t\t//如果计算量大于1000，那么拆分为两个任务\n\t\t\tsumtask task1 = new sumtask(start, (start + end) / 2);\n\t\t\tsumtask task2 = new sumtask((start + end) / 2 + 1, end);\n\t\t\t//执行任务\n\t\t\ttask1.fork();\n\t\t\ttask2.fork();\n\t\t\t//获取任务执行的结果\n\t\t\treturn task1.join() + task2.join();\n\t\t}\n\t}\n\t\n\tpublic static void main(string[] args) throws interruptedexception, executionexception {\n\t\tforkjoinpool pool = new forkjoinpool();\n\t\tforkjointask<integer> task = new sumtask(1, 10000);\n\t\tpool.submit(task);\n\t\tsystem.out.println(task.get());\n\t}\n}\n\n\n * 执行结果\n\nforkjoinpool-1-worker-1 开始执行: 1-625\nforkjoinpool-1-worker-7 开始执行: 6251-6875\nforkjoinpool-1-worker-6 开始执行: 5626-6250\nforkjoinpool-1-worker-10 开始执行: 3751-4375\nforkjoinpool-1-worker-13 开始执行: 2501-3125\nforkjoinpool-1-worker-8 开始执行: 626-1250\nforkjoinpool-1-worker-11 开始执行: 5001-5625\nforkjoinpool-1-worker-3 开始执行: 7501-8125\nforkjoinpool-1-worker-14 开始执行: 1251-1875\nforkjoinpool-1-worker-4 开始执行: 9376-10000\nforkjoinpool-1-worker-8 开始执行: 8126-8750\nforkjoinpool-1-worker-0 开始执行: 1876-2500\nforkjoinpool-1-worker-12 开始执行: 4376-5000\nforkjoinpool-1-worker-5 开始执行: 8751-9375\nforkjoinpool-1-worker-7 开始执行: 6876-7500\nforkjoinpool-1-worker-1 开始执行: 3126-3750\n50005000\n\n\n\n# 实现斐波那契数列\n\n> 斐波那契数列: 1、1、2、3、5、8、13、21、34、…… 公式 : f(1)=1，f(2)=1, f(n)=f(n-1)+f(n-2)(n>=3，n∈n*)\n\npublic static void main(string[] args) {\n    forkjoinpool forkjoinpool = new forkjoinpool(4); // 最大并发数4\n    fibonacci fibonacci = new fibonacci(20);\n    long starttime = system.currenttimemillis();\n    integer result = forkjoinpool.invoke(fibonacci);\n    long endtime = system.currenttimemillis();\n    system.out.println("fork/join sum: " + result + " in " + (endtime - starttime) + " ms.");\n}\n//以下为官方api文档示例\nstatic  class fibonacci extends recursivetask<integer> {\n    final int n;\n    fibonacci(int n) {\n        this.n = n;\n    }\n    @override\n    protected integer compute() {\n        if (n <= 1) {\n            return n;\n        }\n        fibonacci f1 = new fibonacci(n - 1);\n        f1.fork(); \n        fibonacci f2 = new fibonacci(n - 2);\n        return f2.compute() + f1.join(); \n    }\n}\n\n\n当然你也可以两个任务都fork，要注意的是两个任务都fork的情况，必须按照f1.fork()，f2.fork()， f2.join()，f1.join()这样的顺序，不然有性能问题，详见上面注意事项中的说明。\n\n官方api文档是这样写到的，所以平日用invokeall就好了。invokeall会把传入的任务的第一个交给当前线程来执行，其他的任务都fork加入工作队列，这样等于利用当前线程也执行任务了。\n\n{\n    // ...\n    fibonacci f1 = new fibonacci(n - 1);\n    fibonacci f2 = new fibonacci(n - 2);\n    invokeall(f1,f2);\n    return f2.join() + f1.join();\n}\n\npublic static void invokeall(forkjointask<?>... tasks) {\n    throwable ex = null;\n    int last = tasks.length - 1;\n    for (int i = last; i >= 0; --i) {\n        forkjointask<?> t = tasks[i];\n        if (t == null) {\n            if (ex == null)\n                ex = new nullpointerexception();\n        }\n        else if (i != 0)   //除了第一个都fork\n            t.fork();\n        else if (t.doinvoke() < normal && ex == null)  //留一个自己执行\n            ex = t.getexception();\n    }\n    for (int i = 1; i <= last; ++i) {\n        forkjointask<?> t = tasks[i];\n        if (t != null) {\n            if (ex != null)\n                t.cancel(false);\n            else if (t.dojoin() < normal)\n                ex = t.getexception();\n        }\n    }\n    if (ex != null)\n        rethrow(ex);\n}\n\n\n\n\n# 参考文章\n\n * 首先推荐阅读forkjoinpool的作者doug lea的一篇文章《a java fork/join framework》英文原文地址在新窗口打开\n * 本文主要参考自泰迪的bagwell的https://www.jianshu.com/p/32a15ef2f1bf和https://www.jianshu.com/p/6a14d0b54b8d，在此基础上参考了如下文章\n * https://blog.csdn.net/u010841296/article/details/83963637\n * https://blog.csdn.net/holmofy/article/details/82714665\n * https://blog.csdn.net/abc123lzf/article/details/82873181\n * https://blog.csdn.net/yinwenjie/article/details/71524140\n * https://blog.csdn.net/cowbin2012/article/details/89791757\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-executor-forkjoinpool.html',charsets:{cjk:!0}},{title:"JUC - 类汇总和学习指南",frontmatter:{},regularPath:"/java/thread/java-thread-x-juc-overview.html",relativePath:"java/thread/java-thread-x-juc-overview.md",key:"v-4ac8f434",path:"/java/thread/java-thread-x-juc-overview.html",headers:[{level:2,title:"JUC - 类汇总和学习指南",slug:"juc-类汇总和学习指南",normalizedTitle:"juc - 类汇总和学习指南",charIndex:2},{level:2,title:"带着BAT大厂的面试问题去理解",slug:"带着bat大厂的面试问题去理解",normalizedTitle:"带着bat大厂的面试问题去理解",charIndex:165},{level:2,title:"Overview",slug:"overview",normalizedTitle:"overview",charIndex:186},{level:2,title:"Lock框架和Tools类",slug:"lock框架和tools类",normalizedTitle:"lock框架和tools类",charIndex:200},{level:3,title:"类结构总览",slug:"类结构总览",normalizedTitle:"类结构总览",charIndex:221},{level:3,title:"接口: Condition",slug:"接口-condition",normalizedTitle:"接口: condition",charIndex:234},{level:3,title:"接口: Lock",slug:"接口-lock",normalizedTitle:"接口: lock",charIndex:255},{level:3,title:"接口: ReadWriteLock",slug:"接口-readwritelock",normalizedTitle:"接口: readwritelock",charIndex:271},{level:3,title:"抽象类: AbstractOwnableSynchonizer",slug:"抽象类-abstractownablesynchonizer",normalizedTitle:"抽象类: abstractownablesynchonizer",charIndex:296},{level:3,title:"抽象类(long): AbstractQueuedLongSynchronizer",slug:"抽象类-long-abstractqueuedlongsynchronizer",normalizedTitle:"抽象类(long): abstractqueuedlongsynchronizer",charIndex:335},{level:3,title:"核心抽象类(int): AbstractQueuedSynchronizer",slug:"核心抽象类-int-abstractqueuedsynchronizer",normalizedTitle:"核心抽象类(int): abstractqueuedsynchronizer",charIndex:384},{level:3,title:"锁常用类: LockSupport",slug:"锁常用类-locksupport",normalizedTitle:"锁常用类: locksupport",charIndex:430},{level:3,title:"锁常用类: ReentrantLock",slug:"锁常用类-reentrantlock",normalizedTitle:"锁常用类: reentrantlock",charIndex:455},{level:3,title:"锁常用类: ReentrantReadWriteLock",slug:"锁常用类-reentrantreadwritelock",normalizedTitle:"锁常用类: reentrantreadwritelock",charIndex:482},{level:3,title:"锁常用类: StampedLock",slug:"锁常用类-stampedlock",normalizedTitle:"锁常用类: stampedlock",charIndex:518},{level:3,title:"工具常用类: CountDownLatch",slug:"工具常用类-countdownlatch",normalizedTitle:"工具常用类: countdownlatch",charIndex:543},{level:3,title:"工具常用类: CyclicBarrier",slug:"工具常用类-cyclicbarrier",normalizedTitle:"工具常用类: cyclicbarrier",charIndex:572},{level:3,title:"工具常用类: Phaser",slug:"工具常用类-phaser",normalizedTitle:"工具常用类: phaser",charIndex:600},{level:3,title:"工具常用类: Semaphore",slug:"工具常用类-semaphore",normalizedTitle:"工具常用类: semaphore",charIndex:621},{level:3,title:"工具常用类: Exchanger",slug:"工具常用类-exchanger",normalizedTitle:"工具常用类: exchanger",charIndex:645},{level:2,title:"Collections: 并发集合",slug:"collections-并发集合",normalizedTitle:"collections: 并发集合",charIndex:667},{level:3,title:"类结构关系",slug:"类结构关系",normalizedTitle:"类结构关系",charIndex:692},{level:3,title:"Queue: ArrayBlockingQueue",slug:"queue-arrayblockingqueue",normalizedTitle:"queue: arrayblockingqueue",charIndex:705},{level:3,title:"Queue: LinkedBlockingQueue",slug:"queue-linkedblockingqueue",normalizedTitle:"queue: linkedblockingqueue",charIndex:738},{level:3,title:"Queue: LinkedBlockingDeque",slug:"queue-linkedblockingdeque",normalizedTitle:"queue: linkedblockingdeque",charIndex:772},{level:3,title:"Queue: ConcurrentLinkedQueue",slug:"queue-concurrentlinkedqueue",normalizedTitle:"queue: concurrentlinkedqueue",charIndex:806},{level:3,title:"Queue: ConcurrentLinkedDeque",slug:"queue-concurrentlinkeddeque",normalizedTitle:"queue: concurrentlinkeddeque",charIndex:842},{level:3,title:"Queue: DelayQueue",slug:"queue-delayqueue",normalizedTitle:"queue: delayqueue",charIndex:878},{level:3,title:"Queue: PriorityBlockingQueue",slug:"queue-priorityblockingqueue",normalizedTitle:"queue: priorityblockingqueue",charIndex:903},{level:3,title:"Queue: SynchronousQueue",slug:"queue-synchronousqueue",normalizedTitle:"queue: synchronousqueue",charIndex:939},{level:3,title:"Queue: LinkedTransferQueue",slug:"queue-linkedtransferqueue",normalizedTitle:"queue: linkedtransferqueue",charIndex:970},{level:3,title:"List: CopyOnWriteArrayList",slug:"list-copyonwritearraylist",normalizedTitle:"list: copyonwritearraylist",charIndex:1004},{level:3,title:"Set: CopyOnWriteArraySet",slug:"set-copyonwritearrayset",normalizedTitle:"set: copyonwritearrayset",charIndex:1038},{level:3,title:"Set: ConcurrentSkipListSet",slug:"set-concurrentskiplistset",normalizedTitle:"set: concurrentskiplistset",charIndex:1070},{level:3,title:"Map: ConcurrentHashMap",slug:"map-concurrenthashmap",normalizedTitle:"map: concurrenthashmap",charIndex:1104},{level:3,title:"Map: ConcurrentSkipListMap",slug:"map-concurrentskiplistmap",normalizedTitle:"map: concurrentskiplistmap",charIndex:1134},{level:2,title:"Atomic: 原子类",slug:"atomic-原子类",normalizedTitle:"atomic: 原子类",charIndex:1166},{level:3,title:"基础类型：AtomicBoolean，AtomicInteger，AtomicLong",slug:"基础类型-atomicboolean-atomicinteger-atomiclong",normalizedTitle:"基础类型：atomicboolean，atomicinteger，atomiclong",charIndex:1185},{level:3,title:"数组：AtomicIntegerArray，AtomicLongArray，BooleanArray",slug:"数组-atomicintegerarray-atomiclongarray-booleanarray",normalizedTitle:"数组：atomicintegerarray，atomiclongarray，booleanarray",charIndex:1236},{level:3,title:"引用：AtomicReference，AtomicMarkedReference，AtomicStampedReference",slug:"引用-atomicreference-atomicmarkedreference-atomicstampedreference",normalizedTitle:"引用：atomicreference，atomicmarkedreference，atomicstampedreference",charIndex:1294},{level:3,title:"FieldUpdater：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater",slug:"fieldupdater-atomiclongfieldupdater-atomicintegerfieldupdater-atomicreferencefieldupdater",normalizedTitle:"fieldupdater：atomiclongfieldupdater，atomicintegerfieldupdater，atomicreferencefieldupdater",charIndex:1365},{level:2,title:"Executors: 线程池",slug:"executors-线程池",normalizedTitle:"executors: 线程池",charIndex:1460},{level:3,title:"类结构关系",slug:"类结构关系-2",normalizedTitle:"类结构关系",charIndex:692},{level:3,title:"接口: Executor",slug:"接口-executor",normalizedTitle:"接口: executor",charIndex:1495},{level:3,title:"ExecutorService",slug:"executorservice",normalizedTitle:"executorservice",charIndex:1515},{level:3,title:"ScheduledExecutorService",slug:"scheduledexecutorservice",normalizedTitle:"scheduledexecutorservice",charIndex:1538},{level:3,title:"AbstractExecutorService",slug:"abstractexecutorservice",normalizedTitle:"abstractexecutorservice",charIndex:1570},{level:3,title:"FutureTask",slug:"futuretask",normalizedTitle:"futuretask",charIndex:1601},{level:3,title:"核心: ThreadPoolExecutor",slug:"核心-threadpoolexecutor",normalizedTitle:"核心: threadpoolexecutor",charIndex:1619},{level:3,title:"核心: ScheduledThreadExecutor",slug:"核心-scheduledthreadexecutor",normalizedTitle:"核心: scheduledthreadexecutor",charIndex:1649},{level:3,title:"核心: Fork/Join框架",slug:"核心-fork-join框架",normalizedTitle:"核心: fork/join框架",charIndex:1684},{level:3,title:"工具类: Executors",slug:"工具类-executors",normalizedTitle:"工具类: executors",charIndex:1707},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:1727}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"JUC - 类汇总和学习指南 带着BAT大厂的面试问题去理解 Overview Lock框架和Tools类 类结构总览 接口: Condition 接口: Lock 接口: ReadWriteLock 抽象类: AbstractOwnableSynchonizer 抽象类(long): AbstractQueuedLongSynchronizer 核心抽象类(int): AbstractQueuedSynchronizer 锁常用类: LockSupport 锁常用类: ReentrantLock 锁常用类: ReentrantReadWriteLock 锁常用类: StampedLock 工具常用类: CountDownLatch 工具常用类: CyclicBarrier 工具常用类: Phaser 工具常用类: Semaphore 工具常用类: Exchanger Collections: 并发集合 类结构关系 Queue: ArrayBlockingQueue Queue: LinkedBlockingQueue Queue: LinkedBlockingDeque Queue: ConcurrentLinkedQueue Queue: ConcurrentLinkedDeque Queue: DelayQueue Queue: PriorityBlockingQueue Queue: SynchronousQueue Queue: LinkedTransferQueue List: CopyOnWriteArrayList Set: CopyOnWriteArraySet Set: ConcurrentSkipListSet Map: ConcurrentHashMap Map: ConcurrentSkipListMap Atomic: 原子类 基础类型：AtomicBoolean，AtomicInteger，AtomicLong 数组：AtomicIntegerArray，AtomicLongArray，BooleanArray 引用：AtomicReference，AtomicMarkedReference，AtomicStampedReference FieldUpdater：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater Executors: 线程池 类结构关系 接口: Executor ExecutorService ScheduledExecutorService AbstractExecutorService FutureTask 核心: ThreadPoolExecutor 核心: ScheduledThreadExecutor 核心: Fork/Join框架 工具类: Executors 参考文章",content:'# JUC - 类汇总和学习指南\n\n提示\n\n本文对J.U.C进行知识体系解读，后续的文章还针对几乎所有的核心的类以及常用的工具类作了详细的解读; 如果没有时间详细阅读相关章节，可以跟着本文站在一定的高度了解JUC下包的设计和实现；同时对重要的章节提供跳转链接，您可以链接过去详读。\n\n * JUC - 类汇总和学习指南\n   * 带着BAT大厂的面试问题去理解\n   * Overview\n   * Lock框架和Tools类\n     * 类结构总览\n     * 接口: Condition\n     * 接口: Lock\n     * 接口: ReadWriteLock\n     * 抽象类: AbstractOwnableSynchonizer\n     * 抽象类(long): AbstractQueuedLongSynchronizer\n     * 核心抽象类(int): AbstractQueuedSynchronizer\n     * 锁常用类: LockSupport\n     * 锁常用类: ReentrantLock\n     * 锁常用类: ReentrantReadWriteLock\n     * 锁常用类: StampedLock\n     * 工具常用类: CountDownLatch\n     * 工具常用类: CyclicBarrier\n     * 工具常用类: Phaser\n     * 工具常用类: Semaphore\n     * 工具常用类: Exchanger\n   * Collections: 并发集合\n     * 类结构关系\n     * Queue: ArrayBlockingQueue\n     * Queue: LinkedBlockingQueue\n     * Queue: LinkedBlockingDeque\n     * Queue: ConcurrentLinkedQueue\n     * Queue: ConcurrentLinkedDeque\n     * Queue: DelayQueue\n     * Queue: PriorityBlockingQueue\n     * Queue: SynchronousQueue\n     * Queue: LinkedTransferQueue\n     * List: CopyOnWriteArrayList\n     * Set: CopyOnWriteArraySet\n     * Set: ConcurrentSkipListSet\n     * Map: ConcurrentHashMap\n     * Map: ConcurrentSkipListMap\n   * Atomic: 原子类\n     * 基础类型：AtomicBoolean，AtomicInteger，AtomicLong\n     * 数组：AtomicIntegerArray，AtomicLongArray，BooleanArray\n     * 引用：AtomicReference，AtomicMarkedReference，AtomicStampedReference\n     * FieldUpdater：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater\n   * Executors: 线程池\n     * 类结构关系\n     * 接口: Executor\n     * ExecutorService\n     * ScheduledExecutorService\n     * AbstractExecutorService\n     * FutureTask\n     * 核心: ThreadPoolExecutor\n     * 核心: ScheduledThreadExecutor\n     * 核心: Fork/Join框架\n     * 工具类: Executors\n   * 参考文章\n\n\n# 带着BAT大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * JUC框架包含几个部分?\n * 每个部分有哪些核心的类?\n * 最最核心的类有哪些?\n\n\n# Overview\n\n阅读前，推荐你学习下并发相关基础\n\n * Java 并发 - 理论基础\n * Java 并发 - 线程基础\n * 关键字: synchronized详解\n * 关键字: volatile详解\n * 关键字: final详解\n\n正式学习时先了解五个部分：\n\n\n\n主要包含: (注意: 上图是网上找的图，无法表述一些继承关系，同时少了部分类；但是主体上可以看出其分类关系也够了)\n\n * Lock框架和Tools类(把图中这两个放到一起理解)\n * Collections: 并发集合\n * Atomic: 原子类\n * Executors: 线程池\n\n\n# Lock框架和Tools类\n\n\n# 类结构总览\n\n\n\n\n# 接口: Condition\n\n> Condition为接口类型，它将 Object 监视器方法(wait、notify 和 notifyAll)分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set (wait-set)。其中，Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 监视器方法的使用。可以通过await(),signal()来休眠/唤醒线程。\n\n在JUC锁: AbstractQueuedSynchronizer详解中类的内部类-conditionobject类有具体分析。\n\n\n# 接口: Lock\n\n> Lock为接口类型，Lock实现提供了比使用synchronized方法和语句可获得的更广泛的锁定操作。此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的Condition对象。\n\n\n# 接口: ReadWriteLock\n\n> ReadWriteLock为接口类型， 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写入锁是独占的。\n\n\n# 抽象类: AbstractOwnableSynchonizer\n\n> AbstractOwnableSynchonizer为抽象类，可以由线程以独占方式拥有的同步器。此类为创建锁和相关同步器(伴随着所有权的概念)提供了基础。AbstractOwnableSynchronizer 类本身不管理或使用此信息。但是，子类和工具可以使用适当维护的值帮助控制和监视访问以及提供诊断。\n\n\n# 抽象类(long): AbstractQueuedLongSynchronizer\n\n> AbstractQueuedLongSynchronizer为抽象类，以 long 形式维护同步状态的一个 AbstractQueuedSynchronizer 版本。此类具有的结构、属性和方法与 AbstractQueuedSynchronizer 完全相同，但所有与状态相关的参数和结果都定义为 long 而不是 int。当创建需要 64 位状态的多级别锁和屏障等同步器时，此类很有用。\n\n\n# 核心抽象类(int): AbstractQueuedSynchronizer\n\n> AbstractQueuedSynchronizer为抽象类，其为实现依赖于先进先出 (FIFO) 等待队列的阻塞锁和相关同步器(信号量、事件，等等)提供一个框架。此类的设计目标是成为依靠单个原子 int 值来表示状态的大多数同步器的一个有用基础。\n\n详细分析请看: JUC锁: AbstractQueuedSynchronizer详解\n\n\n# 锁常用类: LockSupport\n\n> LockSupport为常用类，用来创建锁和其他同步类的基本线程阻塞原语。LockSupport的功能和"Thread中的 Thread.suspend()和Thread.resume()有点类似"，LockSupport中的park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程。但是park()和unpark()不会遇到“Thread.suspend 和 Thread.resume所可能引发的死锁”问题。\n\n详细分析请看: JUC锁: LockSupport详解\n\n\n# 锁常用类: ReentrantLock\n\n> ReentrantLock为常用类，它是一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。\n\n详细分析请看: JUC锁: ReentrantLock详解\n\n\n# 锁常用类: ReentrantReadWriteLock\n\n> ReentrantReadWriteLock是读写锁接口ReadWriteLock的实现类，它包括Lock子类ReadLock和WriteLock。ReadLock是共享锁，WriteLock是独占锁。\n\n详细分析请看: JUC工具类: ReentrantReadWriteLock详解\n\n\n# 锁常用类: StampedLock\n\n> 它是java8在java.util.concurrent.locks新增的一个API。StampedLock控制锁有三种模式(写，读，乐观读)，一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。\n\n详细分析请看: Java 8 - StampedLock详解\n\n\n# 工具常用类: CountDownLatch\n\n> CountDownLatch为常用类，它是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。\n\n详细分析请看: JUC工具类: CountDownLatch详解\n\n\n# 工具常用类: CyclicBarrier\n\n> CyclicBarrier为常用类，其是一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。\n\n详细分析请看: JUC工具类: CyclicBarrier详解\n\n\n# 工具常用类: Phaser\n\n> Phaser是JDK 7新增的一个同步辅助类，它可以实现CyclicBarrier和CountDownLatch类似的功能，而且它支持对任务的动态调整，并支持分层结构来达到更高的吞吐量。\n\n详细分析请看: JUC工具类: Phaser详解\n\n\n# 工具常用类: Semaphore\n\n> Semaphore为常用类，其是一个计数信号量，从概念上讲，信号量维护了一个许可集。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release() 添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore 只对可用许可的号码进行计数，并采取相应的行动。通常用于限制可以访问某些资源(物理或逻辑的)的线程数目。\n\n详细分析请看: JUC工具类: Semaphore详解\n\n\n# 工具常用类: Exchanger\n\n> Exchanger是用于线程协作的工具类, 主要用于两个线程之间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange()方法交换数据，当一个线程先执行exchange()方法后，它会一直等待第二个线程也执行exchange()方法，当这两个线程到达同步点时，这两个线程就可以交换数据了。\n\n详细分析请看: JUC工具类: Exchanger详解\n\n\n# Collections: 并发集合\n\n\n# 类结构关系\n\n\n\n\n# Queue: ArrayBlockingQueue\n\n> 一个由数组支持的有界阻塞队列。此队列按 FIFO(先进先出)原则对元素进行排序。队列的头部 是在队列中存在时间最长的元素。队列的尾部 是在队列中存在时间最短的元素。新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。\n\n详细分析请看: JUC并发集合: BlockingQueue详解\n\n\n# Queue: LinkedBlockingQueue\n\n> 一个基于已链接节点的、范围任意的 blocking queue。此队列按 FIFO(先进先出)排序元素。队列的头部 是在队列中时间最长的元素。队列的尾部 是在队列中时间最短的元素。新元素插入到队列的尾部，并且队列获取操作会获得位于队列头部的元素。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。\n\n详细分析请看: JUC并发集合: BlockingQueue详解\n\n\n# Queue: LinkedBlockingDeque\n\n> 一个基于已链接节点的、任选范围的阻塞双端队列。\n\n详细分析请看: JUC并发集合: BlockingQueue详解\n\n\n# Queue: ConcurrentLinkedQueue\n\n> 一个基于链接节点的无界线程安全队列。此队列按照 FIFO(先进先出)原则对元素进行排序。队列的头部 是队列中时间最长的元素。队列的尾部 是队列中时间最短的元素。新的元素插入到队列的尾部，队列获取操作从队列头部获得元素。当多个线程共享访问一个公共 collection 时，ConcurrentLinkedQueue 是一个恰当的选择。此队列不允许使用 null 元素。\n\n详细分析请看: JUC并发集合: ConcurrentLinkedQueue详解\n\n\n# Queue: ConcurrentLinkedDeque\n\n> 是双向链表实现的无界队列，该队列同时支持FIFO和FILO两种操作方式。\n\n\n# Queue: DelayQueue\n\n> 延时无界阻塞队列，使用Lock机制实现并发访问。队列里只允许放可以“延期”的元素，队列中的head是最先“到期”的元素。如果队里中没有元素到“到期”，那么就算队列中有元素也不能获取到。\n\n\n# Queue: PriorityBlockingQueue\n\n> 无界优先级阻塞队列，使用Lock机制实现并发访问。priorityQueue的线程安全版，不允许存放null值，依赖于comparable的排序，不允许存放不可比较的对象类型。\n\n\n# Queue: SynchronousQueue\n\n> 没有容量的同步队列，通过CAS实现并发访问，支持FIFO和FILO。\n\n\n# Queue: LinkedTransferQueue\n\n> JDK 7新增，单向链表实现的无界阻塞队列，通过CAS实现并发访问，队列元素使用 FIFO(先进先出)方式。LinkedTransferQueue可以说是ConcurrentLinkedQueue、SynchronousQueue(公平模式)和LinkedBlockingQueue的超集, 它不仅仅综合了这几个类的功能，同时也提供了更高效的实现。\n\n\n# List: CopyOnWriteArrayList\n\n> ArrayList 的一个线程安全的变体，其中所有可变操作(add、set 等等)都是通过对底层数组进行一次新的复制来实现的。这一般需要很大的开销，但是当遍历操作的数量大大超过可变操作的数量时，这种方法可能比其他替代方法更 有效。在不能或不想进行同步遍历，但又需要从并发线程中排除冲突时，它也很有用。\n\n详细分析请看: JUC并发集合: CopyOnWriteArrayList详解\n\n\n# Set: CopyOnWriteArraySet\n\n> 对其所有操作使用内部CopyOnWriteArrayList的Set。即将所有操作转发至CopyOnWriteArayList来进行操作，能够保证线程安全。在add时，会调用addIfAbsent，由于每次add时都要进行数组遍历，因此性能会略低于CopyOnWriteArrayList。\n\n\n# Set: ConcurrentSkipListSet\n\n> 一个基于ConcurrentSkipListMap 的可缩放并发 NavigableSet 实现。set 的元素可以根据它们的自然顺序进行排序，也可以根据创建 set 时所提供的 Comparator 进行排序，具体取决于使用的构造方法。\n\n\n# Map: ConcurrentHashMap\n\n> 是线程安全HashMap的。ConcurrentHashMap在JDK 7之前是通过Lock和segment(分段锁)实现，JDK 8 之后改为CAS+synchronized来保证并发安全。\n\n详细分析请看: JUC并发集合: ConcurrentHashMap详解, 包含了对JDK 7和JDK 8版本的源码分析。\n\n\n# Map: ConcurrentSkipListMap\n\n> 线程安全的有序的哈希表(相当于线程安全的TreeMap);映射可以根据键的自然顺序进行排序，也可以根据创建映射时所提供的 Comparator 进行排序，具体取决于使用的构造方法。\n\n\n# Atomic: 原子类\n\n其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由JVM从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。实际上是借助硬件的相关指令来实现的，不会阻塞线程(或者说只是在硬件级别上阻塞了)。\n\n对CAS，Unsafe类，以及13个原子类详解请参考：详细分析请看: JUC原子类: CAS, Unsafe和原子类详解\n\n\n# 基础类型：AtomicBoolean，AtomicInteger，AtomicLong\n\n> AtomicBoolean，AtomicInteger，AtomicLong是类似的，分别针对bool，interger，long的原子类。\n\n\n# 数组：AtomicIntegerArray，AtomicLongArray，BooleanArray\n\n> AtomicIntegerArray，AtomicLongArray，AtomicBooleanArray是数组原子类。\n\n\n# 引用：AtomicReference，AtomicMarkedReference，AtomicStampedReference\n\n> AtomicReference，AtomicMarkedReference，AtomicStampedReference是引用相关的原子类。\n\n\n# FieldUpdater：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater\n\n> AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater是FieldUpdater原子类。\n\n\n# Executors: 线程池\n\n\n# 类结构关系\n\n\n\n\n# 接口: Executor\n\n> Executor接口提供一种将任务提交与每个任务将如何运行的机制(包括线程使用的细节、调度等)分离开来的方法。通常使用 Executor 而不是显式地创建线程。\n\n\n# ExecutorService\n\n> ExecutorService继承自Executor接口，ExecutorService提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。 可以关闭 ExecutorService，这将导致其停止接受新任务。关闭后，执行程序将最后终止，这时没有任务在执行，也没有任务在等待执行，并且无法提交新任务。\n\n\n# ScheduledExecutorService\n\n> ScheduledExecutorService继承自ExecutorService接口，可安排在给定的延迟后运行或定期执行的命令。\n\n\n# AbstractExecutorService\n\n> AbstractExecutorService继承自ExecutorService接口，其提供 ExecutorService 执行方法的默认实现。此类使用 newTaskFor 返回的 RunnableFuture 实现 submit、invokeAny 和 invokeAll 方法，默认情况下，RunnableFuture 是此包中提供的 FutureTask 类。\n\n\n# FutureTask\n\n> FutureTask 为 Future 提供了基础实现，如获取任务执行结果(get)和取消任务(cancel)等。如果任务尚未完成，获取任务执行结果时将会阻塞。一旦执行结束，任务就不能被重启或取消(除非使用runAndReset执行计算)。FutureTask 常用来封装 Callable 和 Runnable，也可以作为一个任务提交到线程池中执行。除了作为一个独立的类之外，此类也提供了一些功能性函数供我们创建自定义 task 类使用。FutureTask 的线程安全由CAS来保证。\n\n详细分析请看: JUC线程池: FutureTask详解\n\n\n# 核心: ThreadPoolExecutor\n\n> ThreadPoolExecutor实现了AbstractExecutorService接口，也是一个 ExecutorService，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。 线程池可以解决两个不同问题: 由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源(包括执行任务集时使用的线程)的方法。每个 ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。\n\n详细分析请看: JUC线程池: ThreadPoolExecutor详解\n\n\n# 核心: ScheduledThreadExecutor\n\n> ScheduledThreadPoolExecutor实现ScheduledExecutorService接口，可安排在给定的延迟后运行命令，或者定期执行命令。需要多个辅助线程时，或者要求 ThreadPoolExecutor 具有额外的灵活性或功能时，此类要优于 Timer。\n\n详细分析请看: JUC线程池: ScheduledThreadExecutor详解\n\n\n# 核心: Fork/Join框架\n\n> ForkJoinPool 是JDK 7加入的一个线程池类。Fork/Join 技术是分治算法(Divide-and-Conquer)的并行实现，它是一项可以获得良好的并行性能的简单且高效的设计技术。目的是为了帮助我们更好地利用多处理器带来的好处，使用所有可用的运算能力来提升应用的性能。\n\n详细分析请看: JUC线程池: Fork/Join框架详解\n\n\n# 工具类: Executors\n\n> Executors是一个工具类，用其可以创建ExecutorService、ScheduledExecutorService、ThreadFactory、Callable等对象。它的使用融入到了ThreadPoolExecutor, ScheduledThreadExecutor和ForkJoinPool中。\n\n\n# 参考文章\n\n * https://www.cnblogs.com/leesf456/p/5344133.html\n * https://www.cnblogs.com/leesf456/p/5428630.html\n * https://www.cnblogs.com/leesf456/p/5550043.html\n * https://www.jianshu.com/p/8cb5d816cb69\n * 泰迪的bagwell https://www.jianshu.com/p/af9c0f404a93\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-overview.html',normalizedContent:'# juc - 类汇总和学习指南\n\n提示\n\n本文对j.u.c进行知识体系解读，后续的文章还针对几乎所有的核心的类以及常用的工具类作了详细的解读; 如果没有时间详细阅读相关章节，可以跟着本文站在一定的高度了解juc下包的设计和实现；同时对重要的章节提供跳转链接，您可以链接过去详读。\n\n * juc - 类汇总和学习指南\n   * 带着bat大厂的面试问题去理解\n   * overview\n   * lock框架和tools类\n     * 类结构总览\n     * 接口: condition\n     * 接口: lock\n     * 接口: readwritelock\n     * 抽象类: abstractownablesynchonizer\n     * 抽象类(long): abstractqueuedlongsynchronizer\n     * 核心抽象类(int): abstractqueuedsynchronizer\n     * 锁常用类: locksupport\n     * 锁常用类: reentrantlock\n     * 锁常用类: reentrantreadwritelock\n     * 锁常用类: stampedlock\n     * 工具常用类: countdownlatch\n     * 工具常用类: cyclicbarrier\n     * 工具常用类: phaser\n     * 工具常用类: semaphore\n     * 工具常用类: exchanger\n   * collections: 并发集合\n     * 类结构关系\n     * queue: arrayblockingqueue\n     * queue: linkedblockingqueue\n     * queue: linkedblockingdeque\n     * queue: concurrentlinkedqueue\n     * queue: concurrentlinkeddeque\n     * queue: delayqueue\n     * queue: priorityblockingqueue\n     * queue: synchronousqueue\n     * queue: linkedtransferqueue\n     * list: copyonwritearraylist\n     * set: copyonwritearrayset\n     * set: concurrentskiplistset\n     * map: concurrenthashmap\n     * map: concurrentskiplistmap\n   * atomic: 原子类\n     * 基础类型：atomicboolean，atomicinteger，atomiclong\n     * 数组：atomicintegerarray，atomiclongarray，booleanarray\n     * 引用：atomicreference，atomicmarkedreference，atomicstampedreference\n     * fieldupdater：atomiclongfieldupdater，atomicintegerfieldupdater，atomicreferencefieldupdater\n   * executors: 线程池\n     * 类结构关系\n     * 接口: executor\n     * executorservice\n     * scheduledexecutorservice\n     * abstractexecutorservice\n     * futuretask\n     * 核心: threadpoolexecutor\n     * 核心: scheduledthreadexecutor\n     * 核心: fork/join框架\n     * 工具类: executors\n   * 参考文章\n\n\n# 带着bat大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * juc框架包含几个部分?\n * 每个部分有哪些核心的类?\n * 最最核心的类有哪些?\n\n\n# overview\n\n阅读前，推荐你学习下并发相关基础\n\n * java 并发 - 理论基础\n * java 并发 - 线程基础\n * 关键字: synchronized详解\n * 关键字: volatile详解\n * 关键字: final详解\n\n正式学习时先了解五个部分：\n\n\n\n主要包含: (注意: 上图是网上找的图，无法表述一些继承关系，同时少了部分类；但是主体上可以看出其分类关系也够了)\n\n * lock框架和tools类(把图中这两个放到一起理解)\n * collections: 并发集合\n * atomic: 原子类\n * executors: 线程池\n\n\n# lock框架和tools类\n\n\n# 类结构总览\n\n\n\n\n# 接口: condition\n\n> condition为接口类型，它将 object 监视器方法(wait、notify 和 notifyall)分解成截然不同的对象，以便通过将这些对象与任意 lock 实现组合使用，为每个对象提供多个等待 set (wait-set)。其中，lock 替代了 synchronized 方法和语句的使用，condition 替代了 object 监视器方法的使用。可以通过await(),signal()来休眠/唤醒线程。\n\n在juc锁: abstractqueuedsynchronizer详解中类的内部类-conditionobject类有具体分析。\n\n\n# 接口: lock\n\n> lock为接口类型，lock实现提供了比使用synchronized方法和语句可获得的更广泛的锁定操作。此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的condition对象。\n\n\n# 接口: readwritelock\n\n> readwritelock为接口类型， 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写入锁是独占的。\n\n\n# 抽象类: abstractownablesynchonizer\n\n> abstractownablesynchonizer为抽象类，可以由线程以独占方式拥有的同步器。此类为创建锁和相关同步器(伴随着所有权的概念)提供了基础。abstractownablesynchronizer 类本身不管理或使用此信息。但是，子类和工具可以使用适当维护的值帮助控制和监视访问以及提供诊断。\n\n\n# 抽象类(long): abstractqueuedlongsynchronizer\n\n> abstractqueuedlongsynchronizer为抽象类，以 long 形式维护同步状态的一个 abstractqueuedsynchronizer 版本。此类具有的结构、属性和方法与 abstractqueuedsynchronizer 完全相同，但所有与状态相关的参数和结果都定义为 long 而不是 int。当创建需要 64 位状态的多级别锁和屏障等同步器时，此类很有用。\n\n\n# 核心抽象类(int): abstractqueuedsynchronizer\n\n> abstractqueuedsynchronizer为抽象类，其为实现依赖于先进先出 (fifo) 等待队列的阻塞锁和相关同步器(信号量、事件，等等)提供一个框架。此类的设计目标是成为依靠单个原子 int 值来表示状态的大多数同步器的一个有用基础。\n\n详细分析请看: juc锁: abstractqueuedsynchronizer详解\n\n\n# 锁常用类: locksupport\n\n> locksupport为常用类，用来创建锁和其他同步类的基本线程阻塞原语。locksupport的功能和"thread中的 thread.suspend()和thread.resume()有点类似"，locksupport中的park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程。但是park()和unpark()不会遇到“thread.suspend 和 thread.resume所可能引发的死锁”问题。\n\n详细分析请看: juc锁: locksupport详解\n\n\n# 锁常用类: reentrantlock\n\n> reentrantlock为常用类，它是一个可重入的互斥锁 lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。\n\n详细分析请看: juc锁: reentrantlock详解\n\n\n# 锁常用类: reentrantreadwritelock\n\n> reentrantreadwritelock是读写锁接口readwritelock的实现类，它包括lock子类readlock和writelock。readlock是共享锁，writelock是独占锁。\n\n详细分析请看: juc工具类: reentrantreadwritelock详解\n\n\n# 锁常用类: stampedlock\n\n> 它是java8在java.util.concurrent.locks新增的一个api。stampedlock控制锁有三种模式(写，读，乐观读)，一个stampedlock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。\n\n详细分析请看: java 8 - stampedlock详解\n\n\n# 工具常用类: countdownlatch\n\n> countdownlatch为常用类，它是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。\n\n详细分析请看: juc工具类: countdownlatch详解\n\n\n# 工具常用类: cyclicbarrier\n\n> cyclicbarrier为常用类，其是一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 cyclicbarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。\n\n详细分析请看: juc工具类: cyclicbarrier详解\n\n\n# 工具常用类: phaser\n\n> phaser是jdk 7新增的一个同步辅助类，它可以实现cyclicbarrier和countdownlatch类似的功能，而且它支持对任务的动态调整，并支持分层结构来达到更高的吞吐量。\n\n详细分析请看: juc工具类: phaser详解\n\n\n# 工具常用类: semaphore\n\n> semaphore为常用类，其是一个计数信号量，从概念上讲，信号量维护了一个许可集。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release() 添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，semaphore 只对可用许可的号码进行计数，并采取相应的行动。通常用于限制可以访问某些资源(物理或逻辑的)的线程数目。\n\n详细分析请看: juc工具类: semaphore详解\n\n\n# 工具常用类: exchanger\n\n> exchanger是用于线程协作的工具类, 主要用于两个线程之间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange()方法交换数据，当一个线程先执行exchange()方法后，它会一直等待第二个线程也执行exchange()方法，当这两个线程到达同步点时，这两个线程就可以交换数据了。\n\n详细分析请看: juc工具类: exchanger详解\n\n\n# collections: 并发集合\n\n\n# 类结构关系\n\n\n\n\n# queue: arrayblockingqueue\n\n> 一个由数组支持的有界阻塞队列。此队列按 fifo(先进先出)原则对元素进行排序。队列的头部 是在队列中存在时间最长的元素。队列的尾部 是在队列中存在时间最短的元素。新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。\n\n详细分析请看: juc并发集合: blockingqueue详解\n\n\n# queue: linkedblockingqueue\n\n> 一个基于已链接节点的、范围任意的 blocking queue。此队列按 fifo(先进先出)排序元素。队列的头部 是在队列中时间最长的元素。队列的尾部 是在队列中时间最短的元素。新元素插入到队列的尾部，并且队列获取操作会获得位于队列头部的元素。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。\n\n详细分析请看: juc并发集合: blockingqueue详解\n\n\n# queue: linkedblockingdeque\n\n> 一个基于已链接节点的、任选范围的阻塞双端队列。\n\n详细分析请看: juc并发集合: blockingqueue详解\n\n\n# queue: concurrentlinkedqueue\n\n> 一个基于链接节点的无界线程安全队列。此队列按照 fifo(先进先出)原则对元素进行排序。队列的头部 是队列中时间最长的元素。队列的尾部 是队列中时间最短的元素。新的元素插入到队列的尾部，队列获取操作从队列头部获得元素。当多个线程共享访问一个公共 collection 时，concurrentlinkedqueue 是一个恰当的选择。此队列不允许使用 null 元素。\n\n详细分析请看: juc并发集合: concurrentlinkedqueue详解\n\n\n# queue: concurrentlinkeddeque\n\n> 是双向链表实现的无界队列，该队列同时支持fifo和filo两种操作方式。\n\n\n# queue: delayqueue\n\n> 延时无界阻塞队列，使用lock机制实现并发访问。队列里只允许放可以“延期”的元素，队列中的head是最先“到期”的元素。如果队里中没有元素到“到期”，那么就算队列中有元素也不能获取到。\n\n\n# queue: priorityblockingqueue\n\n> 无界优先级阻塞队列，使用lock机制实现并发访问。priorityqueue的线程安全版，不允许存放null值，依赖于comparable的排序，不允许存放不可比较的对象类型。\n\n\n# queue: synchronousqueue\n\n> 没有容量的同步队列，通过cas实现并发访问，支持fifo和filo。\n\n\n# queue: linkedtransferqueue\n\n> jdk 7新增，单向链表实现的无界阻塞队列，通过cas实现并发访问，队列元素使用 fifo(先进先出)方式。linkedtransferqueue可以说是concurrentlinkedqueue、synchronousqueue(公平模式)和linkedblockingqueue的超集, 它不仅仅综合了这几个类的功能，同时也提供了更高效的实现。\n\n\n# list: copyonwritearraylist\n\n> arraylist 的一个线程安全的变体，其中所有可变操作(add、set 等等)都是通过对底层数组进行一次新的复制来实现的。这一般需要很大的开销，但是当遍历操作的数量大大超过可变操作的数量时，这种方法可能比其他替代方法更 有效。在不能或不想进行同步遍历，但又需要从并发线程中排除冲突时，它也很有用。\n\n详细分析请看: juc并发集合: copyonwritearraylist详解\n\n\n# set: copyonwritearrayset\n\n> 对其所有操作使用内部copyonwritearraylist的set。即将所有操作转发至copyonwritearaylist来进行操作，能够保证线程安全。在add时，会调用addifabsent，由于每次add时都要进行数组遍历，因此性能会略低于copyonwritearraylist。\n\n\n# set: concurrentskiplistset\n\n> 一个基于concurrentskiplistmap 的可缩放并发 navigableset 实现。set 的元素可以根据它们的自然顺序进行排序，也可以根据创建 set 时所提供的 comparator 进行排序，具体取决于使用的构造方法。\n\n\n# map: concurrenthashmap\n\n> 是线程安全hashmap的。concurrenthashmap在jdk 7之前是通过lock和segment(分段锁)实现，jdk 8 之后改为cas+synchronized来保证并发安全。\n\n详细分析请看: juc并发集合: concurrenthashmap详解, 包含了对jdk 7和jdk 8版本的源码分析。\n\n\n# map: concurrentskiplistmap\n\n> 线程安全的有序的哈希表(相当于线程安全的treemap);映射可以根据键的自然顺序进行排序，也可以根据创建映射时所提供的 comparator 进行排序，具体取决于使用的构造方法。\n\n\n# atomic: 原子类\n\n其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由jvm从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。实际上是借助硬件的相关指令来实现的，不会阻塞线程(或者说只是在硬件级别上阻塞了)。\n\n对cas，unsafe类，以及13个原子类详解请参考：详细分析请看: juc原子类: cas, unsafe和原子类详解\n\n\n# 基础类型：atomicboolean，atomicinteger，atomiclong\n\n> atomicboolean，atomicinteger，atomiclong是类似的，分别针对bool，interger，long的原子类。\n\n\n# 数组：atomicintegerarray，atomiclongarray，booleanarray\n\n> atomicintegerarray，atomiclongarray，atomicbooleanarray是数组原子类。\n\n\n# 引用：atomicreference，atomicmarkedreference，atomicstampedreference\n\n> atomicreference，atomicmarkedreference，atomicstampedreference是引用相关的原子类。\n\n\n# fieldupdater：atomiclongfieldupdater，atomicintegerfieldupdater，atomicreferencefieldupdater\n\n> atomiclongfieldupdater，atomicintegerfieldupdater，atomicreferencefieldupdater是fieldupdater原子类。\n\n\n# executors: 线程池\n\n\n# 类结构关系\n\n\n\n\n# 接口: executor\n\n> executor接口提供一种将任务提交与每个任务将如何运行的机制(包括线程使用的细节、调度等)分离开来的方法。通常使用 executor 而不是显式地创建线程。\n\n\n# executorservice\n\n> executorservice继承自executor接口，executorservice提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 future 的方法。 可以关闭 executorservice，这将导致其停止接受新任务。关闭后，执行程序将最后终止，这时没有任务在执行，也没有任务在等待执行，并且无法提交新任务。\n\n\n# scheduledexecutorservice\n\n> scheduledexecutorservice继承自executorservice接口，可安排在给定的延迟后运行或定期执行的命令。\n\n\n# abstractexecutorservice\n\n> abstractexecutorservice继承自executorservice接口，其提供 executorservice 执行方法的默认实现。此类使用 newtaskfor 返回的 runnablefuture 实现 submit、invokeany 和 invokeall 方法，默认情况下，runnablefuture 是此包中提供的 futuretask 类。\n\n\n# futuretask\n\n> futuretask 为 future 提供了基础实现，如获取任务执行结果(get)和取消任务(cancel)等。如果任务尚未完成，获取任务执行结果时将会阻塞。一旦执行结束，任务就不能被重启或取消(除非使用runandreset执行计算)。futuretask 常用来封装 callable 和 runnable，也可以作为一个任务提交到线程池中执行。除了作为一个独立的类之外，此类也提供了一些功能性函数供我们创建自定义 task 类使用。futuretask 的线程安全由cas来保证。\n\n详细分析请看: juc线程池: futuretask详解\n\n\n# 核心: threadpoolexecutor\n\n> threadpoolexecutor实现了abstractexecutorservice接口，也是一个 executorservice，它使用可能的几个池线程之一执行每个提交的任务，通常使用 executors 工厂方法配置。 线程池可以解决两个不同问题: 由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源(包括执行任务集时使用的线程)的方法。每个 threadpoolexecutor 还维护着一些基本的统计数据，如完成的任务数。\n\n详细分析请看: juc线程池: threadpoolexecutor详解\n\n\n# 核心: scheduledthreadexecutor\n\n> scheduledthreadpoolexecutor实现scheduledexecutorservice接口，可安排在给定的延迟后运行命令，或者定期执行命令。需要多个辅助线程时，或者要求 threadpoolexecutor 具有额外的灵活性或功能时，此类要优于 timer。\n\n详细分析请看: juc线程池: scheduledthreadexecutor详解\n\n\n# 核心: fork/join框架\n\n> forkjoinpool 是jdk 7加入的一个线程池类。fork/join 技术是分治算法(divide-and-conquer)的并行实现，它是一项可以获得良好的并行性能的简单且高效的设计技术。目的是为了帮助我们更好地利用多处理器带来的好处，使用所有可用的运算能力来提升应用的性能。\n\n详细分析请看: juc线程池: fork/join框架详解\n\n\n# 工具类: executors\n\n> executors是一个工具类，用其可以创建executorservice、scheduledexecutorservice、threadfactory、callable等对象。它的使用融入到了threadpoolexecutor, scheduledthreadexecutor和forkjoinpool中。\n\n\n# 参考文章\n\n * https://www.cnblogs.com/leesf456/p/5344133.html\n * https://www.cnblogs.com/leesf456/p/5428630.html\n * https://www.cnblogs.com/leesf456/p/5550043.html\n * https://www.jianshu.com/p/8cb5d816cb69\n * 泰迪的bagwell https://www.jianshu.com/p/af9c0f404a93\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-overview.html',charsets:{cjk:!0}},{title:"JUC线程池: ThreadPoolExecutor详解",frontmatter:{},regularPath:"/java/thread/java-thread-x-juc-executor-ThreadPoolExecutor.html",relativePath:"java/thread/java-thread-x-juc-executor-ThreadPoolExecutor.md",key:"v-3969da64",path:"/java/thread/java-thread-x-juc-executor-ThreadPoolExecutor.html",headers:[{level:2,title:"JUC线程池: ThreadPoolExecutor详解",slug:"juc线程池-threadpoolexecutor详解",normalizedTitle:"juc线程池: threadpoolexecutor详解",charIndex:2},{level:2,title:"带着BAT大厂的面试问题去理解",slug:"带着bat大厂的面试问题去理解",normalizedTitle:"带着bat大厂的面试问题去理解",charIndex:99},{level:2,title:"为什么要有线程池",slug:"为什么要有线程池",normalizedTitle:"为什么要有线程池",charIndex:120},{level:2,title:"ThreadPoolExecutor例子",slug:"threadpoolexecutor例子",normalizedTitle:"threadpoolexecutor例子",charIndex:134},{level:2,title:"ThreadPoolExecutor使用详解",slug:"threadpoolexecutor使用详解",normalizedTitle:"threadpoolexecutor使用详解",charIndex:160},{level:3,title:"Execute原理",slug:"execute原理",normalizedTitle:"execute原理",charIndex:190},{level:3,title:"参数",slug:"参数",normalizedTitle:"参数",charIndex:207},{level:3,title:"三种类型",slug:"三种类型",normalizedTitle:"三种类型",charIndex:217},{level:3,title:"关闭线程池",slug:"关闭线程池",normalizedTitle:"关闭线程池",charIndex:319},{level:2,title:"ThreadPoolExecutor源码详解",slug:"threadpoolexecutor源码详解",normalizedTitle:"threadpoolexecutor源码详解",charIndex:383},{level:3,title:"几个关键属性",slug:"几个关键属性",normalizedTitle:"几个关键属性",charIndex:413},{level:3,title:"内部状态",slug:"内部状态",normalizedTitle:"内部状态",charIndex:427},{level:3,title:"任务的执行",slug:"任务的执行",normalizedTitle:"任务的执行",charIndex:439},{level:3,title:"任务的提交",slug:"任务的提交",normalizedTitle:"任务的提交",charIndex:542},{level:3,title:"任务的关闭",slug:"任务的关闭",normalizedTitle:"任务的关闭",charIndex:595},{level:2,title:"更深入理解",slug:"更深入理解",normalizedTitle:"更深入理解",charIndex:606},{level:3,title:"为什么线程池不允许使用Executors去创建? 推荐方式是什么?",slug:"为什么线程池不允许使用executors去创建-推荐方式是什么",normalizedTitle:"为什么线程池不允许使用executors去创建? 推荐方式是什么?",charIndex:619},{level:3,title:"配置线程池需要考虑因素",slug:"配置线程池需要考虑因素",normalizedTitle:"配置线程池需要考虑因素",charIndex:708},{level:3,title:"监控线程池的状态",slug:"监控线程池的状态",normalizedTitle:"监控线程池的状态",charIndex:727},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:741}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"JUC线程池: ThreadPoolExecutor详解 带着BAT大厂的面试问题去理解 为什么要有线程池 ThreadPoolExecutor例子 ThreadPoolExecutor使用详解 Execute原理 参数 三种类型 关闭线程池 ThreadPoolExecutor源码详解 几个关键属性 内部状态 任务的执行 任务的提交 任务的关闭 更深入理解 为什么线程池不允许使用Executors去创建? 推荐方式是什么? 配置线程池需要考虑因素 监控线程池的状态 参考文章",content:'# JUC线程池: ThreadPoolExecutor详解\n\n> 本文主要对ThreadPoolExecutor详解。\n\n * JUC线程池: ThreadPoolExecutor详解\n   * 带着BAT大厂的面试问题去理解\n   * 为什么要有线程池\n   * ThreadPoolExecutor例子\n   * ThreadPoolExecutor使用详解\n     * Execute原理\n     * 参数\n     * 三种类型\n       * newFixedThreadPool\n       * newSingleThreadExecutor\n       * newCachedThreadPool\n     * 关闭线程池\n       * 关闭方式 - shutdown\n       * 关闭方式 - shutdownNow\n   * ThreadPoolExecutor源码详解\n     * 几个关键属性\n     * 内部状态\n     * 任务的执行\n       * execute()方法\n       * addWorker方法\n       * Worker类的runworker方法\n       * getTask方法\n     * 任务的提交\n       * submit方法\n       * FutureTask对象\n     * 任务的关闭\n   * 更深入理解\n     * 为什么线程池不允许使用Executors去创建? 推荐方式是什么?\n       * 推荐方式 1\n       * 推荐方式 2\n       * 推荐方式 3\n     * 配置线程池需要考虑因素\n     * 监控线程池的状态\n   * 参考文章\n\n\n# 带着BAT大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 为什么要有线程池?\n * Java是实现和管理线程池有哪些方式? 请简单举例如何使用。\n * 为什么很多公司不允许使用Executors去创建线程池? 那么推荐怎么使用呢?\n * ThreadPoolExecutor有哪些核心的配置参数? 请简要说明\n * ThreadPoolExecutor可以创建哪是哪三种线程池呢?\n * 当队列满了并且worker的数量达到maxSize的时候，会怎么样?\n * 说说ThreadPoolExecutor有哪些RejectedExecutionHandler策略? 默认是什么策略?\n * 简要说下线程池的任务执行机制? execute –> addWorker –>runworker (getTask)\n * 线程池中任务是如何提交的?\n * 线程池中任务是如何关闭的?\n * 在配置线程池的时候需要考虑哪些配置因素?\n * 如何监控线程池的状态?\n\n\n# 为什么要有线程池\n\n线程池能够对线程进行统一分配，调优和监控:\n\n * 降低资源消耗(线程无限制地创建，然后使用完毕后销毁)\n * 提高响应速度(无须创建线程)\n * 提高线程的可管理性\n\n\n# ThreadPoolExecutor例子\n\nJava是如何实现和管理线程池的?\n\n从JDK 5开始，把工作单元与执行机制分离开来，工作单元包括Runnable和Callable，而执行机制由Executor框架提供。\n\n * WorkerThread\n\npublic class WorkerThread implements Runnable {\n     \n    private String command;\n     \n    public WorkerThread(String s){\n        this.command=s;\n    }\n \n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName()+" Start. Command = "+command);\n        processCommand();\n        System.out.println(Thread.currentThread().getName()+" End.");\n    }\n \n    private void processCommand() {\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n \n    @Override\n    public String toString(){\n        return this.command;\n    }\n}\n\n\n * SimpleThreadPool\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n \npublic class SimpleThreadPool {\n \n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newFixedThreadPool(5);\n        for (int i = 0; i < 10; i++) {\n            Runnable worker = new WorkerThread("" + i);\n            executor.execute(worker);\n          }\n        executor.shutdown(); // This will make the executor accept no new threads and finish all existing threads in the queue\n        while (!executor.isTerminated()) { // Wait until all threads are finish,and also you can use "executor.awaitTermination();" to wait\n        }\n        System.out.println("Finished all threads");\n    }\n\n}\n\n\n程序中我们创建了固定大小为五个工作线程的线程池。然后分配给线程池十个工作，因为线程池大小为五，它将启动五个工作线程先处理五个工作，其他的工作则处于等待状态，一旦有工作完成，空闲下来工作线程就会捡取等待队列里的其他工作进行执行。\n\n这里是以上程序的输出。\n\npool-1-thread-2 Start. Command = 1\npool-1-thread-4 Start. Command = 3\npool-1-thread-1 Start. Command = 0\npool-1-thread-3 Start. Command = 2\npool-1-thread-5 Start. Command = 4\npool-1-thread-4 End.\npool-1-thread-5 End.\npool-1-thread-1 End.\npool-1-thread-3 End.\npool-1-thread-3 Start. Command = 8\npool-1-thread-2 End.\npool-1-thread-2 Start. Command = 9\npool-1-thread-1 Start. Command = 7\npool-1-thread-5 Start. Command = 6\npool-1-thread-4 Start. Command = 5\npool-1-thread-2 End.\npool-1-thread-4 End.\npool-1-thread-3 End.\npool-1-thread-5 End.\npool-1-thread-1 End.\nFinished all threads\n\n\n输出表明线程池中至始至终只有五个名为 "pool-1-thread-1" 到 "pool-1-thread-5" 的五个线程，这五个线程不随着工作的完成而消亡，会一直存在，并负责执行分配给线程池的任务，直到线程池消亡。\n\nExecutors 类提供了使用了 ThreadPoolExecutor 的简单的 ExecutorService 实现，但是 ThreadPoolExecutor 提供的功能远不止于此。我们可以在创建 ThreadPoolExecutor 实例时指定活动线程的数量，我们也可以限制线程池的大小并且创建我们自己的 RejectedExecutionHandler 实现来处理不能适应工作队列的工作。\n\n这里是我们自定义的 RejectedExecutionHandler 接口的实现。\n\n * RejectedExecutionHandlerImpl.java\n\nimport java.util.concurrent.RejectedExecutionHandler;\nimport java.util.concurrent.ThreadPoolExecutor;\n \npublic class RejectedExecutionHandlerImpl implements RejectedExecutionHandler {\n \n    @Override\n    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {\n        System.out.println(r.toString() + " is rejected");\n    }\n \n}\n\n\nThreadPoolExecutor 提供了一些方法，我们可以使用这些方法来查询 executor 的当前状态，线程池大小，活动线程数量以及任务数量。因此我是用来一个监控线程在特定的时间间隔内打印 executor 信息。\n\n * MyMonitorThread.java\n\nimport java.util.concurrent.ThreadPoolExecutor;\n \npublic class MyMonitorThread implements Runnable\n{\n    private ThreadPoolExecutor executor;\n     \n    private int seconds;\n     \n    private boolean run=true;\n \n    public MyMonitorThread(ThreadPoolExecutor executor, int delay)\n    {\n        this.executor = executor;\n        this.seconds=delay;\n    }\n     \n    public void shutdown(){\n        this.run=false;\n    }\n \n    @Override\n    public void run()\n    {\n        while(run){\n                System.out.println(\n                    String.format("[monitor] [%d/%d] Active: %d, Completed: %d, Task: %d, isShutdown: %s, isTerminated: %s",\n                        this.executor.getPoolSize(),\n                        this.executor.getCorePoolSize(),\n                        this.executor.getActiveCount(),\n                        this.executor.getCompletedTaskCount(),\n                        this.executor.getTaskCount(),\n                        this.executor.isShutdown(),\n                        this.executor.isTerminated()));\n                try {\n                    Thread.sleep(seconds*1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n        }\n             \n    }\n}\n\n\n这里是使用 ThreadPoolExecutor 的线程池实现例子。\n\n * WorkerPool.java\n\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n \npublic class WorkerPool {\n \n    public static void main(String args[]) throws InterruptedException{\n        //RejectedExecutionHandler implementation\n        RejectedExecutionHandlerImpl rejectionHandler = new RejectedExecutionHandlerImpl();\n        //Get the ThreadFactory implementation to use\n        ThreadFactory threadFactory = Executors.defaultThreadFactory();\n        //creating the ThreadPoolExecutor\n        ThreadPoolExecutor executorPool = new ThreadPoolExecutor(2, 4, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(2), threadFactory, rejectionHandler);\n        //start the monitoring thread\n        MyMonitorThread monitor = new MyMonitorThread(executorPool, 3);\n        Thread monitorThread = new Thread(monitor);\n        monitorThread.start();\n        //submit work to the thread pool\n        for(int i=0; i<10; i++){\n            executorPool.execute(new WorkerThread("cmd"+i));\n        }\n         \n        Thread.sleep(30000);\n        //shut down the pool\n        executorPool.shutdown();\n        //shut down the monitor thread\n        Thread.sleep(5000);\n        monitor.shutdown();\n         \n    }\n}\n\n\n注意在初始化 ThreadPoolExecutor 时，我们保持初始池大小为 2，最大池大小为 4 而工作队列大小为 2。因此如果已经有四个正在执行的任务而此时分配来更多任务的话，工作队列将仅仅保留他们(新任务)中的两个，其他的将会被 RejectedExecutionHandlerImpl 处理。\n\n上面程序的输出可以证实以上观点。\n\npool-1-thread-1 Start. Command = cmd0\npool-1-thread-4 Start. Command = cmd5\ncmd6 is rejected\npool-1-thread-3 Start. Command = cmd4\npool-1-thread-2 Start. Command = cmd1\ncmd7 is rejected\ncmd8 is rejected\ncmd9 is rejected\n[monitor] [0/2] Active: 4, Completed: 0, Task: 6, isShutdown: false, isTerminated: false\n[monitor] [4/2] Active: 4, Completed: 0, Task: 6, isShutdown: false, isTerminated: false\npool-1-thread-4 End.\npool-1-thread-1 End.\npool-1-thread-2 End.\npool-1-thread-3 End.\npool-1-thread-1 Start. Command = cmd3\npool-1-thread-4 Start. Command = cmd2\n[monitor] [4/2] Active: 2, Completed: 4, Task: 6, isShutdown: false, isTerminated: false\n[monitor] [4/2] Active: 2, Completed: 4, Task: 6, isShutdown: false, isTerminated: false\npool-1-thread-1 End.\npool-1-thread-4 End.\n[monitor] [4/2] Active: 0, Completed: 6, Task: 6, isShutdown: false, isTerminated: false\n[monitor] [2/2] Active: 0, Completed: 6, Task: 6, isShutdown: false, isTerminated: false\n[monitor] [2/2] Active: 0, Completed: 6, Task: 6, isShutdown: false, isTerminated: false\n[monitor] [2/2] Active: 0, Completed: 6, Task: 6, isShutdown: false, isTerminated: false\n[monitor] [2/2] Active: 0, Completed: 6, Task: 6, isShutdown: false, isTerminated: false\n[monitor] [2/2] Active: 0, Completed: 6, Task: 6, isShutdown: false, isTerminated: false\n[monitor] [0/2] Active: 0, Completed: 6, Task: 6, isShutdown: true, isTerminated: true\n[monitor] [0/2] Active: 0, Completed: 6, Task: 6, isShutdown: true, isTerminated: true\n\n\n注意 executor 的活动任务、完成任务以及所有完成任务，这些数量上的变化。我们可以调用 shutdown() 方法来结束所有提交的任务并终止线程池。\n\n\n# ThreadPoolExecutor使用详解\n\n其实java线程池的实现原理很简单，说白了就是一个线程集合workerSet和一个阻塞队列workQueue。当用户向线程池提交一个任务(也就是线程)时，线程池会先将任务放入workQueue中。workerSet中的线程会不断的从workQueue中获取线程然后执行。当workQueue中没有任务的时候，worker就会阻塞，直到队列中有任务了就取出来继续执行。\n\n\n\n\n# Execute原理\n\n当一个任务提交至线程池之后:\n\n 1. 线程池首先当前运行的线程数量是否少于corePoolSize。如果是，则创建一个新的工作线程来执行任务。如果都在执行任务，则进入2.\n 2. 判断BlockingQueue是否已经满了，倘若还没有满，则将线程放入BlockingQueue。否则进入3.\n 3. 如果创建一个新的工作线程将使当前运行的线程数量超过maximumPoolSize，则交给RejectedExecutionHandler来处理任务。\n\n当ThreadPoolExecutor创建新线程时，通过CAS来更新线程池的状态ctl.\n\n\n# 参数\n\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              RejectedExecutionHandler handler)\n\n\n * corePoolSize 线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize, 即使有其他空闲线程能够执行新来的任务, 也会继续创建线程；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。\n\n * workQueue 用来保存等待被执行的任务的阻塞队列. 在JDK中提供了如下阻塞队列: 具体可以参考JUC 集合: BlockQueue详解\n   \n   * ArrayBlockingQueue: 基于数组结构的有界阻塞队列，按FIFO排序任务；\n   * LinkedBlockingQueue: 基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQueue；\n   * SynchronousQueue: 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue；\n   * PriorityBlockingQueue: 具有优先级的无界阻塞队列；\n\nLinkedBlockingQueue比ArrayBlockingQueue在插入删除节点性能方面更优，但是二者在put(), take()任务的时均需要加锁，SynchronousQueue使用无锁算法，根据节点的状态判断执行，而不需要用到锁，其核心是Transfer.transfer().\n\n * maximumPoolSize 线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize；当阻塞队列是无界队列, 则maximumPoolSize则不起作用, 因为无法提交至核心线程池的线程会一直持续地放入workQueue.\n\n * keepAliveTime 线程空闲时的存活时间，即当线程没有任务执行时，该线程继续存活的时间；默认情况下，该参数只在线程数大于corePoolSize时才有用, 超过这个时间的空闲线程将被终止；\n\n * unit keepAliveTime的单位\n\n * threadFactory 创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名。默认为DefaultThreadFactory\n\n * handler 线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略:\n   \n   * AbortPolicy: 直接抛出异常，默认策略；\n   * CallerRunsPolicy: 用调用者所在的线程来执行任务；\n   * DiscardOldestPolicy: 丢弃阻塞队列中靠最前的任务，并执行当前任务；\n   * DiscardPolicy: 直接丢弃任务；\n\n当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。\n\n\n# 三种类型\n\n# newFixedThreadPool\n\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue<Runnable>());\n}\n\n\n线程池的线程数量达corePoolSize后，即使线程池没有可执行任务时，也不会释放线程。\n\nFixedThreadPool的工作队列为无界队列LinkedBlockingQueue(队列容量为Integer.MAX_VALUE), 这会导致以下问题:\n\n * 线程池里的线程数量不超过corePoolSize,这导致了maximumPoolSize和keepAliveTime将会是个无用参数\n * 由于使用了无界队列, 所以FixedThreadPool永远不会拒绝, 即饱和策略失效\n\n# newSingleThreadExecutor\n\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue<Runnable>()));\n}\n\n\n初始化的线程池中只有一个线程，如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行.\n\n由于使用了无界队列, 所以SingleThreadPool永远不会拒绝, 即饱和策略失效\n\n# newCachedThreadPool\n\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                    60L, TimeUnit.SECONDS,\n                                    new SynchronousQueue<Runnable>());\n}\n\n\n线程池的线程数可达到Integer.MAX_VALUE，即2147483647，内部使用SynchronousQueue作为阻塞队列； 和newFixedThreadPool创建的线程池不同，newCachedThreadPool在没有任务执行时，当线程的空闲时间超过keepAliveTime，会自动释放线程资源，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销； 执行过程与前两种稍微不同:\n\n * 主线程调用SynchronousQueue的offer()方法放入task, 倘若此时线程池中有空闲的线程尝试读取 SynchronousQueue的task, 即调用了SynchronousQueue的poll(), 那么主线程将该task交给空闲线程. 否则执行(2)\n * 当线程池为空或者没有空闲的线程, 则创建新的线程执行任务.\n * 执行完任务的线程倘若在60s内仍空闲, 则会被终止. 因此长时间空闲的CachedThreadPool不会持有任何线程资源.\n\n\n# 关闭线程池\n\n遍历线程池中的所有线程，然后逐个调用线程的interrupt方法来中断线程.\n\n# 关闭方式 - shutdown\n\n将线程池里的线程状态设置成SHUTDOWN状态, 然后中断所有没有正在执行任务的线程.\n\n# 关闭方式 - shutdownNow\n\n将线程池里的线程状态设置成STOP状态, 然后停止所有正在执行或暂停任务的线程. 只要调用这两个关闭方法中的任意一个, isShutDown() 返回true. 当所有任务都成功关闭了, isTerminated()返回true.\n\n\n# ThreadPoolExecutor源码详解\n\n\n# 几个关键属性\n\n//这个属性是用来存放 当前运行的worker数量以及线程池状态的\n//int是32位的，这里把int的高3位拿来充当线程池状态的标志位,后29位拿来充当当前运行worker的数量\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n//存放任务的阻塞队列\nprivate final BlockingQueue<Runnable> workQueue;\n//worker的集合,用set来存放\nprivate final HashSet<Worker> workers = new HashSet<Worker>();\n//历史达到的worker数最大值\nprivate int largestPoolSize;\n//当队列满了并且worker的数量达到maxSize的时候,执行具体的拒绝策略\nprivate volatile RejectedExecutionHandler handler;\n//超出coreSize的worker的生存时间\nprivate volatile long keepAliveTime;\n//常驻worker的数量\nprivate volatile int corePoolSize;\n//最大worker的数量,一般当workQueue满了才会用到这个参数\nprivate volatile int maximumPoolSize;\n\n\n\n# 内部状态\n\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\nprivate static final int COUNT_BITS = Integer.SIZE - 3;\nprivate static final int CAPACITY   = (1 << COUNT_BITS) - 1;\n\n// runState is stored in the high-order bits\nprivate static final int RUNNING    = -1 << COUNT_BITS;\nprivate static final int SHUTDOWN   =  0 << COUNT_BITS;\nprivate static final int STOP       =  1 << COUNT_BITS;\nprivate static final int TIDYING    =  2 << COUNT_BITS;\nprivate static final int TERMINATED =  3 << COUNT_BITS;\n\n// Packing and unpacking ctl\nprivate static int runStateOf(int c)     { return c & ~CAPACITY; }\nprivate static int workerCountOf(int c)  { return c & CAPACITY; }\nprivate static int ctlOf(int rs, int wc) { return rs | wc; }\n\n\n其中AtomicInteger变量ctl的功能非常强大: 利用低29位表示线程池中线程数，通过高3位表示线程池的运行状态:\n\n * RUNNING: -1 << COUNT_BITS，即高3位为111，该状态的线程池会接收新任务，并处理阻塞队列中的任务；\n * SHUTDOWN: 0 << COUNT_BITS，即高3位为000，该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；\n * STOP : 1 << COUNT_BITS，即高3位为001，该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；\n * TIDYING : 2 << COUNT_BITS，即高3位为010, 所有的任务都已经终止；\n * TERMINATED: 3 << COUNT_BITS，即高3位为011, terminated()方法已经执行完成\n\n\n\n\n# 任务的执行\n\n> execute –> addWorker –>runworker (getTask)\n\n线程池的工作线程通过Woker类实现，在ReentrantLock锁的保证下，把Woker实例插入到HashSet后，并启动Woker中的线程。 从Woker类的构造方法实现可以发现: 线程工厂在创建线程thread时，将Woker实例本身this作为参数传入，当执行start方法启动线程thread时，本质是执行了Worker的runWorker方法。 firstTask执行完成之后，通过getTask方法从阻塞队列中获取等待的任务，如果队列中没有任务，getTask方法会被阻塞并挂起，不会占用cpu资源；\n\n# execute()方法\n\nThreadPoolExecutor.execute(task)实现了Executor.execute(task)\n\npublic void execute(Runnable command) {\n    if (command == null)\n        throw new NullPointerException();\n    /*\n     * Proceed in 3 steps:\n     *\n     * 1. If fewer than corePoolSize threads are running, try to\n     * start a new thread with the given command as its first\n     * task.  The call to addWorker atomically checks runState and\n     * workerCount, and so prevents false alarms that would add\n     * threads when it shouldn\'t, by returning false.\n     *\n     * 2. If a task can be successfully queued, then we still need\n     * to double-check whether we should have added a thread\n     * (because existing ones died since last checking) or that\n     * the pool shut down since entry into this method. So we\n     * recheck state and if necessary roll back the enqueuing if\n     * stopped, or start a new thread if there are none.\n     *\n     * 3. If we cannot queue task, then we try to add a new\n     * thread.  If it fails, we know we are shut down or saturated\n     * and so reject the task.\n     */\n    int c = ctl.get();\n    if (workerCountOf(c) < corePoolSize) {  \n    //workerCountOf获取线程池的当前线程数；小于corePoolSize，执行addWorker创建新线程执行command任务\n       if (addWorker(command, true))\n            return;\n        c = ctl.get();\n    }\n    // double check: c, recheck\n    // 线程池处于RUNNING状态，把提交的任务成功放入阻塞队列中\n    if (isRunning(c) && workQueue.offer(command)) {\n        int recheck = ctl.get();\n        // recheck and if necessary 回滚到入队操作前，即倘若线程池shutdown状态，就remove(command)\n        //如果线程池没有RUNNING，成功从阻塞队列中删除任务，执行reject方法处理任务\n        if (! isRunning(recheck) && remove(command))\n            reject(command);\n        //线程池处于running状态，但是没有线程，则创建线程\n        else if (workerCountOf(recheck) == 0)\n            addWorker(null, false);\n    }\n    // 往线程池中创建新的线程失败，则reject任务\n    else if (!addWorker(command, false))\n        reject(command);\n}\n\n\n * 为什么需要double check线程池的状态?\n\n在多线程环境下，线程池的状态时刻在变化，而ctl.get()是非原子操作，很有可能刚获取了线程池状态后线程池状态就改变了。判断是否将command加入workque是线程池之前的状态。倘若没有double check，万一线程池处于非running状态(在多线程环境下很有可能发生)，那么command永远不会执行。\n\n# addWorker方法\n\n从方法execute的实现可以看出: addWorker主要负责创建新的线程并执行任务 线程池创建新线程执行任务时，需要 获取全局锁:\n\nprivate final ReentrantLock mainLock = new ReentrantLock();\n\n\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    // CAS更新线程池数量\n    retry:\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // Check if queue empty only if necessary.\n        if (rs >= SHUTDOWN &&\n            ! (rs == SHUTDOWN &&\n                firstTask == null &&\n                ! workQueue.isEmpty()))\n            return false;\n\n        for (;;) {\n            int wc = workerCountOf(c);\n            if (wc >= CAPACITY ||\n                wc >= (core ? corePoolSize : maximumPoolSize))\n                return false;\n            if (compareAndIncrementWorkerCount(c))\n                break retry;\n            c = ctl.get();  // Re-read ctl\n            if (runStateOf(c) != rs)\n                continue retry;\n            // else CAS failed due to workerCount change; retry inner loop\n        }\n    }\n\n    boolean workerStarted = false;\n    boolean workerAdded = false;\n    Worker w = null;\n    try {\n        w = new Worker(firstTask);\n        final Thread t = w.thread;\n        if (t != null) {\n            // 线程池重入锁\n            final ReentrantLock mainLock = this.mainLock;\n            mainLock.lock();\n            try {\n                // Recheck while holding lock.\n                // Back out on ThreadFactory failure or if\n                // shut down before lock acquired.\n                int rs = runStateOf(ctl.get());\n\n                if (rs < SHUTDOWN ||\n                    (rs == SHUTDOWN && firstTask == null)) {\n                    if (t.isAlive()) // precheck that t is startable\n                        throw new IllegalThreadStateException();\n                    workers.add(w);\n                    int s = workers.size();\n                    if (s > largestPoolSize)\n                        largestPoolSize = s;\n                    workerAdded = true;\n                }\n            } finally {\n                mainLock.unlock();\n            }\n            if (workerAdded) {\n                t.start();  // 线程启动，执行任务(Worker.thread(firstTask).start());\n                workerStarted = true;\n            }\n        }\n    } finally {\n        if (! workerStarted)\n            addWorkerFailed(w);\n    }\n    return workerStarted;\n}\n\n\n# Worker类的runworker方法\n\n private final class Worker extends AbstractQueuedSynchronizer implements Runnable{\n     Worker(Runnable firstTask) {\n         setState(-1); // inhibit interrupts until runWorker\n         this.firstTask = firstTask;\n         this.thread = getThreadFactory().newThread(this); // 创建线程\n     }\n     /** Delegates main run loop to outer runWorker  */\n     public void run() {\n         runWorker(this);\n     }\n     // ...\n }\n\n\n * 继承了AQS类，可以方便的实现工作线程的中止操作；\n * 实现了Runnable接口，可以将自身作为一个任务在工作线程中执行；\n * 当前提交的任务firstTask作为参数传入Worker的构造方法；\n\n一些属性还有构造方法:\n\n//运行的线程,前面addWorker方法中就是直接通过启动这个线程来启动这个worker\nfinal Thread thread;\n//当一个worker刚创建的时候,就先尝试执行这个任务\nRunnable firstTask;\n//记录完成任务的数量\nvolatile long completedTasks;\n\nWorker(Runnable firstTask) {\n    setState(-1); // inhibit interrupts until runWorker\n    this.firstTask = firstTask;\n    //创建一个Thread,将自己设置给他,后面这个thread启动的时候,也就是执行worker的run方法\n    this.thread = getThreadFactory().newThread(this);\n}   \n\n\nrunWorker方法是线程池的核心:\n\n * 线程启动之后，通过unlock方法释放锁，设置AQS的state为0，表示运行可中断；\n * Worker执行firstTask或从workQueue中获取任务:\n   * 进行加锁操作，保证thread不被其他线程中断(除非线程池被中断)\n   * 检查线程池状态，倘若线程池处于中断状态，当前线程将中断。\n   * 执行beforeExecute\n   * 执行任务的run方法\n   * 执行afterExecute方法\n   * 解锁操作\n\n> 通过getTask方法从阻塞队列中获取等待的任务，如果队列中没有任务，getTask方法会被阻塞并挂起，不会占用cpu资源；\n\nfinal void runWorker(Worker w) {\n    Thread wt = Thread.currentThread();\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    w.unlock(); // allow interrupts\n    boolean completedAbruptly = true;\n    try {\n        // 先执行firstTask，再从workerQueue中取task(getTask())\n\n        while (task != null || (task = getTask()) != null) {\n            w.lock();\n            // If pool is stopping, ensure thread is interrupted;\n            // if not, ensure thread is not interrupted.  This\n            // requires a recheck in second case to deal with\n            // shutdownNow race while clearing interrupt\n            if ((runStateAtLeast(ctl.get(), STOP) ||\n                    (Thread.interrupted() &&\n                    runStateAtLeast(ctl.get(), STOP))) &&\n                !wt.isInterrupted())\n                wt.interrupt();\n            try {\n                beforeExecute(wt, task);\n                Throwable thrown = null;\n                try {\n                    task.run();\n                } catch (RuntimeException x) {\n                    thrown = x; throw x;\n                } catch (Error x) {\n                    thrown = x; throw x;\n                } catch (Throwable x) {\n                    thrown = x; throw new Error(x);\n                } finally {\n                    afterExecute(task, thrown);\n                }\n            } finally {\n                task = null;\n                w.completedTasks++;\n                w.unlock();\n            }\n        }\n        completedAbruptly = false;\n    } finally {\n        processWorkerExit(w, completedAbruptly);\n    }\n}\n\n\n# getTask方法\n\n下面来看一下getTask()方法，这里面涉及到keepAliveTime的使用，从这个方法我们可以看出线程池是怎么让超过corePoolSize的那部分worker销毁的。\n\nprivate Runnable getTask() {\n    boolean timedOut = false; // Did the last poll() time out?\n\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // Check if queue empty only if necessary.\n        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {\n            decrementWorkerCount();\n            return null;\n        }\n\n        int wc = workerCountOf(c);\n\n        // Are workers subject to culling?\n        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\n\n        if ((wc > maximumPoolSize || (timed && timedOut))\n            && (wc > 1 || workQueue.isEmpty())) {\n            if (compareAndDecrementWorkerCount(c))\n                return null;\n            continue;\n        }\n\n        try {\n            Runnable r = timed ?\n                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                workQueue.take();\n            if (r != null)\n                return r;\n            timedOut = true;\n        } catch (InterruptedException retry) {\n            timedOut = false;\n        }\n    }\n}\n\n\n注意这里一段代码是keepAliveTime起作用的关键:\n\nboolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\nRunnable r = timed ?\n                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                workQueue.take();\n\n\nallowCoreThreadTimeOut为false，线程即使空闲也不会被销毁；倘若为ture，在keepAliveTime内仍空闲则会被销毁。\n\n如果线程允许空闲等待而不被销毁timed == false，workQueue.take任务: 如果阻塞队列为空，当前线程会被挂起等待；当队列中有任务加入时，线程被唤醒，take方法返回任务，并执行；\n\n如果线程不允许无休止空闲timed == true, workQueue.poll任务: 如果在keepAliveTime时间内，阻塞队列还是没有任务，则返回null；\n\n\n# 任务的提交\n\n\n\n 1. submit任务，等待线程池execute\n 2. 执行FutureTask类的get方法时，会把主线程封装成WaitNode节点并保存在waiters链表中， 并阻塞等待运行结果；\n 3. FutureTask任务执行完成后，通过UNSAFE设置waiters相应的waitNode为null，并通过LockSupport类unpark方法唤醒主线程；\n\npublic class Test{\n    public static void main(String[] args) {\n\n        ExecutorService es = Executors.newCachedThreadPool();\n        Future<String> future = es.submit(new Callable<String>() {\n            @Override\n            public String call() throws Exception {\n                try {\n                    TimeUnit.SECONDS.sleep(2);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                return "future result";\n            }\n        });\n        try {\n            String result = future.get();\n            System.out.println(result);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\n在实际业务场景中，Future和Callable基本是成对出现的，Callable负责产生结果，Future负责获取结果。\n\n 1. Callable接口类似于Runnable，只是Runnable没有返回值。\n 2. Callable任务除了返回正常结果之外，如果发生异常，该异常也会被返回，即Future可以拿到异步执行任务各种结果；\n 3. Future.get方法会导致主线程阻塞，直到Callable任务执行完成；\n\n# submit方法\n\nAbstractExecutorService.submit()实现了ExecutorService.submit() 可以获取执行完的返回值, 而ThreadPoolExecutor 是AbstractExecutorService.submit()的子类，所以submit方法也是ThreadPoolExecutor`的方法。\n\n// submit()在ExecutorService中的定义\n<T> Future<T> submit(Callable<T> task);\n\n<T> Future<T> submit(Runnable task, T result);\n\nFuture<?> submit(Runnable task);\n\n\n// submit方法在AbstractExecutorService中的实现\npublic Future<?> submit(Runnable task) {\n    if (task == null) throw new NullPointerException();\n    // 通过submit方法提交的Callable任务会被封装成了一个FutureTask对象。\n    RunnableFuture<Void> ftask = newTaskFor(task, null);\n    execute(ftask);\n    return ftask;\n}\n\n\n通过submit方法提交的Callable任务会被封装成了一个FutureTask对象。通过Executor.execute方法提交FutureTask到线程池中等待被执行，最终执行的是FutureTask的run方法；\n\n# FutureTask对象\n\npublic class FutureTask<V> implements RunnableFuture<V> 可以将FutureTask提交至线程池中等待被执行(通过FutureTask的run方法来执行)\n\n * 内部状态\n\n/* The run state of this task, initially NEW. \n    * ...\n    * Possible state transitions:\n    * NEW -> COMPLETING -> NORMAL\n    * NEW -> COMPLETING -> EXCEPTIONAL\n    * NEW -> CANCELLED\n    * NEW -> INTERRUPTING -> INTERRUPTED\n    */\nprivate volatile int state;\nprivate static final int NEW          = 0;\nprivate static final int COMPLETING   = 1;\nprivate static final int NORMAL       = 2;\nprivate static final int EXCEPTIONAL  = 3;\nprivate static final int CANCELLED    = 4;\nprivate static final int INTERRUPTING = 5;\nprivate static final int INTERRUPTED  = 6;\n\n\n内部状态的修改通过sun.misc.Unsafe修改\n\n * get方法\n\npublic V get() throws InterruptedException, ExecutionException {\n    int s = state;\n    if (s <= COMPLETING)\n        s = awaitDone(false, 0L);\n    return report(s);\n} \n\n\n内部通过awaitDone方法对主线程进行阻塞，具体实现如下:\n\nprivate int awaitDone(boolean timed, long nanos)\n    throws InterruptedException {\n    final long deadline = timed ? System.nanoTime() + nanos : 0L;\n    WaitNode q = null;\n    boolean queued = false;\n    for (;;) {\n        if (Thread.interrupted()) {\n            removeWaiter(q);\n            throw new InterruptedException();\n        }\n\n        int s = state;\n        if (s > COMPLETING) {\n            if (q != null)\n                q.thread = null;\n            return s;\n        }\n        else if (s == COMPLETING) // cannot time out yet\n            Thread.yield();\n        else if (q == null)\n            q = new WaitNode();\n        else if (!queued)\n            queued = UNSAFE.compareAndSwapObject(this, waitersOffset,q.next = waiters, q);\n        else if (timed) {\n            nanos = deadline - System.nanoTime();\n            if (nanos <= 0L) {\n                removeWaiter(q);\n                return state;\n            }\n            LockSupport.parkNanos(this, nanos);\n        }\n        else\n            LockSupport.park(this);\n    }\n}\n\n\n 1. 如果主线程被中断，则抛出中断异常；\n 2. 判断FutureTask当前的state，如果大于COMPLETING，说明任务已经执行完成，则直接返回；\n 3. 如果当前state等于COMPLETING，说明任务已经执行完，这时主线程只需通过yield方法让出cpu资源，等待state变成NORMAL；\n 4. 通过WaitNode类封装当前线程，并通过UNSAFE添加到waiters链表；\n 5. 最终通过LockSupport的park或parkNanos挂起线程；\n\nrun方法\n\npublic void run() {\n    if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread()))\n        return;\n    try {\n        Callable<V> c = callable;\n        if (c != null && state == NEW) {\n            V result;\n            boolean ran;\n            try {\n                result = c.call();\n                ran = true;\n            } catch (Throwable ex) {\n                result = null;\n                ran = false;\n                setException(ex);\n            }\n            if (ran)\n                set(result);\n        }\n    } finally {\n        // runner must be non-null until state is settled to\n        // prevent concurrent calls to run()\n        runner = null;\n        // state must be re-read after nulling runner to prevent\n        // leaked interrupts\n        int s = state;\n        if (s >= INTERRUPTING)\n            handlePossibleCancellationInterrupt(s);\n    }\n}\n\n\nFutureTask.run方法是在线程池中被执行的，而非主线程\n\n 1. 通过执行Callable任务的call方法；\n 2. 如果call执行成功，则通过set方法保存结果；\n 3. 如果call执行有异常，则通过setException保存异常；\n\n\n# 任务的关闭\n\nshutdown方法会将线程池的状态设置为SHUTDOWN,线程池进入这个状态后,就拒绝再接受任务,然后会将剩余的任务全部执行完\n\npublic void shutdown() {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        //检查是否可以关闭线程\n        checkShutdownAccess();\n        //设置线程池状态\n        advanceRunState(SHUTDOWN);\n        //尝试中断worker\n        interruptIdleWorkers();\n            //预留方法,留给子类实现\n        onShutdown(); // hook for ScheduledThreadPoolExecutor\n    } finally {\n        mainLock.unlock();\n    }\n    tryTerminate();\n}\n\nprivate void interruptIdleWorkers() {\n    interruptIdleWorkers(false);\n}\n\nprivate void interruptIdleWorkers(boolean onlyOne) {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        //遍历所有的worker\n        for (Worker w : workers) {\n            Thread t = w.thread;\n            //先尝试调用w.tryLock(),如果获取到锁,就说明worker是空闲的,就可以直接中断它\n            //注意的是,worker自己本身实现了AQS同步框架,然后实现的类似锁的功能\n            //它实现的锁是不可重入的,所以如果worker在执行任务的时候,会先进行加锁,这里tryLock()就会返回false\n            if (!t.isInterrupted() && w.tryLock()) {\n                try {\n                    t.interrupt();\n                } catch (SecurityException ignore) {\n                } finally {\n                    w.unlock();\n                }\n            }\n            if (onlyOne)\n                break;\n        }\n    } finally {\n        mainLock.unlock();\n    }\n}\n\n\nshutdownNow做的比较绝，它先将线程池状态设置为STOP，然后拒绝所有提交的任务。最后中断左右正在运行中的worker,然后清空任务队列。\n\npublic List<Runnable> shutdownNow() {\n    List<Runnable> tasks;\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        checkShutdownAccess();\n        //检测权限\n        advanceRunState(STOP);\n        //中断所有的worker\n        interruptWorkers();\n        //清空任务队列\n        tasks = drainQueue();\n    } finally {\n        mainLock.unlock();\n    }\n    tryTerminate();\n    return tasks;\n}\n\nprivate void interruptWorkers() {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        //遍历所有worker，然后调用中断方法\n        for (Worker w : workers)\n            w.interruptIfStarted();\n    } finally {\n        mainLock.unlock();\n    }\n}\n\n\n\n# 更深入理解\n\n\n# 为什么线程池不允许使用Executors去创建? 推荐方式是什么?\n\n线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors各个方法的弊端：\n\n * newFixedThreadPool和newSingleThreadExecutor:   主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。\n * newCachedThreadPool和newScheduledThreadPool:   主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。\n\n# 推荐方式 1\n\n首先引入：commons-lang3包\n\nScheduledExecutorService executorService = new ScheduledThreadPoolExecutor(1,\n        new BasicThreadFactory.Builder().namingPattern("example-schedule-pool-%d").daemon(true).build());\n\n\n# 推荐方式 2\n\n首先引入：com.google.guava包\n\nThreadFactory namedThreadFactory = new ThreadFactoryBuilder().setNameFormat("demo-pool-%d").build();\n\n//Common Thread Pool\nExecutorService pool = new ThreadPoolExecutor(5, 200, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());\n\n// excute\npool.execute(()-> System.out.println(Thread.currentThread().getName()));\n\n //gracefully shutdown\npool.shutdown();\n\n\n# 推荐方式 3\n\nspring配置线程池方式：自定义线程工厂bean需要实现ThreadFactory，可参考该接口的其它默认实现类，使用方式直接注入bean调用execute(Runnable task)方法即可\n\n    <bean id="userThreadPool" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor">\n        <property name="corePoolSize" value="10" />\n        <property name="maxPoolSize" value="100" />\n        <property name="queueCapacity" value="2000" />\n\n    <property name="threadFactory" value= threadFactory />\n        <property name="rejectedExecutionHandler">\n            <ref local="rejectedExecutionHandler" />\n        </property>\n    </bean>\n    \n    //in code\n    userThreadPool.execute(thread);\n\n\n\n# 配置线程池需要考虑因素\n\n从任务的优先级，任务的执行时间长短，任务的性质(CPU密集/ IO密集)，任务的依赖关系这四个角度来分析。并且近可能地使用有界的工作队列。\n\n性质不同的任务可用使用不同规模的线程池分开处理:\n\n * CPU密集型: 尽可能少的线程，Ncpu+1\n * IO密集型: 尽可能多的线程, Ncpu*2，比如数据库连接池\n * 混合型: CPU密集型的任务与IO密集型任务的执行时间差别较小，拆分为两个线程池；否则没有必要拆分。\n\n\n# 监控线程池的状态\n\n可以使用ThreadPoolExecutor以下方法:\n\n * getTaskCount() Returns the approximate total number of tasks that have ever been scheduled for execution.\n * getCompletedTaskCount() Returns the approximate total number of tasks that have completed execution. 返回结果少于getTaskCount()。\n * getLargestPoolSize() Returns the largest number of threads that have ever simultaneously been in the pool. 返回结果小于等于maximumPoolSize\n * getPoolSize() Returns the current number of threads in the pool.\n * getActiveCount() Returns the approximate number of threads that are actively executing tasks.\n\n\n# 参考文章\n\n * 《Java并发编程艺术》\n * https://www.jianshu.com/p/87bff5cc8d8c\n * https://blog.csdn.net/programmer_at/article/details/79799267\n * https://blog.csdn.net/u013332124/article/details/79587436\n * https://www.journaldev.com/1069/threadpoolexecutor-java-thread-pool-example-executorservice\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-executor-ThreadPoolExecutor.html',normalizedContent:'# juc线程池: threadpoolexecutor详解\n\n> 本文主要对threadpoolexecutor详解。\n\n * juc线程池: threadpoolexecutor详解\n   * 带着bat大厂的面试问题去理解\n   * 为什么要有线程池\n   * threadpoolexecutor例子\n   * threadpoolexecutor使用详解\n     * execute原理\n     * 参数\n     * 三种类型\n       * newfixedthreadpool\n       * newsinglethreadexecutor\n       * newcachedthreadpool\n     * 关闭线程池\n       * 关闭方式 - shutdown\n       * 关闭方式 - shutdownnow\n   * threadpoolexecutor源码详解\n     * 几个关键属性\n     * 内部状态\n     * 任务的执行\n       * execute()方法\n       * addworker方法\n       * worker类的runworker方法\n       * gettask方法\n     * 任务的提交\n       * submit方法\n       * futuretask对象\n     * 任务的关闭\n   * 更深入理解\n     * 为什么线程池不允许使用executors去创建? 推荐方式是什么?\n       * 推荐方式 1\n       * 推荐方式 2\n       * 推荐方式 3\n     * 配置线程池需要考虑因素\n     * 监控线程池的状态\n   * 参考文章\n\n\n# 带着bat大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 为什么要有线程池?\n * java是实现和管理线程池有哪些方式? 请简单举例如何使用。\n * 为什么很多公司不允许使用executors去创建线程池? 那么推荐怎么使用呢?\n * threadpoolexecutor有哪些核心的配置参数? 请简要说明\n * threadpoolexecutor可以创建哪是哪三种线程池呢?\n * 当队列满了并且worker的数量达到maxsize的时候，会怎么样?\n * 说说threadpoolexecutor有哪些rejectedexecutionhandler策略? 默认是什么策略?\n * 简要说下线程池的任务执行机制? execute –> addworker –>runworker (gettask)\n * 线程池中任务是如何提交的?\n * 线程池中任务是如何关闭的?\n * 在配置线程池的时候需要考虑哪些配置因素?\n * 如何监控线程池的状态?\n\n\n# 为什么要有线程池\n\n线程池能够对线程进行统一分配，调优和监控:\n\n * 降低资源消耗(线程无限制地创建，然后使用完毕后销毁)\n * 提高响应速度(无须创建线程)\n * 提高线程的可管理性\n\n\n# threadpoolexecutor例子\n\njava是如何实现和管理线程池的?\n\n从jdk 5开始，把工作单元与执行机制分离开来，工作单元包括runnable和callable，而执行机制由executor框架提供。\n\n * workerthread\n\npublic class workerthread implements runnable {\n     \n    private string command;\n     \n    public workerthread(string s){\n        this.command=s;\n    }\n \n    @override\n    public void run() {\n        system.out.println(thread.currentthread().getname()+" start. command = "+command);\n        processcommand();\n        system.out.println(thread.currentthread().getname()+" end.");\n    }\n \n    private void processcommand() {\n        try {\n            thread.sleep(5000);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n    }\n \n    @override\n    public string tostring(){\n        return this.command;\n    }\n}\n\n\n * simplethreadpool\n\nimport java.util.concurrent.executorservice;\nimport java.util.concurrent.executors;\n \npublic class simplethreadpool {\n \n    public static void main(string[] args) {\n        executorservice executor = executors.newfixedthreadpool(5);\n        for (int i = 0; i < 10; i++) {\n            runnable worker = new workerthread("" + i);\n            executor.execute(worker);\n          }\n        executor.shutdown(); // this will make the executor accept no new threads and finish all existing threads in the queue\n        while (!executor.isterminated()) { // wait until all threads are finish,and also you can use "executor.awaittermination();" to wait\n        }\n        system.out.println("finished all threads");\n    }\n\n}\n\n\n程序中我们创建了固定大小为五个工作线程的线程池。然后分配给线程池十个工作，因为线程池大小为五，它将启动五个工作线程先处理五个工作，其他的工作则处于等待状态，一旦有工作完成，空闲下来工作线程就会捡取等待队列里的其他工作进行执行。\n\n这里是以上程序的输出。\n\npool-1-thread-2 start. command = 1\npool-1-thread-4 start. command = 3\npool-1-thread-1 start. command = 0\npool-1-thread-3 start. command = 2\npool-1-thread-5 start. command = 4\npool-1-thread-4 end.\npool-1-thread-5 end.\npool-1-thread-1 end.\npool-1-thread-3 end.\npool-1-thread-3 start. command = 8\npool-1-thread-2 end.\npool-1-thread-2 start. command = 9\npool-1-thread-1 start. command = 7\npool-1-thread-5 start. command = 6\npool-1-thread-4 start. command = 5\npool-1-thread-2 end.\npool-1-thread-4 end.\npool-1-thread-3 end.\npool-1-thread-5 end.\npool-1-thread-1 end.\nfinished all threads\n\n\n输出表明线程池中至始至终只有五个名为 "pool-1-thread-1" 到 "pool-1-thread-5" 的五个线程，这五个线程不随着工作的完成而消亡，会一直存在，并负责执行分配给线程池的任务，直到线程池消亡。\n\nexecutors 类提供了使用了 threadpoolexecutor 的简单的 executorservice 实现，但是 threadpoolexecutor 提供的功能远不止于此。我们可以在创建 threadpoolexecutor 实例时指定活动线程的数量，我们也可以限制线程池的大小并且创建我们自己的 rejectedexecutionhandler 实现来处理不能适应工作队列的工作。\n\n这里是我们自定义的 rejectedexecutionhandler 接口的实现。\n\n * rejectedexecutionhandlerimpl.java\n\nimport java.util.concurrent.rejectedexecutionhandler;\nimport java.util.concurrent.threadpoolexecutor;\n \npublic class rejectedexecutionhandlerimpl implements rejectedexecutionhandler {\n \n    @override\n    public void rejectedexecution(runnable r, threadpoolexecutor executor) {\n        system.out.println(r.tostring() + " is rejected");\n    }\n \n}\n\n\nthreadpoolexecutor 提供了一些方法，我们可以使用这些方法来查询 executor 的当前状态，线程池大小，活动线程数量以及任务数量。因此我是用来一个监控线程在特定的时间间隔内打印 executor 信息。\n\n * mymonitorthread.java\n\nimport java.util.concurrent.threadpoolexecutor;\n \npublic class mymonitorthread implements runnable\n{\n    private threadpoolexecutor executor;\n     \n    private int seconds;\n     \n    private boolean run=true;\n \n    public mymonitorthread(threadpoolexecutor executor, int delay)\n    {\n        this.executor = executor;\n        this.seconds=delay;\n    }\n     \n    public void shutdown(){\n        this.run=false;\n    }\n \n    @override\n    public void run()\n    {\n        while(run){\n                system.out.println(\n                    string.format("[monitor] [%d/%d] active: %d, completed: %d, task: %d, isshutdown: %s, isterminated: %s",\n                        this.executor.getpoolsize(),\n                        this.executor.getcorepoolsize(),\n                        this.executor.getactivecount(),\n                        this.executor.getcompletedtaskcount(),\n                        this.executor.gettaskcount(),\n                        this.executor.isshutdown(),\n                        this.executor.isterminated()));\n                try {\n                    thread.sleep(seconds*1000);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n        }\n             \n    }\n}\n\n\n这里是使用 threadpoolexecutor 的线程池实现例子。\n\n * workerpool.java\n\nimport java.util.concurrent.arrayblockingqueue;\nimport java.util.concurrent.executors;\nimport java.util.concurrent.threadfactory;\nimport java.util.concurrent.threadpoolexecutor;\nimport java.util.concurrent.timeunit;\n \npublic class workerpool {\n \n    public static void main(string args[]) throws interruptedexception{\n        //rejectedexecutionhandler implementation\n        rejectedexecutionhandlerimpl rejectionhandler = new rejectedexecutionhandlerimpl();\n        //get the threadfactory implementation to use\n        threadfactory threadfactory = executors.defaultthreadfactory();\n        //creating the threadpoolexecutor\n        threadpoolexecutor executorpool = new threadpoolexecutor(2, 4, 10, timeunit.seconds, new arrayblockingqueue<runnable>(2), threadfactory, rejectionhandler);\n        //start the monitoring thread\n        mymonitorthread monitor = new mymonitorthread(executorpool, 3);\n        thread monitorthread = new thread(monitor);\n        monitorthread.start();\n        //submit work to the thread pool\n        for(int i=0; i<10; i++){\n            executorpool.execute(new workerthread("cmd"+i));\n        }\n         \n        thread.sleep(30000);\n        //shut down the pool\n        executorpool.shutdown();\n        //shut down the monitor thread\n        thread.sleep(5000);\n        monitor.shutdown();\n         \n    }\n}\n\n\n注意在初始化 threadpoolexecutor 时，我们保持初始池大小为 2，最大池大小为 4 而工作队列大小为 2。因此如果已经有四个正在执行的任务而此时分配来更多任务的话，工作队列将仅仅保留他们(新任务)中的两个，其他的将会被 rejectedexecutionhandlerimpl 处理。\n\n上面程序的输出可以证实以上观点。\n\npool-1-thread-1 start. command = cmd0\npool-1-thread-4 start. command = cmd5\ncmd6 is rejected\npool-1-thread-3 start. command = cmd4\npool-1-thread-2 start. command = cmd1\ncmd7 is rejected\ncmd8 is rejected\ncmd9 is rejected\n[monitor] [0/2] active: 4, completed: 0, task: 6, isshutdown: false, isterminated: false\n[monitor] [4/2] active: 4, completed: 0, task: 6, isshutdown: false, isterminated: false\npool-1-thread-4 end.\npool-1-thread-1 end.\npool-1-thread-2 end.\npool-1-thread-3 end.\npool-1-thread-1 start. command = cmd3\npool-1-thread-4 start. command = cmd2\n[monitor] [4/2] active: 2, completed: 4, task: 6, isshutdown: false, isterminated: false\n[monitor] [4/2] active: 2, completed: 4, task: 6, isshutdown: false, isterminated: false\npool-1-thread-1 end.\npool-1-thread-4 end.\n[monitor] [4/2] active: 0, completed: 6, task: 6, isshutdown: false, isterminated: false\n[monitor] [2/2] active: 0, completed: 6, task: 6, isshutdown: false, isterminated: false\n[monitor] [2/2] active: 0, completed: 6, task: 6, isshutdown: false, isterminated: false\n[monitor] [2/2] active: 0, completed: 6, task: 6, isshutdown: false, isterminated: false\n[monitor] [2/2] active: 0, completed: 6, task: 6, isshutdown: false, isterminated: false\n[monitor] [2/2] active: 0, completed: 6, task: 6, isshutdown: false, isterminated: false\n[monitor] [0/2] active: 0, completed: 6, task: 6, isshutdown: true, isterminated: true\n[monitor] [0/2] active: 0, completed: 6, task: 6, isshutdown: true, isterminated: true\n\n\n注意 executor 的活动任务、完成任务以及所有完成任务，这些数量上的变化。我们可以调用 shutdown() 方法来结束所有提交的任务并终止线程池。\n\n\n# threadpoolexecutor使用详解\n\n其实java线程池的实现原理很简单，说白了就是一个线程集合workerset和一个阻塞队列workqueue。当用户向线程池提交一个任务(也就是线程)时，线程池会先将任务放入workqueue中。workerset中的线程会不断的从workqueue中获取线程然后执行。当workqueue中没有任务的时候，worker就会阻塞，直到队列中有任务了就取出来继续执行。\n\n\n\n\n# execute原理\n\n当一个任务提交至线程池之后:\n\n 1. 线程池首先当前运行的线程数量是否少于corepoolsize。如果是，则创建一个新的工作线程来执行任务。如果都在执行任务，则进入2.\n 2. 判断blockingqueue是否已经满了，倘若还没有满，则将线程放入blockingqueue。否则进入3.\n 3. 如果创建一个新的工作线程将使当前运行的线程数量超过maximumpoolsize，则交给rejectedexecutionhandler来处理任务。\n\n当threadpoolexecutor创建新线程时，通过cas来更新线程池的状态ctl.\n\n\n# 参数\n\npublic threadpoolexecutor(int corepoolsize,\n                              int maximumpoolsize,\n                              long keepalivetime,\n                              timeunit unit,\n                              blockingqueue<runnable> workqueue,\n                              rejectedexecutionhandler handler)\n\n\n * corepoolsize 线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corepoolsize, 即使有其他空闲线程能够执行新来的任务, 也会继续创建线程；如果当前线程数为corepoolsize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartallcorethreads()方法，线程池会提前创建并启动所有核心线程。\n\n * workqueue 用来保存等待被执行的任务的阻塞队列. 在jdk中提供了如下阻塞队列: 具体可以参考juc 集合: blockqueue详解\n   \n   * arrayblockingqueue: 基于数组结构的有界阻塞队列，按fifo排序任务；\n   * linkedblockingqueue: 基于链表结构的阻塞队列，按fifo排序任务，吞吐量通常要高于arrayblockingqueue；\n   * synchronousqueue: 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于linkedblockingqueue；\n   * priorityblockingqueue: 具有优先级的无界阻塞队列；\n\nlinkedblockingqueue比arrayblockingqueue在插入删除节点性能方面更优，但是二者在put(), take()任务的时均需要加锁，synchronousqueue使用无锁算法，根据节点的状态判断执行，而不需要用到锁，其核心是transfer.transfer().\n\n * maximumpoolsize 线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumpoolsize；当阻塞队列是无界队列, 则maximumpoolsize则不起作用, 因为无法提交至核心线程池的线程会一直持续地放入workqueue.\n\n * keepalivetime 线程空闲时的存活时间，即当线程没有任务执行时，该线程继续存活的时间；默认情况下，该参数只在线程数大于corepoolsize时才有用, 超过这个时间的空闲线程将被终止；\n\n * unit keepalivetime的单位\n\n * threadfactory 创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名。默认为defaultthreadfactory\n\n * handler 线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略:\n   \n   * abortpolicy: 直接抛出异常，默认策略；\n   * callerrunspolicy: 用调用者所在的线程来执行任务；\n   * discardoldestpolicy: 丢弃阻塞队列中靠最前的任务，并执行当前任务；\n   * discardpolicy: 直接丢弃任务；\n\n当然也可以根据应用场景实现rejectedexecutionhandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。\n\n\n# 三种类型\n\n# newfixedthreadpool\n\npublic static executorservice newfixedthreadpool(int nthreads) {\n    return new threadpoolexecutor(nthreads, nthreads,\n                                0l, timeunit.milliseconds,\n                                new linkedblockingqueue<runnable>());\n}\n\n\n线程池的线程数量达corepoolsize后，即使线程池没有可执行任务时，也不会释放线程。\n\nfixedthreadpool的工作队列为无界队列linkedblockingqueue(队列容量为integer.max_value), 这会导致以下问题:\n\n * 线程池里的线程数量不超过corepoolsize,这导致了maximumpoolsize和keepalivetime将会是个无用参数\n * 由于使用了无界队列, 所以fixedthreadpool永远不会拒绝, 即饱和策略失效\n\n# newsinglethreadexecutor\n\npublic static executorservice newsinglethreadexecutor() {\n    return new finalizabledelegatedexecutorservice\n        (new threadpoolexecutor(1, 1,\n                                0l, timeunit.milliseconds,\n                                new linkedblockingqueue<runnable>()));\n}\n\n\n初始化的线程池中只有一个线程，如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行.\n\n由于使用了无界队列, 所以singlethreadpool永远不会拒绝, 即饱和策略失效\n\n# newcachedthreadpool\n\npublic static executorservice newcachedthreadpool() {\n    return new threadpoolexecutor(0, integer.max_value,\n                                    60l, timeunit.seconds,\n                                    new synchronousqueue<runnable>());\n}\n\n\n线程池的线程数可达到integer.max_value，即2147483647，内部使用synchronousqueue作为阻塞队列； 和newfixedthreadpool创建的线程池不同，newcachedthreadpool在没有任务执行时，当线程的空闲时间超过keepalivetime，会自动释放线程资源，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销； 执行过程与前两种稍微不同:\n\n * 主线程调用synchronousqueue的offer()方法放入task, 倘若此时线程池中有空闲的线程尝试读取 synchronousqueue的task, 即调用了synchronousqueue的poll(), 那么主线程将该task交给空闲线程. 否则执行(2)\n * 当线程池为空或者没有空闲的线程, 则创建新的线程执行任务.\n * 执行完任务的线程倘若在60s内仍空闲, 则会被终止. 因此长时间空闲的cachedthreadpool不会持有任何线程资源.\n\n\n# 关闭线程池\n\n遍历线程池中的所有线程，然后逐个调用线程的interrupt方法来中断线程.\n\n# 关闭方式 - shutdown\n\n将线程池里的线程状态设置成shutdown状态, 然后中断所有没有正在执行任务的线程.\n\n# 关闭方式 - shutdownnow\n\n将线程池里的线程状态设置成stop状态, 然后停止所有正在执行或暂停任务的线程. 只要调用这两个关闭方法中的任意一个, isshutdown() 返回true. 当所有任务都成功关闭了, isterminated()返回true.\n\n\n# threadpoolexecutor源码详解\n\n\n# 几个关键属性\n\n//这个属性是用来存放 当前运行的worker数量以及线程池状态的\n//int是32位的，这里把int的高3位拿来充当线程池状态的标志位,后29位拿来充当当前运行worker的数量\nprivate final atomicinteger ctl = new atomicinteger(ctlof(running, 0));\n//存放任务的阻塞队列\nprivate final blockingqueue<runnable> workqueue;\n//worker的集合,用set来存放\nprivate final hashset<worker> workers = new hashset<worker>();\n//历史达到的worker数最大值\nprivate int largestpoolsize;\n//当队列满了并且worker的数量达到maxsize的时候,执行具体的拒绝策略\nprivate volatile rejectedexecutionhandler handler;\n//超出coresize的worker的生存时间\nprivate volatile long keepalivetime;\n//常驻worker的数量\nprivate volatile int corepoolsize;\n//最大worker的数量,一般当workqueue满了才会用到这个参数\nprivate volatile int maximumpoolsize;\n\n\n\n# 内部状态\n\nprivate final atomicinteger ctl = new atomicinteger(ctlof(running, 0));\nprivate static final int count_bits = integer.size - 3;\nprivate static final int capacity   = (1 << count_bits) - 1;\n\n// runstate is stored in the high-order bits\nprivate static final int running    = -1 << count_bits;\nprivate static final int shutdown   =  0 << count_bits;\nprivate static final int stop       =  1 << count_bits;\nprivate static final int tidying    =  2 << count_bits;\nprivate static final int terminated =  3 << count_bits;\n\n// packing and unpacking ctl\nprivate static int runstateof(int c)     { return c & ~capacity; }\nprivate static int workercountof(int c)  { return c & capacity; }\nprivate static int ctlof(int rs, int wc) { return rs | wc; }\n\n\n其中atomicinteger变量ctl的功能非常强大: 利用低29位表示线程池中线程数，通过高3位表示线程池的运行状态:\n\n * running: -1 << count_bits，即高3位为111，该状态的线程池会接收新任务，并处理阻塞队列中的任务；\n * shutdown: 0 << count_bits，即高3位为000，该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；\n * stop : 1 << count_bits，即高3位为001，该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；\n * tidying : 2 << count_bits，即高3位为010, 所有的任务都已经终止；\n * terminated: 3 << count_bits，即高3位为011, terminated()方法已经执行完成\n\n\n\n\n# 任务的执行\n\n> execute –> addworker –>runworker (gettask)\n\n线程池的工作线程通过woker类实现，在reentrantlock锁的保证下，把woker实例插入到hashset后，并启动woker中的线程。 从woker类的构造方法实现可以发现: 线程工厂在创建线程thread时，将woker实例本身this作为参数传入，当执行start方法启动线程thread时，本质是执行了worker的runworker方法。 firsttask执行完成之后，通过gettask方法从阻塞队列中获取等待的任务，如果队列中没有任务，gettask方法会被阻塞并挂起，不会占用cpu资源；\n\n# execute()方法\n\nthreadpoolexecutor.execute(task)实现了executor.execute(task)\n\npublic void execute(runnable command) {\n    if (command == null)\n        throw new nullpointerexception();\n    /*\n     * proceed in 3 steps:\n     *\n     * 1. if fewer than corepoolsize threads are running, try to\n     * start a new thread with the given command as its first\n     * task.  the call to addworker atomically checks runstate and\n     * workercount, and so prevents false alarms that would add\n     * threads when it shouldn\'t, by returning false.\n     *\n     * 2. if a task can be successfully queued, then we still need\n     * to double-check whether we should have added a thread\n     * (because existing ones died since last checking) or that\n     * the pool shut down since entry into this method. so we\n     * recheck state and if necessary roll back the enqueuing if\n     * stopped, or start a new thread if there are none.\n     *\n     * 3. if we cannot queue task, then we try to add a new\n     * thread.  if it fails, we know we are shut down or saturated\n     * and so reject the task.\n     */\n    int c = ctl.get();\n    if (workercountof(c) < corepoolsize) {  \n    //workercountof获取线程池的当前线程数；小于corepoolsize，执行addworker创建新线程执行command任务\n       if (addworker(command, true))\n            return;\n        c = ctl.get();\n    }\n    // double check: c, recheck\n    // 线程池处于running状态，把提交的任务成功放入阻塞队列中\n    if (isrunning(c) && workqueue.offer(command)) {\n        int recheck = ctl.get();\n        // recheck and if necessary 回滚到入队操作前，即倘若线程池shutdown状态，就remove(command)\n        //如果线程池没有running，成功从阻塞队列中删除任务，执行reject方法处理任务\n        if (! isrunning(recheck) && remove(command))\n            reject(command);\n        //线程池处于running状态，但是没有线程，则创建线程\n        else if (workercountof(recheck) == 0)\n            addworker(null, false);\n    }\n    // 往线程池中创建新的线程失败，则reject任务\n    else if (!addworker(command, false))\n        reject(command);\n}\n\n\n * 为什么需要double check线程池的状态?\n\n在多线程环境下，线程池的状态时刻在变化，而ctl.get()是非原子操作，很有可能刚获取了线程池状态后线程池状态就改变了。判断是否将command加入workque是线程池之前的状态。倘若没有double check，万一线程池处于非running状态(在多线程环境下很有可能发生)，那么command永远不会执行。\n\n# addworker方法\n\n从方法execute的实现可以看出: addworker主要负责创建新的线程并执行任务 线程池创建新线程执行任务时，需要 获取全局锁:\n\nprivate final reentrantlock mainlock = new reentrantlock();\n\n\nprivate boolean addworker(runnable firsttask, boolean core) {\n    // cas更新线程池数量\n    retry:\n    for (;;) {\n        int c = ctl.get();\n        int rs = runstateof(c);\n\n        // check if queue empty only if necessary.\n        if (rs >= shutdown &&\n            ! (rs == shutdown &&\n                firsttask == null &&\n                ! workqueue.isempty()))\n            return false;\n\n        for (;;) {\n            int wc = workercountof(c);\n            if (wc >= capacity ||\n                wc >= (core ? corepoolsize : maximumpoolsize))\n                return false;\n            if (compareandincrementworkercount(c))\n                break retry;\n            c = ctl.get();  // re-read ctl\n            if (runstateof(c) != rs)\n                continue retry;\n            // else cas failed due to workercount change; retry inner loop\n        }\n    }\n\n    boolean workerstarted = false;\n    boolean workeradded = false;\n    worker w = null;\n    try {\n        w = new worker(firsttask);\n        final thread t = w.thread;\n        if (t != null) {\n            // 线程池重入锁\n            final reentrantlock mainlock = this.mainlock;\n            mainlock.lock();\n            try {\n                // recheck while holding lock.\n                // back out on threadfactory failure or if\n                // shut down before lock acquired.\n                int rs = runstateof(ctl.get());\n\n                if (rs < shutdown ||\n                    (rs == shutdown && firsttask == null)) {\n                    if (t.isalive()) // precheck that t is startable\n                        throw new illegalthreadstateexception();\n                    workers.add(w);\n                    int s = workers.size();\n                    if (s > largestpoolsize)\n                        largestpoolsize = s;\n                    workeradded = true;\n                }\n            } finally {\n                mainlock.unlock();\n            }\n            if (workeradded) {\n                t.start();  // 线程启动，执行任务(worker.thread(firsttask).start());\n                workerstarted = true;\n            }\n        }\n    } finally {\n        if (! workerstarted)\n            addworkerfailed(w);\n    }\n    return workerstarted;\n}\n\n\n# worker类的runworker方法\n\n private final class worker extends abstractqueuedsynchronizer implements runnable{\n     worker(runnable firsttask) {\n         setstate(-1); // inhibit interrupts until runworker\n         this.firsttask = firsttask;\n         this.thread = getthreadfactory().newthread(this); // 创建线程\n     }\n     /** delegates main run loop to outer runworker  */\n     public void run() {\n         runworker(this);\n     }\n     // ...\n }\n\n\n * 继承了aqs类，可以方便的实现工作线程的中止操作；\n * 实现了runnable接口，可以将自身作为一个任务在工作线程中执行；\n * 当前提交的任务firsttask作为参数传入worker的构造方法；\n\n一些属性还有构造方法:\n\n//运行的线程,前面addworker方法中就是直接通过启动这个线程来启动这个worker\nfinal thread thread;\n//当一个worker刚创建的时候,就先尝试执行这个任务\nrunnable firsttask;\n//记录完成任务的数量\nvolatile long completedtasks;\n\nworker(runnable firsttask) {\n    setstate(-1); // inhibit interrupts until runworker\n    this.firsttask = firsttask;\n    //创建一个thread,将自己设置给他,后面这个thread启动的时候,也就是执行worker的run方法\n    this.thread = getthreadfactory().newthread(this);\n}   \n\n\nrunworker方法是线程池的核心:\n\n * 线程启动之后，通过unlock方法释放锁，设置aqs的state为0，表示运行可中断；\n * worker执行firsttask或从workqueue中获取任务:\n   * 进行加锁操作，保证thread不被其他线程中断(除非线程池被中断)\n   * 检查线程池状态，倘若线程池处于中断状态，当前线程将中断。\n   * 执行beforeexecute\n   * 执行任务的run方法\n   * 执行afterexecute方法\n   * 解锁操作\n\n> 通过gettask方法从阻塞队列中获取等待的任务，如果队列中没有任务，gettask方法会被阻塞并挂起，不会占用cpu资源；\n\nfinal void runworker(worker w) {\n    thread wt = thread.currentthread();\n    runnable task = w.firsttask;\n    w.firsttask = null;\n    w.unlock(); // allow interrupts\n    boolean completedabruptly = true;\n    try {\n        // 先执行firsttask，再从workerqueue中取task(gettask())\n\n        while (task != null || (task = gettask()) != null) {\n            w.lock();\n            // if pool is stopping, ensure thread is interrupted;\n            // if not, ensure thread is not interrupted.  this\n            // requires a recheck in second case to deal with\n            // shutdownnow race while clearing interrupt\n            if ((runstateatleast(ctl.get(), stop) ||\n                    (thread.interrupted() &&\n                    runstateatleast(ctl.get(), stop))) &&\n                !wt.isinterrupted())\n                wt.interrupt();\n            try {\n                beforeexecute(wt, task);\n                throwable thrown = null;\n                try {\n                    task.run();\n                } catch (runtimeexception x) {\n                    thrown = x; throw x;\n                } catch (error x) {\n                    thrown = x; throw x;\n                } catch (throwable x) {\n                    thrown = x; throw new error(x);\n                } finally {\n                    afterexecute(task, thrown);\n                }\n            } finally {\n                task = null;\n                w.completedtasks++;\n                w.unlock();\n            }\n        }\n        completedabruptly = false;\n    } finally {\n        processworkerexit(w, completedabruptly);\n    }\n}\n\n\n# gettask方法\n\n下面来看一下gettask()方法，这里面涉及到keepalivetime的使用，从这个方法我们可以看出线程池是怎么让超过corepoolsize的那部分worker销毁的。\n\nprivate runnable gettask() {\n    boolean timedout = false; // did the last poll() time out?\n\n    for (;;) {\n        int c = ctl.get();\n        int rs = runstateof(c);\n\n        // check if queue empty only if necessary.\n        if (rs >= shutdown && (rs >= stop || workqueue.isempty())) {\n            decrementworkercount();\n            return null;\n        }\n\n        int wc = workercountof(c);\n\n        // are workers subject to culling?\n        boolean timed = allowcorethreadtimeout || wc > corepoolsize;\n\n        if ((wc > maximumpoolsize || (timed && timedout))\n            && (wc > 1 || workqueue.isempty())) {\n            if (compareanddecrementworkercount(c))\n                return null;\n            continue;\n        }\n\n        try {\n            runnable r = timed ?\n                workqueue.poll(keepalivetime, timeunit.nanoseconds) :\n                workqueue.take();\n            if (r != null)\n                return r;\n            timedout = true;\n        } catch (interruptedexception retry) {\n            timedout = false;\n        }\n    }\n}\n\n\n注意这里一段代码是keepalivetime起作用的关键:\n\nboolean timed = allowcorethreadtimeout || wc > corepoolsize;\nrunnable r = timed ?\n                workqueue.poll(keepalivetime, timeunit.nanoseconds) :\n                workqueue.take();\n\n\nallowcorethreadtimeout为false，线程即使空闲也不会被销毁；倘若为ture，在keepalivetime内仍空闲则会被销毁。\n\n如果线程允许空闲等待而不被销毁timed == false，workqueue.take任务: 如果阻塞队列为空，当前线程会被挂起等待；当队列中有任务加入时，线程被唤醒，take方法返回任务，并执行；\n\n如果线程不允许无休止空闲timed == true, workqueue.poll任务: 如果在keepalivetime时间内，阻塞队列还是没有任务，则返回null；\n\n\n# 任务的提交\n\n\n\n 1. submit任务，等待线程池execute\n 2. 执行futuretask类的get方法时，会把主线程封装成waitnode节点并保存在waiters链表中， 并阻塞等待运行结果；\n 3. futuretask任务执行完成后，通过unsafe设置waiters相应的waitnode为null，并通过locksupport类unpark方法唤醒主线程；\n\npublic class test{\n    public static void main(string[] args) {\n\n        executorservice es = executors.newcachedthreadpool();\n        future<string> future = es.submit(new callable<string>() {\n            @override\n            public string call() throws exception {\n                try {\n                    timeunit.seconds.sleep(2);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n                return "future result";\n            }\n        });\n        try {\n            string result = future.get();\n            system.out.println(result);\n        } catch (exception e) {\n            e.printstacktrace();\n        }\n    }\n}\n\n\n在实际业务场景中，future和callable基本是成对出现的，callable负责产生结果，future负责获取结果。\n\n 1. callable接口类似于runnable，只是runnable没有返回值。\n 2. callable任务除了返回正常结果之外，如果发生异常，该异常也会被返回，即future可以拿到异步执行任务各种结果；\n 3. future.get方法会导致主线程阻塞，直到callable任务执行完成；\n\n# submit方法\n\nabstractexecutorservice.submit()实现了executorservice.submit() 可以获取执行完的返回值, 而threadpoolexecutor 是abstractexecutorservice.submit()的子类，所以submit方法也是threadpoolexecutor`的方法。\n\n// submit()在executorservice中的定义\n<t> future<t> submit(callable<t> task);\n\n<t> future<t> submit(runnable task, t result);\n\nfuture<?> submit(runnable task);\n\n\n// submit方法在abstractexecutorservice中的实现\npublic future<?> submit(runnable task) {\n    if (task == null) throw new nullpointerexception();\n    // 通过submit方法提交的callable任务会被封装成了一个futuretask对象。\n    runnablefuture<void> ftask = newtaskfor(task, null);\n    execute(ftask);\n    return ftask;\n}\n\n\n通过submit方法提交的callable任务会被封装成了一个futuretask对象。通过executor.execute方法提交futuretask到线程池中等待被执行，最终执行的是futuretask的run方法；\n\n# futuretask对象\n\npublic class futuretask<v> implements runnablefuture<v> 可以将futuretask提交至线程池中等待被执行(通过futuretask的run方法来执行)\n\n * 内部状态\n\n/* the run state of this task, initially new. \n    * ...\n    * possible state transitions:\n    * new -> completing -> normal\n    * new -> completing -> exceptional\n    * new -> cancelled\n    * new -> interrupting -> interrupted\n    */\nprivate volatile int state;\nprivate static final int new          = 0;\nprivate static final int completing   = 1;\nprivate static final int normal       = 2;\nprivate static final int exceptional  = 3;\nprivate static final int cancelled    = 4;\nprivate static final int interrupting = 5;\nprivate static final int interrupted  = 6;\n\n\n内部状态的修改通过sun.misc.unsafe修改\n\n * get方法\n\npublic v get() throws interruptedexception, executionexception {\n    int s = state;\n    if (s <= completing)\n        s = awaitdone(false, 0l);\n    return report(s);\n} \n\n\n内部通过awaitdone方法对主线程进行阻塞，具体实现如下:\n\nprivate int awaitdone(boolean timed, long nanos)\n    throws interruptedexception {\n    final long deadline = timed ? system.nanotime() + nanos : 0l;\n    waitnode q = null;\n    boolean queued = false;\n    for (;;) {\n        if (thread.interrupted()) {\n            removewaiter(q);\n            throw new interruptedexception();\n        }\n\n        int s = state;\n        if (s > completing) {\n            if (q != null)\n                q.thread = null;\n            return s;\n        }\n        else if (s == completing) // cannot time out yet\n            thread.yield();\n        else if (q == null)\n            q = new waitnode();\n        else if (!queued)\n            queued = unsafe.compareandswapobject(this, waitersoffset,q.next = waiters, q);\n        else if (timed) {\n            nanos = deadline - system.nanotime();\n            if (nanos <= 0l) {\n                removewaiter(q);\n                return state;\n            }\n            locksupport.parknanos(this, nanos);\n        }\n        else\n            locksupport.park(this);\n    }\n}\n\n\n 1. 如果主线程被中断，则抛出中断异常；\n 2. 判断futuretask当前的state，如果大于completing，说明任务已经执行完成，则直接返回；\n 3. 如果当前state等于completing，说明任务已经执行完，这时主线程只需通过yield方法让出cpu资源，等待state变成normal；\n 4. 通过waitnode类封装当前线程，并通过unsafe添加到waiters链表；\n 5. 最终通过locksupport的park或parknanos挂起线程；\n\nrun方法\n\npublic void run() {\n    if (state != new || !unsafe.compareandswapobject(this, runneroffset, null, thread.currentthread()))\n        return;\n    try {\n        callable<v> c = callable;\n        if (c != null && state == new) {\n            v result;\n            boolean ran;\n            try {\n                result = c.call();\n                ran = true;\n            } catch (throwable ex) {\n                result = null;\n                ran = false;\n                setexception(ex);\n            }\n            if (ran)\n                set(result);\n        }\n    } finally {\n        // runner must be non-null until state is settled to\n        // prevent concurrent calls to run()\n        runner = null;\n        // state must be re-read after nulling runner to prevent\n        // leaked interrupts\n        int s = state;\n        if (s >= interrupting)\n            handlepossiblecancellationinterrupt(s);\n    }\n}\n\n\nfuturetask.run方法是在线程池中被执行的，而非主线程\n\n 1. 通过执行callable任务的call方法；\n 2. 如果call执行成功，则通过set方法保存结果；\n 3. 如果call执行有异常，则通过setexception保存异常；\n\n\n# 任务的关闭\n\nshutdown方法会将线程池的状态设置为shutdown,线程池进入这个状态后,就拒绝再接受任务,然后会将剩余的任务全部执行完\n\npublic void shutdown() {\n    final reentrantlock mainlock = this.mainlock;\n    mainlock.lock();\n    try {\n        //检查是否可以关闭线程\n        checkshutdownaccess();\n        //设置线程池状态\n        advancerunstate(shutdown);\n        //尝试中断worker\n        interruptidleworkers();\n            //预留方法,留给子类实现\n        onshutdown(); // hook for scheduledthreadpoolexecutor\n    } finally {\n        mainlock.unlock();\n    }\n    tryterminate();\n}\n\nprivate void interruptidleworkers() {\n    interruptidleworkers(false);\n}\n\nprivate void interruptidleworkers(boolean onlyone) {\n    final reentrantlock mainlock = this.mainlock;\n    mainlock.lock();\n    try {\n        //遍历所有的worker\n        for (worker w : workers) {\n            thread t = w.thread;\n            //先尝试调用w.trylock(),如果获取到锁,就说明worker是空闲的,就可以直接中断它\n            //注意的是,worker自己本身实现了aqs同步框架,然后实现的类似锁的功能\n            //它实现的锁是不可重入的,所以如果worker在执行任务的时候,会先进行加锁,这里trylock()就会返回false\n            if (!t.isinterrupted() && w.trylock()) {\n                try {\n                    t.interrupt();\n                } catch (securityexception ignore) {\n                } finally {\n                    w.unlock();\n                }\n            }\n            if (onlyone)\n                break;\n        }\n    } finally {\n        mainlock.unlock();\n    }\n}\n\n\nshutdownnow做的比较绝，它先将线程池状态设置为stop，然后拒绝所有提交的任务。最后中断左右正在运行中的worker,然后清空任务队列。\n\npublic list<runnable> shutdownnow() {\n    list<runnable> tasks;\n    final reentrantlock mainlock = this.mainlock;\n    mainlock.lock();\n    try {\n        checkshutdownaccess();\n        //检测权限\n        advancerunstate(stop);\n        //中断所有的worker\n        interruptworkers();\n        //清空任务队列\n        tasks = drainqueue();\n    } finally {\n        mainlock.unlock();\n    }\n    tryterminate();\n    return tasks;\n}\n\nprivate void interruptworkers() {\n    final reentrantlock mainlock = this.mainlock;\n    mainlock.lock();\n    try {\n        //遍历所有worker，然后调用中断方法\n        for (worker w : workers)\n            w.interruptifstarted();\n    } finally {\n        mainlock.unlock();\n    }\n}\n\n\n\n# 更深入理解\n\n\n# 为什么线程池不允许使用executors去创建? 推荐方式是什么?\n\n线程池不允许使用executors去创建，而是通过threadpoolexecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：executors各个方法的弊端：\n\n * newfixedthreadpool和newsinglethreadexecutor:   主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至oom。\n * newcachedthreadpool和newscheduledthreadpool:   主要问题是线程数最大数是integer.max_value，可能会创建数量非常多的线程，甚至oom。\n\n# 推荐方式 1\n\n首先引入：commons-lang3包\n\nscheduledexecutorservice executorservice = new scheduledthreadpoolexecutor(1,\n        new basicthreadfactory.builder().namingpattern("example-schedule-pool-%d").daemon(true).build());\n\n\n# 推荐方式 2\n\n首先引入：com.google.guava包\n\nthreadfactory namedthreadfactory = new threadfactorybuilder().setnameformat("demo-pool-%d").build();\n\n//common thread pool\nexecutorservice pool = new threadpoolexecutor(5, 200, 0l, timeunit.milliseconds, new linkedblockingqueue<runnable>(1024), namedthreadfactory, new threadpoolexecutor.abortpolicy());\n\n// excute\npool.execute(()-> system.out.println(thread.currentthread().getname()));\n\n //gracefully shutdown\npool.shutdown();\n\n\n# 推荐方式 3\n\nspring配置线程池方式：自定义线程工厂bean需要实现threadfactory，可参考该接口的其它默认实现类，使用方式直接注入bean调用execute(runnable task)方法即可\n\n    <bean id="userthreadpool" class="org.springframework.scheduling.concurrent.threadpooltaskexecutor">\n        <property name="corepoolsize" value="10" />\n        <property name="maxpoolsize" value="100" />\n        <property name="queuecapacity" value="2000" />\n\n    <property name="threadfactory" value= threadfactory />\n        <property name="rejectedexecutionhandler">\n            <ref local="rejectedexecutionhandler" />\n        </property>\n    </bean>\n    \n    //in code\n    userthreadpool.execute(thread);\n\n\n\n# 配置线程池需要考虑因素\n\n从任务的优先级，任务的执行时间长短，任务的性质(cpu密集/ io密集)，任务的依赖关系这四个角度来分析。并且近可能地使用有界的工作队列。\n\n性质不同的任务可用使用不同规模的线程池分开处理:\n\n * cpu密集型: 尽可能少的线程，ncpu+1\n * io密集型: 尽可能多的线程, ncpu*2，比如数据库连接池\n * 混合型: cpu密集型的任务与io密集型任务的执行时间差别较小，拆分为两个线程池；否则没有必要拆分。\n\n\n# 监控线程池的状态\n\n可以使用threadpoolexecutor以下方法:\n\n * gettaskcount() returns the approximate total number of tasks that have ever been scheduled for execution.\n * getcompletedtaskcount() returns the approximate total number of tasks that have completed execution. 返回结果少于gettaskcount()。\n * getlargestpoolsize() returns the largest number of threads that have ever simultaneously been in the pool. 返回结果小于等于maximumpoolsize\n * getpoolsize() returns the current number of threads in the pool.\n * getactivecount() returns the approximate number of threads that are actively executing tasks.\n\n\n# 参考文章\n\n * 《java并发编程艺术》\n * https://www.jianshu.com/p/87bff5cc8d8c\n * https://blog.csdn.net/programmer_at/article/details/79799267\n * https://blog.csdn.net/u013332124/article/details/79587436\n * https://www.journaldev.com/1069/threadpoolexecutor-java-thread-pool-example-executorservice\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-executor-threadpoolexecutor.html',charsets:{cjk:!0}},{title:"JUC工具类: CountDownLatch详解",frontmatter:{},regularPath:"/java/thread/java-thread-x-juc-tool-countdownlatch.html",relativePath:"java/thread/java-thread-x-juc-tool-countdownlatch.md",key:"v-6403e0ae",path:"/java/thread/java-thread-x-juc-tool-countdownlatch.html",headers:[{level:2,title:"JUC工具类: CountDownLatch详解",slug:"juc工具类-countdownlatch详解",normalizedTitle:"juc工具类: countdownlatch详解",charIndex:2},{level:2,title:"带着BAT大厂的面试问题去理解",slug:"带着bat大厂的面试问题去理解",normalizedTitle:"带着bat大厂的面试问题去理解",charIndex:129},{level:2,title:"CountDownLatch介绍",slug:"countdownlatch介绍",normalizedTitle:"countdownlatch介绍",charIndex:150},{level:2,title:"CountDownLatch源码分析",slug:"countdownlatch源码分析",normalizedTitle:"countdownlatch源码分析",charIndex:172},{level:3,title:"类的继承关系",slug:"类的继承关系",normalizedTitle:"类的继承关系",charIndex:198},{level:3,title:"类的内部类",slug:"类的内部类",normalizedTitle:"类的内部类",charIndex:212},{level:3,title:"类的属性",slug:"类的属性",normalizedTitle:"类的属性",charIndex:225},{level:3,title:"类的构造函数",slug:"类的构造函数",normalizedTitle:"类的构造函数",charIndex:237},{level:3,title:"核心函数 - await函数",slug:"核心函数-await函数",normalizedTitle:"核心函数 - await函数",charIndex:251},{level:3,title:"核心函数 - countDown函数",slug:"核心函数-countdown函数",normalizedTitle:"核心函数 - countdown函数",charIndex:273},{level:2,title:"CountDownLatch示例",slug:"countdownlatch示例",normalizedTitle:"countdownlatch示例",charIndex:297},{level:2,title:"更深入理解",slug:"更深入理解",normalizedTitle:"更深入理解",charIndex:319},{level:3,title:"写道面试题",slug:"写道面试题",normalizedTitle:"写道面试题",charIndex:332},{level:3,title:"使用wait和notify实现",slug:"使用wait和notify实现",normalizedTitle:"使用wait和notify实现",charIndex:345},{level:3,title:"CountDownLatch实现",slug:"countdownlatch实现",normalizedTitle:"countdownlatch实现",charIndex:368},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:390}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"JUC工具类: CountDownLatch详解 带着BAT大厂的面试问题去理解 CountDownLatch介绍 CountDownLatch源码分析 类的继承关系 类的内部类 类的属性 类的构造函数 核心函数 - await函数 核心函数 - countDown函数 CountDownLatch示例 更深入理解 写道面试题 使用wait和notify实现 CountDownLatch实现 参考文章",content:'# JUC工具类: CountDownLatch详解\n\n> CountDownLatch底层也是由AQS，用来同步一个或多个任务的常用并发工具类，强制它们等待由其他任务执行的一组操作完成。\n\n * JUC工具类: CountDownLatch详解\n   * 带着BAT大厂的面试问题去理解\n   * CountDownLatch介绍\n   * CountDownLatch源码分析\n     * 类的继承关系\n     * 类的内部类\n     * 类的属性\n     * 类的构造函数\n     * 核心函数 - await函数\n     * 核心函数 - countDown函数\n   * CountDownLatch示例\n   * 更深入理解\n     * 写道面试题\n     * 使用wait和notify实现\n     * CountDownLatch实现\n   * 参考文章\n\n\n# 带着BAT大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 什么是CountDownLatch?\n * CountDownLatch底层实现原理?\n * CountDownLatch一次可以唤醒几个任务? 多个\n * CountDownLatch有哪些主要方法? await(),countDown()\n * CountDownLatch适用于什么场景?\n * 写道题：实现一个容器，提供两个方法，add，size 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束? 使用CountDownLatch 代替wait notify 好处。\n\n\n# CountDownLatch介绍\n\n从源码可知，其底层是由AQS提供支持，所以其数据结构可以参考AQS的数据结构，而AQS的数据结构核心就是两个虚拟队列: 同步队列sync queue 和条件队列condition queue，不同的条件会有不同的条件队列。CountDownLatch典型的用法是将一个程序分为n个互相独立的可解决任务，并创建值为n的CountDownLatch。当每一个任务完成时，都会在这个锁存器上调用countDown，等待问题被解决的任务调用这个锁存器的await，将他们自己拦住，直至锁存器计数结束。\n\n\n# CountDownLatch源码分析\n\n\n# 类的继承关系\n\nCountDownLatch没有显示继承哪个父类或者实现哪个父接口, 它底层是AQS是通过内部类Sync来实现的。\n\npublic class CountDownLatch {}\n\n\n\n# 类的内部类\n\nCountDownLatch类存在一个内部类Sync，继承自AbstractQueuedSynchronizer，其源代码如下。\n\nprivate static final class Sync extends AbstractQueuedSynchronizer {\n    // 版本号\n    private static final long serialVersionUID = 4982264981922014374L;\n    \n    // 构造器\n    Sync(int count) {\n        setState(count);\n    }\n    \n    // 返回当前计数\n    int getCount() {\n        return getState();\n    }\n\n    // 试图在共享模式下获取对象状态\n    protected int tryAcquireShared(int acquires) {\n        return (getState() == 0) ? 1 : -1;\n    }\n\n    // 试图设置状态来反映共享模式下的一个释放\n    protected boolean tryReleaseShared(int releases) {\n        // Decrement count; signal when transition to zero\n        // 无限循环\n        for (;;) {\n            // 获取状态\n            int c = getState();\n            if (c == 0) // 没有被线程占有\n                return false;\n            // 下一个状态\n            int nextc = c-1;\n            if (compareAndSetState(c, nextc)) // 比较并且设置成功\n                return nextc == 0;\n        }\n    }\n}\n\n\n说明: 对CountDownLatch方法的调用会转发到对Sync或AQS的方法的调用，所以，AQS对CountDownLatch提供支持。\n\n\n# 类的属性\n\n可以看到CountDownLatch类的内部只有一个Sync类型的属性:\n\npublic class CountDownLatch {\n    // 同步队列\n    private final Sync sync;\n}\n\n\n\n# 类的构造函数\n\npublic CountDownLatch(int count) {\n    if (count < 0) throw new IllegalArgumentException("count < 0");\n    // 初始化状态数\n    this.sync = new Sync(count);\n}\n\n\n说明: 该构造函数可以构造一个用给定计数初始化的CountDownLatch，并且构造函数内完成了sync的初始化，并设置了状态数。\n\n\n# 核心函数 - await函数\n\n此函数将会使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断。其源码如下\n\npublic void await() throws InterruptedException {\n    // 转发到sync对象上\n    sync.acquireSharedInterruptibly(1);\n}\n\n\n说明: 由源码可知，对CountDownLatch对象的await的调用会转发为对Sync的acquireSharedInterruptibly(从AQS继承的方法)方法的调用。\n\n * acquireSharedInterruptibly源码如下:\n\npublic final void acquireSharedInterruptibly(int arg)\n        throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    if (tryAcquireShared(arg) < 0)\n        doAcquireSharedInterruptibly(arg);\n}\n\n\n说明: 从源码中可知，acquireSharedInterruptibly又调用了CountDownLatch的内部类Sync的tryAcquireShared和AQS的doAcquireSharedInterruptibly函数。\n\n * tryAcquireShared函数的源码如下:\n\nprotected int tryAcquireShared(int acquires) {\n    return (getState() == 0) ? 1 : -1;\n}\n\n\n说明: 该函数只是简单的判断AQS的state是否为0，为0则返回1，不为0则返回-1。\n\n * doAcquireSharedInterruptibly函数的源码如下:\n\nprivate void doAcquireSharedInterruptibly(int arg) throws InterruptedException {\n    // 添加节点至等待队列\n    final Node node = addWaiter(Node.SHARED);\n    boolean failed = true;\n    try {\n        for (;;) { // 无限循环\n            // 获取node的前驱节点\n            final Node p = node.predecessor();\n            if (p == head) { // 前驱节点为头节点\n                // 试图在共享模式下获取对象状态\n                int r = tryAcquireShared(arg);\n                if (r >= 0) { // 获取成功\n                    // 设置头节点并进行繁殖\n                    setHeadAndPropagate(node, r);\n                    // 设置节点next域\n                    p.next = null; // help GC\n                    failed = false;\n                    return;\n                }\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt()) // 在获取失败后是否需要禁止线程并且进行中断检查\n                // 抛出异常\n                throw new InterruptedException();\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n\n\n说明: 在AQS的doAcquireSharedInterruptibly中可能会再次调用CountDownLatch的内部类Sync的tryAcquireShared方法和AQS的setHeadAndPropagate方法。\n\n * setHeadAndPropagate方法源码如下。\n\nprivate void setHeadAndPropagate(Node node, int propagate) {\n    // 获取头节点\n    Node h = head; // Record old head for check below\n    // 设置头节点\n    setHead(node);\n    /*\n        * Try to signal next queued node if:\n        *   Propagation was indicated by caller,\n        *     or was recorded (as h.waitStatus either before\n        *     or after setHead) by a previous operation\n        *     (note: this uses sign-check of waitStatus because\n        *      PROPAGATE status may transition to SIGNAL.)\n        * and\n        *   The next node is waiting in shared mode,\n        *     or we don\'t know, because it appears null\n        *\n        * The conservatism in both of these checks may cause\n        * unnecessary wake-ups, but only when there are multiple\n        * racing acquires/releases, so most need signals now or soon\n        * anyway.\n        */\n    // 进行判断\n    if (propagate > 0 || h == null || h.waitStatus < 0 ||\n        (h = head) == null || h.waitStatus < 0) {\n        // 获取节点的后继\n        Node s = node.next;\n        if (s == null || s.isShared()) // 后继为空或者为共享模式\n            // 以共享模式进行释放\n            doReleaseShared();\n    }\n}\n\n\n说明: 该方法设置头节点并且释放头节点后面的满足条件的结点，该方法中可能会调用到AQS的doReleaseShared方法，其源码如下。\n\nprivate void doReleaseShared() {\n    /*\n        * Ensure that a release propagates, even if there are other\n        * in-progress acquires/releases.  This proceeds in the usual\n        * way of trying to unparkSuccessor of head if it needs\n        * signal. But if it does not, status is set to PROPAGATE to\n        * ensure that upon release, propagation continues.\n        * Additionally, we must loop in case a new node is added\n        * while we are doing this. Also, unlike other uses of\n        * unparkSuccessor, we need to know if CAS to reset status\n        * fails, if so rechecking.\n        */\n    // 无限循环\n    for (;;) {\n        // 保存头节点\n        Node h = head;\n        if (h != null && h != tail) { // 头节点不为空并且头节点不为尾结点\n            // 获取头节点的等待状态\n            int ws = h.waitStatus; \n            if (ws == Node.SIGNAL) { // 状态为SIGNAL\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) // 不成功就继续\n                    continue;            // loop to recheck cases\n                // 释放后继结点\n                unparkSuccessor(h);\n            }\n            else if (ws == 0 &&\n                        !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) // 状态为0并且不成功，继续\n                continue;                // loop on failed CAS\n        }\n        if (h == head) // 若头节点改变，继续循环  \n            break;\n    }\n}\n\n\n说明: 该方法在共享模式下释放，具体的流程再之后会通过一个示例给出。\n\n所以，对CountDownLatch的await调用大致会有如下的调用链。\n\n\n\n说明: 上图给出了可能会调用到的主要方法，并非一定会调用到，之后，会通过一个示例给出详细的分析。\n\n\n# 核心函数 - countDown函数\n\n此函数将递减锁存器的计数，如果计数到达零，则释放所有等待的线程\n\npublic void countDown() {\n    sync.releaseShared(1);\n}\n\n\n说明: 对countDown的调用转换为对Sync对象的releaseShared(从AQS继承而来)方法的调用。\n\n * releaseShared源码如下\n\npublic final boolean releaseShared(int arg) {\n    if (tryReleaseShared(arg)) {\n        doReleaseShared();\n        return true;\n    }\n    return false;\n}\n\n\n说明: 此函数会以共享模式释放对象，并且在函数中会调用到CountDownLatch的tryReleaseShared函数，并且可能会调用AQS的doReleaseShared函数。\n\n * tryReleaseShared源码如下\n\nprotected boolean tryReleaseShared(int releases) {\n    // Decrement count; signal when transition to zero\n    // 无限循环\n    for (;;) {\n        // 获取状态\n        int c = getState();\n        if (c == 0) // 没有被线程占有\n            return false;\n        // 下一个状态\n        int nextc = c-1;\n        if (compareAndSetState(c, nextc)) // 比较并且设置成功\n            return nextc == 0;\n    }\n}\n\n\n说明: 此函数会试图设置状态来反映共享模式下的一个释放。具体的流程在下面的示例中会进行分析。\n\n * AQS的doReleaseShared的源码如下\n\nprivate void doReleaseShared() {\n    /*\n        * Ensure that a release propagates, even if there are other\n        * in-progress acquires/releases.  This proceeds in the usual\n        * way of trying to unparkSuccessor of head if it needs\n        * signal. But if it does not, status is set to PROPAGATE to\n        * ensure that upon release, propagation continues.\n        * Additionally, we must loop in case a new node is added\n        * while we are doing this. Also, unlike other uses of\n        * unparkSuccessor, we need to know if CAS to reset status\n        * fails, if so rechecking.\n        */\n    // 无限循环\n    for (;;) {\n        // 保存头节点\n        Node h = head;\n        if (h != null && h != tail) { // 头节点不为空并且头节点不为尾结点\n            // 获取头节点的等待状态\n            int ws = h.waitStatus; \n            if (ws == Node.SIGNAL) { // 状态为SIGNAL\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) // 不成功就继续\n                    continue;            // loop to recheck cases\n                // 释放后继结点\n                unparkSuccessor(h);\n            }\n            else if (ws == 0 &&\n                        !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) // 状态为0并且不成功，继续\n                continue;                // loop on failed CAS\n        }\n        if (h == head) // 若头节点改变，继续循环  \n            break;\n    }\n}\n\n\n说明: 此函数在共享模式下释放资源。\n\n所以，对CountDownLatch的countDown调用大致会有如下的调用链。\n\n\n\n说明: 上图给出了可能会调用到的主要方法，并非一定会调用到，之后，会通过一个示例给出详细的分析。\n\n\n# CountDownLatch示例\n\n下面给出了一个使用CountDownLatch的示例。\n\nimport java.util.concurrent.CountDownLatch;\n\nclass MyThread extends Thread {\n    private CountDownLatch countDownLatch;\n    \n    public MyThread(String name, CountDownLatch countDownLatch) {\n        super(name);\n        this.countDownLatch = countDownLatch;\n    }\n    \n    public void run() {\n        System.out.println(Thread.currentThread().getName() + " doing something");\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + " finish");\n        countDownLatch.countDown();\n    }\n}\n\npublic class CountDownLatchDemo {\n    public static void main(String[] args) {\n        CountDownLatch countDownLatch = new CountDownLatch(2);\n        MyThread t1 = new MyThread("t1", countDownLatch);\n        MyThread t2 = new MyThread("t2", countDownLatch);\n        t1.start();\n        t2.start();\n        System.out.println("Waiting for t1 thread and t2 thread to finish");\n        try {\n            countDownLatch.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }            \n        System.out.println(Thread.currentThread().getName() + " continue");        \n    }\n}\n\n\n运行结果(某一次):\n\nWaiting for t1 thread and t2 thread to finish\nt1 doing something\nt2 doing something\nt1 finish\nt2 finish\nmain continue\n\n\n说明: 本程序首先计数器初始化为2。根据结果，可能会存在如下的一种时序图。\n\n\n\n说明: 首先main线程会调用await操作，此时main线程会被阻塞，等待被唤醒，之后t1线程执行了countDown操作，最后，t2线程执行了countDown操作，此时main线程就被唤醒了，可以继续运行。下面，进行详细分析。\n\n * main线程执行countDownLatch.await操作，主要调用的函数如下。\n\n\n\n说明: 在最后，main线程就被park了，即禁止运行了。此时Sync queue(同步队列)中有两个节点，AQS的state为2，包含main线程的结点的nextWaiter指向SHARED结点。\n\n * t1线程执行countDownLatch.countDown操作，主要调用的函数如下。\n\n\n\n说明: 此时，Sync queue队列里的结点个数未发生变化，但是此时，AQS的state已经变为1了。\n\n * t2线程执行countDownLatch.countDown操作，主要调用的函数如下。\n\n\n\n说明: 经过调用后，AQS的state为0，并且此时，main线程会被unpark，可以继续运行。当main线程获取cpu资源后，继续运行。\n\n * main线程获取cpu资源，继续运行，由于main线程是在parkAndCheckInterrupt函数中被禁止的，所以此时，继续在parkAndCheckInterrupt函数运行。\n\n\n\n说明: main线程恢复，继续在parkAndCheckInterrupt函数中运行，之后又会回到最终达到的状态为AQS的state为0，并且head与tail指向同一个结点，该节点的额nextWaiter域还是指向SHARED结点。\n\n\n# 更深入理解\n\n\n# 写道面试题\n\n> 实现一个容器，提供两个方法，add，size 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束.\n\n\n# 使用wait和notify实现\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n *  必须先让t2先进行启动 使用wait 和 notify 进行相互通讯，wait会释放锁，notify不会释放锁\n */\npublic class T2 {\n\n volatile   List list = new ArrayList();\n\n    public void add (int i){\n        list.add(i);\n    }\n\n    public int getSize(){\n        return list.size();\n    }\n\n    public static void main(String[] args) {\n\n        T2 t2 = new T2();\n\n        Object lock = new Object();\n\n        new Thread(() -> {\n            synchronized(lock){\n                System.out.println("t2 启动");\n                if(t2.getSize() != 5){\n                    try {\n                        /**会释放锁*/\n                        lock.wait();\n                        System.out.println("t2 结束");\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                lock.notify();\n            }\n        },"t2").start();\n\n        new Thread(() -> {\n           synchronized (lock){\n               System.out.println("t1 启动");\n               for (int i=0;i<9;i++){\n                   t2.add(i);\n                   System.out.println("add"+i);\n                   if(t2.getSize() == 5){\n                       /**不会释放锁*/\n                       lock.notify();\n                       try {\n                           lock.wait();\n                       } catch (InterruptedException e) {\n                           e.printStackTrace();\n                       }\n                   }\n               }\n           }\n        }).start();\n    }\n}\n\n\n输出：\n\nt2 启动\nt1 启动\nadd0\nadd1\nadd2\nadd3\nadd4\nt2 结束\nadd5\nadd6\nadd7\nadd8\n\n\n\n# CountDownLatch实现\n\n说出使用CountDownLatch 代替wait notify 好处?\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\n\n/**\n * 使用CountDownLatch 代替wait notify 好处是通讯方式简单，不涉及锁定  Count 值为0时当前线程继续执行，\n */\npublic class T3 {\n\n   volatile List list = new ArrayList();\n\n    public void add(int i){\n        list.add(i);\n    }\n\n    public int getSize(){\n        return list.size();\n    }\n\n\n    public static void main(String[] args) {\n        T3 t = new T3();\n        CountDownLatch countDownLatch = new CountDownLatch(1);\n\n        new Thread(() -> {\n            System.out.println("t2 start");\n           if(t.getSize() != 5){\n               try {\n                   countDownLatch.await();\n                   System.out.println("t2 end");\n               } catch (InterruptedException e) {\n                   e.printStackTrace();\n               }\n           }\n        },"t2").start();\n\n        new Thread(()->{\n            System.out.println("t1 start");\n           for (int i = 0;i<9;i++){\n               t.add(i);\n               System.out.println("add"+ i);\n               if(t.getSize() == 5){\n                   System.out.println("countdown is open");\n                   countDownLatch.countDown();\n               }\n           }\n            System.out.println("t1 end");\n        },"t1").start();\n    }\n\n}\n\n\n\n# 参考文章\n\n * 文章主要参考自leesf的https://www.cnblogs.com/leesf456/p/5406191.html，在此基础上做了增改。\n * https://www.jianshu.com/p/40336ef1f5fe\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-tool-countdownlatch.html',normalizedContent:'# juc工具类: countdownlatch详解\n\n> countdownlatch底层也是由aqs，用来同步一个或多个任务的常用并发工具类，强制它们等待由其他任务执行的一组操作完成。\n\n * juc工具类: countdownlatch详解\n   * 带着bat大厂的面试问题去理解\n   * countdownlatch介绍\n   * countdownlatch源码分析\n     * 类的继承关系\n     * 类的内部类\n     * 类的属性\n     * 类的构造函数\n     * 核心函数 - await函数\n     * 核心函数 - countdown函数\n   * countdownlatch示例\n   * 更深入理解\n     * 写道面试题\n     * 使用wait和notify实现\n     * countdownlatch实现\n   * 参考文章\n\n\n# 带着bat大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 什么是countdownlatch?\n * countdownlatch底层实现原理?\n * countdownlatch一次可以唤醒几个任务? 多个\n * countdownlatch有哪些主要方法? await(),countdown()\n * countdownlatch适用于什么场景?\n * 写道题：实现一个容器，提供两个方法，add，size 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束? 使用countdownlatch 代替wait notify 好处。\n\n\n# countdownlatch介绍\n\n从源码可知，其底层是由aqs提供支持，所以其数据结构可以参考aqs的数据结构，而aqs的数据结构核心就是两个虚拟队列: 同步队列sync queue 和条件队列condition queue，不同的条件会有不同的条件队列。countdownlatch典型的用法是将一个程序分为n个互相独立的可解决任务，并创建值为n的countdownlatch。当每一个任务完成时，都会在这个锁存器上调用countdown，等待问题被解决的任务调用这个锁存器的await，将他们自己拦住，直至锁存器计数结束。\n\n\n# countdownlatch源码分析\n\n\n# 类的继承关系\n\ncountdownlatch没有显示继承哪个父类或者实现哪个父接口, 它底层是aqs是通过内部类sync来实现的。\n\npublic class countdownlatch {}\n\n\n\n# 类的内部类\n\ncountdownlatch类存在一个内部类sync，继承自abstractqueuedsynchronizer，其源代码如下。\n\nprivate static final class sync extends abstractqueuedsynchronizer {\n    // 版本号\n    private static final long serialversionuid = 4982264981922014374l;\n    \n    // 构造器\n    sync(int count) {\n        setstate(count);\n    }\n    \n    // 返回当前计数\n    int getcount() {\n        return getstate();\n    }\n\n    // 试图在共享模式下获取对象状态\n    protected int tryacquireshared(int acquires) {\n        return (getstate() == 0) ? 1 : -1;\n    }\n\n    // 试图设置状态来反映共享模式下的一个释放\n    protected boolean tryreleaseshared(int releases) {\n        // decrement count; signal when transition to zero\n        // 无限循环\n        for (;;) {\n            // 获取状态\n            int c = getstate();\n            if (c == 0) // 没有被线程占有\n                return false;\n            // 下一个状态\n            int nextc = c-1;\n            if (compareandsetstate(c, nextc)) // 比较并且设置成功\n                return nextc == 0;\n        }\n    }\n}\n\n\n说明: 对countdownlatch方法的调用会转发到对sync或aqs的方法的调用，所以，aqs对countdownlatch提供支持。\n\n\n# 类的属性\n\n可以看到countdownlatch类的内部只有一个sync类型的属性:\n\npublic class countdownlatch {\n    // 同步队列\n    private final sync sync;\n}\n\n\n\n# 类的构造函数\n\npublic countdownlatch(int count) {\n    if (count < 0) throw new illegalargumentexception("count < 0");\n    // 初始化状态数\n    this.sync = new sync(count);\n}\n\n\n说明: 该构造函数可以构造一个用给定计数初始化的countdownlatch，并且构造函数内完成了sync的初始化，并设置了状态数。\n\n\n# 核心函数 - await函数\n\n此函数将会使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断。其源码如下\n\npublic void await() throws interruptedexception {\n    // 转发到sync对象上\n    sync.acquiresharedinterruptibly(1);\n}\n\n\n说明: 由源码可知，对countdownlatch对象的await的调用会转发为对sync的acquiresharedinterruptibly(从aqs继承的方法)方法的调用。\n\n * acquiresharedinterruptibly源码如下:\n\npublic final void acquiresharedinterruptibly(int arg)\n        throws interruptedexception {\n    if (thread.interrupted())\n        throw new interruptedexception();\n    if (tryacquireshared(arg) < 0)\n        doacquiresharedinterruptibly(arg);\n}\n\n\n说明: 从源码中可知，acquiresharedinterruptibly又调用了countdownlatch的内部类sync的tryacquireshared和aqs的doacquiresharedinterruptibly函数。\n\n * tryacquireshared函数的源码如下:\n\nprotected int tryacquireshared(int acquires) {\n    return (getstate() == 0) ? 1 : -1;\n}\n\n\n说明: 该函数只是简单的判断aqs的state是否为0，为0则返回1，不为0则返回-1。\n\n * doacquiresharedinterruptibly函数的源码如下:\n\nprivate void doacquiresharedinterruptibly(int arg) throws interruptedexception {\n    // 添加节点至等待队列\n    final node node = addwaiter(node.shared);\n    boolean failed = true;\n    try {\n        for (;;) { // 无限循环\n            // 获取node的前驱节点\n            final node p = node.predecessor();\n            if (p == head) { // 前驱节点为头节点\n                // 试图在共享模式下获取对象状态\n                int r = tryacquireshared(arg);\n                if (r >= 0) { // 获取成功\n                    // 设置头节点并进行繁殖\n                    setheadandpropagate(node, r);\n                    // 设置节点next域\n                    p.next = null; // help gc\n                    failed = false;\n                    return;\n                }\n            }\n            if (shouldparkafterfailedacquire(p, node) &&\n                parkandcheckinterrupt()) // 在获取失败后是否需要禁止线程并且进行中断检查\n                // 抛出异常\n                throw new interruptedexception();\n        }\n    } finally {\n        if (failed)\n            cancelacquire(node);\n    }\n}\n\n\n说明: 在aqs的doacquiresharedinterruptibly中可能会再次调用countdownlatch的内部类sync的tryacquireshared方法和aqs的setheadandpropagate方法。\n\n * setheadandpropagate方法源码如下。\n\nprivate void setheadandpropagate(node node, int propagate) {\n    // 获取头节点\n    node h = head; // record old head for check below\n    // 设置头节点\n    sethead(node);\n    /*\n        * try to signal next queued node if:\n        *   propagation was indicated by caller,\n        *     or was recorded (as h.waitstatus either before\n        *     or after sethead) by a previous operation\n        *     (note: this uses sign-check of waitstatus because\n        *      propagate status may transition to signal.)\n        * and\n        *   the next node is waiting in shared mode,\n        *     or we don\'t know, because it appears null\n        *\n        * the conservatism in both of these checks may cause\n        * unnecessary wake-ups, but only when there are multiple\n        * racing acquires/releases, so most need signals now or soon\n        * anyway.\n        */\n    // 进行判断\n    if (propagate > 0 || h == null || h.waitstatus < 0 ||\n        (h = head) == null || h.waitstatus < 0) {\n        // 获取节点的后继\n        node s = node.next;\n        if (s == null || s.isshared()) // 后继为空或者为共享模式\n            // 以共享模式进行释放\n            doreleaseshared();\n    }\n}\n\n\n说明: 该方法设置头节点并且释放头节点后面的满足条件的结点，该方法中可能会调用到aqs的doreleaseshared方法，其源码如下。\n\nprivate void doreleaseshared() {\n    /*\n        * ensure that a release propagates, even if there are other\n        * in-progress acquires/releases.  this proceeds in the usual\n        * way of trying to unparksuccessor of head if it needs\n        * signal. but if it does not, status is set to propagate to\n        * ensure that upon release, propagation continues.\n        * additionally, we must loop in case a new node is added\n        * while we are doing this. also, unlike other uses of\n        * unparksuccessor, we need to know if cas to reset status\n        * fails, if so rechecking.\n        */\n    // 无限循环\n    for (;;) {\n        // 保存头节点\n        node h = head;\n        if (h != null && h != tail) { // 头节点不为空并且头节点不为尾结点\n            // 获取头节点的等待状态\n            int ws = h.waitstatus; \n            if (ws == node.signal) { // 状态为signal\n                if (!compareandsetwaitstatus(h, node.signal, 0)) // 不成功就继续\n                    continue;            // loop to recheck cases\n                // 释放后继结点\n                unparksuccessor(h);\n            }\n            else if (ws == 0 &&\n                        !compareandsetwaitstatus(h, 0, node.propagate)) // 状态为0并且不成功，继续\n                continue;                // loop on failed cas\n        }\n        if (h == head) // 若头节点改变，继续循环  \n            break;\n    }\n}\n\n\n说明: 该方法在共享模式下释放，具体的流程再之后会通过一个示例给出。\n\n所以，对countdownlatch的await调用大致会有如下的调用链。\n\n\n\n说明: 上图给出了可能会调用到的主要方法，并非一定会调用到，之后，会通过一个示例给出详细的分析。\n\n\n# 核心函数 - countdown函数\n\n此函数将递减锁存器的计数，如果计数到达零，则释放所有等待的线程\n\npublic void countdown() {\n    sync.releaseshared(1);\n}\n\n\n说明: 对countdown的调用转换为对sync对象的releaseshared(从aqs继承而来)方法的调用。\n\n * releaseshared源码如下\n\npublic final boolean releaseshared(int arg) {\n    if (tryreleaseshared(arg)) {\n        doreleaseshared();\n        return true;\n    }\n    return false;\n}\n\n\n说明: 此函数会以共享模式释放对象，并且在函数中会调用到countdownlatch的tryreleaseshared函数，并且可能会调用aqs的doreleaseshared函数。\n\n * tryreleaseshared源码如下\n\nprotected boolean tryreleaseshared(int releases) {\n    // decrement count; signal when transition to zero\n    // 无限循环\n    for (;;) {\n        // 获取状态\n        int c = getstate();\n        if (c == 0) // 没有被线程占有\n            return false;\n        // 下一个状态\n        int nextc = c-1;\n        if (compareandsetstate(c, nextc)) // 比较并且设置成功\n            return nextc == 0;\n    }\n}\n\n\n说明: 此函数会试图设置状态来反映共享模式下的一个释放。具体的流程在下面的示例中会进行分析。\n\n * aqs的doreleaseshared的源码如下\n\nprivate void doreleaseshared() {\n    /*\n        * ensure that a release propagates, even if there are other\n        * in-progress acquires/releases.  this proceeds in the usual\n        * way of trying to unparksuccessor of head if it needs\n        * signal. but if it does not, status is set to propagate to\n        * ensure that upon release, propagation continues.\n        * additionally, we must loop in case a new node is added\n        * while we are doing this. also, unlike other uses of\n        * unparksuccessor, we need to know if cas to reset status\n        * fails, if so rechecking.\n        */\n    // 无限循环\n    for (;;) {\n        // 保存头节点\n        node h = head;\n        if (h != null && h != tail) { // 头节点不为空并且头节点不为尾结点\n            // 获取头节点的等待状态\n            int ws = h.waitstatus; \n            if (ws == node.signal) { // 状态为signal\n                if (!compareandsetwaitstatus(h, node.signal, 0)) // 不成功就继续\n                    continue;            // loop to recheck cases\n                // 释放后继结点\n                unparksuccessor(h);\n            }\n            else if (ws == 0 &&\n                        !compareandsetwaitstatus(h, 0, node.propagate)) // 状态为0并且不成功，继续\n                continue;                // loop on failed cas\n        }\n        if (h == head) // 若头节点改变，继续循环  \n            break;\n    }\n}\n\n\n说明: 此函数在共享模式下释放资源。\n\n所以，对countdownlatch的countdown调用大致会有如下的调用链。\n\n\n\n说明: 上图给出了可能会调用到的主要方法，并非一定会调用到，之后，会通过一个示例给出详细的分析。\n\n\n# countdownlatch示例\n\n下面给出了一个使用countdownlatch的示例。\n\nimport java.util.concurrent.countdownlatch;\n\nclass mythread extends thread {\n    private countdownlatch countdownlatch;\n    \n    public mythread(string name, countdownlatch countdownlatch) {\n        super(name);\n        this.countdownlatch = countdownlatch;\n    }\n    \n    public void run() {\n        system.out.println(thread.currentthread().getname() + " doing something");\n        try {\n            thread.sleep(1000);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n        system.out.println(thread.currentthread().getname() + " finish");\n        countdownlatch.countdown();\n    }\n}\n\npublic class countdownlatchdemo {\n    public static void main(string[] args) {\n        countdownlatch countdownlatch = new countdownlatch(2);\n        mythread t1 = new mythread("t1", countdownlatch);\n        mythread t2 = new mythread("t2", countdownlatch);\n        t1.start();\n        t2.start();\n        system.out.println("waiting for t1 thread and t2 thread to finish");\n        try {\n            countdownlatch.await();\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }            \n        system.out.println(thread.currentthread().getname() + " continue");        \n    }\n}\n\n\n运行结果(某一次):\n\nwaiting for t1 thread and t2 thread to finish\nt1 doing something\nt2 doing something\nt1 finish\nt2 finish\nmain continue\n\n\n说明: 本程序首先计数器初始化为2。根据结果，可能会存在如下的一种时序图。\n\n\n\n说明: 首先main线程会调用await操作，此时main线程会被阻塞，等待被唤醒，之后t1线程执行了countdown操作，最后，t2线程执行了countdown操作，此时main线程就被唤醒了，可以继续运行。下面，进行详细分析。\n\n * main线程执行countdownlatch.await操作，主要调用的函数如下。\n\n\n\n说明: 在最后，main线程就被park了，即禁止运行了。此时sync queue(同步队列)中有两个节点，aqs的state为2，包含main线程的结点的nextwaiter指向shared结点。\n\n * t1线程执行countdownlatch.countdown操作，主要调用的函数如下。\n\n\n\n说明: 此时，sync queue队列里的结点个数未发生变化，但是此时，aqs的state已经变为1了。\n\n * t2线程执行countdownlatch.countdown操作，主要调用的函数如下。\n\n\n\n说明: 经过调用后，aqs的state为0，并且此时，main线程会被unpark，可以继续运行。当main线程获取cpu资源后，继续运行。\n\n * main线程获取cpu资源，继续运行，由于main线程是在parkandcheckinterrupt函数中被禁止的，所以此时，继续在parkandcheckinterrupt函数运行。\n\n\n\n说明: main线程恢复，继续在parkandcheckinterrupt函数中运行，之后又会回到最终达到的状态为aqs的state为0，并且head与tail指向同一个结点，该节点的额nextwaiter域还是指向shared结点。\n\n\n# 更深入理解\n\n\n# 写道面试题\n\n> 实现一个容器，提供两个方法，add，size 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束.\n\n\n# 使用wait和notify实现\n\nimport java.util.arraylist;\nimport java.util.list;\n\n/**\n *  必须先让t2先进行启动 使用wait 和 notify 进行相互通讯，wait会释放锁，notify不会释放锁\n */\npublic class t2 {\n\n volatile   list list = new arraylist();\n\n    public void add (int i){\n        list.add(i);\n    }\n\n    public int getsize(){\n        return list.size();\n    }\n\n    public static void main(string[] args) {\n\n        t2 t2 = new t2();\n\n        object lock = new object();\n\n        new thread(() -> {\n            synchronized(lock){\n                system.out.println("t2 启动");\n                if(t2.getsize() != 5){\n                    try {\n                        /**会释放锁*/\n                        lock.wait();\n                        system.out.println("t2 结束");\n                    } catch (interruptedexception e) {\n                        e.printstacktrace();\n                    }\n                }\n                lock.notify();\n            }\n        },"t2").start();\n\n        new thread(() -> {\n           synchronized (lock){\n               system.out.println("t1 启动");\n               for (int i=0;i<9;i++){\n                   t2.add(i);\n                   system.out.println("add"+i);\n                   if(t2.getsize() == 5){\n                       /**不会释放锁*/\n                       lock.notify();\n                       try {\n                           lock.wait();\n                       } catch (interruptedexception e) {\n                           e.printstacktrace();\n                       }\n                   }\n               }\n           }\n        }).start();\n    }\n}\n\n\n输出：\n\nt2 启动\nt1 启动\nadd0\nadd1\nadd2\nadd3\nadd4\nt2 结束\nadd5\nadd6\nadd7\nadd8\n\n\n\n# countdownlatch实现\n\n说出使用countdownlatch 代替wait notify 好处?\n\nimport java.util.arraylist;\nimport java.util.list;\nimport java.util.concurrent.countdownlatch;\n\n/**\n * 使用countdownlatch 代替wait notify 好处是通讯方式简单，不涉及锁定  count 值为0时当前线程继续执行，\n */\npublic class t3 {\n\n   volatile list list = new arraylist();\n\n    public void add(int i){\n        list.add(i);\n    }\n\n    public int getsize(){\n        return list.size();\n    }\n\n\n    public static void main(string[] args) {\n        t3 t = new t3();\n        countdownlatch countdownlatch = new countdownlatch(1);\n\n        new thread(() -> {\n            system.out.println("t2 start");\n           if(t.getsize() != 5){\n               try {\n                   countdownlatch.await();\n                   system.out.println("t2 end");\n               } catch (interruptedexception e) {\n                   e.printstacktrace();\n               }\n           }\n        },"t2").start();\n\n        new thread(()->{\n            system.out.println("t1 start");\n           for (int i = 0;i<9;i++){\n               t.add(i);\n               system.out.println("add"+ i);\n               if(t.getsize() == 5){\n                   system.out.println("countdown is open");\n                   countdownlatch.countdown();\n               }\n           }\n            system.out.println("t1 end");\n        },"t1").start();\n    }\n\n}\n\n\n\n# 参考文章\n\n * 文章主要参考自leesf的https://www.cnblogs.com/leesf456/p/5406191.html，在此基础上做了增改。\n * https://www.jianshu.com/p/40336ef1f5fe\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-tool-countdownlatch.html',charsets:{cjk:!0}},{title:"JUC工具类: CyclicBarrier详解",frontmatter:{},regularPath:"/java/thread/java-thread-x-juc-tool-cyclicbarrier.html",relativePath:"java/thread/java-thread-x-juc-tool-cyclicbarrier.md",key:"v-120dde14",path:"/java/thread/java-thread-x-juc-tool-cyclicbarrier.html",headers:[{level:2,title:"JUC工具类: CyclicBarrier详解",slug:"juc工具类-cyclicbarrier详解",normalizedTitle:"juc工具类: cyclicbarrier详解",charIndex:2},{level:2,title:"带着BAT大厂的面试问题去理解",slug:"带着bat大厂的面试问题去理解",normalizedTitle:"带着bat大厂的面试问题去理解",charIndex:165},{level:2,title:"CyclicBarrier简介",slug:"cyclicbarrier简介",normalizedTitle:"cyclicbarrier简介",charIndex:186},{level:2,title:"CyclicBarrier源码分析",slug:"cyclicbarrier源码分析",normalizedTitle:"cyclicbarrier源码分析",charIndex:207},{level:3,title:"类的继承关系",slug:"类的继承关系",normalizedTitle:"类的继承关系",charIndex:232},{level:3,title:"类的内部类",slug:"类的内部类",normalizedTitle:"类的内部类",charIndex:1061},{level:3,title:"类的属性",slug:"类的属性",normalizedTitle:"类的属性",charIndex:246},{level:3,title:"类的构造函数",slug:"类的构造函数",normalizedTitle:"类的构造函数",charIndex:258},{level:3,title:"核心函数 - dowait函数",slug:"核心函数-dowait函数",normalizedTitle:"核心函数 - dowait函数",charIndex:272},{level:3,title:"核心函数 - nextGeneration函数",slug:"核心函数-nextgeneration函数",normalizedTitle:"核心函数 - nextgeneration函数",charIndex:295},{level:3,title:"breakBarrier函数",slug:"breakbarrier函数",normalizedTitle:"breakbarrier函数",charIndex:326},{level:2,title:"CyclicBarrier示例",slug:"cyclicbarrier示例",normalizedTitle:"cyclicbarrier示例",charIndex:346},{level:2,title:"和CountDonwLatch再对比",slug:"和countdonwlatch再对比",normalizedTitle:"和countdonwlatch再对比",charIndex:367},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:391}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"JUC工具类: CyclicBarrier详解 带着BAT大厂的面试问题去理解 CyclicBarrier简介 CyclicBarrier源码分析 类的继承关系 类的内部类 类的属性 类的构造函数 核心函数 - dowait函数 核心函数 - nextGeneration函数 breakBarrier函数 CyclicBarrier示例 和CountDonwLatch再对比 参考文章",content:'# JUC工具类: CyclicBarrier详解\n\n> CyclicBarrier底层是基于ReentrantLock和AbstractQueuedSynchronizer来实现的, 在理解的时候最好和CountDownLatch放在一起理解(相见本文分析)。\n\n * JUC工具类: CyclicBarrier详解\n   * 带着BAT大厂的面试问题去理解\n   * CyclicBarrier简介\n   * CyclicBarrier源码分析\n     * 类的继承关系\n     * 类的属性\n     * 类的构造函数\n     * 核心函数 - dowait函数\n     * 核心函数 - nextGeneration函数\n     * breakBarrier函数\n   * CyclicBarrier示例\n   * 和CountDonwLatch再对比\n   * 参考文章\n\n\n# 带着BAT大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 什么是CyclicBarrier?\n * CyclicBarrier底层实现原理?\n * CountDownLatch和CyclicBarrier对比?\n * CyclicBarrier的核心函数有哪些?\n * CyclicBarrier适用于什么场景?\n\n\n# CyclicBarrier简介\n\n * 对于CountDownLatch，其他线程为游戏玩家，比如英雄联盟，主线程为控制游戏开始的线程。在所有的玩家都准备好之前，主线程是处于等待状态的，也就是游戏不能开始。当所有的玩家准备好之后，下一步的动作实施者为主线程，即开始游戏。\n\n * 对于CyclicBarrier，假设有一家公司要全体员工进行团建活动，活动内容为翻越三个障碍物，每一个人翻越障碍物所用的时间是不一样的。但是公司要求所有人在翻越当前障碍物之后再开始翻越下一个障碍物，也就是所有人翻越第一个障碍物之后，才开始翻越第二个，以此类推。类比地，每一个员工都是一个“其他线程”。当所有人都翻越的所有的障碍物之后，程序才结束。而主线程可能早就结束了，这里我们不用管主线程。\n\n\n# CyclicBarrier源码分析\n\n\n# 类的继承关系\n\nCyclicBarrier没有显示继承哪个父类或者实现哪个父接口, 所有AQS和重入锁不是通过继承实现的，而是通过组合实现的。\n\npublic class CyclicBarrier {}\n\n\n\n# 类的内部类\n\nCyclicBarrier类存在一个内部类Generation，每一次使用的CycBarrier可以当成Generation的实例，其源代码如下\n\nprivate static class Generation {\n    boolean broken = false;\n}\n\n\n说明: Generation类有一个属性broken，用来表示当前屏障是否被损坏。\n\n\n# 类的属性\n\npublic class CyclicBarrier {\n    \n    /** The lock for guarding barrier entry */\n    // 可重入锁\n    private final ReentrantLock lock = new ReentrantLock();\n    /** Condition to wait on until tripped */\n    // 条件队列\n    private final Condition trip = lock.newCondition();\n    /** The number of parties */\n    // 参与的线程数量\n    private final int parties;\n    /* The command to run when tripped */\n    // 由最后一个进入 barrier 的线程执行的操作\n    private final Runnable barrierCommand;\n    /** The current generation */\n    // 当前代\n    private Generation generation = new Generation();\n    // 正在等待进入屏障的线程数量\n    private int count;\n}\n\n\n说明: 该属性有一个为ReentrantLock对象，有一个为Condition对象，而Condition对象又是基于AQS的，所以，归根到底，底层还是由AQS提供支持。\n\n\n# 类的构造函数\n\n * CyclicBarrier(int, Runnable)型构造函数\n\npublic CyclicBarrier(int parties, Runnable barrierAction) {\n    // 参与的线程数量小于等于0，抛出异常\n    if (parties <= 0) throw new IllegalArgumentException();\n    // 设置parties\n    this.parties = parties;\n    // 设置count\n    this.count = parties;\n    // 设置barrierCommand\n    this.barrierCommand = barrierAction;\n}\n\n\n说明: 该构造函数可以指定关联该CyclicBarrier的线程数量，并且可以指定在所有线程都进入屏障后的执行动作，该执行动作由最后一个进行屏障的线程执行。\n\n * CyclicBarrier(int)型构造函数\n\npublic CyclicBarrier(int parties) {\n    // 调用含有两个参数的构造函数\n    this(parties, null);\n}\n\n\n说明: 该构造函数仅仅执行了关联该CyclicBarrier的线程数量，没有设置执行动作。\n\n\n# 核心函数 - dowait函数\n\n此函数为CyclicBarrier类的核心函数，CyclicBarrier类对外提供的await函数在底层都是调用该了doawait函数，其源代码如下。\n\nprivate int dowait(boolean timed, long nanos)\n    throws InterruptedException, BrokenBarrierException,\n            TimeoutException {\n    // 保存当前锁\n    final ReentrantLock lock = this.lock;\n    // 锁定\n    lock.lock();\n    try {\n        // 保存当前代\n        final Generation g = generation;\n        \n        if (g.broken) // 屏障被破坏，抛出异常\n            throw new BrokenBarrierException();\n\n        if (Thread.interrupted()) { // 线程被中断\n            // 损坏当前屏障，并且唤醒所有的线程，只有拥有锁的时候才会调用\n            breakBarrier();\n            // 抛出异常\n            throw new InterruptedException();\n        }\n        \n        // 减少正在等待进入屏障的线程数量\n        int index = --count;\n        if (index == 0) {  // 正在等待进入屏障的线程数量为0，所有线程都已经进入\n            // 运行的动作标识\n            boolean ranAction = false;\n            try {\n                // 保存运行动作\n                final Runnable command = barrierCommand;\n                if (command != null) // 动作不为空\n                    // 运行\n                    command.run();\n                // 设置ranAction状态\n                ranAction = true;\n                // 进入下一代\n                nextGeneration();\n                return 0;\n            } finally {\n                if (!ranAction) // 没有运行的动作\n                    // 损坏当前屏障\n                    breakBarrier();\n            }\n        }\n\n        // loop until tripped, broken, interrupted, or timed out\n        // 无限循环\n        for (;;) {\n            try {\n                if (!timed) // 没有设置等待时间\n                    // 等待\n                    trip.await(); \n                else if (nanos > 0L) // 设置了等待时间，并且等待时间大于0\n                    // 等待指定时长\n                    nanos = trip.awaitNanos(nanos);\n            } catch (InterruptedException ie) { \n                if (g == generation && ! g.broken) { // 等于当前代并且屏障没有被损坏\n                    // 损坏当前屏障\n                    breakBarrier();\n                    // 抛出异常\n                    throw ie;\n                } else { // 不等于当前带后者是屏障被损坏\n                    // We\'re about to finish waiting even if we had not\n                    // been interrupted, so this interrupt is deemed to\n                    // "belong" to subsequent execution.\n                    // 中断当前线程\n                    Thread.currentThread().interrupt();\n                }\n            }\n\n            if (g.broken) // 屏障被损坏，抛出异常\n                throw new BrokenBarrierException();\n\n            if (g != generation) // 不等于当前代\n                // 返回索引\n                return index;\n\n            if (timed && nanos <= 0L) { // 设置了等待时间，并且等待时间小于0\n                // 损坏屏障\n                breakBarrier();\n                // 抛出异常\n                throw new TimeoutException();\n            }\n        }\n    } finally {\n        // 释放锁\n        lock.unlock();\n    }\n}\n\n\n说明: dowait方法的逻辑会进行一系列的判断，大致流程如下:\n\n\n\n\n# 核心函数 - nextGeneration函数\n\n此函数在所有线程进入屏障后会被调用，即生成下一个版本，所有线程又可以重新进入到屏障中，其源代码如下\n\nprivate void nextGeneration() {\n    // signal completion of last generation\n    // 唤醒所有线程\n    trip.signalAll();\n    // set up next generation\n    // 恢复正在等待进入屏障的线程数量\n    count = parties;\n    // 新生一代\n    generation = new Generation();\n}\n\n\n在此函数中会调用AQS的signalAll方法，即唤醒所有等待线程。如果所有的线程都在等待此条件，则唤醒所有线程。其源代码如下\n\npublic final void signalAll() {\n    if (!isHeldExclusively()) // 不被当前线程独占，抛出异常\n        throw new IllegalMonitorStateException();\n    // 保存condition队列头节点\n    Node first = firstWaiter;\n    if (first != null) // 头节点不为空\n        // 唤醒所有等待线程\n        doSignalAll(first);\n}\n\n\n说明: 此函数判断头节点是否为空，即条件队列是否为空，然后会调用doSignalAll函数，doSignalAll函数源码如下\n\nprivate void doSignalAll(Node first) {\n    // condition队列的头节点尾结点都设置为空\n    lastWaiter = firstWaiter = null;\n    // 循环\n    do {\n        // 获取first结点的nextWaiter域结点\n        Node next = first.nextWaiter;\n        // 设置first结点的nextWaiter域为空\n        first.nextWaiter = null;\n        // 将first结点从condition队列转移到sync队列\n        transferForSignal(first);\n        // 重新设置first\n        first = next;\n    } while (first != null);\n}\n\n\n说明: 此函数会依次将条件队列中的节点转移到同步队列中，会调用到transferForSignal函数，其源码如下\n\nfinal boolean transferForSignal(Node node) {\n    /*\n        * If cannot change waitStatus, the node has been cancelled.\n        */\n    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))\n        return false;\n\n    /*\n        * Splice onto queue and try to set waitStatus of predecessor to\n        * indicate that thread is (probably) waiting. If cancelled or\n        * attempt to set waitStatus fails, wake up to resync (in which\n        * case the waitStatus can be transiently and harmlessly wrong).\n        */\n    Node p = enq(node);\n    int ws = p.waitStatus;\n    if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))\n        LockSupport.unpark(node.thread);\n    return true;\n}\n\n\n说明: 此函数的作用就是将处于条件队列中的节点转移到同步队列中，并设置结点的状态信息，其中会调用到enq函数，其源代码如下。\n\nprivate Node enq(final Node node) {\n    for (;;) { // 无限循环，确保结点能够成功入队列\n        // 保存尾结点\n        Node t = tail;\n        if (t == null) { // 尾结点为空，即还没被初始化\n            if (compareAndSetHead(new Node())) // 头节点为空，并设置头节点为新生成的结点\n                tail = head; // 头节点与尾结点都指向同一个新生结点\n        } else { // 尾结点不为空，即已经被初始化过\n            // 将node结点的prev域连接到尾结点\n            node.prev = t; \n            if (compareAndSetTail(t, node)) { // 比较结点t是否为尾结点，若是则将尾结点设置为node\n                // 设置尾结点的next域为node\n                t.next = node; \n                return t; // 返回尾结点\n            }\n        }\n    }\n}\n\n\n说明: 此函数完成了结点插入同步队列的过程，也很好理解。\n\n综合上面的分析可知，newGeneration函数的主要方法的调用如下，之后会通过一个例子详细讲解:\n\n\n\n\n# breakBarrier函数\n\n此函数的作用是损坏当前屏障，会唤醒所有在屏障中的线程。源代码如下:\n\nprivate void breakBarrier() {\n    // 设置状态\n    generation.broken = true;\n    // 恢复正在等待进入屏障的线程数量\n    count = parties;\n    // 唤醒所有线程\n    trip.signalAll();\n}\n\n\n说明: 可以看到，此函数也调用了AQS的signalAll函数，由signal函数提供支持。\n\n\n# CyclicBarrier示例\n\n下面通过一个例子来详解CyclicBarrier的使用和内部工作机制，源代码如下\n\nimport java.util.concurrent.BrokenBarrierException;\nimport java.util.concurrent.CyclicBarrier;\n\nclass MyThread extends Thread {\n    private CyclicBarrier cb;\n    public MyThread(String name, CyclicBarrier cb) {\n        super(name);\n        this.cb = cb;\n    }\n    \n    public void run() {\n        System.out.println(Thread.currentThread().getName() + " going to await");\n        try {\n            cb.await();\n            System.out.println(Thread.currentThread().getName() + " continue");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\npublic class CyclicBarrierDemo {\n    public static void main(String[] args) throws InterruptedException, BrokenBarrierException {\n        CyclicBarrier cb = new CyclicBarrier(3, new Thread("barrierAction") {\n            public void run() {\n                System.out.println(Thread.currentThread().getName() + " barrier action");\n                \n            }\n        });\n        MyThread t1 = new MyThread("t1", cb);\n        MyThread t2 = new MyThread("t2", cb);\n        t1.start();\n        t2.start();\n        System.out.println(Thread.currentThread().getName() + " going to await");\n        cb.await();\n        System.out.println(Thread.currentThread().getName() + " continue");\n\n    }\n}\n\n\n运行结果(某一次):\n\nt1 going to await\nmain going to await\nt2 going to await\nt2 barrier action\nt2 continue\nt1 continue\nmain continue\n\n\n说明: 根据结果可知，可能会存在如下的调用时序。\n\n\n\n说明: 由上图可知，假设t1线程的cb.await是在main线程的cb.barrierAction动作是由最后一个进入屏障的线程执行的。根据时序图，进一步分析出其内部工作流程。\n\n * main(主)线程执行cb.await操作，主要调用的函数如下。\n\n\n\n说明: 由于ReentrantLock的默认采用非公平策略，所以在dowait函数中调用的是ReentrantLock.NonfairSync的lock函数，由于此时AQS的状态是0，表示还没有被任何线程占用，故main线程可以占用，之后在dowait中会调用trip.await函数，最终的结果是条件队列中存放了一个包含main线程的结点，并且被禁止运行了，同时，main线程所拥有的资源也被释放了，可以供其他线程获取。\n\n * t1线程执行cb.await操作，其中假设t1线程的lock.lock操作在main线程释放了资源之后，则其主要调用的函数如下。\n\n\n\n说明: 可以看到，之后condition queue(条件队列)里面有两个节点，包含t1线程的结点插入在队列的尾部，并且t1线程也被禁止了，因为执行了park操作，此时两个线程都被禁止了。\n\n * t2线程执行cb.await操作，其中假设t2线程的lock.lock操作在t1线程释放了资源之后，则其主要调用的函数如下。\n\n\n\n说明: 由上图可知，在t2线程执行await操作后，会直接执行command.run方法，不是重新开启一个线程，而是最后进入屏障的线程执行。同时，会将Condition queue中的所有节点都转移到Sync queue中，并且最后main线程会被unpark，可以继续运行。main线程获取cpu资源，继续运行。\n\n * main线程获取cpu资源，继续运行，下图给出了主要的方法调用:\n\n\n\n说明: 其中，由于main线程是在AQS.CO的wait中被park的，所以恢复时，会继续在该方法中运行。运行过后，t1线程被unpark，它获得cpu资源可以继续运行。\n\n * t1线程获取cpu资源，继续运行，下图给出了主要的方法调用。\n\n\n\n说明: 其中，由于t1线程是在AQS.CO的wait方法中被park，所以恢复时，会继续在该方法中运行。运行过后，Sync queue中保持着一个空节点。头节点与尾节点均指向它。\n\n注意: 在线程await过程中中断线程会抛出异常，所有进入屏障的线程都将被释放。至于CyclicBarrier的其他用法，读者可以自行查阅API，不再累赘。\n\n\n# 和CountDonwLatch再对比\n\n * CountDownLatch减计数，CyclicBarrier加计数。\n * CountDownLatch是一次性的，CyclicBarrier可以重用。\n * CountDownLatch和CyclicBarrier都有让多个线程等待同步然后再开始下一步动作的意思，但是CountDownLatch的下一步的动作实施者是主线程，具有不可重复性；而CyclicBarrier的下一步动作实施者还是“其他线程”本身，具有往复多次实施动作的特点。\n\n\n# 参考文章\n\n * 文章主要参考自leesf的https://www.cnblogs.com/leesf456/p/5392816.html，在此基础上做了增改。\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-tool-cyclicbarrier.html',normalizedContent:'# juc工具类: cyclicbarrier详解\n\n> cyclicbarrier底层是基于reentrantlock和abstractqueuedsynchronizer来实现的, 在理解的时候最好和countdownlatch放在一起理解(相见本文分析)。\n\n * juc工具类: cyclicbarrier详解\n   * 带着bat大厂的面试问题去理解\n   * cyclicbarrier简介\n   * cyclicbarrier源码分析\n     * 类的继承关系\n     * 类的属性\n     * 类的构造函数\n     * 核心函数 - dowait函数\n     * 核心函数 - nextgeneration函数\n     * breakbarrier函数\n   * cyclicbarrier示例\n   * 和countdonwlatch再对比\n   * 参考文章\n\n\n# 带着bat大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 什么是cyclicbarrier?\n * cyclicbarrier底层实现原理?\n * countdownlatch和cyclicbarrier对比?\n * cyclicbarrier的核心函数有哪些?\n * cyclicbarrier适用于什么场景?\n\n\n# cyclicbarrier简介\n\n * 对于countdownlatch，其他线程为游戏玩家，比如英雄联盟，主线程为控制游戏开始的线程。在所有的玩家都准备好之前，主线程是处于等待状态的，也就是游戏不能开始。当所有的玩家准备好之后，下一步的动作实施者为主线程，即开始游戏。\n\n * 对于cyclicbarrier，假设有一家公司要全体员工进行团建活动，活动内容为翻越三个障碍物，每一个人翻越障碍物所用的时间是不一样的。但是公司要求所有人在翻越当前障碍物之后再开始翻越下一个障碍物，也就是所有人翻越第一个障碍物之后，才开始翻越第二个，以此类推。类比地，每一个员工都是一个“其他线程”。当所有人都翻越的所有的障碍物之后，程序才结束。而主线程可能早就结束了，这里我们不用管主线程。\n\n\n# cyclicbarrier源码分析\n\n\n# 类的继承关系\n\ncyclicbarrier没有显示继承哪个父类或者实现哪个父接口, 所有aqs和重入锁不是通过继承实现的，而是通过组合实现的。\n\npublic class cyclicbarrier {}\n\n\n\n# 类的内部类\n\ncyclicbarrier类存在一个内部类generation，每一次使用的cycbarrier可以当成generation的实例，其源代码如下\n\nprivate static class generation {\n    boolean broken = false;\n}\n\n\n说明: generation类有一个属性broken，用来表示当前屏障是否被损坏。\n\n\n# 类的属性\n\npublic class cyclicbarrier {\n    \n    /** the lock for guarding barrier entry */\n    // 可重入锁\n    private final reentrantlock lock = new reentrantlock();\n    /** condition to wait on until tripped */\n    // 条件队列\n    private final condition trip = lock.newcondition();\n    /** the number of parties */\n    // 参与的线程数量\n    private final int parties;\n    /* the command to run when tripped */\n    // 由最后一个进入 barrier 的线程执行的操作\n    private final runnable barriercommand;\n    /** the current generation */\n    // 当前代\n    private generation generation = new generation();\n    // 正在等待进入屏障的线程数量\n    private int count;\n}\n\n\n说明: 该属性有一个为reentrantlock对象，有一个为condition对象，而condition对象又是基于aqs的，所以，归根到底，底层还是由aqs提供支持。\n\n\n# 类的构造函数\n\n * cyclicbarrier(int, runnable)型构造函数\n\npublic cyclicbarrier(int parties, runnable barrieraction) {\n    // 参与的线程数量小于等于0，抛出异常\n    if (parties <= 0) throw new illegalargumentexception();\n    // 设置parties\n    this.parties = parties;\n    // 设置count\n    this.count = parties;\n    // 设置barriercommand\n    this.barriercommand = barrieraction;\n}\n\n\n说明: 该构造函数可以指定关联该cyclicbarrier的线程数量，并且可以指定在所有线程都进入屏障后的执行动作，该执行动作由最后一个进行屏障的线程执行。\n\n * cyclicbarrier(int)型构造函数\n\npublic cyclicbarrier(int parties) {\n    // 调用含有两个参数的构造函数\n    this(parties, null);\n}\n\n\n说明: 该构造函数仅仅执行了关联该cyclicbarrier的线程数量，没有设置执行动作。\n\n\n# 核心函数 - dowait函数\n\n此函数为cyclicbarrier类的核心函数，cyclicbarrier类对外提供的await函数在底层都是调用该了doawait函数，其源代码如下。\n\nprivate int dowait(boolean timed, long nanos)\n    throws interruptedexception, brokenbarrierexception,\n            timeoutexception {\n    // 保存当前锁\n    final reentrantlock lock = this.lock;\n    // 锁定\n    lock.lock();\n    try {\n        // 保存当前代\n        final generation g = generation;\n        \n        if (g.broken) // 屏障被破坏，抛出异常\n            throw new brokenbarrierexception();\n\n        if (thread.interrupted()) { // 线程被中断\n            // 损坏当前屏障，并且唤醒所有的线程，只有拥有锁的时候才会调用\n            breakbarrier();\n            // 抛出异常\n            throw new interruptedexception();\n        }\n        \n        // 减少正在等待进入屏障的线程数量\n        int index = --count;\n        if (index == 0) {  // 正在等待进入屏障的线程数量为0，所有线程都已经进入\n            // 运行的动作标识\n            boolean ranaction = false;\n            try {\n                // 保存运行动作\n                final runnable command = barriercommand;\n                if (command != null) // 动作不为空\n                    // 运行\n                    command.run();\n                // 设置ranaction状态\n                ranaction = true;\n                // 进入下一代\n                nextgeneration();\n                return 0;\n            } finally {\n                if (!ranaction) // 没有运行的动作\n                    // 损坏当前屏障\n                    breakbarrier();\n            }\n        }\n\n        // loop until tripped, broken, interrupted, or timed out\n        // 无限循环\n        for (;;) {\n            try {\n                if (!timed) // 没有设置等待时间\n                    // 等待\n                    trip.await(); \n                else if (nanos > 0l) // 设置了等待时间，并且等待时间大于0\n                    // 等待指定时长\n                    nanos = trip.awaitnanos(nanos);\n            } catch (interruptedexception ie) { \n                if (g == generation && ! g.broken) { // 等于当前代并且屏障没有被损坏\n                    // 损坏当前屏障\n                    breakbarrier();\n                    // 抛出异常\n                    throw ie;\n                } else { // 不等于当前带后者是屏障被损坏\n                    // we\'re about to finish waiting even if we had not\n                    // been interrupted, so this interrupt is deemed to\n                    // "belong" to subsequent execution.\n                    // 中断当前线程\n                    thread.currentthread().interrupt();\n                }\n            }\n\n            if (g.broken) // 屏障被损坏，抛出异常\n                throw new brokenbarrierexception();\n\n            if (g != generation) // 不等于当前代\n                // 返回索引\n                return index;\n\n            if (timed && nanos <= 0l) { // 设置了等待时间，并且等待时间小于0\n                // 损坏屏障\n                breakbarrier();\n                // 抛出异常\n                throw new timeoutexception();\n            }\n        }\n    } finally {\n        // 释放锁\n        lock.unlock();\n    }\n}\n\n\n说明: dowait方法的逻辑会进行一系列的判断，大致流程如下:\n\n\n\n\n# 核心函数 - nextgeneration函数\n\n此函数在所有线程进入屏障后会被调用，即生成下一个版本，所有线程又可以重新进入到屏障中，其源代码如下\n\nprivate void nextgeneration() {\n    // signal completion of last generation\n    // 唤醒所有线程\n    trip.signalall();\n    // set up next generation\n    // 恢复正在等待进入屏障的线程数量\n    count = parties;\n    // 新生一代\n    generation = new generation();\n}\n\n\n在此函数中会调用aqs的signalall方法，即唤醒所有等待线程。如果所有的线程都在等待此条件，则唤醒所有线程。其源代码如下\n\npublic final void signalall() {\n    if (!isheldexclusively()) // 不被当前线程独占，抛出异常\n        throw new illegalmonitorstateexception();\n    // 保存condition队列头节点\n    node first = firstwaiter;\n    if (first != null) // 头节点不为空\n        // 唤醒所有等待线程\n        dosignalall(first);\n}\n\n\n说明: 此函数判断头节点是否为空，即条件队列是否为空，然后会调用dosignalall函数，dosignalall函数源码如下\n\nprivate void dosignalall(node first) {\n    // condition队列的头节点尾结点都设置为空\n    lastwaiter = firstwaiter = null;\n    // 循环\n    do {\n        // 获取first结点的nextwaiter域结点\n        node next = first.nextwaiter;\n        // 设置first结点的nextwaiter域为空\n        first.nextwaiter = null;\n        // 将first结点从condition队列转移到sync队列\n        transferforsignal(first);\n        // 重新设置first\n        first = next;\n    } while (first != null);\n}\n\n\n说明: 此函数会依次将条件队列中的节点转移到同步队列中，会调用到transferforsignal函数，其源码如下\n\nfinal boolean transferforsignal(node node) {\n    /*\n        * if cannot change waitstatus, the node has been cancelled.\n        */\n    if (!compareandsetwaitstatus(node, node.condition, 0))\n        return false;\n\n    /*\n        * splice onto queue and try to set waitstatus of predecessor to\n        * indicate that thread is (probably) waiting. if cancelled or\n        * attempt to set waitstatus fails, wake up to resync (in which\n        * case the waitstatus can be transiently and harmlessly wrong).\n        */\n    node p = enq(node);\n    int ws = p.waitstatus;\n    if (ws > 0 || !compareandsetwaitstatus(p, ws, node.signal))\n        locksupport.unpark(node.thread);\n    return true;\n}\n\n\n说明: 此函数的作用就是将处于条件队列中的节点转移到同步队列中，并设置结点的状态信息，其中会调用到enq函数，其源代码如下。\n\nprivate node enq(final node node) {\n    for (;;) { // 无限循环，确保结点能够成功入队列\n        // 保存尾结点\n        node t = tail;\n        if (t == null) { // 尾结点为空，即还没被初始化\n            if (compareandsethead(new node())) // 头节点为空，并设置头节点为新生成的结点\n                tail = head; // 头节点与尾结点都指向同一个新生结点\n        } else { // 尾结点不为空，即已经被初始化过\n            // 将node结点的prev域连接到尾结点\n            node.prev = t; \n            if (compareandsettail(t, node)) { // 比较结点t是否为尾结点，若是则将尾结点设置为node\n                // 设置尾结点的next域为node\n                t.next = node; \n                return t; // 返回尾结点\n            }\n        }\n    }\n}\n\n\n说明: 此函数完成了结点插入同步队列的过程，也很好理解。\n\n综合上面的分析可知，newgeneration函数的主要方法的调用如下，之后会通过一个例子详细讲解:\n\n\n\n\n# breakbarrier函数\n\n此函数的作用是损坏当前屏障，会唤醒所有在屏障中的线程。源代码如下:\n\nprivate void breakbarrier() {\n    // 设置状态\n    generation.broken = true;\n    // 恢复正在等待进入屏障的线程数量\n    count = parties;\n    // 唤醒所有线程\n    trip.signalall();\n}\n\n\n说明: 可以看到，此函数也调用了aqs的signalall函数，由signal函数提供支持。\n\n\n# cyclicbarrier示例\n\n下面通过一个例子来详解cyclicbarrier的使用和内部工作机制，源代码如下\n\nimport java.util.concurrent.brokenbarrierexception;\nimport java.util.concurrent.cyclicbarrier;\n\nclass mythread extends thread {\n    private cyclicbarrier cb;\n    public mythread(string name, cyclicbarrier cb) {\n        super(name);\n        this.cb = cb;\n    }\n    \n    public void run() {\n        system.out.println(thread.currentthread().getname() + " going to await");\n        try {\n            cb.await();\n            system.out.println(thread.currentthread().getname() + " continue");\n        } catch (exception e) {\n            e.printstacktrace();\n        }\n    }\n}\npublic class cyclicbarrierdemo {\n    public static void main(string[] args) throws interruptedexception, brokenbarrierexception {\n        cyclicbarrier cb = new cyclicbarrier(3, new thread("barrieraction") {\n            public void run() {\n                system.out.println(thread.currentthread().getname() + " barrier action");\n                \n            }\n        });\n        mythread t1 = new mythread("t1", cb);\n        mythread t2 = new mythread("t2", cb);\n        t1.start();\n        t2.start();\n        system.out.println(thread.currentthread().getname() + " going to await");\n        cb.await();\n        system.out.println(thread.currentthread().getname() + " continue");\n\n    }\n}\n\n\n运行结果(某一次):\n\nt1 going to await\nmain going to await\nt2 going to await\nt2 barrier action\nt2 continue\nt1 continue\nmain continue\n\n\n说明: 根据结果可知，可能会存在如下的调用时序。\n\n\n\n说明: 由上图可知，假设t1线程的cb.await是在main线程的cb.barrieraction动作是由最后一个进入屏障的线程执行的。根据时序图，进一步分析出其内部工作流程。\n\n * main(主)线程执行cb.await操作，主要调用的函数如下。\n\n\n\n说明: 由于reentrantlock的默认采用非公平策略，所以在dowait函数中调用的是reentrantlock.nonfairsync的lock函数，由于此时aqs的状态是0，表示还没有被任何线程占用，故main线程可以占用，之后在dowait中会调用trip.await函数，最终的结果是条件队列中存放了一个包含main线程的结点，并且被禁止运行了，同时，main线程所拥有的资源也被释放了，可以供其他线程获取。\n\n * t1线程执行cb.await操作，其中假设t1线程的lock.lock操作在main线程释放了资源之后，则其主要调用的函数如下。\n\n\n\n说明: 可以看到，之后condition queue(条件队列)里面有两个节点，包含t1线程的结点插入在队列的尾部，并且t1线程也被禁止了，因为执行了park操作，此时两个线程都被禁止了。\n\n * t2线程执行cb.await操作，其中假设t2线程的lock.lock操作在t1线程释放了资源之后，则其主要调用的函数如下。\n\n\n\n说明: 由上图可知，在t2线程执行await操作后，会直接执行command.run方法，不是重新开启一个线程，而是最后进入屏障的线程执行。同时，会将condition queue中的所有节点都转移到sync queue中，并且最后main线程会被unpark，可以继续运行。main线程获取cpu资源，继续运行。\n\n * main线程获取cpu资源，继续运行，下图给出了主要的方法调用:\n\n\n\n说明: 其中，由于main线程是在aqs.co的wait中被park的，所以恢复时，会继续在该方法中运行。运行过后，t1线程被unpark，它获得cpu资源可以继续运行。\n\n * t1线程获取cpu资源，继续运行，下图给出了主要的方法调用。\n\n\n\n说明: 其中，由于t1线程是在aqs.co的wait方法中被park，所以恢复时，会继续在该方法中运行。运行过后，sync queue中保持着一个空节点。头节点与尾节点均指向它。\n\n注意: 在线程await过程中中断线程会抛出异常，所有进入屏障的线程都将被释放。至于cyclicbarrier的其他用法，读者可以自行查阅api，不再累赘。\n\n\n# 和countdonwlatch再对比\n\n * countdownlatch减计数，cyclicbarrier加计数。\n * countdownlatch是一次性的，cyclicbarrier可以重用。\n * countdownlatch和cyclicbarrier都有让多个线程等待同步然后再开始下一步动作的意思，但是countdownlatch的下一步的动作实施者是主线程，具有不可重复性；而cyclicbarrier的下一步动作实施者还是“其他线程”本身，具有往复多次实施动作的特点。\n\n\n# 参考文章\n\n * 文章主要参考自leesf的https://www.cnblogs.com/leesf456/p/5392816.html，在此基础上做了增改。\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-tool-cyclicbarrier.html',charsets:{cjk:!0}},{title:"JUC工具类: Exchanger详解",frontmatter:{},regularPath:"/java/thread/java-thread-x-juc-tool-exchanger.html",relativePath:"java/thread/java-thread-x-juc-tool-exchanger.md",key:"v-0751ed32",path:"/java/thread/java-thread-x-juc-tool-exchanger.html",headers:[{level:2,title:"JUC工具类: Exchanger详解",slug:"juc工具类-exchanger详解",normalizedTitle:"juc工具类: exchanger详解",charIndex:2},{level:2,title:"带着BAT大厂的面试问题去理解Exchanger",slug:"带着bat大厂的面试问题去理解exchanger",normalizedTitle:"带着bat大厂的面试问题去理解exchanger",charIndex:93},{level:2,title:"Exchanger简介",slug:"exchanger简介",normalizedTitle:"exchanger简介",charIndex:123},{level:2,title:"Exchanger实现机制",slug:"exchanger实现机制",normalizedTitle:"exchanger实现机制",charIndex:140},{level:2,title:"Exchanger源码解析",slug:"exchanger源码解析",normalizedTitle:"exchanger源码解析",charIndex:159},{level:3,title:"内部类 - Participant",slug:"内部类-participant",normalizedTitle:"内部类 - participant",charIndex:180},{level:3,title:"内部类 - Node",slug:"内部类-node",normalizedTitle:"内部类 - node",charIndex:205},{level:3,title:"核心属性",slug:"核心属性",normalizedTitle:"核心属性",charIndex:223},{level:3,title:"构造函数",slug:"构造函数",normalizedTitle:"构造函数",charIndex:235},{level:3,title:"核心方法 - exchange(V x)",slug:"核心方法-exchange-v-x",normalizedTitle:"核心方法 - exchange(v x)",charIndex:247},{level:3,title:"slotExchange(Object item, boolean timed, long ns)",slug:"slotexchange-object-item-boolean-timed-long-ns",normalizedTitle:"slotexchange(object item, boolean timed, long ns)",charIndex:275},{level:3,title:"arenaExchange(Object item, boolean timed, long ns)",slug:"arenaexchange-object-item-boolean-timed-long-ns",normalizedTitle:"arenaexchange(object item, boolean timed, long ns)",charIndex:332},{level:3,title:"更深入理解",slug:"更深入理解",normalizedTitle:"更深入理解",charIndex:15006},{level:3,title:"Exchanger示例",slug:"exchanger示例",normalizedTitle:"exchanger示例",charIndex:15416},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:388}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"JUC工具类: Exchanger详解 带着BAT大厂的面试问题去理解Exchanger Exchanger简介 Exchanger实现机制 Exchanger源码解析 内部类 - Participant 内部类 - Node 核心属性 构造函数 核心方法 - exchange(V x) slotExchange(Object item, boolean timed, long ns) arenaExchange(Object item, boolean timed, long ns) 更深入理解 Exchanger示例 参考文章",content:'# JUC工具类: Exchanger详解\n\n> Exchanger是用于线程协作的工具类, 主要用于两个线程之间的数据交换。\n\n * JUC工具类: Exchanger详解\n   * 带着BAT大厂的面试问题去理解Exchanger\n   * Exchanger简介\n   * Exchanger实现机制\n   * Exchanger源码解析\n     * 内部类 - Participant\n     * 内部类 - Node\n     * 核心属性\n     * 构造函数\n     * 核心方法 - exchange(V x)\n     * slotExchange(Object item, boolean timed, long ns)\n     * arenaExchange(Object item, boolean timed, long ns)\n   * 参考文章\n\n\n# 带着BAT大厂的面试问题去理解Exchanger\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解Exchanger。\n\n * Exchanger主要解决什么问题?\n * 对比SynchronousQueue，为什么说Exchanger可被视为 SynchronousQueue 的双向形式?\n * Exchanger在不同的JDK版本中实现有什么差别?\n * Exchanger实现机制?\n * Exchanger已经有了slot单节点，为什么会加入arena node数组? 什么时候会用到数组?\n * arena可以确保不同的slot在arena中是不会相冲突的，那么是怎么保证的呢?\n * 什么是伪共享，Exchanger中如何体现的?\n * Exchanger实现举例\n\n\n# Exchanger简介\n\nExchanger用于进行两个线程之间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange()方法交换数据，当一个线程先执行exchange()方法后，它会一直等待第二个线程也执行exchange()方法，当这两个线程到达同步点时，这两个线程就可以交换数据了。\n\n\n# Exchanger实现机制\n\nfor (;;) {\n    if (slot is empty) { // offer\n        // slot为空时，将item 设置到Node 中        \n        place item in a Node;\n        if (can CAS slot from empty to node) {\n            // 当将node通过CAS交换到slot中时，挂起线程等待被唤醒\n            wait for release;\n            // 被唤醒后返回node中匹配到的item\n            return matching item in node;\n        }\n    } else if (can CAS slot from node to empty) { // release\n         // 将slot设置为空\n        // 获取node中的item，将需要交换的数据设置到匹配的item\n        get the item in node;\n        set matching item in node;\n        // 唤醒等待的线程\n        release waiting thread;\n    }\n    // else retry on CAS failure\n}\n\n\n比如有2条线程A和B，A线程交换数据时，发现slot为空，则将需要交换的数据放在slot中等待其它线程进来交换数据，等线程B进来，读取A设置的数据，然后设置线程B需要交换的数据，然后唤醒A线程，原理就是这么简单。但是当多个线程之间进行交换数据时就会出现问题，所以Exchanger加入了slot数组。\n\n\n# Exchanger源码解析\n\n\n# 内部类 - Participant\n\nstatic final class Participant extends ThreadLocal<Node> {\n    public Node initialValue() { return new Node(); }\n}\n\n\nParticipant的作用是为每个线程保留唯一的一个Node节点, 它继承ThreadLocal，说明每个线程具有不同的状态。\n\n\n# 内部类 - Node\n\n@sun.misc.Contended static final class Node {\n     // arena的下标，多个槽位的时候利用\n    int index; \n    // 上一次记录的Exchanger.bound\n    int bound; \n    // 在当前bound下CAS失败的次数；\n    int collides;\n    // 用于自旋；\n    int hash; \n    // 这个线程的当前项，也就是需要交换的数据；\n    Object item; \n    //做releasing操作的线程传递的项；\n    volatile Object match; \n    //挂起时设置线程值，其他情况下为null；\n    volatile Thread parked;\n}\n\n\n在Node定义中有两个变量值得思考：bound以及collides。前面提到了数组area是为了避免竞争而产生的，如果系统不存在竞争问题，那么完全没有必要开辟一个高效的arena来徒增系统的复杂性。首先通过单个slot的exchanger来交换数据，当探测到竞争时将安排不同的位置的slot来保存线程Node，并且可以确保没有slot会在同一个缓存行上。如何来判断会有竞争呢? CAS替换slot失败，如果失败，则通过记录冲突次数来扩展arena的尺寸，我们在记录冲突的过程中会跟踪“bound”的值，以及会重新计算冲突次数在bound的值被改变时。\n\n\n# 核心属性\n\nprivate final Participant participant;\nprivate volatile Node[] arena;\nprivate volatile Node slot;\n\n\n * 为什么会有 arena数组槽?\n\nslot为单个槽，arena为数组槽, 他们都是Node类型。在这里可能会感觉到疑惑，slot作为Exchanger交换数据的场景，应该只需要一个就可以了啊? 为何还多了一个Participant 和数组类型的arena呢? 一个slot交换场所原则上来说应该是可以的，但实际情况却不是如此，多个参与者使用同一个交换场所时，会存在严重伸缩性问题。既然单个交换场所存在问题，那么我们就安排多个，也就是数组arena。通过数组arena来安排不同的线程使用不同的slot来降低竞争问题，并且可以保证最终一定会成对交换数据。但是Exchanger不是一来就会生成arena数组来降低竞争，只有当产生竞争是才会生成arena数组。\n\n * 那么怎么将Node与当前线程绑定呢？\n\nParticipant，Participant 的作用就是为每个线程保留唯一的一个Node节点，它继承ThreadLocal，同时在Node节点中记录在arena中的下标index。\n\n\n# 构造函数\n\n/**\n* Creates a new Exchanger.\n*/\npublic Exchanger() {\n    participant = new Participant();\n}\n\n\n初始化participant对象。\n\n\n# 核心方法 - exchange(V x)\n\n等待另一个线程到达此交换点(除非当前线程被中断)，然后将给定的对象传送给该线程，并接收该线程的对象。\n\npublic V exchange(V x) throws InterruptedException {\n    Object v;\n    // 当参数为null时需要将item设置为空的对象\n    Object item = (x == null) ? NULL_ITEM : x; // translate null args\n    // 注意到这里的这个表达式是整个方法的核心\n    if ((arena != null ||\n            (v = slotExchange(item, false, 0 L)) == null) &&\n        ((Thread.interrupted() || // disambiguates null return\n            (v = arenaExchange(item, false, 0 L)) == null)))\n        throw new InterruptedException();\n    return (v == NULL_ITEM) ? null : (V) v;\n}\n\n\n这个方法比较好理解：arena为数组槽，如果为null，则执行slotExchange()方法，否则判断线程是否中断，如果中断值抛出InterruptedException异常，没有中断则执行arenaExchange()方法。整套逻辑就是：如果slotExchange(Object item, boolean timed, long ns)方法执行失败了就执行arenaExchange(Object item, boolean timed, long ns)方法，最后返回结果V。\n\nNULL_ITEM 为一个空节点，其实就是一个Object对象而已，slotExchange()为单个slot交换。\n\n\n# slotExchange(Object item, boolean timed, long ns)\n\nprivate final Object slotExchange(Object item, boolean timed, long ns) {\n    // 获取当前线程node对象\n    Node p = participant.get();\n    // 当前线程\n    Thread t = Thread.currentThread();\n    // 若果线程被中断，就直接返回null\n    if (t.isInterrupted()) // preserve interrupt status so caller can recheck\n        return null;\n\t// 自旋\n    for (Node q;;) {\n        // 将slot值赋给q\n        if ((q = slot) != null) {\n             // slot 不为null，即表示已有线程已经把需要交换的数据设置在slot中了\n\t\t\t// 通过CAS将slot设置成null\n            if (U.compareAndSwapObject(this, SLOT, q, null)) {\n                // CAS操作成功后，将slot中的item赋值给对象v，以便返回。\n                // 这里也是就读取之前线程要交换的数据\n                Object v = q.item;\n                // 将当前线程需要交给的数据设置在q中的match\n                q.match = item;\n                 // 获取被挂起的线程\n                Thread w = q.parked;\n                if (w != null)\n                    // 如果线程不为null，唤醒它\n                    U.unpark(w);\n                // 返回其他线程给的V\n                return v;\n            }\n            // create arena on contention, but continue until slot null\n            // CAS 操作失败，表示有其它线程竞争，在此线程之前将数据已取走\n            // NCPU:CPU的核数\n            // bound == 0 表示arena数组未初始化过，CAS操作bound将其增加SEQ\n            if (NCPU > 1 && bound == 0 &&\n                U.compareAndSwapInt(this, BOUND, 0, SEQ))\n                // 初始化arena数组\n                arena = new Node[(FULL + 2) << ASHIFT];\n        }\n        // 上面分析过，只有当arena不为空才会执行slotExchange方法的\n\t\t// 所以表示刚好已有其它线程加入进来将arena初始化\n        else if (arena != null)\n            // 这里就需要去执行arenaExchange\n            return null; // caller must reroute to arenaExchange\n        else {\n            // 这里表示当前线程是以第一个线程进来交换数据\n            // 或者表示之前的数据交换已进行完毕，这里可以看作是第一个线程\n            // 将需要交换的数据先存放在当前线程变量p中\n            p.item = item;\n            // 将需要交换的数据通过CAS设置到交换区slot\n            if (U.compareAndSwapObject(this, SLOT, null, p))\n                // 交换成功后跳出自旋\n                break;\n            // CAS操作失败，表示有其它线程刚好先于当前线程将数据设置到交换区slot\n            // 将当前线程变量中的item设置为null，然后自旋获取其它线程存放在交换区slot的数据\n            p.item = null;\n        }\n    }\n\n    // await release\n    // 执行到这里表示当前线程已将需要的交换的数据放置于交换区slot中了，\n    // 等待其它线程交换数据然后唤醒当前线程\n    int h = p.hash;\n    long end = timed ? System.nanoTime() + ns : 0 L;\n    // 自旋次数\n    int spins = (NCPU > 1) ? SPINS : 1;\n    Object v;\n    // 自旋等待直到p.match不为null，也就是说等待其它线程将需要交换的数据放置于交换区slot\n    while ((v = p.match) == null) {\n        // 下面的逻辑主要是自旋等待，直到spins递减到0为止\n        if (spins > 0) {\n            h ^= h << 1;\n            h ^= h >>> 3;\n            h ^= h << 10;\n            if (h == 0)\n                h = SPINS | (int) t.getId();\n            else if (h < 0 && (--spins & ((SPINS >>> 1) - 1)) == 0)\n                Thread.yield();\n        } else if (slot != p)\n            spins = SPINS;\n        // 此处表示未设置超时或者时间未超时\n        else if (!t.isInterrupted() && arena == null &&\n            (!timed || (ns = end - System.nanoTime()) > 0 L)) {\n            // 设置线程t被当前对象阻塞\n            U.putObject(t, BLOCKER, this);\n            // 给p挂机线程的值赋值\n            p.parked = t;\n            if (slot == p)\n                // 如果slot还没有被置为null，也就表示暂未有线程过来交换数据，需要将当前线程挂起\n                U.park(false, ns);\n            // 线程被唤醒，将被挂起的线程设置为null\n            p.parked = null;\n            // 设置线程t未被任何对象阻塞\n            U.putObject(t, BLOCKER, null);\n        // 不是以上条件时(可能是arena已不为null或者超时)    \n        } else if (U.compareAndSwapObject(this, SLOT, p, null)) {\n             // arena不为null则v为null,其它为超时则v为超市对象TIMED_OUT，并且跳出循环\n            v = timed && ns <= 0 L && !t.isInterrupted() ? TIMED_OUT : null;\n            break;\n        }\n    }\n    // 取走match值，并将p中的match置为null\n    U.putOrderedObject(p, MATCH, null);\n    // 设置item为null\n    p.item = null;\n    p.hash = h;\n    // 返回交换值\n    return v;\n}\n\n\n程序首先通过participant获取当前线程节点Node。检测是否中断，如果中断return null，等待后续抛出InterruptedException异常。\n\n * 如果slot不为null，则进行slot消除，成功直接返回数据V，否则失败，则创建arena消除数组。\n * 如果slot为null，但arena不为null，则返回null，进入arenaExchange逻辑。\n * 如果slot为null，且arena也为null，则尝试占领该slot，失败重试，成功则跳出循环进入spin+block(自旋+阻塞)模式。\n\n在自旋+阻塞模式中，首先取得结束时间和自旋次数。如果match(做releasing操作的线程传递的项)为null，其首先尝试spins+随机次自旋(改自旋使用当前节点中的hash，并改变之)和退让。当自旋数为0后，假如slot发生了改变(slot != p)则重置自旋数并重试。否则假如：当前未中断&arena为null&(当前不是限时版本或者限时版本+当前时间未结束)：阻塞或者限时阻塞。假如：当前中断或者arena不为null或者当前为限时版本+时间已经结束：不限时版本：置v为null；限时版本：如果时间结束以及未中断则TIMED_OUT；否则给出null(原因是探测到arena非空或者当前线程中断)。\n\nmatch不为空时跳出循环。\n\n\n# arenaExchange(Object item, boolean timed, long ns)\n\n此方法被执行时表示多个线程进入交换区交换数据，arena数组已被初始化，此方法中的一些处理方式和slotExchange比较类似，它是通过遍历arena数组找到需要交换的数据。\n\n// timed 为true表示设置了超时时间，ns为>0的值，反之没有设置超时时间\nprivate final Object arenaExchange(Object item, boolean timed, long ns) {\n    Node[] a = arena;\n    // 获取当前线程中的存放的node\n    Node p = participant.get();\n    //index初始值0\n    for (int i = p.index;;) { // access slot at i\n        // 遍历，如果在数组中找到数据则直接交换并唤醒线程，如未找到则将需要交换给其它线程的数据放置于数组中\n        int b, m, c;\n        long j; // j is raw array offset\n        // 其实这里就是向右遍历数组，只是用到了元素在内存偏移的偏移量\n        // q实际为arena数组偏移(i + 1) *  128个地址位上的node\n        Node q = (Node) U.getObjectVolatile(a, j = (i << ASHIFT) + ABASE);\n        // 如果q不为null，并且CAS操作成功，将下标j的元素置为null\n        if (q != null && U.compareAndSwapObject(a, j, q, null)) {\n            // 表示当前线程已发现有交换的数据，然后获取数据，唤醒等待的线程\n            Object v = q.item; // release\n            q.match = item;\n            Thread w = q.parked;\n            if (w != null)\n                U.unpark(w);\n            return v;\n        // q 为null 并且 i 未超过数组边界    \n        } else if (i <= (m = (b = bound) & MMASK) && q == null) {\n             // 将需要给其它线程的item赋予给p中的item\n            p.item = item; // offer\n            if (U.compareAndSwapObject(a, j, null, p)) {\n                // 交换成功\n                long end = (timed && m == 0) ? System.nanoTime() + ns : 0 L;\n                Thread t = Thread.currentThread(); // wait\n                // 自旋直到有其它线程进入，遍历到该元素并与其交换，同时当前线程被唤醒\n                for (int h = p.hash, spins = SPINS;;) {\n                    Object v = p.match;\n                    if (v != null) {\n                        // 其它线程设置的需要交换的数据match不为null\n                        // 将match设置null,item设置为null\n                        U.putOrderedObject(p, MATCH, null);\n                        p.item = null; // clear for next use\n                        p.hash = h;\n                        return v;\n                    } else if (spins > 0) {\n                        h ^= h << 1;\n                        h ^= h >>> 3;\n                        h ^= h << 10; // xorshift\n                        if (h == 0) // initialize hash\n                            h = SPINS | (int) t.getId();\n                        else if (h < 0 && // approx 50% true\n                            (--spins & ((SPINS >>> 1) - 1)) == 0)\n                            Thread.yield(); // two yields per wait\n                    } else if (U.getObjectVolatile(a, j) != p)\n                        // 和slotExchange方法中的类似，arena数组中的数据已被CAS设置\n                       // match值还未设置，让其再自旋等待match被设置\n                        spins = SPINS; // releaser hasn\'t set match yet\n                    else if (!t.isInterrupted() && m == 0 &&\n                        (!timed ||\n                            (ns = end - System.nanoTime()) > 0 L)) {\n                        // 设置线程t被当前对象阻塞\n                        U.putObject(t, BLOCKER, this); // emulate LockSupport\n                         // 线程t赋值\n                        p.parked = t; // minimize window\n                        if (U.getObjectVolatile(a, j) == p)\n                            // 数组中对象还相等，表示线程还未被唤醒，唤醒线程\n                            U.park(false, ns);\n                        p.parked = null;\n                         // 设置线程t未被任何对象阻塞\n                        U.putObject(t, BLOCKER, null);\n                    } else if (U.getObjectVolatile(a, j) == p &&\n                        U.compareAndSwapObject(a, j, p, null)) {\n                        // 这里给bound增加加一个SEQ\n                        if (m != 0) // try to shrink\n                            U.compareAndSwapInt(this, BOUND, b, b + SEQ - 1);\n                        p.item = null;\n                        p.hash = h;\n                        i = p.index >>>= 1; // descend\n                        if (Thread.interrupted())\n                            return null;\n                        if (timed && m == 0 && ns <= 0 L)\n                            return TIMED_OUT;\n                        break; // expired; restart\n                    }\n                }\n            } else\n                // 交换失败，表示有其它线程更改了arena数组中下标i的元素\n                p.item = null; // clear offer\n        } else {\n            // 此时表示下标不在bound & MMASK或q不为null但CAS操作失败\n           // 需要更新bound变化后的值\n            if (p.bound != b) { // stale; reset\n                p.bound = b;\n                p.collides = 0;\n                // 反向遍历\n                i = (i != m || m == 0) ? m : m - 1;\n            } else if ((c = p.collides) < m || m == FULL ||\n                !U.compareAndSwapInt(this, BOUND, b, b + SEQ + 1)) {\n                 // 记录CAS失败的次数\n                p.collides = c + 1;\n                // 循环遍历\n                i = (i == 0) ? m : i - 1; // cyclically traverse\n            } else\n                // 此时表示bound值增加了SEQ+1\n                i = m + 1; // grow\n            // 设置下标\n            p.index = i;\n        }\n    }\n}\n\n\n首先通过participant取得当前节点Node，然后根据当前节点Node的index去取arena中相对应的节点node。\n\n * 前面提到过arena可以确保不同的slot在arena中是不会相冲突的，那么是怎么保证的呢？\n\narena = new Node[(FULL + 2) << ASHIFT];\n// 这个arena到底有多大呢? 我们先看FULL 和ASHIFT的定义：\nstatic final int FULL = (NCPU >= (MMASK << 1)) ? MMASK : NCPU >>> 1;\nprivate static final int ASHIFT = 7;\n\nprivate static final int NCPU = Runtime.getRuntime().availableProcessors();\nprivate static final int MMASK = 0xff;        // 255\n// 假如我的机器NCPU = 8 ，则得到的是768大小的arena数组。然后通过以下代码取得在arena中的节点：\n\nNode q = (Node)U.getObjectVolatile(a, j = (i << ASHIFT) + ABASE);\n// 它仍然是通过右移ASHIFT位来取得Node的，ABASE定义如下：\n\nClass<?> ak = Node[].class;\nABASE = U.arrayBaseOffset(ak) + (1 << ASHIFT);\n// U.arrayBaseOffset获取对象头长度，数组元素的大小可以通过unsafe.arrayIndexScale(T[].class) 方法获取到。这也就是说要访问类型为T的第N个元素的话，你的偏移量offset应该是arrayOffset+N*arrayScale。也就是说BASE = arrayOffset+ 128 。\n\n\n * 用@sun.misc.Contended来规避伪共享？\n\n伪共享说明：假设一个类的两个相互独立的属性a和b在内存地址上是连续的(比如FIFO队列的头尾指针)，那么它们通常会被加载到相同的cpu cache line里面。并发情况下，如果一个线程修改了a，会导致整个cache line失效(包括b)，这时另一个线程来读b，就需要从内存里再次加载了，这种多线程频繁修改ab的情况下，虽然a和b看似独立，但它们会互相干扰，非常影响性能。\n\n我们再看Node节点的定义, 在Java 8 中我们是可以利用sun.misc.Contended来规避伪共享的。所以说通过 << ASHIFT方式加上sun.misc.Contended，所以使得任意两个可用Node不会再同一个缓存行中。\n\n@sun.misc.Contended static final class Node{\n....\n}\n\n\n我们再次回到arenaExchange()。取得arena中的node节点后，如果定位的节点q 不为空，且CAS操作成功，则交换数据，返回交换的数据，唤醒等待的线程。\n\n * 如果q等于null且下标在bound & MMASK范围之内，则尝试占领该位置，如果成功，则采用自旋 + 阻塞的方式进行等待交换数据。\n * 如果下标不在bound & MMASK范围之内获取由于q不为null但是竞争失败的时候：消除p。加入bound 不等于当前节点的bond(b != p.bound)，则更新p.bound = b，collides = 0 ，i = m或者m - 1。如果冲突的次数不到m 获取m 已经为最大值或者修改当前bound的值失败，则通过增加一次collides以及循环递减下标i的值；否则更新当前bound的值成功：我们令i为m+1即为此时最大的下标。最后更新当前index的值。\n\n\n# 更深入理解\n\n * SynchronousQueue对比？\n\nExchanger是一种线程间安全交换数据的机制。可以和之前分析过的SynchronousQueue对比一下：线程A通过SynchronousQueue将数据a交给线程B；线程A通过Exchanger和线程B交换数据，线程A把数据a交给线程B，同时线程B把数据b交给线程A。可见，SynchronousQueue是交给一个数据，Exchanger是交换两个数据。\n\n * 不同JDK实现有何差别？\n   \n   * 在JDK5中Exchanger被设计成一个容量为1的容器，存放一个等待线程，直到有另外线程到来就会发生数据交换，然后清空容器，等到下一个到来的线程。\n   * 从JDK6开始，Exchanger用了类似ConcurrentMap的分段思想，提供了多个slot，增加了并发执行时的吞吐量。\n\nJDK1.6实现可以参考 这里在新窗口打开\n\n\n# Exchanger示例\n\n来一个非常经典的并发问题：你有相同的数据buffer，一个或多个数据生产者，和一个或多个数据消费者。只是Exchange类只能同步2个线程，所以你只能在你的生产者和消费者问题中只有一个生产者和一个消费者时使用这个类。\n\npublic class Test {\n    static class Producer extends Thread {\n        private Exchanger<Integer> exchanger;\n        private static int data = 0;\n        Producer(String name, Exchanger<Integer> exchanger) {\n            super("Producer-" + name);\n            this.exchanger = exchanger;\n        }\n\n        @Override\n        public void run() {\n            for (int i=1; i<5; i++) {\n                try {\n                    TimeUnit.SECONDS.sleep(1);\n                    data = i;\n                    System.out.println(getName()+" 交换前:" + data);\n                    data = exchanger.exchange(data);\n                    System.out.println(getName()+" 交换后:" + data);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    static class Consumer extends Thread {\n        private Exchanger<Integer> exchanger;\n        private static int data = 0;\n        Consumer(String name, Exchanger<Integer> exchanger) {\n            super("Consumer-" + name);\n            this.exchanger = exchanger;\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                data = 0;\n                System.out.println(getName()+" 交换前:" + data);\n                try {\n                    TimeUnit.SECONDS.sleep(1);\n                    data = exchanger.exchange(data);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(getName()+" 交换后:" + data);\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        Exchanger<Integer> exchanger = new Exchanger<Integer>();\n        new Producer("", exchanger).start();\n        new Consumer("", exchanger).start();\n        TimeUnit.SECONDS.sleep(7);\n        System.exit(-1);\n    }\n}\n\n\n可以看到，其结果可能如下：\n\nConsumer- 交换前:0\nProducer- 交换前:1\nConsumer- 交换后:1\nConsumer- 交换前:0\nProducer- 交换后:0\nProducer- 交换前:2\nProducer- 交换后:0\nConsumer- 交换后:2\nConsumer- 交换前:0\nProducer- 交换前:3\nProducer- 交换后:0\nConsumer- 交换后:3\nConsumer- 交换前:0\nProducer- 交换前:4\nProducer- 交换后:0\nConsumer- 交换后:4\nConsumer- 交换前:0\n\n\n\n# 参考文章\n\n * https://cloud.tencent.com/developer/article/1529492\n * https://coderbee.net/index.php/concurrent/20140424/897\n * https://www.cnblogs.com/wanly3643/p/3939552.html\n * https://www.iteye.com/blog/brokendreams-2253956\n * https://blog.csdn.net/u014634338/article/details/78385521\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-tool-exchanger.html',normalizedContent:'# juc工具类: exchanger详解\n\n> exchanger是用于线程协作的工具类, 主要用于两个线程之间的数据交换。\n\n * juc工具类: exchanger详解\n   * 带着bat大厂的面试问题去理解exchanger\n   * exchanger简介\n   * exchanger实现机制\n   * exchanger源码解析\n     * 内部类 - participant\n     * 内部类 - node\n     * 核心属性\n     * 构造函数\n     * 核心方法 - exchange(v x)\n     * slotexchange(object item, boolean timed, long ns)\n     * arenaexchange(object item, boolean timed, long ns)\n   * 参考文章\n\n\n# 带着bat大厂的面试问题去理解exchanger\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解exchanger。\n\n * exchanger主要解决什么问题?\n * 对比synchronousqueue，为什么说exchanger可被视为 synchronousqueue 的双向形式?\n * exchanger在不同的jdk版本中实现有什么差别?\n * exchanger实现机制?\n * exchanger已经有了slot单节点，为什么会加入arena node数组? 什么时候会用到数组?\n * arena可以确保不同的slot在arena中是不会相冲突的，那么是怎么保证的呢?\n * 什么是伪共享，exchanger中如何体现的?\n * exchanger实现举例\n\n\n# exchanger简介\n\nexchanger用于进行两个线程之间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange()方法交换数据，当一个线程先执行exchange()方法后，它会一直等待第二个线程也执行exchange()方法，当这两个线程到达同步点时，这两个线程就可以交换数据了。\n\n\n# exchanger实现机制\n\nfor (;;) {\n    if (slot is empty) { // offer\n        // slot为空时，将item 设置到node 中        \n        place item in a node;\n        if (can cas slot from empty to node) {\n            // 当将node通过cas交换到slot中时，挂起线程等待被唤醒\n            wait for release;\n            // 被唤醒后返回node中匹配到的item\n            return matching item in node;\n        }\n    } else if (can cas slot from node to empty) { // release\n         // 将slot设置为空\n        // 获取node中的item，将需要交换的数据设置到匹配的item\n        get the item in node;\n        set matching item in node;\n        // 唤醒等待的线程\n        release waiting thread;\n    }\n    // else retry on cas failure\n}\n\n\n比如有2条线程a和b，a线程交换数据时，发现slot为空，则将需要交换的数据放在slot中等待其它线程进来交换数据，等线程b进来，读取a设置的数据，然后设置线程b需要交换的数据，然后唤醒a线程，原理就是这么简单。但是当多个线程之间进行交换数据时就会出现问题，所以exchanger加入了slot数组。\n\n\n# exchanger源码解析\n\n\n# 内部类 - participant\n\nstatic final class participant extends threadlocal<node> {\n    public node initialvalue() { return new node(); }\n}\n\n\nparticipant的作用是为每个线程保留唯一的一个node节点, 它继承threadlocal，说明每个线程具有不同的状态。\n\n\n# 内部类 - node\n\n@sun.misc.contended static final class node {\n     // arena的下标，多个槽位的时候利用\n    int index; \n    // 上一次记录的exchanger.bound\n    int bound; \n    // 在当前bound下cas失败的次数；\n    int collides;\n    // 用于自旋；\n    int hash; \n    // 这个线程的当前项，也就是需要交换的数据；\n    object item; \n    //做releasing操作的线程传递的项；\n    volatile object match; \n    //挂起时设置线程值，其他情况下为null；\n    volatile thread parked;\n}\n\n\n在node定义中有两个变量值得思考：bound以及collides。前面提到了数组area是为了避免竞争而产生的，如果系统不存在竞争问题，那么完全没有必要开辟一个高效的arena来徒增系统的复杂性。首先通过单个slot的exchanger来交换数据，当探测到竞争时将安排不同的位置的slot来保存线程node，并且可以确保没有slot会在同一个缓存行上。如何来判断会有竞争呢? cas替换slot失败，如果失败，则通过记录冲突次数来扩展arena的尺寸，我们在记录冲突的过程中会跟踪“bound”的值，以及会重新计算冲突次数在bound的值被改变时。\n\n\n# 核心属性\n\nprivate final participant participant;\nprivate volatile node[] arena;\nprivate volatile node slot;\n\n\n * 为什么会有 arena数组槽?\n\nslot为单个槽，arena为数组槽, 他们都是node类型。在这里可能会感觉到疑惑，slot作为exchanger交换数据的场景，应该只需要一个就可以了啊? 为何还多了一个participant 和数组类型的arena呢? 一个slot交换场所原则上来说应该是可以的，但实际情况却不是如此，多个参与者使用同一个交换场所时，会存在严重伸缩性问题。既然单个交换场所存在问题，那么我们就安排多个，也就是数组arena。通过数组arena来安排不同的线程使用不同的slot来降低竞争问题，并且可以保证最终一定会成对交换数据。但是exchanger不是一来就会生成arena数组来降低竞争，只有当产生竞争是才会生成arena数组。\n\n * 那么怎么将node与当前线程绑定呢？\n\nparticipant，participant 的作用就是为每个线程保留唯一的一个node节点，它继承threadlocal，同时在node节点中记录在arena中的下标index。\n\n\n# 构造函数\n\n/**\n* creates a new exchanger.\n*/\npublic exchanger() {\n    participant = new participant();\n}\n\n\n初始化participant对象。\n\n\n# 核心方法 - exchange(v x)\n\n等待另一个线程到达此交换点(除非当前线程被中断)，然后将给定的对象传送给该线程，并接收该线程的对象。\n\npublic v exchange(v x) throws interruptedexception {\n    object v;\n    // 当参数为null时需要将item设置为空的对象\n    object item = (x == null) ? null_item : x; // translate null args\n    // 注意到这里的这个表达式是整个方法的核心\n    if ((arena != null ||\n            (v = slotexchange(item, false, 0 l)) == null) &&\n        ((thread.interrupted() || // disambiguates null return\n            (v = arenaexchange(item, false, 0 l)) == null)))\n        throw new interruptedexception();\n    return (v == null_item) ? null : (v) v;\n}\n\n\n这个方法比较好理解：arena为数组槽，如果为null，则执行slotexchange()方法，否则判断线程是否中断，如果中断值抛出interruptedexception异常，没有中断则执行arenaexchange()方法。整套逻辑就是：如果slotexchange(object item, boolean timed, long ns)方法执行失败了就执行arenaexchange(object item, boolean timed, long ns)方法，最后返回结果v。\n\nnull_item 为一个空节点，其实就是一个object对象而已，slotexchange()为单个slot交换。\n\n\n# slotexchange(object item, boolean timed, long ns)\n\nprivate final object slotexchange(object item, boolean timed, long ns) {\n    // 获取当前线程node对象\n    node p = participant.get();\n    // 当前线程\n    thread t = thread.currentthread();\n    // 若果线程被中断，就直接返回null\n    if (t.isinterrupted()) // preserve interrupt status so caller can recheck\n        return null;\n\t// 自旋\n    for (node q;;) {\n        // 将slot值赋给q\n        if ((q = slot) != null) {\n             // slot 不为null，即表示已有线程已经把需要交换的数据设置在slot中了\n\t\t\t// 通过cas将slot设置成null\n            if (u.compareandswapobject(this, slot, q, null)) {\n                // cas操作成功后，将slot中的item赋值给对象v，以便返回。\n                // 这里也是就读取之前线程要交换的数据\n                object v = q.item;\n                // 将当前线程需要交给的数据设置在q中的match\n                q.match = item;\n                 // 获取被挂起的线程\n                thread w = q.parked;\n                if (w != null)\n                    // 如果线程不为null，唤醒它\n                    u.unpark(w);\n                // 返回其他线程给的v\n                return v;\n            }\n            // create arena on contention, but continue until slot null\n            // cas 操作失败，表示有其它线程竞争，在此线程之前将数据已取走\n            // ncpu:cpu的核数\n            // bound == 0 表示arena数组未初始化过，cas操作bound将其增加seq\n            if (ncpu > 1 && bound == 0 &&\n                u.compareandswapint(this, bound, 0, seq))\n                // 初始化arena数组\n                arena = new node[(full + 2) << ashift];\n        }\n        // 上面分析过，只有当arena不为空才会执行slotexchange方法的\n\t\t// 所以表示刚好已有其它线程加入进来将arena初始化\n        else if (arena != null)\n            // 这里就需要去执行arenaexchange\n            return null; // caller must reroute to arenaexchange\n        else {\n            // 这里表示当前线程是以第一个线程进来交换数据\n            // 或者表示之前的数据交换已进行完毕，这里可以看作是第一个线程\n            // 将需要交换的数据先存放在当前线程变量p中\n            p.item = item;\n            // 将需要交换的数据通过cas设置到交换区slot\n            if (u.compareandswapobject(this, slot, null, p))\n                // 交换成功后跳出自旋\n                break;\n            // cas操作失败，表示有其它线程刚好先于当前线程将数据设置到交换区slot\n            // 将当前线程变量中的item设置为null，然后自旋获取其它线程存放在交换区slot的数据\n            p.item = null;\n        }\n    }\n\n    // await release\n    // 执行到这里表示当前线程已将需要的交换的数据放置于交换区slot中了，\n    // 等待其它线程交换数据然后唤醒当前线程\n    int h = p.hash;\n    long end = timed ? system.nanotime() + ns : 0 l;\n    // 自旋次数\n    int spins = (ncpu > 1) ? spins : 1;\n    object v;\n    // 自旋等待直到p.match不为null，也就是说等待其它线程将需要交换的数据放置于交换区slot\n    while ((v = p.match) == null) {\n        // 下面的逻辑主要是自旋等待，直到spins递减到0为止\n        if (spins > 0) {\n            h ^= h << 1;\n            h ^= h >>> 3;\n            h ^= h << 10;\n            if (h == 0)\n                h = spins | (int) t.getid();\n            else if (h < 0 && (--spins & ((spins >>> 1) - 1)) == 0)\n                thread.yield();\n        } else if (slot != p)\n            spins = spins;\n        // 此处表示未设置超时或者时间未超时\n        else if (!t.isinterrupted() && arena == null &&\n            (!timed || (ns = end - system.nanotime()) > 0 l)) {\n            // 设置线程t被当前对象阻塞\n            u.putobject(t, blocker, this);\n            // 给p挂机线程的值赋值\n            p.parked = t;\n            if (slot == p)\n                // 如果slot还没有被置为null，也就表示暂未有线程过来交换数据，需要将当前线程挂起\n                u.park(false, ns);\n            // 线程被唤醒，将被挂起的线程设置为null\n            p.parked = null;\n            // 设置线程t未被任何对象阻塞\n            u.putobject(t, blocker, null);\n        // 不是以上条件时(可能是arena已不为null或者超时)    \n        } else if (u.compareandswapobject(this, slot, p, null)) {\n             // arena不为null则v为null,其它为超时则v为超市对象timed_out，并且跳出循环\n            v = timed && ns <= 0 l && !t.isinterrupted() ? timed_out : null;\n            break;\n        }\n    }\n    // 取走match值，并将p中的match置为null\n    u.putorderedobject(p, match, null);\n    // 设置item为null\n    p.item = null;\n    p.hash = h;\n    // 返回交换值\n    return v;\n}\n\n\n程序首先通过participant获取当前线程节点node。检测是否中断，如果中断return null，等待后续抛出interruptedexception异常。\n\n * 如果slot不为null，则进行slot消除，成功直接返回数据v，否则失败，则创建arena消除数组。\n * 如果slot为null，但arena不为null，则返回null，进入arenaexchange逻辑。\n * 如果slot为null，且arena也为null，则尝试占领该slot，失败重试，成功则跳出循环进入spin+block(自旋+阻塞)模式。\n\n在自旋+阻塞模式中，首先取得结束时间和自旋次数。如果match(做releasing操作的线程传递的项)为null，其首先尝试spins+随机次自旋(改自旋使用当前节点中的hash，并改变之)和退让。当自旋数为0后，假如slot发生了改变(slot != p)则重置自旋数并重试。否则假如：当前未中断&arena为null&(当前不是限时版本或者限时版本+当前时间未结束)：阻塞或者限时阻塞。假如：当前中断或者arena不为null或者当前为限时版本+时间已经结束：不限时版本：置v为null；限时版本：如果时间结束以及未中断则timed_out；否则给出null(原因是探测到arena非空或者当前线程中断)。\n\nmatch不为空时跳出循环。\n\n\n# arenaexchange(object item, boolean timed, long ns)\n\n此方法被执行时表示多个线程进入交换区交换数据，arena数组已被初始化，此方法中的一些处理方式和slotexchange比较类似，它是通过遍历arena数组找到需要交换的数据。\n\n// timed 为true表示设置了超时时间，ns为>0的值，反之没有设置超时时间\nprivate final object arenaexchange(object item, boolean timed, long ns) {\n    node[] a = arena;\n    // 获取当前线程中的存放的node\n    node p = participant.get();\n    //index初始值0\n    for (int i = p.index;;) { // access slot at i\n        // 遍历，如果在数组中找到数据则直接交换并唤醒线程，如未找到则将需要交换给其它线程的数据放置于数组中\n        int b, m, c;\n        long j; // j is raw array offset\n        // 其实这里就是向右遍历数组，只是用到了元素在内存偏移的偏移量\n        // q实际为arena数组偏移(i + 1) *  128个地址位上的node\n        node q = (node) u.getobjectvolatile(a, j = (i << ashift) + abase);\n        // 如果q不为null，并且cas操作成功，将下标j的元素置为null\n        if (q != null && u.compareandswapobject(a, j, q, null)) {\n            // 表示当前线程已发现有交换的数据，然后获取数据，唤醒等待的线程\n            object v = q.item; // release\n            q.match = item;\n            thread w = q.parked;\n            if (w != null)\n                u.unpark(w);\n            return v;\n        // q 为null 并且 i 未超过数组边界    \n        } else if (i <= (m = (b = bound) & mmask) && q == null) {\n             // 将需要给其它线程的item赋予给p中的item\n            p.item = item; // offer\n            if (u.compareandswapobject(a, j, null, p)) {\n                // 交换成功\n                long end = (timed && m == 0) ? system.nanotime() + ns : 0 l;\n                thread t = thread.currentthread(); // wait\n                // 自旋直到有其它线程进入，遍历到该元素并与其交换，同时当前线程被唤醒\n                for (int h = p.hash, spins = spins;;) {\n                    object v = p.match;\n                    if (v != null) {\n                        // 其它线程设置的需要交换的数据match不为null\n                        // 将match设置null,item设置为null\n                        u.putorderedobject(p, match, null);\n                        p.item = null; // clear for next use\n                        p.hash = h;\n                        return v;\n                    } else if (spins > 0) {\n                        h ^= h << 1;\n                        h ^= h >>> 3;\n                        h ^= h << 10; // xorshift\n                        if (h == 0) // initialize hash\n                            h = spins | (int) t.getid();\n                        else if (h < 0 && // approx 50% true\n                            (--spins & ((spins >>> 1) - 1)) == 0)\n                            thread.yield(); // two yields per wait\n                    } else if (u.getobjectvolatile(a, j) != p)\n                        // 和slotexchange方法中的类似，arena数组中的数据已被cas设置\n                       // match值还未设置，让其再自旋等待match被设置\n                        spins = spins; // releaser hasn\'t set match yet\n                    else if (!t.isinterrupted() && m == 0 &&\n                        (!timed ||\n                            (ns = end - system.nanotime()) > 0 l)) {\n                        // 设置线程t被当前对象阻塞\n                        u.putobject(t, blocker, this); // emulate locksupport\n                         // 线程t赋值\n                        p.parked = t; // minimize window\n                        if (u.getobjectvolatile(a, j) == p)\n                            // 数组中对象还相等，表示线程还未被唤醒，唤醒线程\n                            u.park(false, ns);\n                        p.parked = null;\n                         // 设置线程t未被任何对象阻塞\n                        u.putobject(t, blocker, null);\n                    } else if (u.getobjectvolatile(a, j) == p &&\n                        u.compareandswapobject(a, j, p, null)) {\n                        // 这里给bound增加加一个seq\n                        if (m != 0) // try to shrink\n                            u.compareandswapint(this, bound, b, b + seq - 1);\n                        p.item = null;\n                        p.hash = h;\n                        i = p.index >>>= 1; // descend\n                        if (thread.interrupted())\n                            return null;\n                        if (timed && m == 0 && ns <= 0 l)\n                            return timed_out;\n                        break; // expired; restart\n                    }\n                }\n            } else\n                // 交换失败，表示有其它线程更改了arena数组中下标i的元素\n                p.item = null; // clear offer\n        } else {\n            // 此时表示下标不在bound & mmask或q不为null但cas操作失败\n           // 需要更新bound变化后的值\n            if (p.bound != b) { // stale; reset\n                p.bound = b;\n                p.collides = 0;\n                // 反向遍历\n                i = (i != m || m == 0) ? m : m - 1;\n            } else if ((c = p.collides) < m || m == full ||\n                !u.compareandswapint(this, bound, b, b + seq + 1)) {\n                 // 记录cas失败的次数\n                p.collides = c + 1;\n                // 循环遍历\n                i = (i == 0) ? m : i - 1; // cyclically traverse\n            } else\n                // 此时表示bound值增加了seq+1\n                i = m + 1; // grow\n            // 设置下标\n            p.index = i;\n        }\n    }\n}\n\n\n首先通过participant取得当前节点node，然后根据当前节点node的index去取arena中相对应的节点node。\n\n * 前面提到过arena可以确保不同的slot在arena中是不会相冲突的，那么是怎么保证的呢？\n\narena = new node[(full + 2) << ashift];\n// 这个arena到底有多大呢? 我们先看full 和ashift的定义：\nstatic final int full = (ncpu >= (mmask << 1)) ? mmask : ncpu >>> 1;\nprivate static final int ashift = 7;\n\nprivate static final int ncpu = runtime.getruntime().availableprocessors();\nprivate static final int mmask = 0xff;        // 255\n// 假如我的机器ncpu = 8 ，则得到的是768大小的arena数组。然后通过以下代码取得在arena中的节点：\n\nnode q = (node)u.getobjectvolatile(a, j = (i << ashift) + abase);\n// 它仍然是通过右移ashift位来取得node的，abase定义如下：\n\nclass<?> ak = node[].class;\nabase = u.arraybaseoffset(ak) + (1 << ashift);\n// u.arraybaseoffset获取对象头长度，数组元素的大小可以通过unsafe.arrayindexscale(t[].class) 方法获取到。这也就是说要访问类型为t的第n个元素的话，你的偏移量offset应该是arrayoffset+n*arrayscale。也就是说base = arrayoffset+ 128 。\n\n\n * 用@sun.misc.contended来规避伪共享？\n\n伪共享说明：假设一个类的两个相互独立的属性a和b在内存地址上是连续的(比如fifo队列的头尾指针)，那么它们通常会被加载到相同的cpu cache line里面。并发情况下，如果一个线程修改了a，会导致整个cache line失效(包括b)，这时另一个线程来读b，就需要从内存里再次加载了，这种多线程频繁修改ab的情况下，虽然a和b看似独立，但它们会互相干扰，非常影响性能。\n\n我们再看node节点的定义, 在java 8 中我们是可以利用sun.misc.contended来规避伪共享的。所以说通过 << ashift方式加上sun.misc.contended，所以使得任意两个可用node不会再同一个缓存行中。\n\n@sun.misc.contended static final class node{\n....\n}\n\n\n我们再次回到arenaexchange()。取得arena中的node节点后，如果定位的节点q 不为空，且cas操作成功，则交换数据，返回交换的数据，唤醒等待的线程。\n\n * 如果q等于null且下标在bound & mmask范围之内，则尝试占领该位置，如果成功，则采用自旋 + 阻塞的方式进行等待交换数据。\n * 如果下标不在bound & mmask范围之内获取由于q不为null但是竞争失败的时候：消除p。加入bound 不等于当前节点的bond(b != p.bound)，则更新p.bound = b，collides = 0 ，i = m或者m - 1。如果冲突的次数不到m 获取m 已经为最大值或者修改当前bound的值失败，则通过增加一次collides以及循环递减下标i的值；否则更新当前bound的值成功：我们令i为m+1即为此时最大的下标。最后更新当前index的值。\n\n\n# 更深入理解\n\n * synchronousqueue对比？\n\nexchanger是一种线程间安全交换数据的机制。可以和之前分析过的synchronousqueue对比一下：线程a通过synchronousqueue将数据a交给线程b；线程a通过exchanger和线程b交换数据，线程a把数据a交给线程b，同时线程b把数据b交给线程a。可见，synchronousqueue是交给一个数据，exchanger是交换两个数据。\n\n * 不同jdk实现有何差别？\n   \n   * 在jdk5中exchanger被设计成一个容量为1的容器，存放一个等待线程，直到有另外线程到来就会发生数据交换，然后清空容器，等到下一个到来的线程。\n   * 从jdk6开始，exchanger用了类似concurrentmap的分段思想，提供了多个slot，增加了并发执行时的吞吐量。\n\njdk1.6实现可以参考 这里在新窗口打开\n\n\n# exchanger示例\n\n来一个非常经典的并发问题：你有相同的数据buffer，一个或多个数据生产者，和一个或多个数据消费者。只是exchange类只能同步2个线程，所以你只能在你的生产者和消费者问题中只有一个生产者和一个消费者时使用这个类。\n\npublic class test {\n    static class producer extends thread {\n        private exchanger<integer> exchanger;\n        private static int data = 0;\n        producer(string name, exchanger<integer> exchanger) {\n            super("producer-" + name);\n            this.exchanger = exchanger;\n        }\n\n        @override\n        public void run() {\n            for (int i=1; i<5; i++) {\n                try {\n                    timeunit.seconds.sleep(1);\n                    data = i;\n                    system.out.println(getname()+" 交换前:" + data);\n                    data = exchanger.exchange(data);\n                    system.out.println(getname()+" 交换后:" + data);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n        }\n    }\n\n    static class consumer extends thread {\n        private exchanger<integer> exchanger;\n        private static int data = 0;\n        consumer(string name, exchanger<integer> exchanger) {\n            super("consumer-" + name);\n            this.exchanger = exchanger;\n        }\n\n        @override\n        public void run() {\n            while (true) {\n                data = 0;\n                system.out.println(getname()+" 交换前:" + data);\n                try {\n                    timeunit.seconds.sleep(1);\n                    data = exchanger.exchange(data);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n                system.out.println(getname()+" 交换后:" + data);\n            }\n        }\n    }\n\n    public static void main(string[] args) throws interruptedexception {\n        exchanger<integer> exchanger = new exchanger<integer>();\n        new producer("", exchanger).start();\n        new consumer("", exchanger).start();\n        timeunit.seconds.sleep(7);\n        system.exit(-1);\n    }\n}\n\n\n可以看到，其结果可能如下：\n\nconsumer- 交换前:0\nproducer- 交换前:1\nconsumer- 交换后:1\nconsumer- 交换前:0\nproducer- 交换后:0\nproducer- 交换前:2\nproducer- 交换后:0\nconsumer- 交换后:2\nconsumer- 交换前:0\nproducer- 交换前:3\nproducer- 交换后:0\nconsumer- 交换后:3\nconsumer- 交换前:0\nproducer- 交换前:4\nproducer- 交换后:0\nconsumer- 交换后:4\nconsumer- 交换前:0\n\n\n\n# 参考文章\n\n * https://cloud.tencent.com/developer/article/1529492\n * https://coderbee.net/index.php/concurrent/20140424/897\n * https://www.cnblogs.com/wanly3643/p/3939552.html\n * https://www.iteye.com/blog/brokendreams-2253956\n * https://blog.csdn.net/u014634338/article/details/78385521\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-tool-exchanger.html',charsets:{cjk:!0}},{title:"JUC工具类: Semaphore详解",frontmatter:{},regularPath:"/java/thread/java-thread-x-juc-tool-semaphore.html",relativePath:"java/thread/java-thread-x-juc-tool-semaphore.md",key:"v-58f4b370",path:"/java/thread/java-thread-x-juc-tool-semaphore.html",headers:[{level:2,title:"JUC工具类: Semaphore详解",slug:"juc工具类-semaphore详解",normalizedTitle:"juc工具类: semaphore详解",charIndex:2},{level:2,title:"带着BAT大厂的面试问题去理解",slug:"带着bat大厂的面试问题去理解",normalizedTitle:"带着bat大厂的面试问题去理解",charIndex:173},{level:2,title:"Semaphore源码分析",slug:"semaphore源码分析",normalizedTitle:"semaphore源码分析",charIndex:194},{level:3,title:"类的继承关系",slug:"类的继承关系",normalizedTitle:"类的继承关系",charIndex:215},{level:3,title:"类的内部类",slug:"类的内部类",normalizedTitle:"类的内部类",charIndex:229},{level:3,title:"类的内部类 - Sync类",slug:"类的内部类-sync类",normalizedTitle:"类的内部类 - sync类",charIndex:242},{level:3,title:"类的内部类 - NonfairSync类",slug:"类的内部类-nonfairsync类",normalizedTitle:"类的内部类 - nonfairsync类",charIndex:263},{level:3,title:"类的内部类 - FairSync类",slug:"类的内部类-fairsync类",normalizedTitle:"类的内部类 - fairsync类",charIndex:291},{level:3,title:"类的属性",slug:"类的属性",normalizedTitle:"类的属性",charIndex:316},{level:3,title:"类的构造函数",slug:"类的构造函数",normalizedTitle:"类的构造函数",charIndex:328},{level:3,title:"核心函数分析 - acquire函数",slug:"核心函数分析-acquire函数",normalizedTitle:"核心函数分析 - acquire函数",charIndex:342},{level:3,title:"核心函数分析 - release函数",slug:"核心函数分析-release函数",normalizedTitle:"核心函数分析 - release函数",charIndex:368},{level:2,title:"Semaphore示例",slug:"semaphore示例",normalizedTitle:"semaphore示例",charIndex:392},{level:2,title:"更深入理解",slug:"更深入理解",normalizedTitle:"更深入理解",charIndex:409},{level:3,title:"单独使用Semaphore是不会使用到AQS的条件队列的",slug:"单独使用semaphore是不会使用到aqs的条件队列的",normalizedTitle:"单独使用semaphore是不会使用到aqs的条件队列的",charIndex:422},{level:3,title:"场景问题",slug:"场景问题",normalizedTitle:"场景问题",charIndex:458},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:750}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"JUC工具类: Semaphore详解 带着BAT大厂的面试问题去理解 Semaphore源码分析 类的继承关系 类的内部类 类的内部类 - Sync类 类的内部类 - NonfairSync类 类的内部类 - FairSync类 类的属性 类的构造函数 核心函数分析 - acquire函数 核心函数分析 - release函数 Semaphore示例 更深入理解 单独使用Semaphore是不会使用到AQS的条件队列的 场景问题 参考文章",content:'# JUC工具类: Semaphore详解\n\n> Semaphore底层是基于AbstractQueuedSynchronizer来实现的。Semaphore称为计数信号量，它允许n个任务同时访问某个资源，可以将信号量看做是在向外分发使用资源的许可证，只有成功获取许可证，才能使用资源。\n\n * JUC工具类: Semaphore详解\n   * 带着BAT大厂的面试问题去理解\n   * Semaphore源码分析\n     * 类的继承关系\n     * 类的内部类\n     * 类的内部类 - Sync类\n     * 类的内部类 - NonfairSync类\n     * 类的内部类 - FairSync类\n     * 类的属性\n     * 类的构造函数\n     * 核心函数分析 - acquire函数\n     * 核心函数分析 - release函数\n   * Semaphore示例\n   * 更深入理解\n     * 单独使用Semaphore是不会使用到AQS的条件队列的\n     * 场景问题\n       * semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么?\n       * semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么?\n       * semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire(2)方法，此线程能够获取到足够的令牌并继续运行吗?\n       * semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗?\n   * 参考文章\n\n\n# 带着BAT大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 什么是Semaphore?\n * Semaphore内部原理?\n * Semaphore常用方法有哪些? 如何实现线程同步和互斥的?\n * Semaphore适合用在什么场景?\n * 单独使用Semaphore是不会使用到AQS的条件队列?\n * Semaphore中申请令牌(acquire)、释放令牌(release)的实现?\n * Semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么?\n * Semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么?\n * Semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire(2)方法，此线程能够获取到足够的令牌并继续运行吗?\n * Semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗?\n\n\n# Semaphore源码分析\n\n\n# 类的继承关系\n\npublic class Semaphore implements java.io.Serializable {}\n\n\n说明: Semaphore实现了Serializable接口，即可以进行序列化。\n\n\n# 类的内部类\n\nSemaphore总共有三个内部类，并且三个内部类是紧密相关的，下面先看三个类的关系。\n\n\n\n说明: Semaphore与ReentrantLock的内部类的结构相同，类内部总共存在Sync、NonfairSync、FairSync三个类，NonfairSync与FairSync类继承自Sync类，Sync类继承自AbstractQueuedSynchronizer抽象类。下面逐个进行分析。\n\n\n# 类的内部类 - Sync类\n\nSync类的源码如下\n\n// 内部类，继承自AQS\nabstract static class Sync extends AbstractQueuedSynchronizer {\n    // 版本号\n    private static final long serialVersionUID = 1192457210091910933L;\n    \n    // 构造函数\n    Sync(int permits) {\n        // 设置状态数\n        setState(permits);\n    }\n    \n    // 获取许可\n    final int getPermits() {\n        return getState();\n    }\n\n    // 共享模式下非公平策略获取\n    final int nonfairTryAcquireShared(int acquires) {\n        for (;;) { // 无限循环\n            // 获取许可数\n            int available = getState();\n            // 剩余的许可\n            int remaining = available - acquires;\n            if (remaining < 0 ||\n                compareAndSetState(available, remaining)) // 许可小于0或者比较并且设置状态成功\n                return remaining;\n        }\n    }\n    \n    // 共享模式下进行释放\n    protected final boolean tryReleaseShared(int releases) {\n        for (;;) { // 无限循环\n            // 获取许可\n            int current = getState();\n            // 可用的许可\n            int next = current + releases;\n            if (next < current) // overflow\n                throw new Error("Maximum permit count exceeded");\n            if (compareAndSetState(current, next)) // 比较并进行设置成功\n                return true;\n        }\n    }\n\n    // 根据指定的缩减量减小可用许可的数目\n    final void reducePermits(int reductions) {\n        for (;;) { // 无限循环\n            // 获取许可\n            int current = getState();\n            // 可用的许可\n            int next = current - reductions;\n            if (next > current) // underflow\n                throw new Error("Permit count underflow");\n            if (compareAndSetState(current, next)) // 比较并进行设置成功\n                return;\n        }\n    }\n\n    // 获取并返回立即可用的所有许可\n    final int drainPermits() {\n        for (;;) { // 无限循环\n            // 获取许可\n            int current = getState();\n            if (current == 0 || compareAndSetState(current, 0)) // 许可为0或者比较并设置成功\n                return current;\n        }\n    }\n}\n\n\n说明: Sync类的属性相对简单，只有一个版本号，Sync类存在如下方法和作用如下。\n\n\n\n\n# 类的内部类 - NonfairSync类\n\nNonfairSync类继承了Sync类，表示采用非公平策略获取资源，其只有一个tryAcquireShared方法，重写了AQS的该方法，其源码如下:\n\nstatic final class NonfairSync extends Sync {\n    // 版本号\n    private static final long serialVersionUID = -2694183684443567898L;\n    \n    // 构造函数\n    NonfairSync(int permits) {\n        super(permits);\n    }\n    // 共享模式下获取\n    protected int tryAcquireShared(int acquires) {\n        return nonfairTryAcquireShared(acquires);\n    }\n}\n\n\n说明: 从tryAcquireShared方法的源码可知，其会调用父类Sync的nonfairTryAcquireShared方法，表示按照非公平策略进行资源的获取。\n\n\n# 类的内部类 - FairSync类\n\nFairSync类继承了Sync类，表示采用公平策略获取资源，其只有一个tryAcquireShared方法，重写了AQS的该方法，其源码如下。\n\nprotected int tryAcquireShared(int acquires) {\n    for (;;) { // 无限循环\n        if (hasQueuedPredecessors()) // 同步队列中存在其他节点\n            return -1;\n        // 获取许可\n        int available = getState();\n        // 剩余的许可\n        int remaining = available - acquires;\n        if (remaining < 0 ||\n            compareAndSetState(available, remaining)) // 剩余的许可小于0或者比较设置成功\n            return remaining;\n    }\n}\n\n\n说明: 从tryAcquireShared方法的源码可知，它使用公平策略来获取资源，它会判断同步队列中是否存在其他的等待节点。\n\n\n# 类的属性\n\npublic class Semaphore implements java.io.Serializable {\n    // 版本号\n    private static final long serialVersionUID = -3222578661600680210L;\n    // 属性\n    private final Sync sync;\n}\n\n\n说明: Semaphore自身只有两个属性，最重要的是sync属性，基于Semaphore对象的操作绝大多数都转移到了对sync的操作。\n\n\n# 类的构造函数\n\n * Semaphore(int)型构造函数\n\npublic Semaphore(int permits) {\n    sync = new NonfairSync(permits);\n}\n\n\n说明: 该构造函数会创建具有给定的许可数和非公平的公平设置的Semaphore。\n\n * Semaphore(int, boolean)型构造函数\n\npublic Semaphore(int permits, boolean fair) {\n    sync = fair ? new FairSync(permits) : new NonfairSync(permits);\n}\n\n\n说明: 该构造函数会创建具有给定的许可数和给定的公平设置的Semaphore。\n\n\n# 核心函数分析 - acquire函数\n\n此方法从信号量获取一个(多个)许可，在提供一个许可前一直将线程阻塞，或者线程被中断，其源码如下\n\npublic void acquire() throws InterruptedException {\n    sync.acquireSharedInterruptibly(1);\n}\n\n\n说明: 该方法中将会调用Sync对象的acquireSharedInterruptibly(从AQS继承而来的方法)方法，而acquireSharedInterruptibly方法在上一篇CountDownLatch中已经进行了分析，在此不再累赘。\n\n最终可以获取大致的方法调用序列(假设使用非公平策略)。如下图所示。\n\n\n\n说明: 上图只是给出了大体会调用到的方法，和具体的示例可能会有些差别，之后会根据具体的示例进行分析。\n\n\n# 核心函数分析 - release函数\n\n此方法释放一个(多个)许可，将其返回给信号量，源码如下。\n\npublic void release() {\n    sync.releaseShared(1);\n}\n\n\n说明: 该方法中将会调用Sync对象的releaseShared(从AQS继承而来的方法)方法，而releaseShared方法在上一篇CountDownLatch中已经进行了分析，在此不再累赘。\n\n最终可以获取大致的方法调用序列(假设使用非公平策略)。如下图所示:\n\n\n\n说明: 上图只是给出了大体会调用到的方法，和具体的示例可能会有些差别，之后会根据具体的示例进行分析。\n\n\n# Semaphore示例\n\n下面给出了一个使用Semaphore的示例。\n\nimport java.util.concurrent.Semaphore;\n\nclass MyThread extends Thread {\n    private Semaphore semaphore;\n    \n    public MyThread(String name, Semaphore semaphore) {\n        super(name);\n        this.semaphore = semaphore;\n    }\n    \n    public void run() {        \n        int count = 3;\n        System.out.println(Thread.currentThread().getName() + " trying to acquire");\n        try {\n            semaphore.acquire(count);\n            System.out.println(Thread.currentThread().getName() + " acquire successfully");\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            semaphore.release(count);\n            System.out.println(Thread.currentThread().getName() + " release successfully");\n        }\n    }\n}\n\npublic class SemaphoreDemo {\n    public final static int SEM_SIZE = 10;\n    \n    public static void main(String[] args) {\n        Semaphore semaphore = new Semaphore(SEM_SIZE);\n        MyThread t1 = new MyThread("t1", semaphore);\n        MyThread t2 = new MyThread("t2", semaphore);\n        t1.start();\n        t2.start();\n        int permits = 5;\n        System.out.println(Thread.currentThread().getName() + " trying to acquire");\n        try {\n            semaphore.acquire(permits);\n            System.out.println(Thread.currentThread().getName() + " acquire successfully");\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            semaphore.release();\n            System.out.println(Thread.currentThread().getName() + " release successfully");\n        }      \n    }\n}\n\n\n运行结果(某一次):\n\nmain trying to acquire\nmain acquire successfully\nt1 trying to acquire\nt1 acquire successfully\nt2 trying to acquire\nt1 release successfully\nmain release successfully\nt2 acquire successfully\nt2 release successfully\n\n\n说明: 首先，生成一个信号量，信号量有10个许可，然后，main，t1，t2三个线程获取许可运行，根据结果，可能存在如下的一种时序。\n\n\n\n说明: 如上图所示，首先，main线程执行acquire操作，并且成功获得许可，之后t1线程执行acquire操作，成功获得许可，之后t2执行acquire操作，由于此时许可数量不够，t2线程将会阻塞，直到许可可用。之后t1线程释放许可，main线程释放许可，此时的许可数量可以满足t2线程的要求，所以，此时t2线程会成功获得许可运行，t2运行完成后释放许可。下面进行详细分析。\n\n * main线程执行semaphore.acquire操作。主要的函数调用如下图所示。\n\n\n\n说明: 此时，可以看到只是AQS的state变为了5，main线程并没有被阻塞，可以继续运行。\n\n * t1线程执行semaphore.acquire操作。主要的函数调用如下图所示。\n\n\n\n说明: 此时，可以看到只是AQS的state变为了2，t1线程并没有被阻塞，可以继续运行。\n\n * t2线程执行semaphore.acquire操作。主要的函数调用如下图所示。\n\n\n\n说明: 此时，t2线程获取许可不会成功，之后会导致其被禁止运行，值得注意的是，AQS的state还是为2。\n\n * t1执行semaphore.release操作。主要的函数调用如下图所示。\n\n\n\n说明: 此时，t2线程将会被unpark，并且AQS的state为5，t2获取cpu资源后可以继续运行。\n\n * main线程执行semaphore.release操作。主要的函数调用如下图所示。\n\n\n\n说明: 此时，t2线程还会被unpark，但是不会产生影响，此时，只要t2线程获得CPU资源就可以运行了。此时，AQS的state为10。\n\n * t2获取CPU资源，继续运行，此时t2需要恢复现场，回到parkAndCheckInterrupt函数中，也是在should继续运行。主要的函数调用如下图所示。\n\n\n\n说明: 此时，可以看到，Sync queue中只有一个结点，头节点与尾节点都指向该结点，在setHeadAndPropagate的函数中会设置头节点并且会unpark队列中的其他结点。\n\n * t2线程执行semaphore.release操作。主要的函数调用如下图所示。\n\n\n\n说明: t2线程经过release后，此时信号量的许可又变为10个了，此时Sync queue中的结点还是没有变化。\n\n\n# 更深入理解\n\n\n# 单独使用Semaphore是不会使用到AQS的条件队列的\n\n不同于CyclicBarrier和ReentrantLock，单独使用Semaphore是不会使用到AQS的条件队列的，其实，只有进行await操作才会进入条件队列，其他的都是在同步队列中，只是当前线程会被park。\n\n\n# 场景问题\n\n# semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么?\n\n答案：拿不到令牌的线程阻塞，不会继续往下运行。\n\n# semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么?\n\n答案：线程阻塞，不会继续往下运行。可能你会考虑类似于锁的重入的问题，很好，但是，令牌没有重入的概念。你只要调用一次acquire方法，就需要有一个令牌才能继续运行。\n\n# semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire(2)方法，此线程能够获取到足够的令牌并继续运行吗?\n\n答案：能，原因是release方法会添加令牌，并不会以初始化的大小为准。\n\n# semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗?\n\n答案：能，原因是release会添加令牌，并不会以初始化的大小为准。Semaphore中release方法的调用并没有限制要在acquire后调用。\n\n具体示例如下，如果不相信的话，可以运行一下下面的demo，在做实验之前，笔者也认为应该是不允许的。。\n\npublic class TestSemaphore2 {\n    public static void main(String[] args) {\n        int permitsNum = 2;\n        final Semaphore semaphore = new Semaphore(permitsNum);\n        try {\n            System.out.println("availablePermits:"+semaphore.availablePermits()+",semaphore.tryAcquire(3,1, TimeUnit.SECONDS):"+semaphore.tryAcquire(3,1, TimeUnit.SECONDS));\n            semaphore.release();\n            System.out.println("availablePermits:"+semaphore.availablePermits()+",semaphore.tryAcquire(3,1, TimeUnit.SECONDS):"+semaphore.tryAcquire(3,1, TimeUnit.SECONDS));\n        }catch (Exception e) {\n\n        }\n    }\n}\n\n\n\n# 参考文章\n\n * 文章主要参考自leesf的https://www.cnblogs.com/leesf456/p/5414778.html，在此基础上做了增改。\n * https://blog.csdn.net/u010412719/article/details/94986327\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-tool-semaphore.html',normalizedContent:'# juc工具类: semaphore详解\n\n> semaphore底层是基于abstractqueuedsynchronizer来实现的。semaphore称为计数信号量，它允许n个任务同时访问某个资源，可以将信号量看做是在向外分发使用资源的许可证，只有成功获取许可证，才能使用资源。\n\n * juc工具类: semaphore详解\n   * 带着bat大厂的面试问题去理解\n   * semaphore源码分析\n     * 类的继承关系\n     * 类的内部类\n     * 类的内部类 - sync类\n     * 类的内部类 - nonfairsync类\n     * 类的内部类 - fairsync类\n     * 类的属性\n     * 类的构造函数\n     * 核心函数分析 - acquire函数\n     * 核心函数分析 - release函数\n   * semaphore示例\n   * 更深入理解\n     * 单独使用semaphore是不会使用到aqs的条件队列的\n     * 场景问题\n       * semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么?\n       * semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么?\n       * semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire(2)方法，此线程能够获取到足够的令牌并继续运行吗?\n       * semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗?\n   * 参考文章\n\n\n# 带着bat大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 什么是semaphore?\n * semaphore内部原理?\n * semaphore常用方法有哪些? 如何实现线程同步和互斥的?\n * semaphore适合用在什么场景?\n * 单独使用semaphore是不会使用到aqs的条件队列?\n * semaphore中申请令牌(acquire)、释放令牌(release)的实现?\n * semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么?\n * semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么?\n * semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire(2)方法，此线程能够获取到足够的令牌并继续运行吗?\n * semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗?\n\n\n# semaphore源码分析\n\n\n# 类的继承关系\n\npublic class semaphore implements java.io.serializable {}\n\n\n说明: semaphore实现了serializable接口，即可以进行序列化。\n\n\n# 类的内部类\n\nsemaphore总共有三个内部类，并且三个内部类是紧密相关的，下面先看三个类的关系。\n\n\n\n说明: semaphore与reentrantlock的内部类的结构相同，类内部总共存在sync、nonfairsync、fairsync三个类，nonfairsync与fairsync类继承自sync类，sync类继承自abstractqueuedsynchronizer抽象类。下面逐个进行分析。\n\n\n# 类的内部类 - sync类\n\nsync类的源码如下\n\n// 内部类，继承自aqs\nabstract static class sync extends abstractqueuedsynchronizer {\n    // 版本号\n    private static final long serialversionuid = 1192457210091910933l;\n    \n    // 构造函数\n    sync(int permits) {\n        // 设置状态数\n        setstate(permits);\n    }\n    \n    // 获取许可\n    final int getpermits() {\n        return getstate();\n    }\n\n    // 共享模式下非公平策略获取\n    final int nonfairtryacquireshared(int acquires) {\n        for (;;) { // 无限循环\n            // 获取许可数\n            int available = getstate();\n            // 剩余的许可\n            int remaining = available - acquires;\n            if (remaining < 0 ||\n                compareandsetstate(available, remaining)) // 许可小于0或者比较并且设置状态成功\n                return remaining;\n        }\n    }\n    \n    // 共享模式下进行释放\n    protected final boolean tryreleaseshared(int releases) {\n        for (;;) { // 无限循环\n            // 获取许可\n            int current = getstate();\n            // 可用的许可\n            int next = current + releases;\n            if (next < current) // overflow\n                throw new error("maximum permit count exceeded");\n            if (compareandsetstate(current, next)) // 比较并进行设置成功\n                return true;\n        }\n    }\n\n    // 根据指定的缩减量减小可用许可的数目\n    final void reducepermits(int reductions) {\n        for (;;) { // 无限循环\n            // 获取许可\n            int current = getstate();\n            // 可用的许可\n            int next = current - reductions;\n            if (next > current) // underflow\n                throw new error("permit count underflow");\n            if (compareandsetstate(current, next)) // 比较并进行设置成功\n                return;\n        }\n    }\n\n    // 获取并返回立即可用的所有许可\n    final int drainpermits() {\n        for (;;) { // 无限循环\n            // 获取许可\n            int current = getstate();\n            if (current == 0 || compareandsetstate(current, 0)) // 许可为0或者比较并设置成功\n                return current;\n        }\n    }\n}\n\n\n说明: sync类的属性相对简单，只有一个版本号，sync类存在如下方法和作用如下。\n\n\n\n\n# 类的内部类 - nonfairsync类\n\nnonfairsync类继承了sync类，表示采用非公平策略获取资源，其只有一个tryacquireshared方法，重写了aqs的该方法，其源码如下:\n\nstatic final class nonfairsync extends sync {\n    // 版本号\n    private static final long serialversionuid = -2694183684443567898l;\n    \n    // 构造函数\n    nonfairsync(int permits) {\n        super(permits);\n    }\n    // 共享模式下获取\n    protected int tryacquireshared(int acquires) {\n        return nonfairtryacquireshared(acquires);\n    }\n}\n\n\n说明: 从tryacquireshared方法的源码可知，其会调用父类sync的nonfairtryacquireshared方法，表示按照非公平策略进行资源的获取。\n\n\n# 类的内部类 - fairsync类\n\nfairsync类继承了sync类，表示采用公平策略获取资源，其只有一个tryacquireshared方法，重写了aqs的该方法，其源码如下。\n\nprotected int tryacquireshared(int acquires) {\n    for (;;) { // 无限循环\n        if (hasqueuedpredecessors()) // 同步队列中存在其他节点\n            return -1;\n        // 获取许可\n        int available = getstate();\n        // 剩余的许可\n        int remaining = available - acquires;\n        if (remaining < 0 ||\n            compareandsetstate(available, remaining)) // 剩余的许可小于0或者比较设置成功\n            return remaining;\n    }\n}\n\n\n说明: 从tryacquireshared方法的源码可知，它使用公平策略来获取资源，它会判断同步队列中是否存在其他的等待节点。\n\n\n# 类的属性\n\npublic class semaphore implements java.io.serializable {\n    // 版本号\n    private static final long serialversionuid = -3222578661600680210l;\n    // 属性\n    private final sync sync;\n}\n\n\n说明: semaphore自身只有两个属性，最重要的是sync属性，基于semaphore对象的操作绝大多数都转移到了对sync的操作。\n\n\n# 类的构造函数\n\n * semaphore(int)型构造函数\n\npublic semaphore(int permits) {\n    sync = new nonfairsync(permits);\n}\n\n\n说明: 该构造函数会创建具有给定的许可数和非公平的公平设置的semaphore。\n\n * semaphore(int, boolean)型构造函数\n\npublic semaphore(int permits, boolean fair) {\n    sync = fair ? new fairsync(permits) : new nonfairsync(permits);\n}\n\n\n说明: 该构造函数会创建具有给定的许可数和给定的公平设置的semaphore。\n\n\n# 核心函数分析 - acquire函数\n\n此方法从信号量获取一个(多个)许可，在提供一个许可前一直将线程阻塞，或者线程被中断，其源码如下\n\npublic void acquire() throws interruptedexception {\n    sync.acquiresharedinterruptibly(1);\n}\n\n\n说明: 该方法中将会调用sync对象的acquiresharedinterruptibly(从aqs继承而来的方法)方法，而acquiresharedinterruptibly方法在上一篇countdownlatch中已经进行了分析，在此不再累赘。\n\n最终可以获取大致的方法调用序列(假设使用非公平策略)。如下图所示。\n\n\n\n说明: 上图只是给出了大体会调用到的方法，和具体的示例可能会有些差别，之后会根据具体的示例进行分析。\n\n\n# 核心函数分析 - release函数\n\n此方法释放一个(多个)许可，将其返回给信号量，源码如下。\n\npublic void release() {\n    sync.releaseshared(1);\n}\n\n\n说明: 该方法中将会调用sync对象的releaseshared(从aqs继承而来的方法)方法，而releaseshared方法在上一篇countdownlatch中已经进行了分析，在此不再累赘。\n\n最终可以获取大致的方法调用序列(假设使用非公平策略)。如下图所示:\n\n\n\n说明: 上图只是给出了大体会调用到的方法，和具体的示例可能会有些差别，之后会根据具体的示例进行分析。\n\n\n# semaphore示例\n\n下面给出了一个使用semaphore的示例。\n\nimport java.util.concurrent.semaphore;\n\nclass mythread extends thread {\n    private semaphore semaphore;\n    \n    public mythread(string name, semaphore semaphore) {\n        super(name);\n        this.semaphore = semaphore;\n    }\n    \n    public void run() {        \n        int count = 3;\n        system.out.println(thread.currentthread().getname() + " trying to acquire");\n        try {\n            semaphore.acquire(count);\n            system.out.println(thread.currentthread().getname() + " acquire successfully");\n            thread.sleep(1000);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        } finally {\n            semaphore.release(count);\n            system.out.println(thread.currentthread().getname() + " release successfully");\n        }\n    }\n}\n\npublic class semaphoredemo {\n    public final static int sem_size = 10;\n    \n    public static void main(string[] args) {\n        semaphore semaphore = new semaphore(sem_size);\n        mythread t1 = new mythread("t1", semaphore);\n        mythread t2 = new mythread("t2", semaphore);\n        t1.start();\n        t2.start();\n        int permits = 5;\n        system.out.println(thread.currentthread().getname() + " trying to acquire");\n        try {\n            semaphore.acquire(permits);\n            system.out.println(thread.currentthread().getname() + " acquire successfully");\n            thread.sleep(1000);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        } finally {\n            semaphore.release();\n            system.out.println(thread.currentthread().getname() + " release successfully");\n        }      \n    }\n}\n\n\n运行结果(某一次):\n\nmain trying to acquire\nmain acquire successfully\nt1 trying to acquire\nt1 acquire successfully\nt2 trying to acquire\nt1 release successfully\nmain release successfully\nt2 acquire successfully\nt2 release successfully\n\n\n说明: 首先，生成一个信号量，信号量有10个许可，然后，main，t1，t2三个线程获取许可运行，根据结果，可能存在如下的一种时序。\n\n\n\n说明: 如上图所示，首先，main线程执行acquire操作，并且成功获得许可，之后t1线程执行acquire操作，成功获得许可，之后t2执行acquire操作，由于此时许可数量不够，t2线程将会阻塞，直到许可可用。之后t1线程释放许可，main线程释放许可，此时的许可数量可以满足t2线程的要求，所以，此时t2线程会成功获得许可运行，t2运行完成后释放许可。下面进行详细分析。\n\n * main线程执行semaphore.acquire操作。主要的函数调用如下图所示。\n\n\n\n说明: 此时，可以看到只是aqs的state变为了5，main线程并没有被阻塞，可以继续运行。\n\n * t1线程执行semaphore.acquire操作。主要的函数调用如下图所示。\n\n\n\n说明: 此时，可以看到只是aqs的state变为了2，t1线程并没有被阻塞，可以继续运行。\n\n * t2线程执行semaphore.acquire操作。主要的函数调用如下图所示。\n\n\n\n说明: 此时，t2线程获取许可不会成功，之后会导致其被禁止运行，值得注意的是，aqs的state还是为2。\n\n * t1执行semaphore.release操作。主要的函数调用如下图所示。\n\n\n\n说明: 此时，t2线程将会被unpark，并且aqs的state为5，t2获取cpu资源后可以继续运行。\n\n * main线程执行semaphore.release操作。主要的函数调用如下图所示。\n\n\n\n说明: 此时，t2线程还会被unpark，但是不会产生影响，此时，只要t2线程获得cpu资源就可以运行了。此时，aqs的state为10。\n\n * t2获取cpu资源，继续运行，此时t2需要恢复现场，回到parkandcheckinterrupt函数中，也是在should继续运行。主要的函数调用如下图所示。\n\n\n\n说明: 此时，可以看到，sync queue中只有一个结点，头节点与尾节点都指向该结点，在setheadandpropagate的函数中会设置头节点并且会unpark队列中的其他结点。\n\n * t2线程执行semaphore.release操作。主要的函数调用如下图所示。\n\n\n\n说明: t2线程经过release后，此时信号量的许可又变为10个了，此时sync queue中的结点还是没有变化。\n\n\n# 更深入理解\n\n\n# 单独使用semaphore是不会使用到aqs的条件队列的\n\n不同于cyclicbarrier和reentrantlock，单独使用semaphore是不会使用到aqs的条件队列的，其实，只有进行await操作才会进入条件队列，其他的都是在同步队列中，只是当前线程会被park。\n\n\n# 场景问题\n\n# semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么?\n\n答案：拿不到令牌的线程阻塞，不会继续往下运行。\n\n# semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么?\n\n答案：线程阻塞，不会继续往下运行。可能你会考虑类似于锁的重入的问题，很好，但是，令牌没有重入的概念。你只要调用一次acquire方法，就需要有一个令牌才能继续运行。\n\n# semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire(2)方法，此线程能够获取到足够的令牌并继续运行吗?\n\n答案：能，原因是release方法会添加令牌，并不会以初始化的大小为准。\n\n# semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗?\n\n答案：能，原因是release会添加令牌，并不会以初始化的大小为准。semaphore中release方法的调用并没有限制要在acquire后调用。\n\n具体示例如下，如果不相信的话，可以运行一下下面的demo，在做实验之前，笔者也认为应该是不允许的。。\n\npublic class testsemaphore2 {\n    public static void main(string[] args) {\n        int permitsnum = 2;\n        final semaphore semaphore = new semaphore(permitsnum);\n        try {\n            system.out.println("availablepermits:"+semaphore.availablepermits()+",semaphore.tryacquire(3,1, timeunit.seconds):"+semaphore.tryacquire(3,1, timeunit.seconds));\n            semaphore.release();\n            system.out.println("availablepermits:"+semaphore.availablepermits()+",semaphore.tryacquire(3,1, timeunit.seconds):"+semaphore.tryacquire(3,1, timeunit.seconds));\n        }catch (exception e) {\n\n        }\n    }\n}\n\n\n\n# 参考文章\n\n * 文章主要参考自leesf的https://www.cnblogs.com/leesf456/p/5414778.html，在此基础上做了增改。\n * https://blog.csdn.net/u010412719/article/details/94986327\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-tool-semaphore.html',charsets:{cjk:!0}},{title:"JUC工具类: Phaser详解",frontmatter:{},regularPath:"/java/thread/java-thread-x-juc-tool-phaser.html",relativePath:"java/thread/java-thread-x-juc-tool-phaser.md",key:"v-57dda42e",path:"/java/thread/java-thread-x-juc-tool-phaser.html",headers:[{level:2,title:"JUC工具类: Phaser详解",slug:"juc工具类-phaser详解",normalizedTitle:"juc工具类: phaser详解",charIndex:2},{level:2,title:"带着BAT大厂的面试问题去理解Phaser工具",slug:"带着bat大厂的面试问题去理解phaser工具",normalizedTitle:"带着bat大厂的面试问题去理解phaser工具",charIndex:142},{level:2,title:"Phaser运行机制",slug:"phaser运行机制",normalizedTitle:"phaser运行机制",charIndex:171},{level:2,title:"Phaser源码详解",slug:"phaser源码详解",normalizedTitle:"phaser源码详解",charIndex:187},{level:3,title:"核心参数",slug:"核心参数",normalizedTitle:"核心参数",charIndex:205},{level:3,title:"函数列表",slug:"函数列表",normalizedTitle:"函数列表",charIndex:217},{level:3,title:"方法 - register()",slug:"方法-register",normalizedTitle:"方法 - register()",charIndex:229},{level:3,title:"方法 - arrive()",slug:"方法-arrive",normalizedTitle:"方法 - arrive()",charIndex:252},{level:3,title:"方法 - arriveAndAwaitAdvance()",slug:"方法-arriveandawaitadvance",normalizedTitle:"方法 - arriveandawaitadvance()",charIndex:273},{level:3,title:"方法 - awaitAdvance(int phase)",slug:"方法-awaitadvance-int-phase",normalizedTitle:"方法 - awaitadvance(int phase)",charIndex:309},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:343}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"JUC工具类: Phaser详解 带着BAT大厂的面试问题去理解Phaser工具 Phaser运行机制 Phaser源码详解 核心参数 函数列表 方法 - register() 方法 - arrive() 方法 - arriveAndAwaitAdvance() 方法 - awaitAdvance(int phase) 参考文章",content:'# JUC工具类: Phaser详解\n\n> Phaser是JDK 7新增的一个同步辅助类，它可以实现CyclicBarrier和CountDownLatch类似的功能，而且它支持对任务的动态调整，并支持分层结构来达到更高的吞吐量。\n\n * JUC工具类: Phaser详解\n   * 带着BAT大厂的面试问题去理解Phaser工具\n   * Phaser运行机制\n   * Phaser源码详解\n     * 核心参数\n     * 函数列表\n     * 方法 - register()\n     * 方法 - arrive()\n     * 方法 - arriveAndAwaitAdvance()\n     * 方法 - awaitAdvance(int phase)\n   * 参考文章\n\n\n# 带着BAT大厂的面试问题去理解Phaser工具\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解Phaser工具。\n\n * Phaser主要用来解决什么问题?\n * Phaser与CyclicBarrier和CountDownLatch的区别是什么?\n * 如果用CountDownLatch来实现Phaser的功能应该怎么实现?\n * Phaser运行机制是什么样的?\n * 给一个Phaser使用的示例?\n\n\n# Phaser运行机制\n\n\n\n * Registration(注册)\n\n跟其他barrier不同，在phaser上注册的parties会随着时间的变化而变化。任务可以随时注册(使用方法register,bulkRegister注册，或者由构造器确定初始parties)，并且在任何抵达点可以随意地撤销注册(方法arriveAndDeregister)。就像大多数基本的同步结构一样，注册和撤销只影响内部count；不会创建更深的内部记录，所以任务不能查询他们是否已经注册。(不过，可以通过继承来实现类似的记录)\n\n * Synchronization(同步机制)\n\n和CyclicBarrier一样，Phaser也可以重复await。方法arriveAndAwaitAdvance的效果类似CyclicBarrier.await。phaser的每一代都有一个相关的phase number，初始值为0，当所有注册的任务都到达phaser时phase+1，到达最大值(Integer.MAX_VALUE)之后清零。使用phase number可以独立控制 到达phaser 和 等待其他线程 的动作，通过下面两种类型的方法:\n\n>  * Arrival(到达机制) arrive和arriveAndDeregister方法记录到达状态。这些方法不会阻塞，但是会返回一个相关的arrival phase number；也就是说，phase number用来确定到达状态。当所有任务都到达给定phase时，可以执行一个可选的函数，这个函数通过重写onAdvance方法实现，通常可以用来控制终止状态。重写此方法类似于为CyclicBarrier提供一个barrierAction，但比它更灵活。\n> \n>  * Waiting(等待机制) awaitAdvance方法需要一个表示arrival phase number的参数，并且在phaser前进到与给定phase不同的phase时返回。和CyclicBarrier不同，即使等待线程已经被中断，awaitAdvance方法也会一直等待。中断状态和超时时间同样可用，但是当任务等待中断或超时后未改变phaser的状态时会遭遇异常。如果有必要，在方法forceTermination之后可以执行这些异常的相关的handler进行恢复操作，Phaser也可能被ForkJoinPool中的任务使用，这样在其他任务阻塞等待一个phase时可以保证足够的并行度来执行任务。\n\n * Termination(终止机制) :\n\n可以用isTerminated方法检查phaser的终止状态。在终止时，所有同步方法立刻返回一个负值。在终止时尝试注册也没有效果。当调用onAdvance返回true时Termination被触发。当deregistration操作使已注册的parties变为0时，onAdvance的默认实现就会返回true。也可以重写onAdvance方法来定义终止动作。forceTermination方法也可以释放等待线程并且允许它们终止。\n\n * Tiering(分层结构) :\n\nPhaser支持分层结构(树状构造)来减少竞争。注册了大量parties的Phaser可能会因为同步竞争消耗很高的成本， 因此可以设置一些子Phaser来共享一个通用的parent。这样的话即使每个操作消耗了更多的开销，但是会提高整体吞吐量。 在一个分层结构的phaser里，子节点phaser的注册和取消注册都通过父节点管理。子节点phaser通过构造或方法register、bulkRegister进行首次注册时，在其父节点上注册。子节点phaser通过调用arriveAndDeregister进行最后一次取消注册时，也在其父节点上取消注册。\n\n * Monitoring(状态监控) :\n\n由于同步方法可能只被已注册的parties调用，所以phaser的当前状态也可能被任何调用者监控。在任何时候，可以通过getRegisteredParties获取parties数，其中getArrivedParties方法返回已经到达当前phase的parties数。当剩余的parties(通过方法getUnarrivedParties获取)到达时，phase进入下一代。这些方法返回的值可能只表示短暂的状态，所以一般来说在同步结构里并没有啥卵用。\n\n\n# Phaser源码详解\n\n\n# 核心参数\n\nprivate volatile long state;\n/**\n * The parent of this phaser, or null if none\n */\nprivate final Phaser parent;\n/**\n * The root of phaser tree. Equals this if not in a tree.\n */\nprivate final Phaser root;\n//等待线程的栈顶元素，根据phase取模定义为一个奇数header和一个偶数header\nprivate final AtomicReference<QNode> evenQ;\nprivate final AtomicReference<QNode> oddQ;\n\n\n\nstate状态说明:\n\nPhaser使用一个long型state值来标识内部状态:\n\n * 低0-15位表示未到达parties数；\n * 中16-31位表示等待的parties数；\n * 中32-62位表示phase当前代；\n * 高63位表示当前phaser的终止状态。\n\n注意: 子Phaser的phase在没有被真正使用之前，允许滞后于它的root节点。这里在后面源码分析的reconcileState方法里会讲解。 Qnode是Phaser定义的内部等待队列，用于在阻塞时记录等待线程及相关信息。实现了ForkJoinPool的一个内部接口ManagedBlocker，上面已经说过，Phaser也可能被ForkJoinPool中的任务使用，这样在其他任务阻塞等待一个phase时可以保证足够的并行度来执行任务(通过内部实现方法isReleasable和block)。\n\n\n# 函数列表\n\n//构造方法\npublic Phaser() {\n    this(null, 0);\n}\npublic Phaser(int parties) {\n    this(null, parties);\n}\npublic Phaser(Phaser parent) {\n    this(parent, 0);\n}\npublic Phaser(Phaser parent, int parties)\n//注册一个新的party\npublic int register()\n//批量注册\npublic int bulkRegister(int parties)\n//使当前线程到达phaser，不等待其他任务到达。返回arrival phase number\npublic int arrive() \n//使当前线程到达phaser并撤销注册，返回arrival phase number\npublic int arriveAndDeregister()\n/*\n * 使当前线程到达phaser并等待其他任务到达，等价于awaitAdvance(arrive())。\n * 如果需要等待中断或超时，可以使用awaitAdvance方法完成一个类似的构造。\n * 如果需要在到达后取消注册，可以使用awaitAdvance(arriveAndDeregister())。\n */\npublic int arriveAndAwaitAdvance()\n//等待给定phase数，返回下一个 arrival phase number\npublic int awaitAdvance(int phase)\n//阻塞等待，直到phase前进到下一代，返回下一代的phase number\npublic int awaitAdvance(int phase) \n//响应中断版awaitAdvance\npublic int awaitAdvanceInterruptibly(int phase) throws InterruptedException\npublic int awaitAdvanceInterruptibly(int phase, long timeout, TimeUnit unit)\n    throws InterruptedException, TimeoutException\n//使当前phaser进入终止状态，已注册的parties不受影响，如果是分层结构，则终止所有phaser\npublic void forceTermination()\n\n\n\n# 方法 - register()\n\n//注册一个新的party\npublic int register() {\n    return doRegister(1);\n}\nprivate int doRegister(int registrations) {\n    // adjustment to state\n    long adjust = ((long)registrations << PARTIES_SHIFT) | registrations;\n    final Phaser parent = this.parent;\n    int phase;\n    for (;;) {\n        long s = (parent == null) ? state : reconcileState();\n        int counts = (int)s;\n        int parties = counts >>> PARTIES_SHIFT;//获取已注册parties数\n        int unarrived = counts & UNARRIVED_MASK;//未到达数\n        if (registrations > MAX_PARTIES - parties)\n            throw new IllegalStateException(badRegister(s));\n        phase = (int)(s >>> PHASE_SHIFT);//获取当前代\n        if (phase < 0)\n            break;\n        if (counts != EMPTY) {                  // not 1st registration\n            if (parent == null || reconcileState() == s) {\n                if (unarrived == 0)             // wait out advance\n                    root.internalAwaitAdvance(phase, null);//等待其他任务到达\n                else if (UNSAFE.compareAndSwapLong(this, stateOffset,\n                                                   s, s + adjust))//更新注册的parties数\n                    break;\n            }\n        }\n        else if (parent == null) {              // 1st root registration\n            long next = ((long)phase << PHASE_SHIFT) | adjust;\n            if (UNSAFE.compareAndSwapLong(this, stateOffset, s, next))//更新phase\n                break;\n        }\n        else {\n            //分层结构，子phaser首次注册用父节点管理\n            synchronized (this) {               // 1st sub registration\n                if (state == s) {               // recheck under lock\n                    phase = parent.doRegister(1);//分层结构，使用父节点注册\n                    if (phase < 0)\n                        break;\n                    // finish registration whenever parent registration\n                    // succeeded, even when racing with termination,\n                    // since these are part of the same "transaction".\n                    //由于在同一个事务里，即使phaser已终止，也会完成注册\n                    while (!UNSAFE.compareAndSwapLong\n                           (this, stateOffset, s,\n                            ((long)phase << PHASE_SHIFT) | adjust)) {//更新phase\n                        s = state;\n                        phase = (int)(root.state >>> PHASE_SHIFT);\n                        // assert (int)s == EMPTY;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    return phase;\n}\n\n\n说明: register方法为phaser添加一个新的party，如果onAdvance正在运行，那么这个方法会等待它运行结束再返回结果。如果当前phaser有父节点，并且当前phaser上没有已注册的party，那么就会交给父节点注册。\n\nregister和bulkRegister都由doRegister实现，大概流程如下:\n\n * 如果当前操作不是首次注册，那么直接在当前phaser上更新注册parties数\n * 如果是首次注册，并且当前phaser没有父节点，说明是root节点注册，直接更新phase\n * 如果当前操作是首次注册，并且当前phaser由父节点，则注册操作交由父节点，并更新当前phaser的phase\n * 上面说过，子Phaser的phase在没有被真正使用之前，允许滞后于它的root节点。非首次注册时，如果Phaser有父节点，则调用reconcileState()方法解决root节点的phase延迟传递问题， 源码如下:\n\nprivate long reconcileState() {\n    final Phaser root = this.root;\n    long s = state;\n    if (root != this) {\n        int phase, p;\n        // CAS to root phase with current parties, tripping unarrived\n        while ((phase = (int)(root.state >>> PHASE_SHIFT)) !=\n               (int)(s >>> PHASE_SHIFT) &&\n               !UNSAFE.compareAndSwapLong\n               (this, stateOffset, s,\n                s = (((long)phase << PHASE_SHIFT) |\n                     ((phase < 0) ? (s & COUNTS_MASK) :\n                      (((p = (int)s >>> PARTIES_SHIFT) == 0) ? EMPTY :\n                       ((s & PARTIES_MASK) | p))))))\n            s = state;\n    }\n    return s;\n}\n\n\n当root节点的phase已经advance到下一代，但是子节点phaser还没有，这种情况下它们必须通过更新未到达parties数 完成它们自己的advance操作(如果parties为0，重置为EMPTY状态)。\n\n回到register方法的第一步，如果当前未到达数为0，说明上一代phase正在进行到达操作，此时调用internalAwaitAdvance()方法等待其他任务完成到达操作，源码如下:\n\n//阻塞等待phase到下一代\nprivate int internalAwaitAdvance(int phase, QNode node) {\n    // assert root == this;\n    releaseWaiters(phase-1);          // ensure old queue clean\n    boolean queued = false;           // true when node is enqueued\n    int lastUnarrived = 0;            // to increase spins upon change\n    int spins = SPINS_PER_ARRIVAL;\n    long s;\n    int p;\n    while ((p = (int)((s = state) >>> PHASE_SHIFT)) == phase) {\n        if (node == null) {           // spinning in noninterruptible mode\n            int unarrived = (int)s & UNARRIVED_MASK;//未到达数\n            if (unarrived != lastUnarrived &&\n                (lastUnarrived = unarrived) < NCPU)\n                spins += SPINS_PER_ARRIVAL;\n            boolean interrupted = Thread.interrupted();\n            if (interrupted || --spins < 0) { // need node to record intr\n                //使用node记录中断状态\n                node = new QNode(this, phase, false, false, 0L);\n                node.wasInterrupted = interrupted;\n            }\n        }\n        else if (node.isReleasable()) // done or aborted\n            break;\n        else if (!queued) {           // push onto queue\n            AtomicReference<QNode> head = (phase & 1) == 0 ? evenQ : oddQ;\n            QNode q = node.next = head.get();\n            if ((q == null || q.phase == phase) &&\n                (int)(state >>> PHASE_SHIFT) == phase) // avoid stale enq\n                queued = head.compareAndSet(q, node);\n        }\n        else {\n            try {\n                ForkJoinPool.managedBlock(node);//阻塞给定node\n            } catch (InterruptedException ie) {\n                node.wasInterrupted = true;\n            }\n        }\n    }\n\n    if (node != null) {\n        if (node.thread != null)\n            node.thread = null;       // avoid need for unpark()\n        if (node.wasInterrupted && !node.interruptible)\n            Thread.currentThread().interrupt();\n        if (p == phase && (p = (int)(state >>> PHASE_SHIFT)) == phase)\n            return abortWait(phase); // possibly clean up on abort\n    }\n    releaseWaiters(phase);\n    return p;\n}\n\n\n简单介绍下第二个参数node，如果不为空，则说明等待线程需要追踪中断状态或超时状态。以doRegister中的调用为例，不考虑线程争用，internalAwaitAdvance大概流程如下:\n\n * 首先调用releaseWaiters唤醒上一代所有等待线程，确保旧队列中没有遗留的等待线程。\n * 循环SPINS_PER_ARRIVAL指定的次数或者当前线程被中断，创建node记录等待线程及相关信息。\n * 继续循环调用ForkJoinPool.managedBlock运行被阻塞的任务\n * 继续循环，阻塞任务运行成功被释放，跳出循环\n * 最后唤醒当前phase的线程\n\n\n# 方法 - arrive()\n\n//使当前线程到达phaser，不等待其他任务到达。返回arrival phase number\npublic int arrive() {\n    return doArrive(ONE_ARRIVAL);\n}\n\nprivate int doArrive(int adjust) {\n    final Phaser root = this.root;\n    for (;;) {\n        long s = (root == this) ? state : reconcileState();\n        int phase = (int)(s >>> PHASE_SHIFT);\n        if (phase < 0)\n            return phase;\n        int counts = (int)s;\n        //获取未到达数\n        int unarrived = (counts == EMPTY) ? 0 : (counts & UNARRIVED_MASK);\n        if (unarrived <= 0)\n            throw new IllegalStateException(badArrive(s));\n        if (UNSAFE.compareAndSwapLong(this, stateOffset, s, s-=adjust)) {//更新state\n            if (unarrived == 1) {//当前为最后一个未到达的任务\n                long n = s & PARTIES_MASK;  // base of next state\n                int nextUnarrived = (int)n >>> PARTIES_SHIFT;\n                if (root == this) {\n                    if (onAdvance(phase, nextUnarrived))//检查是否需要终止phaser\n                        n |= TERMINATION_BIT;\n                    else if (nextUnarrived == 0)\n                        n |= EMPTY;\n                    else\n                        n |= nextUnarrived;\n                    int nextPhase = (phase + 1) & MAX_PHASE;\n                    n |= (long)nextPhase << PHASE_SHIFT;\n                    UNSAFE.compareAndSwapLong(this, stateOffset, s, n);\n                    releaseWaiters(phase);//释放等待phase的线程\n                }\n                //分层结构，使用父节点管理arrive\n                else if (nextUnarrived == 0) { //propagate deregistration\n                    phase = parent.doArrive(ONE_DEREGISTER);\n                    UNSAFE.compareAndSwapLong(this, stateOffset,\n                                              s, s | EMPTY);\n                }\n                else\n                    phase = parent.doArrive(ONE_ARRIVAL);\n            }\n            return phase;\n        }\n    }\n}\n\n\n说明: arrive方法手动调整到达数，使当前线程到达phaser。arrive和arriveAndDeregister都调用了doArrive实现，大概流程如下:\n\n * 首先更新state(state - adjust)；\n * 如果当前不是最后一个未到达的任务，直接返回phase\n * 如果当前是最后一个未到达的任务:\n   * 如果当前是root节点，判断是否需要终止phaser，CAS更新phase，最后释放等待的线程；\n   * 如果是分层结构，并且已经没有下一代未到达的parties，则交由父节点处理doArrive逻辑，然后更新state为EMPTY。\n\n\n# 方法 - arriveAndAwaitAdvance()\n\npublic int arriveAndAwaitAdvance() {\n    // Specialization of doArrive+awaitAdvance eliminating some reads/paths\n    final Phaser root = this.root;\n    for (;;) {\n        long s = (root == this) ? state : reconcileState();\n        int phase = (int)(s >>> PHASE_SHIFT);\n        if (phase < 0)\n            return phase;\n        int counts = (int)s;\n        int unarrived = (counts == EMPTY) ? 0 : (counts & UNARRIVED_MASK);//获取未到达数\n        if (unarrived <= 0)\n            throw new IllegalStateException(badArrive(s));\n        if (UNSAFE.compareAndSwapLong(this, stateOffset, s,\n                                      s -= ONE_ARRIVAL)) {//更新state\n            if (unarrived > 1)\n                return root.internalAwaitAdvance(phase, null);//阻塞等待其他任务\n            if (root != this)\n                return parent.arriveAndAwaitAdvance();//子Phaser交给父节点处理\n            long n = s & PARTIES_MASK;  // base of next state\n            int nextUnarrived = (int)n >>> PARTIES_SHIFT;\n            if (onAdvance(phase, nextUnarrived))//全部到达，检查是否可销毁\n                n |= TERMINATION_BIT;\n            else if (nextUnarrived == 0)\n                n |= EMPTY;\n            else\n                n |= nextUnarrived;\n            int nextPhase = (phase + 1) & MAX_PHASE;//计算下一代phase\n            n |= (long)nextPhase << PHASE_SHIFT;\n            if (!UNSAFE.compareAndSwapLong(this, stateOffset, s, n))//更新state\n                return (int)(state >>> PHASE_SHIFT); // terminated\n            releaseWaiters(phase);//释放等待phase的线程\n            return nextPhase;\n        }\n    }\n}\n\n\n说明: 使当前线程到达phaser并等待其他任务到达，等价于awaitAdvance(arrive())。如果需要等待中断或超时，可以使用awaitAdvance方法完成一个类似的构造。如果需要在到达后取消注册，可以使用awaitAdvance(arriveAndDeregister())。效果类似于CyclicBarrier.await。大概流程如下:\n\n * 更新state(state - 1)；\n * 如果未到达数大于1，调用internalAwaitAdvance阻塞等待其他任务到达，返回当前phase\n * 如果为分层结构，则交由父节点处理arriveAndAwaitAdvance逻辑\n * 如果未到达数<=1，判断phaser终止状态，CAS更新phase到下一代，最后释放等待当前phase的线程，并返回下一代phase。\n\n\n# 方法 - awaitAdvance(int phase)\n\npublic int awaitAdvance(int phase) {\n    final Phaser root = this.root;\n    long s = (root == this) ? state : reconcileState();\n    int p = (int)(s >>> PHASE_SHIFT);\n    if (phase < 0)\n        return phase;\n    if (p == phase)\n        return root.internalAwaitAdvance(phase, null);\n    return p;\n}\n//响应中断版awaitAdvance\npublic int awaitAdvanceInterruptibly(int phase)\n    throws InterruptedException {\n    final Phaser root = this.root;\n    long s = (root == this) ? state : reconcileState();\n    int p = (int)(s >>> PHASE_SHIFT);\n    if (phase < 0)\n        return phase;\n    if (p == phase) {\n        QNode node = new QNode(this, phase, true, false, 0L);\n        p = root.internalAwaitAdvance(phase, node);\n        if (node.wasInterrupted)\n            throw new InterruptedException();\n    }\n    return p;\n}\n\n\n说明: awaitAdvance用于阻塞等待线程到达，直到phase前进到下一代，返回下一代的phase number。方法很简单，不多赘述。awaitAdvanceInterruptibly方法是响应中断版的awaitAdvance，不同之处在于，调用阻塞时会记录线程的中断状态。\n\n\n# 参考文章\n\n * 本文主要参考自泰迪的bagwell的https://www.jianshu.com/p/e5794645ca8d，在此基础上进行了增改。\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-tool-phaser.html',normalizedContent:'# juc工具类: phaser详解\n\n> phaser是jdk 7新增的一个同步辅助类，它可以实现cyclicbarrier和countdownlatch类似的功能，而且它支持对任务的动态调整，并支持分层结构来达到更高的吞吐量。\n\n * juc工具类: phaser详解\n   * 带着bat大厂的面试问题去理解phaser工具\n   * phaser运行机制\n   * phaser源码详解\n     * 核心参数\n     * 函数列表\n     * 方法 - register()\n     * 方法 - arrive()\n     * 方法 - arriveandawaitadvance()\n     * 方法 - awaitadvance(int phase)\n   * 参考文章\n\n\n# 带着bat大厂的面试问题去理解phaser工具\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解phaser工具。\n\n * phaser主要用来解决什么问题?\n * phaser与cyclicbarrier和countdownlatch的区别是什么?\n * 如果用countdownlatch来实现phaser的功能应该怎么实现?\n * phaser运行机制是什么样的?\n * 给一个phaser使用的示例?\n\n\n# phaser运行机制\n\n\n\n * registration(注册)\n\n跟其他barrier不同，在phaser上注册的parties会随着时间的变化而变化。任务可以随时注册(使用方法register,bulkregister注册，或者由构造器确定初始parties)，并且在任何抵达点可以随意地撤销注册(方法arriveandderegister)。就像大多数基本的同步结构一样，注册和撤销只影响内部count；不会创建更深的内部记录，所以任务不能查询他们是否已经注册。(不过，可以通过继承来实现类似的记录)\n\n * synchronization(同步机制)\n\n和cyclicbarrier一样，phaser也可以重复await。方法arriveandawaitadvance的效果类似cyclicbarrier.await。phaser的每一代都有一个相关的phase number，初始值为0，当所有注册的任务都到达phaser时phase+1，到达最大值(integer.max_value)之后清零。使用phase number可以独立控制 到达phaser 和 等待其他线程 的动作，通过下面两种类型的方法:\n\n>  * arrival(到达机制) arrive和arriveandderegister方法记录到达状态。这些方法不会阻塞，但是会返回一个相关的arrival phase number；也就是说，phase number用来确定到达状态。当所有任务都到达给定phase时，可以执行一个可选的函数，这个函数通过重写onadvance方法实现，通常可以用来控制终止状态。重写此方法类似于为cyclicbarrier提供一个barrieraction，但比它更灵活。\n> \n>  * waiting(等待机制) awaitadvance方法需要一个表示arrival phase number的参数，并且在phaser前进到与给定phase不同的phase时返回。和cyclicbarrier不同，即使等待线程已经被中断，awaitadvance方法也会一直等待。中断状态和超时时间同样可用，但是当任务等待中断或超时后未改变phaser的状态时会遭遇异常。如果有必要，在方法forcetermination之后可以执行这些异常的相关的handler进行恢复操作，phaser也可能被forkjoinpool中的任务使用，这样在其他任务阻塞等待一个phase时可以保证足够的并行度来执行任务。\n\n * termination(终止机制) :\n\n可以用isterminated方法检查phaser的终止状态。在终止时，所有同步方法立刻返回一个负值。在终止时尝试注册也没有效果。当调用onadvance返回true时termination被触发。当deregistration操作使已注册的parties变为0时，onadvance的默认实现就会返回true。也可以重写onadvance方法来定义终止动作。forcetermination方法也可以释放等待线程并且允许它们终止。\n\n * tiering(分层结构) :\n\nphaser支持分层结构(树状构造)来减少竞争。注册了大量parties的phaser可能会因为同步竞争消耗很高的成本， 因此可以设置一些子phaser来共享一个通用的parent。这样的话即使每个操作消耗了更多的开销，但是会提高整体吞吐量。 在一个分层结构的phaser里，子节点phaser的注册和取消注册都通过父节点管理。子节点phaser通过构造或方法register、bulkregister进行首次注册时，在其父节点上注册。子节点phaser通过调用arriveandderegister进行最后一次取消注册时，也在其父节点上取消注册。\n\n * monitoring(状态监控) :\n\n由于同步方法可能只被已注册的parties调用，所以phaser的当前状态也可能被任何调用者监控。在任何时候，可以通过getregisteredparties获取parties数，其中getarrivedparties方法返回已经到达当前phase的parties数。当剩余的parties(通过方法getunarrivedparties获取)到达时，phase进入下一代。这些方法返回的值可能只表示短暂的状态，所以一般来说在同步结构里并没有啥卵用。\n\n\n# phaser源码详解\n\n\n# 核心参数\n\nprivate volatile long state;\n/**\n * the parent of this phaser, or null if none\n */\nprivate final phaser parent;\n/**\n * the root of phaser tree. equals this if not in a tree.\n */\nprivate final phaser root;\n//等待线程的栈顶元素，根据phase取模定义为一个奇数header和一个偶数header\nprivate final atomicreference<qnode> evenq;\nprivate final atomicreference<qnode> oddq;\n\n\n\nstate状态说明:\n\nphaser使用一个long型state值来标识内部状态:\n\n * 低0-15位表示未到达parties数；\n * 中16-31位表示等待的parties数；\n * 中32-62位表示phase当前代；\n * 高63位表示当前phaser的终止状态。\n\n注意: 子phaser的phase在没有被真正使用之前，允许滞后于它的root节点。这里在后面源码分析的reconcilestate方法里会讲解。 qnode是phaser定义的内部等待队列，用于在阻塞时记录等待线程及相关信息。实现了forkjoinpool的一个内部接口managedblocker，上面已经说过，phaser也可能被forkjoinpool中的任务使用，这样在其他任务阻塞等待一个phase时可以保证足够的并行度来执行任务(通过内部实现方法isreleasable和block)。\n\n\n# 函数列表\n\n//构造方法\npublic phaser() {\n    this(null, 0);\n}\npublic phaser(int parties) {\n    this(null, parties);\n}\npublic phaser(phaser parent) {\n    this(parent, 0);\n}\npublic phaser(phaser parent, int parties)\n//注册一个新的party\npublic int register()\n//批量注册\npublic int bulkregister(int parties)\n//使当前线程到达phaser，不等待其他任务到达。返回arrival phase number\npublic int arrive() \n//使当前线程到达phaser并撤销注册，返回arrival phase number\npublic int arriveandderegister()\n/*\n * 使当前线程到达phaser并等待其他任务到达，等价于awaitadvance(arrive())。\n * 如果需要等待中断或超时，可以使用awaitadvance方法完成一个类似的构造。\n * 如果需要在到达后取消注册，可以使用awaitadvance(arriveandderegister())。\n */\npublic int arriveandawaitadvance()\n//等待给定phase数，返回下一个 arrival phase number\npublic int awaitadvance(int phase)\n//阻塞等待，直到phase前进到下一代，返回下一代的phase number\npublic int awaitadvance(int phase) \n//响应中断版awaitadvance\npublic int awaitadvanceinterruptibly(int phase) throws interruptedexception\npublic int awaitadvanceinterruptibly(int phase, long timeout, timeunit unit)\n    throws interruptedexception, timeoutexception\n//使当前phaser进入终止状态，已注册的parties不受影响，如果是分层结构，则终止所有phaser\npublic void forcetermination()\n\n\n\n# 方法 - register()\n\n//注册一个新的party\npublic int register() {\n    return doregister(1);\n}\nprivate int doregister(int registrations) {\n    // adjustment to state\n    long adjust = ((long)registrations << parties_shift) | registrations;\n    final phaser parent = this.parent;\n    int phase;\n    for (;;) {\n        long s = (parent == null) ? state : reconcilestate();\n        int counts = (int)s;\n        int parties = counts >>> parties_shift;//获取已注册parties数\n        int unarrived = counts & unarrived_mask;//未到达数\n        if (registrations > max_parties - parties)\n            throw new illegalstateexception(badregister(s));\n        phase = (int)(s >>> phase_shift);//获取当前代\n        if (phase < 0)\n            break;\n        if (counts != empty) {                  // not 1st registration\n            if (parent == null || reconcilestate() == s) {\n                if (unarrived == 0)             // wait out advance\n                    root.internalawaitadvance(phase, null);//等待其他任务到达\n                else if (unsafe.compareandswaplong(this, stateoffset,\n                                                   s, s + adjust))//更新注册的parties数\n                    break;\n            }\n        }\n        else if (parent == null) {              // 1st root registration\n            long next = ((long)phase << phase_shift) | adjust;\n            if (unsafe.compareandswaplong(this, stateoffset, s, next))//更新phase\n                break;\n        }\n        else {\n            //分层结构，子phaser首次注册用父节点管理\n            synchronized (this) {               // 1st sub registration\n                if (state == s) {               // recheck under lock\n                    phase = parent.doregister(1);//分层结构，使用父节点注册\n                    if (phase < 0)\n                        break;\n                    // finish registration whenever parent registration\n                    // succeeded, even when racing with termination,\n                    // since these are part of the same "transaction".\n                    //由于在同一个事务里，即使phaser已终止，也会完成注册\n                    while (!unsafe.compareandswaplong\n                           (this, stateoffset, s,\n                            ((long)phase << phase_shift) | adjust)) {//更新phase\n                        s = state;\n                        phase = (int)(root.state >>> phase_shift);\n                        // assert (int)s == empty;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    return phase;\n}\n\n\n说明: register方法为phaser添加一个新的party，如果onadvance正在运行，那么这个方法会等待它运行结束再返回结果。如果当前phaser有父节点，并且当前phaser上没有已注册的party，那么就会交给父节点注册。\n\nregister和bulkregister都由doregister实现，大概流程如下:\n\n * 如果当前操作不是首次注册，那么直接在当前phaser上更新注册parties数\n * 如果是首次注册，并且当前phaser没有父节点，说明是root节点注册，直接更新phase\n * 如果当前操作是首次注册，并且当前phaser由父节点，则注册操作交由父节点，并更新当前phaser的phase\n * 上面说过，子phaser的phase在没有被真正使用之前，允许滞后于它的root节点。非首次注册时，如果phaser有父节点，则调用reconcilestate()方法解决root节点的phase延迟传递问题， 源码如下:\n\nprivate long reconcilestate() {\n    final phaser root = this.root;\n    long s = state;\n    if (root != this) {\n        int phase, p;\n        // cas to root phase with current parties, tripping unarrived\n        while ((phase = (int)(root.state >>> phase_shift)) !=\n               (int)(s >>> phase_shift) &&\n               !unsafe.compareandswaplong\n               (this, stateoffset, s,\n                s = (((long)phase << phase_shift) |\n                     ((phase < 0) ? (s & counts_mask) :\n                      (((p = (int)s >>> parties_shift) == 0) ? empty :\n                       ((s & parties_mask) | p))))))\n            s = state;\n    }\n    return s;\n}\n\n\n当root节点的phase已经advance到下一代，但是子节点phaser还没有，这种情况下它们必须通过更新未到达parties数 完成它们自己的advance操作(如果parties为0，重置为empty状态)。\n\n回到register方法的第一步，如果当前未到达数为0，说明上一代phase正在进行到达操作，此时调用internalawaitadvance()方法等待其他任务完成到达操作，源码如下:\n\n//阻塞等待phase到下一代\nprivate int internalawaitadvance(int phase, qnode node) {\n    // assert root == this;\n    releasewaiters(phase-1);          // ensure old queue clean\n    boolean queued = false;           // true when node is enqueued\n    int lastunarrived = 0;            // to increase spins upon change\n    int spins = spins_per_arrival;\n    long s;\n    int p;\n    while ((p = (int)((s = state) >>> phase_shift)) == phase) {\n        if (node == null) {           // spinning in noninterruptible mode\n            int unarrived = (int)s & unarrived_mask;//未到达数\n            if (unarrived != lastunarrived &&\n                (lastunarrived = unarrived) < ncpu)\n                spins += spins_per_arrival;\n            boolean interrupted = thread.interrupted();\n            if (interrupted || --spins < 0) { // need node to record intr\n                //使用node记录中断状态\n                node = new qnode(this, phase, false, false, 0l);\n                node.wasinterrupted = interrupted;\n            }\n        }\n        else if (node.isreleasable()) // done or aborted\n            break;\n        else if (!queued) {           // push onto queue\n            atomicreference<qnode> head = (phase & 1) == 0 ? evenq : oddq;\n            qnode q = node.next = head.get();\n            if ((q == null || q.phase == phase) &&\n                (int)(state >>> phase_shift) == phase) // avoid stale enq\n                queued = head.compareandset(q, node);\n        }\n        else {\n            try {\n                forkjoinpool.managedblock(node);//阻塞给定node\n            } catch (interruptedexception ie) {\n                node.wasinterrupted = true;\n            }\n        }\n    }\n\n    if (node != null) {\n        if (node.thread != null)\n            node.thread = null;       // avoid need for unpark()\n        if (node.wasinterrupted && !node.interruptible)\n            thread.currentthread().interrupt();\n        if (p == phase && (p = (int)(state >>> phase_shift)) == phase)\n            return abortwait(phase); // possibly clean up on abort\n    }\n    releasewaiters(phase);\n    return p;\n}\n\n\n简单介绍下第二个参数node，如果不为空，则说明等待线程需要追踪中断状态或超时状态。以doregister中的调用为例，不考虑线程争用，internalawaitadvance大概流程如下:\n\n * 首先调用releasewaiters唤醒上一代所有等待线程，确保旧队列中没有遗留的等待线程。\n * 循环spins_per_arrival指定的次数或者当前线程被中断，创建node记录等待线程及相关信息。\n * 继续循环调用forkjoinpool.managedblock运行被阻塞的任务\n * 继续循环，阻塞任务运行成功被释放，跳出循环\n * 最后唤醒当前phase的线程\n\n\n# 方法 - arrive()\n\n//使当前线程到达phaser，不等待其他任务到达。返回arrival phase number\npublic int arrive() {\n    return doarrive(one_arrival);\n}\n\nprivate int doarrive(int adjust) {\n    final phaser root = this.root;\n    for (;;) {\n        long s = (root == this) ? state : reconcilestate();\n        int phase = (int)(s >>> phase_shift);\n        if (phase < 0)\n            return phase;\n        int counts = (int)s;\n        //获取未到达数\n        int unarrived = (counts == empty) ? 0 : (counts & unarrived_mask);\n        if (unarrived <= 0)\n            throw new illegalstateexception(badarrive(s));\n        if (unsafe.compareandswaplong(this, stateoffset, s, s-=adjust)) {//更新state\n            if (unarrived == 1) {//当前为最后一个未到达的任务\n                long n = s & parties_mask;  // base of next state\n                int nextunarrived = (int)n >>> parties_shift;\n                if (root == this) {\n                    if (onadvance(phase, nextunarrived))//检查是否需要终止phaser\n                        n |= termination_bit;\n                    else if (nextunarrived == 0)\n                        n |= empty;\n                    else\n                        n |= nextunarrived;\n                    int nextphase = (phase + 1) & max_phase;\n                    n |= (long)nextphase << phase_shift;\n                    unsafe.compareandswaplong(this, stateoffset, s, n);\n                    releasewaiters(phase);//释放等待phase的线程\n                }\n                //分层结构，使用父节点管理arrive\n                else if (nextunarrived == 0) { //propagate deregistration\n                    phase = parent.doarrive(one_deregister);\n                    unsafe.compareandswaplong(this, stateoffset,\n                                              s, s | empty);\n                }\n                else\n                    phase = parent.doarrive(one_arrival);\n            }\n            return phase;\n        }\n    }\n}\n\n\n说明: arrive方法手动调整到达数，使当前线程到达phaser。arrive和arriveandderegister都调用了doarrive实现，大概流程如下:\n\n * 首先更新state(state - adjust)；\n * 如果当前不是最后一个未到达的任务，直接返回phase\n * 如果当前是最后一个未到达的任务:\n   * 如果当前是root节点，判断是否需要终止phaser，cas更新phase，最后释放等待的线程；\n   * 如果是分层结构，并且已经没有下一代未到达的parties，则交由父节点处理doarrive逻辑，然后更新state为empty。\n\n\n# 方法 - arriveandawaitadvance()\n\npublic int arriveandawaitadvance() {\n    // specialization of doarrive+awaitadvance eliminating some reads/paths\n    final phaser root = this.root;\n    for (;;) {\n        long s = (root == this) ? state : reconcilestate();\n        int phase = (int)(s >>> phase_shift);\n        if (phase < 0)\n            return phase;\n        int counts = (int)s;\n        int unarrived = (counts == empty) ? 0 : (counts & unarrived_mask);//获取未到达数\n        if (unarrived <= 0)\n            throw new illegalstateexception(badarrive(s));\n        if (unsafe.compareandswaplong(this, stateoffset, s,\n                                      s -= one_arrival)) {//更新state\n            if (unarrived > 1)\n                return root.internalawaitadvance(phase, null);//阻塞等待其他任务\n            if (root != this)\n                return parent.arriveandawaitadvance();//子phaser交给父节点处理\n            long n = s & parties_mask;  // base of next state\n            int nextunarrived = (int)n >>> parties_shift;\n            if (onadvance(phase, nextunarrived))//全部到达，检查是否可销毁\n                n |= termination_bit;\n            else if (nextunarrived == 0)\n                n |= empty;\n            else\n                n |= nextunarrived;\n            int nextphase = (phase + 1) & max_phase;//计算下一代phase\n            n |= (long)nextphase << phase_shift;\n            if (!unsafe.compareandswaplong(this, stateoffset, s, n))//更新state\n                return (int)(state >>> phase_shift); // terminated\n            releasewaiters(phase);//释放等待phase的线程\n            return nextphase;\n        }\n    }\n}\n\n\n说明: 使当前线程到达phaser并等待其他任务到达，等价于awaitadvance(arrive())。如果需要等待中断或超时，可以使用awaitadvance方法完成一个类似的构造。如果需要在到达后取消注册，可以使用awaitadvance(arriveandderegister())。效果类似于cyclicbarrier.await。大概流程如下:\n\n * 更新state(state - 1)；\n * 如果未到达数大于1，调用internalawaitadvance阻塞等待其他任务到达，返回当前phase\n * 如果为分层结构，则交由父节点处理arriveandawaitadvance逻辑\n * 如果未到达数<=1，判断phaser终止状态，cas更新phase到下一代，最后释放等待当前phase的线程，并返回下一代phase。\n\n\n# 方法 - awaitadvance(int phase)\n\npublic int awaitadvance(int phase) {\n    final phaser root = this.root;\n    long s = (root == this) ? state : reconcilestate();\n    int p = (int)(s >>> phase_shift);\n    if (phase < 0)\n        return phase;\n    if (p == phase)\n        return root.internalawaitadvance(phase, null);\n    return p;\n}\n//响应中断版awaitadvance\npublic int awaitadvanceinterruptibly(int phase)\n    throws interruptedexception {\n    final phaser root = this.root;\n    long s = (root == this) ? state : reconcilestate();\n    int p = (int)(s >>> phase_shift);\n    if (phase < 0)\n        return phase;\n    if (p == phase) {\n        qnode node = new qnode(this, phase, true, false, 0l);\n        p = root.internalawaitadvance(phase, node);\n        if (node.wasinterrupted)\n            throw new interruptedexception();\n    }\n    return p;\n}\n\n\n说明: awaitadvance用于阻塞等待线程到达，直到phase前进到下一代，返回下一代的phase number。方法很简单，不多赘述。awaitadvanceinterruptibly方法是响应中断版的awaitadvance，不同之处在于，调用阻塞时会记录线程的中断状态。\n\n\n# 参考文章\n\n * 本文主要参考自泰迪的bagwell的https://www.jianshu.com/p/e5794645ca8d，在此基础上进行了增改。\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-juc-tool-phaser.html',charsets:{cjk:!0}},{title:"关键字: final详解",frontmatter:{},regularPath:"/java/thread/java-thread-x-key-final.html",relativePath:"java/thread/java-thread-x-key-final.md",key:"v-32f9ea64",path:"/java/thread/java-thread-x-key-final.html",headers:[{level:2,title:"关键字: final详解",slug:"关键字-final详解",normalizedTitle:"关键字: final详解",charIndex:2},{level:2,title:"带着BAT大厂的面试问题去理解final",slug:"带着bat大厂的面试问题去理解final",normalizedTitle:"带着bat大厂的面试问题去理解final",charIndex:113},{level:2,title:"final基础使用",slug:"final基础使用",normalizedTitle:"final基础使用",charIndex:139},{level:3,title:"修饰类",slug:"修饰类",normalizedTitle:"修饰类",charIndex:156},{level:3,title:"修饰方法",slug:"修饰方法",normalizedTitle:"修饰方法",charIndex:167},{level:3,title:"修饰参数",slug:"修饰参数",normalizedTitle:"修饰参数",charIndex:226},{level:3,title:"修饰变量",slug:"修饰变量",normalizedTitle:"修饰变量",charIndex:238},{level:2,title:"final域重排序规则",slug:"final域重排序规则",normalizedTitle:"final域重排序规则",charIndex:323},{level:3,title:"final域为基本类型",slug:"final域为基本类型",normalizedTitle:"final域为基本类型",charIndex:342},{level:3,title:"final域为引用类型",slug:"final域为引用类型",normalizedTitle:"final域为引用类型",charIndex:405},{level:3,title:"关于final重排序的总结",slug:"关于final重排序的总结",normalizedTitle:"关于final重排序的总结",charIndex:480},{level:2,title:"final再深入理解",slug:"final再深入理解",normalizedTitle:"final再深入理解",charIndex:499},{level:3,title:"final的实现原理",slug:"final的实现原理",normalizedTitle:"final的实现原理",charIndex:517},{level:3,title:"为什么final引用不能从构造函数中“溢出”",slug:"为什么final引用不能从构造函数中-溢出",normalizedTitle:"为什么final引用不能从构造函数中“溢出”",charIndex:535},{level:3,title:"使用 final 的限制条件和局限性",slug:"使用-final-的限制条件和局限性",normalizedTitle:"使用 final 的限制条件和局限性",charIndex:565},{level:3,title:"再思考一个有趣的现象：",slug:"再思考一个有趣的现象",normalizedTitle:"再思考一个有趣的现象：",charIndex:591},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:608}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"关键字: final详解 带着BAT大厂的面试问题去理解final final基础使用 修饰类 修饰方法 修饰参数 修饰变量 final域重排序规则 final域为基本类型 final域为引用类型 关于final重排序的总结 final再深入理解 final的实现原理 为什么final引用不能从构造函数中“溢出” 使用 final 的限制条件和局限性 再思考一个有趣的现象： 参考文章",content:'# 关键字: final详解\n\n> final 关键字看上去简单，但是真正深入理解的人可以说少之又少，读完本文你就知道我在说什么了。本文将常规的用法简化，提出一些用法和深入的思考。\n\n * 关键字: final详解\n   * 带着BAT大厂的面试问题去理解final\n   * final基础使用\n     * 修饰类\n     * 修饰方法\n       * private final\n       * final方法是可以被重载的\n     * 修饰参数\n     * 修饰变量\n       * 所有的final修饰的字段都是编译期常量吗?\n       * static final\n       * blank final\n   * final域重排序规则\n     * final域为基本类型\n       * 写final域重排序规则\n       * 读final域重排序规则\n     * final域为引用类型\n       * 对final修饰的对象的成员域写操作\n       * 对final修饰的对象的成员域读操作\n     * 关于final重排序的总结\n   * final再深入理解\n     * final的实现原理\n     * 为什么final引用不能从构造函数中“溢出”\n     * 使用 final 的限制条件和局限性\n     * 再思考一个有趣的现象：\n   * 参考文章\n\n\n# 带着BAT大厂的面试问题去理解final\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解final。\n\n * 所有的final修饰的字段都是编译期常量吗?\n * 如何理解private所修饰的方法是隐式的final?\n * 说说final类型的类如何拓展? 比如String是final类型，我们想写个MyString复用所有String中方法，同时增加一个新的toMyString()的方法，应该如何做?\n * final方法可以被重载吗? 可以\n * 父类的final方法能不能够被子类重写? 不可以\n * 说说final域重排序规则?\n * 说说final的原理?\n * 使用 final 的限制条件和局限性?\n * 看本文最后的一个思考题\n\n\n# final基础使用\n\n\n# 修饰类\n\n当某个类的整体定义为final时，就表明了你不能打算继承该类，而且也不允许别人这么做。即这个类是不能有子类的。\n\n注意：final类中的所有方法都隐式为final，因为无法覆盖他们，所以在final类中给任何方法添加final关键字是没有任何意义的。\n\n> 这里顺道说说final类型的类如何拓展? 比如String是final类型，我们想写个MyString复用所有String中方法，同时增加一个新的toMyString()的方法，应该如何做?\n\n设计模式中最重要的两种关系，一种是继承/实现；另外一种是组合关系。所以当遇到不能用继承的(final修饰的类),应该考虑用组合, 如下代码大概写个组合实现的意思：\n\n/**\n* \n*/\nclass MyString{\n\n    private String innerString;\n\n    // ...init & other methods\n\n    // 支持老的方法\n    public int length(){\n        return innerString.length(); // 通过innerString调用老的方法\n    }\n\n    // 添加新方法\n    public String toMyString(){\n        //...\n    }\n}\n\n\n\n# 修饰方法\n\n> 常规的使用就不说了，这里说下:\n\n * private 方法是隐式的final\n * final方法是可以被重载的\n\n# private final\n\n类中所有private方法都隐式地指定为final的，由于无法取用private方法，所以也就不能覆盖它。可以对private方法增添final关键字，但这样做并没有什么好处。看下下面的例子：\n\npublic class Base {\n    private void test() {\n    }\n}\n\npublic class Son extends Base{\n    public void test() {\n    }\n    public static void main(String[] args) {\n        Son son = new Son();\n        Base father = son;\n        //father.test();\n    }\n}\n\n\nBase和Son都有方法test(),但是这并不是一种覆盖，因为private所修饰的方法是隐式的final，也就是无法被继承，所以更不用说是覆盖了，在Son中的test()方法不过是属于Son的新成员罢了，Son进行向上转型得到father，但是father.test()是不可执行的，因为Base中的test方法是private的，无法被访问到。\n\n# final方法是可以被重载的\n\n我们知道父类的final方法是不能够被子类重写的，那么final方法可以被重载吗? 答案是可以的，下面代码是正确的。\n\npublic class FinalExampleParent {\n    public final void test() {\n    }\n\n    public final void test(String str) {\n    }\n}\n\n\n\n# 修饰参数\n\nJava允许在参数列表中以声明的方式将参数指明为final，这意味这你无法在方法中更改参数引用所指向的对象。这个特性主要用来向匿名内部类传递数据。\n\n\n# 修饰变量\n\n> 常规的用法比较简单，这里通过下面三个问题进一步说明。\n\n# 所有的final修饰的字段都是编译期常量吗?\n\n现在来看编译期常量和非编译期常量, 如：\n\npublic class Test {\n    //编译期常量\n    final int i = 1;\n    final static int J = 1;\n    final int[] a = {1,2,3,4};\n    //非编译期常量\n    Random r = new Random();\n    final int k = r.nextInt();\n\n    public static void main(String[] args) {\n\n    }\n}\n\n\nk的值由随机数对象决定，所以不是所有的final修饰的字段都是编译期常量，只是k的值在被初始化后无法被更改。\n\n# static final\n\n一个既是static又是final 的字段只占据一段不能改变的存储空间，它必须在定义的时候进行赋值，否则编译器将不予通过。\n\nimport java.util.Random;\npublic class Test {\n    static Random r = new Random();\n    final int k = r.nextInt(10);\n    static final int k2 = r.nextInt(10); \n    public static void main(String[] args) {\n        Test t1 = new Test();\n        System.out.println("k="+t1.k+" k2="+t1.k2);\n        Test t2 = new Test();\n        System.out.println("k="+t2.k+" k2="+t2.k2);\n    }\n}\n\n\n上面代码某次输出结果：\n\n我们可以发现对于不同的对象k的值是不同的，但是k2的值却是相同的，这是为什么呢? 因为static关键字所修饰的字段并不属于一个对象，而是属于这个类的。也可简单的理解为static final所修饰的字段仅占据内存的一个一份空间，一旦被初始化之后便不会被更改。\n\n# blank final\n\nJava允许生成空白final，也就是说被声明为final但又没有给出定值的字段,但是必须在该字段被使用之前被赋值，这给予我们两种选择：\n\n * 在定义处进行赋值(这不叫空白final)\n * 在构造器中进行赋值，保证了该值在被使用前赋值。\n\n这增强了final的灵活性。\n\n看下面代码:\n\npublic class Test {\n    final int i1 = 1;\n    final int i2;//空白final\n    public Test() {\n        i2 = 1;\n    }\n    public Test(int x) {\n        this.i2 = x;\n    }\n}\n\n\n可以看到i2的赋值更为灵活。但是请注意，如果字段由static和final修饰，仅能在声明时赋值或声明后在静态代码块中赋值，因为该字段不属于对象，属于这个类。\n\n\n# final域重排序规则\n\n上面我们聊的final使用，应该属于Java基础层面的，当理解这些后我们就真的算是掌握了final吗? 有考虑过final在多线程并发的情况吗? 在java内存模型中我们知道java内存模型为了能让处理器和编译器底层发挥他们的最大优势，对底层的约束就很少，也就是说针对底层来说java内存模型就是一弱内存数据模型。同时，处理器和编译为了性能优化会对指令序列有编译器和处理器重排序。那么，在多线程情况下,final会进行怎样的重排序? 会导致线程安全的问题吗? 下面，就来看看final的重排序。\n\n\n# final域为基本类型\n\n先看一段示例性的代码：\n\npublic class FinalDemo {\n    private int a;  //普通域\n    private final int b; //final域\n    private static FinalDemo finalDemo;\n\n    public FinalDemo() {\n        a = 1; // 1. 写普通域\n        b = 2; // 2. 写final域\n    }\n\n    public static void writer() {\n        finalDemo = new FinalDemo();\n    }\n\n    public static void reader() {\n        FinalDemo demo = finalDemo; // 3.读对象引用\n        int a = demo.a;    //4.读普通域\n        int b = demo.b;    //5.读final域\n    }\n}\n\n\n假设线程A在执行writer()方法，线程B执行reader()方法。\n\n# 写final域重排序规则\n\n写final域的重排序规则禁止对final域的写重排序到构造函数之外，这个规则的实现主要包含了两个方面：\n\n * JMM禁止编译器把final域的写重排序到构造函数之外；\n * 编译器会在final域写之后，构造函数return之前，插入一个storestore屏障。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。\n\n我们再来分析writer方法，虽然只有一行代码，但实际上做了两件事情：\n\n * 构造了一个FinalDemo对象；\n * 把这个对象赋值给成员变量finalDemo。\n\n我们来画下存在的一种可能执行时序图，如下：\n\n\n\n由于a,b之间没有数据依赖性，普通域(普通变量)a可能会被重排序到构造函数之外，线程B就有可能读到的是普通变量a初始化之前的值(零值)，这样就可能出现错误。而final域变量b，根据重排序规则，会禁止final修饰的变量b重排序到构造函数之外，从而b能够正确赋值，线程B就能够读到final变量初始化后的值。\n\n因此，写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域就不具有这个保障。比如在上例，线程B有可能就是一个未正确初始化的对象finalDemo。\n\n# 读final域重排序规则\n\n读final域重排序规则为：在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序。(注意，这个规则仅仅是针对处理器)，处理器会在读final域操作的前面插入一个LoadLoad屏障。实际上，读对象的引用和读该对象的final域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。\n\nread()方法主要包含了三个操作：\n\n * 初次读引用变量finalDemo;\n * 初次读引用变量finalDemo的普通域a;\n * 初次读引用变量finalDemo的final域b;\n\n假设线程A写过程没有重排序，那么线程A和线程B有一种的可能执行时序为下图：\n\n\n\n读对象的普通域被重排序到了读对象引用的前面就会出现线程B还未读到对象引用就在读取该对象的普通域变量，这显然是错误的操作。而final域的读操作就“限定”了在读final域变量前已经读到了该对象的引用，从而就可以避免这种情况。\n\n读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读这个包含这个final域的对象的引用。\n\n\n# final域为引用类型\n\n我们已经知道了final域是基本数据类型的时候重排序规则是怎么的了? 如果是引用数据类型了? 我们接着继续来探讨。\n\n# 对final修饰的对象的成员域写操作\n\n针对引用数据类型，final域写针对编译器和处理器重排序增加了这样的约束：在构造函数内对一个final修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。注意这里的是“增加”也就说前面对final基本数据类型的重排序规则在这里还是使用。这句话是比较拗口的，下面结合实例来看。\n\npublic class FinalReferenceDemo {\n    final int[] arrays;\n    private FinalReferenceDemo finalReferenceDemo;\n\n    public FinalReferenceDemo() {\n        arrays = new int[1];  //1\n        arrays[0] = 1;        //2\n    }\n\n    public void writerOne() {\n        finalReferenceDemo = new FinalReferenceDemo(); //3\n    }\n\n    public void writerTwo() {\n        arrays[0] = 2;  //4\n    }\n\n    public void reader() {\n        if (finalReferenceDemo != null) {  //5\n            int temp = finalReferenceDemo.arrays[0];  //6\n        }\n    }\n}\n\n\n针对上面的实例程序，线程线程A执行wirterOne方法，执行完后线程B执行writerTwo方法，然后线程C执行reader方法。下图就以这种执行时序出现的一种情况来讨论(耐心看完才有收获)。\n\n\n\n由于对final域的写禁止重排序到构造方法外，因此1和3不能被重排序。由于一个final域的引用对象的成员域写入不能与随后将这个被构造出来的对象赋给引用变量重排序，因此2和3不能重排序。\n\n# 对final修饰的对象的成员域读操作\n\nJMM可以确保线程C至少能看到写线程A对final引用的对象的成员域的写入，即能看下arrays[0] = 1，而写线程B对数组元素的写入可能看到可能看不到。JMM不保证线程B的写入对线程C可见，线程B和线程C之间存在数据竞争，此时的结果是不可预知的。如果可见的，可使用锁或者volatile。\n\n\n# 关于final重排序的总结\n\n按照final修饰的数据类型分类：\n\n * 基本数据类型:\n   \n   * final域写：禁止final域写与构造方法重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。\n   * final域读：禁止初次读对象的引用与读该对象包含的final域的重排序。\n\n * 引用数据类型：\n   \n   * 额外增加约束：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量 重排序\n\n\n# final再深入理解\n\n\n# final的实现原理\n\n上面我们提到过，写final域会要求编译器在final域写之后，构造函数返回前插入一个StoreStore屏障。读final域的重排序规则会要求编译器在读final域的操作前插入一个LoadLoad屏障。\n\n很有意思的是，如果以X86处理为例，X86不会对写-写重排序，所以StoreStore屏障可以省略。由于不会对有间接依赖性的操作重排序，所以在X86处理器中，读final域需要的LoadLoad屏障也会被省略掉。也就是说，以X86为例的话，对final域的读/写的内存屏障都会被省略！具体是否插入还是得看是什么处理器\n\n\n# 为什么final引用不能从构造函数中“溢出”\n\n这里还有一个比较有意思的问题：上面对final域写重排序规则可以确保我们在使用一个对象引用的时候该对象的final域已经在构造函数被初始化过了。但是这里其实是有一个前提条件的，也就是：在构造函数，不能让这个被构造的对象被其他线程可见，也就是说该对象引用不能在构造函数中“溢出”。以下面的例子来说：\n\npublic class FinalReferenceEscapeDemo {\n    private final int a;\n    private FinalReferenceEscapeDemo referenceDemo;\n\n    public FinalReferenceEscapeDemo() {\n        a = 1;  //1\n        referenceDemo = this; //2\n    }\n\n    public void writer() {\n        new FinalReferenceEscapeDemo();\n    }\n\n    public void reader() {\n        if (referenceDemo != null) {  //3\n            int temp = referenceDemo.a; //4\n        }\n    }\n}\n\n\n可能的执行时序如图所示：\n\n\n\n假设一个线程A执行writer方法另一个线程执行reader方法。因为构造函数中操作1和2之间没有数据依赖性，1和2可以重排序，先执行了2，这个时候引用对象referenceDemo是个没有完全初始化的对象，而当线程B去读取该对象时就会出错。尽管依然满足了final域写重排序规则：在引用对象对所有线程可见时，其final域已经完全初始化成功。但是，引用对象“this”逸出，该代码依然存在线程安全的问题。\n\n\n# 使用 final 的限制条件和局限性\n\n当声明一个 final 成员时，必须在构造函数退出前设置它的值。\n\npublic class MyClass {\n  private final int myField = 1;\n  public MyClass() {\n    ...\n  }\n}\n\n\n或者\n\npublic class MyClass {\n  private final int myField;\n  public MyClass() {\n    ...\n    myField = 1;\n    ...\n  }\n}\n\n\n将指向对象的成员声明为 final 只能将该引用设为不可变的，而非所指的对象。\n\n下面的方法仍然可以修改该 list。\n\nprivate final List myList = new ArrayList();\nmyList.add("Hello");\n\n\n声明为 final 可以保证如下操作不合法\n\nmyList = new ArrayList();\nmyList = someOtherList;\n\n\n如果一个对象将会在多个线程中访问并且你并没有将其成员声明为 final，则必须提供其他方式保证线程安全。\n\n" 其他方式 " 可以包括声明成员为 volatile，使用 synchronized 或者显式 Lock 控制所有该成员的访问。\n\n\n# 再思考一个有趣的现象：\n\nbyte b1=1;\nbyte b2=3;\nbyte b3=b1+b2;//当程序执行到这一行的时候会出错，因为b1、b2可以自动转换成int类型的变量，运算时java虚拟机对它进行了转换，结果导致把一个int赋值给byte-----出错\n\n\n如果对b1 b2加上final就不会出错\n\nfinal byte b1=1;\nfinal byte b2=3;\nbyte b3=b1+b2;//不会出错，相信你看了上面的解释就知道原因了。\n\n\n\n# 参考文章\n\n * https://www.jianshu.com/p/1e82c75034b7\n * 《java并发编程的艺术》\n * 《疯狂java讲义》\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-key-final.html',normalizedContent:'# 关键字: final详解\n\n> final 关键字看上去简单，但是真正深入理解的人可以说少之又少，读完本文你就知道我在说什么了。本文将常规的用法简化，提出一些用法和深入的思考。\n\n * 关键字: final详解\n   * 带着bat大厂的面试问题去理解final\n   * final基础使用\n     * 修饰类\n     * 修饰方法\n       * private final\n       * final方法是可以被重载的\n     * 修饰参数\n     * 修饰变量\n       * 所有的final修饰的字段都是编译期常量吗?\n       * static final\n       * blank final\n   * final域重排序规则\n     * final域为基本类型\n       * 写final域重排序规则\n       * 读final域重排序规则\n     * final域为引用类型\n       * 对final修饰的对象的成员域写操作\n       * 对final修饰的对象的成员域读操作\n     * 关于final重排序的总结\n   * final再深入理解\n     * final的实现原理\n     * 为什么final引用不能从构造函数中“溢出”\n     * 使用 final 的限制条件和局限性\n     * 再思考一个有趣的现象：\n   * 参考文章\n\n\n# 带着bat大厂的面试问题去理解final\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解final。\n\n * 所有的final修饰的字段都是编译期常量吗?\n * 如何理解private所修饰的方法是隐式的final?\n * 说说final类型的类如何拓展? 比如string是final类型，我们想写个mystring复用所有string中方法，同时增加一个新的tomystring()的方法，应该如何做?\n * final方法可以被重载吗? 可以\n * 父类的final方法能不能够被子类重写? 不可以\n * 说说final域重排序规则?\n * 说说final的原理?\n * 使用 final 的限制条件和局限性?\n * 看本文最后的一个思考题\n\n\n# final基础使用\n\n\n# 修饰类\n\n当某个类的整体定义为final时，就表明了你不能打算继承该类，而且也不允许别人这么做。即这个类是不能有子类的。\n\n注意：final类中的所有方法都隐式为final，因为无法覆盖他们，所以在final类中给任何方法添加final关键字是没有任何意义的。\n\n> 这里顺道说说final类型的类如何拓展? 比如string是final类型，我们想写个mystring复用所有string中方法，同时增加一个新的tomystring()的方法，应该如何做?\n\n设计模式中最重要的两种关系，一种是继承/实现；另外一种是组合关系。所以当遇到不能用继承的(final修饰的类),应该考虑用组合, 如下代码大概写个组合实现的意思：\n\n/**\n* \n*/\nclass mystring{\n\n    private string innerstring;\n\n    // ...init & other methods\n\n    // 支持老的方法\n    public int length(){\n        return innerstring.length(); // 通过innerstring调用老的方法\n    }\n\n    // 添加新方法\n    public string tomystring(){\n        //...\n    }\n}\n\n\n\n# 修饰方法\n\n> 常规的使用就不说了，这里说下:\n\n * private 方法是隐式的final\n * final方法是可以被重载的\n\n# private final\n\n类中所有private方法都隐式地指定为final的，由于无法取用private方法，所以也就不能覆盖它。可以对private方法增添final关键字，但这样做并没有什么好处。看下下面的例子：\n\npublic class base {\n    private void test() {\n    }\n}\n\npublic class son extends base{\n    public void test() {\n    }\n    public static void main(string[] args) {\n        son son = new son();\n        base father = son;\n        //father.test();\n    }\n}\n\n\nbase和son都有方法test(),但是这并不是一种覆盖，因为private所修饰的方法是隐式的final，也就是无法被继承，所以更不用说是覆盖了，在son中的test()方法不过是属于son的新成员罢了，son进行向上转型得到father，但是father.test()是不可执行的，因为base中的test方法是private的，无法被访问到。\n\n# final方法是可以被重载的\n\n我们知道父类的final方法是不能够被子类重写的，那么final方法可以被重载吗? 答案是可以的，下面代码是正确的。\n\npublic class finalexampleparent {\n    public final void test() {\n    }\n\n    public final void test(string str) {\n    }\n}\n\n\n\n# 修饰参数\n\njava允许在参数列表中以声明的方式将参数指明为final，这意味这你无法在方法中更改参数引用所指向的对象。这个特性主要用来向匿名内部类传递数据。\n\n\n# 修饰变量\n\n> 常规的用法比较简单，这里通过下面三个问题进一步说明。\n\n# 所有的final修饰的字段都是编译期常量吗?\n\n现在来看编译期常量和非编译期常量, 如：\n\npublic class test {\n    //编译期常量\n    final int i = 1;\n    final static int j = 1;\n    final int[] a = {1,2,3,4};\n    //非编译期常量\n    random r = new random();\n    final int k = r.nextint();\n\n    public static void main(string[] args) {\n\n    }\n}\n\n\nk的值由随机数对象决定，所以不是所有的final修饰的字段都是编译期常量，只是k的值在被初始化后无法被更改。\n\n# static final\n\n一个既是static又是final 的字段只占据一段不能改变的存储空间，它必须在定义的时候进行赋值，否则编译器将不予通过。\n\nimport java.util.random;\npublic class test {\n    static random r = new random();\n    final int k = r.nextint(10);\n    static final int k2 = r.nextint(10); \n    public static void main(string[] args) {\n        test t1 = new test();\n        system.out.println("k="+t1.k+" k2="+t1.k2);\n        test t2 = new test();\n        system.out.println("k="+t2.k+" k2="+t2.k2);\n    }\n}\n\n\n上面代码某次输出结果：\n\n我们可以发现对于不同的对象k的值是不同的，但是k2的值却是相同的，这是为什么呢? 因为static关键字所修饰的字段并不属于一个对象，而是属于这个类的。也可简单的理解为static final所修饰的字段仅占据内存的一个一份空间，一旦被初始化之后便不会被更改。\n\n# blank final\n\njava允许生成空白final，也就是说被声明为final但又没有给出定值的字段,但是必须在该字段被使用之前被赋值，这给予我们两种选择：\n\n * 在定义处进行赋值(这不叫空白final)\n * 在构造器中进行赋值，保证了该值在被使用前赋值。\n\n这增强了final的灵活性。\n\n看下面代码:\n\npublic class test {\n    final int i1 = 1;\n    final int i2;//空白final\n    public test() {\n        i2 = 1;\n    }\n    public test(int x) {\n        this.i2 = x;\n    }\n}\n\n\n可以看到i2的赋值更为灵活。但是请注意，如果字段由static和final修饰，仅能在声明时赋值或声明后在静态代码块中赋值，因为该字段不属于对象，属于这个类。\n\n\n# final域重排序规则\n\n上面我们聊的final使用，应该属于java基础层面的，当理解这些后我们就真的算是掌握了final吗? 有考虑过final在多线程并发的情况吗? 在java内存模型中我们知道java内存模型为了能让处理器和编译器底层发挥他们的最大优势，对底层的约束就很少，也就是说针对底层来说java内存模型就是一弱内存数据模型。同时，处理器和编译为了性能优化会对指令序列有编译器和处理器重排序。那么，在多线程情况下,final会进行怎样的重排序? 会导致线程安全的问题吗? 下面，就来看看final的重排序。\n\n\n# final域为基本类型\n\n先看一段示例性的代码：\n\npublic class finaldemo {\n    private int a;  //普通域\n    private final int b; //final域\n    private static finaldemo finaldemo;\n\n    public finaldemo() {\n        a = 1; // 1. 写普通域\n        b = 2; // 2. 写final域\n    }\n\n    public static void writer() {\n        finaldemo = new finaldemo();\n    }\n\n    public static void reader() {\n        finaldemo demo = finaldemo; // 3.读对象引用\n        int a = demo.a;    //4.读普通域\n        int b = demo.b;    //5.读final域\n    }\n}\n\n\n假设线程a在执行writer()方法，线程b执行reader()方法。\n\n# 写final域重排序规则\n\n写final域的重排序规则禁止对final域的写重排序到构造函数之外，这个规则的实现主要包含了两个方面：\n\n * jmm禁止编译器把final域的写重排序到构造函数之外；\n * 编译器会在final域写之后，构造函数return之前，插入一个storestore屏障。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。\n\n我们再来分析writer方法，虽然只有一行代码，但实际上做了两件事情：\n\n * 构造了一个finaldemo对象；\n * 把这个对象赋值给成员变量finaldemo。\n\n我们来画下存在的一种可能执行时序图，如下：\n\n\n\n由于a,b之间没有数据依赖性，普通域(普通变量)a可能会被重排序到构造函数之外，线程b就有可能读到的是普通变量a初始化之前的值(零值)，这样就可能出现错误。而final域变量b，根据重排序规则，会禁止final修饰的变量b重排序到构造函数之外，从而b能够正确赋值，线程b就能够读到final变量初始化后的值。\n\n因此，写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域就不具有这个保障。比如在上例，线程b有可能就是一个未正确初始化的对象finaldemo。\n\n# 读final域重排序规则\n\n读final域重排序规则为：在一个线程中，初次读对象引用和初次读该对象包含的final域，jmm会禁止这两个操作的重排序。(注意，这个规则仅仅是针对处理器)，处理器会在读final域操作的前面插入一个loadload屏障。实际上，读对象的引用和读该对象的final域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。\n\nread()方法主要包含了三个操作：\n\n * 初次读引用变量finaldemo;\n * 初次读引用变量finaldemo的普通域a;\n * 初次读引用变量finaldemo的final域b;\n\n假设线程a写过程没有重排序，那么线程a和线程b有一种的可能执行时序为下图：\n\n\n\n读对象的普通域被重排序到了读对象引用的前面就会出现线程b还未读到对象引用就在读取该对象的普通域变量，这显然是错误的操作。而final域的读操作就“限定”了在读final域变量前已经读到了该对象的引用，从而就可以避免这种情况。\n\n读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读这个包含这个final域的对象的引用。\n\n\n# final域为引用类型\n\n我们已经知道了final域是基本数据类型的时候重排序规则是怎么的了? 如果是引用数据类型了? 我们接着继续来探讨。\n\n# 对final修饰的对象的成员域写操作\n\n针对引用数据类型，final域写针对编译器和处理器重排序增加了这样的约束：在构造函数内对一个final修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。注意这里的是“增加”也就说前面对final基本数据类型的重排序规则在这里还是使用。这句话是比较拗口的，下面结合实例来看。\n\npublic class finalreferencedemo {\n    final int[] arrays;\n    private finalreferencedemo finalreferencedemo;\n\n    public finalreferencedemo() {\n        arrays = new int[1];  //1\n        arrays[0] = 1;        //2\n    }\n\n    public void writerone() {\n        finalreferencedemo = new finalreferencedemo(); //3\n    }\n\n    public void writertwo() {\n        arrays[0] = 2;  //4\n    }\n\n    public void reader() {\n        if (finalreferencedemo != null) {  //5\n            int temp = finalreferencedemo.arrays[0];  //6\n        }\n    }\n}\n\n\n针对上面的实例程序，线程线程a执行wirterone方法，执行完后线程b执行writertwo方法，然后线程c执行reader方法。下图就以这种执行时序出现的一种情况来讨论(耐心看完才有收获)。\n\n\n\n由于对final域的写禁止重排序到构造方法外，因此1和3不能被重排序。由于一个final域的引用对象的成员域写入不能与随后将这个被构造出来的对象赋给引用变量重排序，因此2和3不能重排序。\n\n# 对final修饰的对象的成员域读操作\n\njmm可以确保线程c至少能看到写线程a对final引用的对象的成员域的写入，即能看下arrays[0] = 1，而写线程b对数组元素的写入可能看到可能看不到。jmm不保证线程b的写入对线程c可见，线程b和线程c之间存在数据竞争，此时的结果是不可预知的。如果可见的，可使用锁或者volatile。\n\n\n# 关于final重排序的总结\n\n按照final修饰的数据类型分类：\n\n * 基本数据类型:\n   \n   * final域写：禁止final域写与构造方法重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。\n   * final域读：禁止初次读对象的引用与读该对象包含的final域的重排序。\n\n * 引用数据类型：\n   \n   * 额外增加约束：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量 重排序\n\n\n# final再深入理解\n\n\n# final的实现原理\n\n上面我们提到过，写final域会要求编译器在final域写之后，构造函数返回前插入一个storestore屏障。读final域的重排序规则会要求编译器在读final域的操作前插入一个loadload屏障。\n\n很有意思的是，如果以x86处理为例，x86不会对写-写重排序，所以storestore屏障可以省略。由于不会对有间接依赖性的操作重排序，所以在x86处理器中，读final域需要的loadload屏障也会被省略掉。也就是说，以x86为例的话，对final域的读/写的内存屏障都会被省略！具体是否插入还是得看是什么处理器\n\n\n# 为什么final引用不能从构造函数中“溢出”\n\n这里还有一个比较有意思的问题：上面对final域写重排序规则可以确保我们在使用一个对象引用的时候该对象的final域已经在构造函数被初始化过了。但是这里其实是有一个前提条件的，也就是：在构造函数，不能让这个被构造的对象被其他线程可见，也就是说该对象引用不能在构造函数中“溢出”。以下面的例子来说：\n\npublic class finalreferenceescapedemo {\n    private final int a;\n    private finalreferenceescapedemo referencedemo;\n\n    public finalreferenceescapedemo() {\n        a = 1;  //1\n        referencedemo = this; //2\n    }\n\n    public void writer() {\n        new finalreferenceescapedemo();\n    }\n\n    public void reader() {\n        if (referencedemo != null) {  //3\n            int temp = referencedemo.a; //4\n        }\n    }\n}\n\n\n可能的执行时序如图所示：\n\n\n\n假设一个线程a执行writer方法另一个线程执行reader方法。因为构造函数中操作1和2之间没有数据依赖性，1和2可以重排序，先执行了2，这个时候引用对象referencedemo是个没有完全初始化的对象，而当线程b去读取该对象时就会出错。尽管依然满足了final域写重排序规则：在引用对象对所有线程可见时，其final域已经完全初始化成功。但是，引用对象“this”逸出，该代码依然存在线程安全的问题。\n\n\n# 使用 final 的限制条件和局限性\n\n当声明一个 final 成员时，必须在构造函数退出前设置它的值。\n\npublic class myclass {\n  private final int myfield = 1;\n  public myclass() {\n    ...\n  }\n}\n\n\n或者\n\npublic class myclass {\n  private final int myfield;\n  public myclass() {\n    ...\n    myfield = 1;\n    ...\n  }\n}\n\n\n将指向对象的成员声明为 final 只能将该引用设为不可变的，而非所指的对象。\n\n下面的方法仍然可以修改该 list。\n\nprivate final list mylist = new arraylist();\nmylist.add("hello");\n\n\n声明为 final 可以保证如下操作不合法\n\nmylist = new arraylist();\nmylist = someotherlist;\n\n\n如果一个对象将会在多个线程中访问并且你并没有将其成员声明为 final，则必须提供其他方式保证线程安全。\n\n" 其他方式 " 可以包括声明成员为 volatile，使用 synchronized 或者显式 lock 控制所有该成员的访问。\n\n\n# 再思考一个有趣的现象：\n\nbyte b1=1;\nbyte b2=3;\nbyte b3=b1+b2;//当程序执行到这一行的时候会出错，因为b1、b2可以自动转换成int类型的变量，运算时java虚拟机对它进行了转换，结果导致把一个int赋值给byte-----出错\n\n\n如果对b1 b2加上final就不会出错\n\nfinal byte b1=1;\nfinal byte b2=3;\nbyte b3=b1+b2;//不会出错，相信你看了上面的解释就知道原因了。\n\n\n\n# 参考文章\n\n * https://www.jianshu.com/p/1e82c75034b7\n * 《java并发编程的艺术》\n * 《疯狂java讲义》\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-key-final.html',charsets:{cjk:!0}},{title:"关键字: volatile详解",frontmatter:{},regularPath:"/java/thread/java-thread-x-key-volatile.html",relativePath:"java/thread/java-thread-x-key-volatile.md",key:"v-a5b25408",path:"/java/thread/java-thread-x-key-volatile.html",headers:[{level:2,title:"关键字: volatile详解",slug:"关键字-volatile详解",normalizedTitle:"关键字: volatile详解",charIndex:2},{level:2,title:"带着BAT大厂的面试问题去理解volatile",slug:"带着bat大厂的面试问题去理解volatile",normalizedTitle:"带着bat大厂的面试问题去理解volatile",charIndex:106},{level:2,title:"volatile的作用详解",slug:"volatile的作用详解",normalizedTitle:"volatile的作用详解",charIndex:135},{level:3,title:"防重排序",slug:"防重排序",normalizedTitle:"防重排序",charIndex:156},{level:3,title:"实现可见性",slug:"实现可见性",normalizedTitle:"实现可见性",charIndex:168},{level:3,title:"保证原子性:单次读/写",slug:"保证原子性-单次读-写",normalizedTitle:"保证原子性:单次读/写",charIndex:181},{level:2,title:"volatile 的实现原理",slug:"volatile-的实现原理",normalizedTitle:"volatile 的实现原理",charIndex:273},{level:3,title:"volatile 可见性实现",slug:"volatile-可见性实现",normalizedTitle:"volatile 可见性实现",charIndex:295},{level:3,title:"volatile 有序性实现",slug:"volatile-有序性实现",normalizedTitle:"volatile 有序性实现",charIndex:349},{level:2,title:"volatile 的应用场景",slug:"volatile-的应用场景",normalizedTitle:"volatile 的应用场景",charIndex:431},{level:3,title:"模式1：状态标志",slug:"模式1-状态标志",normalizedTitle:"模式1：状态标志",charIndex:453},{level:3,title:"模式2：一次性安全发布(one-time safe publication)",slug:"模式2-一次性安全发布-one-time-safe-publication",normalizedTitle:"模式2：一次性安全发布(one-time safe publication)",charIndex:469},{level:3,title:"模式3：独立观察(independent observation)",slug:"模式3-独立观察-independent-observation",normalizedTitle:"模式3：独立观察(independent observation)",charIndex:515},{level:3,title:"模式4：volatile bean 模式",slug:"模式4-volatile-bean-模式",normalizedTitle:"模式4：volatile bean 模式",charIndex:556},{level:3,title:"模式5：开销较低的读－写锁策略",slug:"模式5-开销较低的读-写锁策略",normalizedTitle:"模式5：开销较低的读－写锁策略",charIndex:584},{level:3,title:"模式6：双重检查(double-checked)",slug:"模式6-双重检查-double-checked",normalizedTitle:"模式6：双重检查(double-checked)",charIndex:607},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:637}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"关键字: volatile详解 带着BAT大厂的面试问题去理解volatile volatile的作用详解 防重排序 实现可见性 保证原子性:单次读/写 volatile 的实现原理 volatile 可见性实现 volatile 有序性实现 volatile 的应用场景 模式1：状态标志 模式2：一次性安全发布(one-time safe publication) 模式3：独立观察(independent observation) 模式4：volatile bean 模式 模式5：开销较低的读－写锁策略 模式6：双重检查(double-checked) 参考文章",content:'# 关键字: volatile详解\n\n> 相比Sychronized(重量级锁，对系统性能影响较大)，volatile提供了另一种解决可见性和有序性问题的方案。\n\n * 关键字: volatile详解\n   * 带着BAT大厂的面试问题去理解volatile\n   * volatile的作用详解\n     * 防重排序\n     * 实现可见性\n     * 保证原子性:单次读/写\n       * 问题1： i++为什么不能保证原子性?\n       * 问题2： 共享的long和double变量的为什么要用volatile?\n   * volatile 的实现原理\n     * volatile 可见性实现\n       * lock 指令\n       * 缓存一致性\n     * volatile 有序性实现\n       * volatile 的 happens-before 关系\n       * volatile 禁止重排序\n   * volatile 的应用场景\n     * 模式1：状态标志\n     * 模式2：一次性安全发布(one-time safe publication)\n     * 模式3：独立观察(independent observation)\n     * 模式4：volatile bean 模式\n     * 模式5：开销较低的读－写锁策略\n     * 模式6：双重检查(double-checked)\n   * 参考文章\n\n\n# 带着BAT大厂的面试问题去理解volatile\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解volatile。\n\n * volatile关键字的作用是什么?\n * volatile能保证原子性吗?\n * 之前32位机器上共享的long和double变量的为什么要用volatile? 现在64位机器上是否也要设置呢?\n * i++为什么不能保证原子性?\n * volatile是如何实现可见性的? 内存屏障。\n * volatile是如何实现有序性的? happens-before等\n * 说下volatile的应用场景?\n\n\n# volatile的作用详解\n\n\n# 防重排序\n\n我们从一个最经典的例子来分析重排序问题。大家应该都很熟悉单例模式的实现，而在并发环境下的单例实现方式，我们通常可以采用双重检查加锁(DCL)的方式来实现。其源码如下：\n\npublic class Singleton {\n    public static volatile Singleton singleton;\n    /**\n     * 构造函数私有，禁止外部实例化\n     */\n    private Singleton() {};\n    public static Singleton getInstance() {\n        if (singleton == null) {\n            synchronized (singleton.class) {\n                if (singleton == null) {\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n}\n\n\n现在我们分析一下为什么要在变量singleton之间加上volatile关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤：\n\n * 分配内存空间。\n * 初始化对象。\n * 将内存空间的地址赋值给对应的引用。\n\n但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程：\n\n * 分配内存空间。\n * 将内存空间的地址赋值给对应的引用。\n * 初始化对象\n\n如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。\n\n\n# 实现可见性\n\n可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。volatile关键字能有效的解决这个问题，我们看下下面的例子，就可以知道其作用：\n\npublic class TestVolatile {\n    private static boolean stop = false;\n\n    public static void main(String[] args) {\n        // Thread-A\n        new Thread("Thread A") {\n            @Override\n            public void run() {\n                while (!stop) {\n                }\n                System.out.println(Thread.currentThread() + " stopped");\n            }\n        }.start();\n\n        // Thread-main\n        try {\n            TimeUnit.SECONDS.sleep(1);\n            System.out.println(Thread.currentThread() + " after 1 seconds");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        stop = true;\n    }\n}\n\n\n执行输出如下\n\nThread[main,5,main] after 1 seconds\n\n// Thread A一直在loop, 因为Thread A 由于可见性原因看不到Thread Main 已经修改stop的值\n\n\n可以看到 Thread-main 休眠1秒之后，设置 stop = ture，但是Thread A根本没停下来，这就是可见性问题。如果通过在stop变量前面加上volatile关键字则会真正stop:\n\nThread[main,5,main] after 1 seconds\nThread[Thread A,5,main] stopped\n\nProcess finished with exit code 0\n\n\n\n# 保证原子性:单次读/写\n\nvolatile不能保证完全的原子性，只能保证单次的读/写操作具有原子性。先从如下两个问题来理解（后文再从内存屏障的角度理解）：\n\n# 问题1： i++为什么不能保证原子性?\n\n对于原子性，需要强调一点，也是大家容易误解的一点：对volatile变量的单次读/写操作可以保证原子性的，如long和double类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。\n\n现在我们就通过下列程序来演示一下这个问题：\n\npublic class VolatileTest01 {\n    volatile int i;\n\n    public void addI(){\n        i++;\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        final  VolatileTest01 test01 = new VolatileTest01();\n        for (int n = 0; n < 1000; n++) {\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        Thread.sleep(10);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    test01.addI();\n                }\n            }).start();\n        }\n        Thread.sleep(10000);//等待10秒，保证上面程序执行完成\n        System.out.println(test01.i);\n    }\n}\n\n\n大家可能会误认为对变量i加上关键字volatile后，这段程序就是线程安全的。大家可以尝试运行上面的程序。下面是我本地运行的结果：981 可能每个人运行的结果不相同。不过应该能看出，volatile是无法保证原子性的(否则结果应该是1000)。原因也很简单，i++其实是一个复合操作，包括三步骤：\n\n * 读取i的值。\n * 对i加1。\n * 将i的值写回内存。 volatile是无法保证这三个操作是具有原子性的，我们可以通过AtomicInteger或者Synchronized来保证+1操作的原子性。 注：上面几段代码中多处执行了Thread.sleep()方法，目的是为了增加并发问题的产生几率，无其他作用。\n\n# 问题2： 共享的long和double变量的为什么要用volatile?\n\n因为long和double两种数据类型的操作可分为高32位和低32位两部分，因此普通的long或double类型读/写可能不是原子的。因此，鼓励大家将共享的long和double变量设置为volatile类型，这样能保证任何情况下对long和double的单次读/写操作都具有原子性。\n\n如下是JLS中的解释：\n\n> 17.7 Non-Atomic Treatment of double and long\n\n * For the purposes of the Java programming language memory model, a single write to a non-volatile long or double value is treated as two separate writes: one to each 32-bit half. This can result in a situation where a thread sees the first 32 bits of a 64-bit value from one write, and the second 32 bits from another write.\n * Writes and reads of volatile long and double values are always atomic.\n * Writes to and reads of references are always atomic, regardless of whether they are implemented as 32-bit or 64-bit values.\n * Some implementations may find it convenient to divide a single write action on a 64-bit long or double value into two write actions on adjacent 32-bit values. For efficiency’s sake, this behavior is implementation-specific; an implementation of the Java Virtual Machine is free to perform writes to long and double values atomically or in two parts.\n * Implementations of the Java Virtual Machine are encouraged to avoid splitting 64-bit values where possible. Programmers are encouraged to declare shared 64-bit values as volatile or synchronize their programs correctly to avoid possible complications.\n\n目前各种平台下的商用虚拟机都选择把 64 位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不把long 和 double 变量专门声明为 volatile多数情况下也是不会错的。\n\n\n# volatile 的实现原理\n\n\n# volatile 可见性实现\n\n> volatile 变量的内存可见性是基于内存屏障(Memory Barrier)实现:\n\n * 内存屏障，又称内存栅栏，是一个 CPU 指令。\n * 在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止+ 特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。\n\n写一段简单的 Java 代码，声明一个 volatile 变量，并赋值。\n\npublic class Test {\n    private volatile int a;\n    public void update() {\n        a = 1;\n    }\n    public static void main(String[] args) {\n        Test test = new Test();\n        test.update();\n    }\n}\n\n\n通过 hsdis 和 jitwatch 工具可以得到编译后的汇编代码:\n\n......\n  0x0000000002951563: and    $0xffffffffffffff87,%rdi\n  0x0000000002951567: je     0x00000000029515f8\n  0x000000000295156d: test   $0x7,%rdi\n  0x0000000002951574: jne    0x00000000029515bd\n  0x0000000002951576: test   $0x300,%rdi\n  0x000000000295157d: jne    0x000000000295159c\n  0x000000000295157f: and    $0x37f,%rax\n  0x0000000002951586: mov    %rax,%rdi\n  0x0000000002951589: or     %r15,%rdi\n  0x000000000295158c: lock cmpxchg %rdi,(%rdx)  //在 volatile 修饰的共享变量进行写操作的时候会多出 lock 前缀的指令\n  0x0000000002951591: jne    0x0000000002951a15\n  0x0000000002951597: jmpq   0x00000000029515f8\n  0x000000000295159c: mov    0x8(%rdx),%edi\n  0x000000000295159f: shl    $0x3,%rdi\n  0x00000000029515a3: mov    0xa8(%rdi),%rdi\n  0x00000000029515aa: or     %r15,%rdi\n......\n\n\nlock 前缀的指令在多核处理器下会引发两件事情:\n\n * 将当前处理器缓存行的数据写回到系统内存。\n * 写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。\n\n为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存(L1，L2 或其他)后再进行操作，但操作完不知道何时会写到内存。\n\n如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。\n\n为了保证各个处理器的缓存是一致的，实现了缓存一致性协议(MESI)，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。\n\n所有多核处理器下还会完成：当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。\n\nvolatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。\n\n# lock 指令\n\n在 Pentium 和早期的 IA-32 处理器中，lock 前缀会使处理器执行当前指令时产生一个 LOCK# 信号，会对总线进行锁定，其它 CPU 对内存的读写请求都会被阻塞，直到锁释放。 后来的处理器，加锁操作是由高速缓存锁代替总线锁来处理。 因为锁总线的开销比较大，锁总线期间其他 CPU 没法访问内存。 这种场景多缓存的数据一致通过缓存一致性协议(MESI)来保证。\n\n# 缓存一致性\n\n缓存是分段(line)的，一个段对应一块存储空间，称之为缓存行，它是 CPU 缓存中可分配的最小存储单元，大小 32 字节、64 字节、128 字节不等，这与 CPU 架构有关，通常来说是 64 字节。 LOCK# 因为锁总线效率太低，因此使用了多组缓存。 为了使其行为看起来如同一组缓存那样。因而设计了 缓存一致性协议。 缓存一致性协议有多种，但是日常处理的大多数计算机设备都属于 " 嗅探(snooping)" 协议。 所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线。 缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁(同一个指令周期中，只有一个 CPU 缓存可以读写内存)。 CPU 缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。 当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。 只要某个处理器写内存，其它处理器马上知道这块内存在它们的缓存段中已经失效。\n\n\n# volatile 有序性实现\n\n# volatile 的 happens-before 关系\n\nhappens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。\n\n//假设线程A执行writer方法，线程B执行reader方法\nclass VolatileExample {\n    int a = 0;\n    volatile boolean flag = false;\n    \n    public void writer() {\n        a = 1;              // 1 线程A修改共享变量\n        flag = true;        // 2 线程A写volatile变量\n    } \n    \n    public void reader() {\n        if (flag) {         // 3 线程B读同一个volatile变量\n        int i = a;          // 4 线程B读共享变量\n        ……\n        }\n    }\n}\n\n\n根据 happens-before 规则，上面过程会建立 3 类 happens-before 关系。\n\n * 根据程序次序规则：1 happens-before 2 且 3 happens-before 4。\n * 根据 volatile 规则：2 happens-before 3。\n * 根据 happens-before 的传递性规则：1 happens-before 4。\n\n\n\n因为以上规则，当线程 A 将 volatile 变量 flag 更改为 true 后，线程 B 能够迅速感知。\n\n# volatile 禁止重排序\n\n为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。JMM 提供了内存屏障阻止这种重排序。\n\nJava 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。\n\nJMM 会针对编译器制定 volatile 重排序规则表。\n\n\n\n" NO " 表示禁止重排序。\n\n为了实现 volatile 内存语义时，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。\n\n对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM 采取了保守的策略。\n\n * 在每个 volatile 写操作的前面插入一个 StoreStore 屏障。\n * 在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。\n * 在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。\n * 在每个 volatile 读操作的后面插入一个 LoadStore 屏障。\n\nvolatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。\n\n内存屏障            说明\nStoreStore 屏障   禁止上面的普通写和下面的 volatile 写重排序。\nStoreLoad 屏障    防止上面的 volatile 写与下面可能有的 volatile 读/写重排序。\nLoadLoad 屏障     禁止下面所有的普通读操作和上面的 volatile 读重排序。\nLoadStore 屏障    禁止下面所有的普通写操作和上面的 volatile 读重排序。\n\n\n\n\n\n\n# volatile 的应用场景\n\n使用 volatile 必须具备的条件\n\n * 对变量的写操作不依赖于当前值。\n * 该变量没有包含在具有其他变量的不变式中。\n * 只有在状态真正独立于程序内其他内容时才能使用 volatile。\n\n\n# 模式1：状态标志\n\n也许实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。\n\nvolatile boolean shutdownRequested;\n......\npublic void shutdown() { shutdownRequested = true; }\npublic void doWork() { \n    while (!shutdownRequested) { \n        // do stuff\n    }\n}\n\n\n\n# 模式2：一次性安全发布(one-time safe publication)\n\n缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原始值变得更加困难。在缺乏同步的情况下，可能会遇到某个对象引用的更新值(由另一个线程写入)和该对象状态的旧值同时存在。(这就是造成著名的双重检查锁定(double-checked-locking)问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象)。\n\npublic class BackgroundFloobleLoader {\n    public volatile Flooble theFlooble;\n \n    public void initInBackground() {\n        // do lots of stuff\n        theFlooble = new Flooble();  // this is the only write to theFlooble\n    }\n}\n \npublic class SomeOtherClass {\n    public void doWork() {\n        while (true) { \n            // do some stuff...\n            // use the Flooble, but only if it is ready\n            if (floobleLoader.theFlooble != null) \n                doSomething(floobleLoader.theFlooble);\n        }\n    }\n}\n\n\n\n# 模式3：独立观察(independent observation)\n\n安全使用 volatile 的另一种简单模式是定期 发布 观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。\n\npublic class UserManager {\n    public volatile String lastUser;\n \n    public boolean authenticate(String user, String password) {\n        boolean valid = passwordIsValid(user, password);\n        if (valid) {\n            User u = new User();\n            activeUsers.add(u);\n            lastUser = user;\n        }\n        return valid;\n    }\n}\n\n\n\n# 模式4：volatile bean 模式\n\n在 volatile bean 模式中，JavaBean 的所有数据成员都是 volatile 类型的，并且 getter 和 setter 方法必须非常普通 —— 除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。(这将禁止具有数组值的属性，因为当数组引用被声明为 volatile 时，只有引用而不是数组本身具有 volatile 语义)。对于任何 volatile 变量，不变式或约束都不能包含 JavaBean 属性。\n\n@ThreadSafe\npublic class Person {\n    private volatile String firstName;\n    private volatile String lastName;\n    private volatile int age;\n \n    public String getFirstName() { return firstName; }\n    public String getLastName() { return lastName; }\n    public int getAge() { return age; }\n \n    public void setFirstName(String firstName) { \n        this.firstName = firstName;\n    }\n \n    public void setLastName(String lastName) { \n        this.lastName = lastName;\n    }\n \n    public void setAge(int age) { \n        this.age = age;\n    }\n}\n\n\n\n# 模式5：开销较低的读－写锁策略\n\nvolatile 的功能还不足以实现计数器。因为 ++x 实际上是三种操作(读、添加、存储)的简单组合，如果多个线程凑巧试图同时对 volatile 计数器执行增量操作，那么它的更新值有可能会丢失。 如果读操作远远超过写操作，可以结合使用内部锁和 volatile 变量来减少公共代码路径的开销。 安全的计数器使用 synchronized 确保增量操作是原子的，并使用 volatile 保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及 volatile 读操作，这通常要优于一个无竞争的锁获取的开销。\n\n@ThreadSafe\npublic class CheesyCounter {\n    // Employs the cheap read-write lock trick\n    // All mutative operations MUST be done with the \'this\' lock held\n    @GuardedBy("this") private volatile int value;\n \n    public int getValue() { return value; }\n \n    public synchronized int increment() {\n        return value++;\n    }\n}\n\n\n\n# 模式6：双重检查(double-checked)\n\n就是我们上文举的例子。\n\n单例模式的一种实现方式，但很多人会忽略 volatile 关键字，因为没有该关键字，程序也可以很好的运行，只不过代码的稳定性总不是 100%，说不定在未来的某个时刻，隐藏的 bug 就出来了。\n\nclass Singleton {\n    private volatile static Singleton instance;\n    private Singleton() {\n    }\n    public static Singleton getInstance() {\n        if (instance == null) {\n            syschronized(Singleton.class) {\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    } \n}\n\n\n\n# 参考文章\n\n * https://blog.csdn.net/devotion987/article/details/68486942\n * https://www.jianshu.com/p/ccfe24b63d87\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-key-volatile.html',normalizedContent:'# 关键字: volatile详解\n\n> 相比sychronized(重量级锁，对系统性能影响较大)，volatile提供了另一种解决可见性和有序性问题的方案。\n\n * 关键字: volatile详解\n   * 带着bat大厂的面试问题去理解volatile\n   * volatile的作用详解\n     * 防重排序\n     * 实现可见性\n     * 保证原子性:单次读/写\n       * 问题1： i++为什么不能保证原子性?\n       * 问题2： 共享的long和double变量的为什么要用volatile?\n   * volatile 的实现原理\n     * volatile 可见性实现\n       * lock 指令\n       * 缓存一致性\n     * volatile 有序性实现\n       * volatile 的 happens-before 关系\n       * volatile 禁止重排序\n   * volatile 的应用场景\n     * 模式1：状态标志\n     * 模式2：一次性安全发布(one-time safe publication)\n     * 模式3：独立观察(independent observation)\n     * 模式4：volatile bean 模式\n     * 模式5：开销较低的读－写锁策略\n     * 模式6：双重检查(double-checked)\n   * 参考文章\n\n\n# 带着bat大厂的面试问题去理解volatile\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解volatile。\n\n * volatile关键字的作用是什么?\n * volatile能保证原子性吗?\n * 之前32位机器上共享的long和double变量的为什么要用volatile? 现在64位机器上是否也要设置呢?\n * i++为什么不能保证原子性?\n * volatile是如何实现可见性的? 内存屏障。\n * volatile是如何实现有序性的? happens-before等\n * 说下volatile的应用场景?\n\n\n# volatile的作用详解\n\n\n# 防重排序\n\n我们从一个最经典的例子来分析重排序问题。大家应该都很熟悉单例模式的实现，而在并发环境下的单例实现方式，我们通常可以采用双重检查加锁(dcl)的方式来实现。其源码如下：\n\npublic class singleton {\n    public static volatile singleton singleton;\n    /**\n     * 构造函数私有，禁止外部实例化\n     */\n    private singleton() {};\n    public static singleton getinstance() {\n        if (singleton == null) {\n            synchronized (singleton.class) {\n                if (singleton == null) {\n                    singleton = new singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n}\n\n\n现在我们分析一下为什么要在变量singleton之间加上volatile关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤：\n\n * 分配内存空间。\n * 初始化对象。\n * 将内存空间的地址赋值给对应的引用。\n\n但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程：\n\n * 分配内存空间。\n * 将内存空间的地址赋值给对应的引用。\n * 初始化对象\n\n如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。\n\n\n# 实现可见性\n\n可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。volatile关键字能有效的解决这个问题，我们看下下面的例子，就可以知道其作用：\n\npublic class testvolatile {\n    private static boolean stop = false;\n\n    public static void main(string[] args) {\n        // thread-a\n        new thread("thread a") {\n            @override\n            public void run() {\n                while (!stop) {\n                }\n                system.out.println(thread.currentthread() + " stopped");\n            }\n        }.start();\n\n        // thread-main\n        try {\n            timeunit.seconds.sleep(1);\n            system.out.println(thread.currentthread() + " after 1 seconds");\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n        stop = true;\n    }\n}\n\n\n执行输出如下\n\nthread[main,5,main] after 1 seconds\n\n// thread a一直在loop, 因为thread a 由于可见性原因看不到thread main 已经修改stop的值\n\n\n可以看到 thread-main 休眠1秒之后，设置 stop = ture，但是thread a根本没停下来，这就是可见性问题。如果通过在stop变量前面加上volatile关键字则会真正stop:\n\nthread[main,5,main] after 1 seconds\nthread[thread a,5,main] stopped\n\nprocess finished with exit code 0\n\n\n\n# 保证原子性:单次读/写\n\nvolatile不能保证完全的原子性，只能保证单次的读/写操作具有原子性。先从如下两个问题来理解（后文再从内存屏障的角度理解）：\n\n# 问题1： i++为什么不能保证原子性?\n\n对于原子性，需要强调一点，也是大家容易误解的一点：对volatile变量的单次读/写操作可以保证原子性的，如long和double类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。\n\n现在我们就通过下列程序来演示一下这个问题：\n\npublic class volatiletest01 {\n    volatile int i;\n\n    public void addi(){\n        i++;\n    }\n\n    public static void main(string[] args) throws interruptedexception {\n        final  volatiletest01 test01 = new volatiletest01();\n        for (int n = 0; n < 1000; n++) {\n            new thread(new runnable() {\n                @override\n                public void run() {\n                    try {\n                        thread.sleep(10);\n                    } catch (interruptedexception e) {\n                        e.printstacktrace();\n                    }\n                    test01.addi();\n                }\n            }).start();\n        }\n        thread.sleep(10000);//等待10秒，保证上面程序执行完成\n        system.out.println(test01.i);\n    }\n}\n\n\n大家可能会误认为对变量i加上关键字volatile后，这段程序就是线程安全的。大家可以尝试运行上面的程序。下面是我本地运行的结果：981 可能每个人运行的结果不相同。不过应该能看出，volatile是无法保证原子性的(否则结果应该是1000)。原因也很简单，i++其实是一个复合操作，包括三步骤：\n\n * 读取i的值。\n * 对i加1。\n * 将i的值写回内存。 volatile是无法保证这三个操作是具有原子性的，我们可以通过atomicinteger或者synchronized来保证+1操作的原子性。 注：上面几段代码中多处执行了thread.sleep()方法，目的是为了增加并发问题的产生几率，无其他作用。\n\n# 问题2： 共享的long和double变量的为什么要用volatile?\n\n因为long和double两种数据类型的操作可分为高32位和低32位两部分，因此普通的long或double类型读/写可能不是原子的。因此，鼓励大家将共享的long和double变量设置为volatile类型，这样能保证任何情况下对long和double的单次读/写操作都具有原子性。\n\n如下是jls中的解释：\n\n> 17.7 non-atomic treatment of double and long\n\n * for the purposes of the java programming language memory model, a single write to a non-volatile long or double value is treated as two separate writes: one to each 32-bit half. this can result in a situation where a thread sees the first 32 bits of a 64-bit value from one write, and the second 32 bits from another write.\n * writes and reads of volatile long and double values are always atomic.\n * writes to and reads of references are always atomic, regardless of whether they are implemented as 32-bit or 64-bit values.\n * some implementations may find it convenient to divide a single write action on a 64-bit long or double value into two write actions on adjacent 32-bit values. for efficiency’s sake, this behavior is implementation-specific; an implementation of the java virtual machine is free to perform writes to long and double values atomically or in two parts.\n * implementations of the java virtual machine are encouraged to avoid splitting 64-bit values where possible. programmers are encouraged to declare shared 64-bit values as volatile or synchronize their programs correctly to avoid possible complications.\n\n目前各种平台下的商用虚拟机都选择把 64 位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不把long 和 double 变量专门声明为 volatile多数情况下也是不会错的。\n\n\n# volatile 的实现原理\n\n\n# volatile 可见性实现\n\n> volatile 变量的内存可见性是基于内存屏障(memory barrier)实现:\n\n * 内存屏障，又称内存栅栏，是一个 cpu 指令。\n * 在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，jmm 为了保证在不同的编译器和 cpu 上有相同的结果，通过插入特定类型的内存屏障来禁止+ 特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 cpu：不管什么指令都不能和这条 memory barrier 指令重排序。\n\n写一段简单的 java 代码，声明一个 volatile 变量，并赋值。\n\npublic class test {\n    private volatile int a;\n    public void update() {\n        a = 1;\n    }\n    public static void main(string[] args) {\n        test test = new test();\n        test.update();\n    }\n}\n\n\n通过 hsdis 和 jitwatch 工具可以得到编译后的汇编代码:\n\n......\n  0x0000000002951563: and    $0xffffffffffffff87,%rdi\n  0x0000000002951567: je     0x00000000029515f8\n  0x000000000295156d: test   $0x7,%rdi\n  0x0000000002951574: jne    0x00000000029515bd\n  0x0000000002951576: test   $0x300,%rdi\n  0x000000000295157d: jne    0x000000000295159c\n  0x000000000295157f: and    $0x37f,%rax\n  0x0000000002951586: mov    %rax,%rdi\n  0x0000000002951589: or     %r15,%rdi\n  0x000000000295158c: lock cmpxchg %rdi,(%rdx)  //在 volatile 修饰的共享变量进行写操作的时候会多出 lock 前缀的指令\n  0x0000000002951591: jne    0x0000000002951a15\n  0x0000000002951597: jmpq   0x00000000029515f8\n  0x000000000295159c: mov    0x8(%rdx),%edi\n  0x000000000295159f: shl    $0x3,%rdi\n  0x00000000029515a3: mov    0xa8(%rdi),%rdi\n  0x00000000029515aa: or     %r15,%rdi\n......\n\n\nlock 前缀的指令在多核处理器下会引发两件事情:\n\n * 将当前处理器缓存行的数据写回到系统内存。\n * 写回内存的操作会使在其他 cpu 里缓存了该内存地址的数据无效。\n\n为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存(l1，l2 或其他)后再进行操作，但操作完不知道何时会写到内存。\n\n如果对声明了 volatile 的变量进行写操作，jvm 就会向处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。\n\n为了保证各个处理器的缓存是一致的，实现了缓存一致性协议(mesi)，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。\n\n所有多核处理器下还会完成：当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。\n\nvolatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。\n\n# lock 指令\n\n在 pentium 和早期的 ia-32 处理器中，lock 前缀会使处理器执行当前指令时产生一个 lock# 信号，会对总线进行锁定，其它 cpu 对内存的读写请求都会被阻塞，直到锁释放。 后来的处理器，加锁操作是由高速缓存锁代替总线锁来处理。 因为锁总线的开销比较大，锁总线期间其他 cpu 没法访问内存。 这种场景多缓存的数据一致通过缓存一致性协议(mesi)来保证。\n\n# 缓存一致性\n\n缓存是分段(line)的，一个段对应一块存储空间，称之为缓存行，它是 cpu 缓存中可分配的最小存储单元，大小 32 字节、64 字节、128 字节不等，这与 cpu 架构有关，通常来说是 64 字节。 lock# 因为锁总线效率太低，因此使用了多组缓存。 为了使其行为看起来如同一组缓存那样。因而设计了 缓存一致性协议。 缓存一致性协议有多种，但是日常处理的大多数计算机设备都属于 " 嗅探(snooping)" 协议。 所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线。 缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁(同一个指令周期中，只有一个 cpu 缓存可以读写内存)。 cpu 缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。 当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。 只要某个处理器写内存，其它处理器马上知道这块内存在它们的缓存段中已经失效。\n\n\n# volatile 有序性实现\n\n# volatile 的 happens-before 关系\n\nhappens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。\n\n//假设线程a执行writer方法，线程b执行reader方法\nclass volatileexample {\n    int a = 0;\n    volatile boolean flag = false;\n    \n    public void writer() {\n        a = 1;              // 1 线程a修改共享变量\n        flag = true;        // 2 线程a写volatile变量\n    } \n    \n    public void reader() {\n        if (flag) {         // 3 线程b读同一个volatile变量\n        int i = a;          // 4 线程b读共享变量\n        ……\n        }\n    }\n}\n\n\n根据 happens-before 规则，上面过程会建立 3 类 happens-before 关系。\n\n * 根据程序次序规则：1 happens-before 2 且 3 happens-before 4。\n * 根据 volatile 规则：2 happens-before 3。\n * 根据 happens-before 的传递性规则：1 happens-before 4。\n\n\n\n因为以上规则，当线程 a 将 volatile 变量 flag 更改为 true 后，线程 b 能够迅速感知。\n\n# volatile 禁止重排序\n\n为了性能优化，jmm 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。jmm 提供了内存屏障阻止这种重排序。\n\njava 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。\n\njmm 会针对编译器制定 volatile 重排序规则表。\n\n\n\n" no " 表示禁止重排序。\n\n为了实现 volatile 内存语义时，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。\n\n对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，jmm 采取了保守的策略。\n\n * 在每个 volatile 写操作的前面插入一个 storestore 屏障。\n * 在每个 volatile 写操作的后面插入一个 storeload 屏障。\n * 在每个 volatile 读操作的后面插入一个 loadload 屏障。\n * 在每个 volatile 读操作的后面插入一个 loadstore 屏障。\n\nvolatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。\n\n内存屏障            说明\nstorestore 屏障   禁止上面的普通写和下面的 volatile 写重排序。\nstoreload 屏障    防止上面的 volatile 写与下面可能有的 volatile 读/写重排序。\nloadload 屏障     禁止下面所有的普通读操作和上面的 volatile 读重排序。\nloadstore 屏障    禁止下面所有的普通写操作和上面的 volatile 读重排序。\n\n\n\n\n\n\n# volatile 的应用场景\n\n使用 volatile 必须具备的条件\n\n * 对变量的写操作不依赖于当前值。\n * 该变量没有包含在具有其他变量的不变式中。\n * 只有在状态真正独立于程序内其他内容时才能使用 volatile。\n\n\n# 模式1：状态标志\n\n也许实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。\n\nvolatile boolean shutdownrequested;\n......\npublic void shutdown() { shutdownrequested = true; }\npublic void dowork() { \n    while (!shutdownrequested) { \n        // do stuff\n    }\n}\n\n\n\n# 模式2：一次性安全发布(one-time safe publication)\n\n缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原始值变得更加困难。在缺乏同步的情况下，可能会遇到某个对象引用的更新值(由另一个线程写入)和该对象状态的旧值同时存在。(这就是造成著名的双重检查锁定(double-checked-locking)问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象)。\n\npublic class backgroundfloobleloader {\n    public volatile flooble theflooble;\n \n    public void initinbackground() {\n        // do lots of stuff\n        theflooble = new flooble();  // this is the only write to theflooble\n    }\n}\n \npublic class someotherclass {\n    public void dowork() {\n        while (true) { \n            // do some stuff...\n            // use the flooble, but only if it is ready\n            if (floobleloader.theflooble != null) \n                dosomething(floobleloader.theflooble);\n        }\n    }\n}\n\n\n\n# 模式3：独立观察(independent observation)\n\n安全使用 volatile 的另一种简单模式是定期 发布 观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。\n\npublic class usermanager {\n    public volatile string lastuser;\n \n    public boolean authenticate(string user, string password) {\n        boolean valid = passwordisvalid(user, password);\n        if (valid) {\n            user u = new user();\n            activeusers.add(u);\n            lastuser = user;\n        }\n        return valid;\n    }\n}\n\n\n\n# 模式4：volatile bean 模式\n\n在 volatile bean 模式中，javabean 的所有数据成员都是 volatile 类型的，并且 getter 和 setter 方法必须非常普通 —— 除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。(这将禁止具有数组值的属性，因为当数组引用被声明为 volatile 时，只有引用而不是数组本身具有 volatile 语义)。对于任何 volatile 变量，不变式或约束都不能包含 javabean 属性。\n\n@threadsafe\npublic class person {\n    private volatile string firstname;\n    private volatile string lastname;\n    private volatile int age;\n \n    public string getfirstname() { return firstname; }\n    public string getlastname() { return lastname; }\n    public int getage() { return age; }\n \n    public void setfirstname(string firstname) { \n        this.firstname = firstname;\n    }\n \n    public void setlastname(string lastname) { \n        this.lastname = lastname;\n    }\n \n    public void setage(int age) { \n        this.age = age;\n    }\n}\n\n\n\n# 模式5：开销较低的读－写锁策略\n\nvolatile 的功能还不足以实现计数器。因为 ++x 实际上是三种操作(读、添加、存储)的简单组合，如果多个线程凑巧试图同时对 volatile 计数器执行增量操作，那么它的更新值有可能会丢失。 如果读操作远远超过写操作，可以结合使用内部锁和 volatile 变量来减少公共代码路径的开销。 安全的计数器使用 synchronized 确保增量操作是原子的，并使用 volatile 保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及 volatile 读操作，这通常要优于一个无竞争的锁获取的开销。\n\n@threadsafe\npublic class cheesycounter {\n    // employs the cheap read-write lock trick\n    // all mutative operations must be done with the \'this\' lock held\n    @guardedby("this") private volatile int value;\n \n    public int getvalue() { return value; }\n \n    public synchronized int increment() {\n        return value++;\n    }\n}\n\n\n\n# 模式6：双重检查(double-checked)\n\n就是我们上文举的例子。\n\n单例模式的一种实现方式，但很多人会忽略 volatile 关键字，因为没有该关键字，程序也可以很好的运行，只不过代码的稳定性总不是 100%，说不定在未来的某个时刻，隐藏的 bug 就出来了。\n\nclass singleton {\n    private volatile static singleton instance;\n    private singleton() {\n    }\n    public static singleton getinstance() {\n        if (instance == null) {\n            syschronized(singleton.class) {\n                if (instance == null) {\n                    instance = new singleton();\n                }\n            }\n        }\n        return instance;\n    } \n}\n\n\n\n# 参考文章\n\n * https://blog.csdn.net/devotion987/article/details/68486942\n * https://www.jianshu.com/p/ccfe24b63d87\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-key-volatile.html',charsets:{cjk:!0}},{title:"JUC锁: LockSupport详解",frontmatter:{},regularPath:"/java/thread/java-thread-x-lock-LockSupport.html",relativePath:"java/thread/java-thread-x-lock-LockSupport.md",key:"v-21f7fb68",path:"/java/thread/java-thread-x-lock-LockSupport.html",headers:[{level:2,title:"JUC锁: LockSupport详解",slug:"juc锁-locksupport详解",normalizedTitle:"juc锁: locksupport详解",charIndex:2},{level:2,title:"带着BAT大厂的面试问题去理解",slug:"带着bat大厂的面试问题去理解",normalizedTitle:"带着bat大厂的面试问题去理解",charIndex:96},{level:2,title:"LockSupport简介",slug:"locksupport简介",normalizedTitle:"locksupport简介",charIndex:117},{level:2,title:"LockSupport源码分析",slug:"locksupport源码分析",normalizedTitle:"locksupport源码分析",charIndex:136},{level:3,title:"类的属性",slug:"类的属性",normalizedTitle:"类的属性",charIndex:159},{level:3,title:"类的构造函数",slug:"类的构造函数",normalizedTitle:"类的构造函数",charIndex:171},{level:3,title:"核心函数分析",slug:"核心函数分析",normalizedTitle:"核心函数分析",charIndex:185},{level:2,title:"LockSupport示例说明",slug:"locksupport示例说明",normalizedTitle:"locksupport示例说明",charIndex:273},{level:3,title:"使用wait/notify实现线程同步",slug:"使用wait-notify实现线程同步",normalizedTitle:"使用wait/notify实现线程同步",charIndex:296},{level:3,title:"使用park/unpark实现线程同步",slug:"使用park-unpark实现线程同步",normalizedTitle:"使用park/unpark实现线程同步",charIndex:323},{level:3,title:"中断响应",slug:"中断响应",normalizedTitle:"中断响应",charIndex:350},{level:2,title:"更深入的理解",slug:"更深入的理解",normalizedTitle:"更深入的理解",charIndex:360},{level:3,title:"Thread.sleep()和Object.wait()的区别",slug:"thread-sleep-和object-wait-的区别",normalizedTitle:"thread.sleep()和object.wait()的区别",charIndex:374},{level:3,title:"Object.wait()和Condition.await()的区别",slug:"object-wait-和condition-await-的区别",normalizedTitle:"object.wait()和condition.await()的区别",charIndex:413},{level:3,title:"Thread.sleep()和LockSupport.park()的区别",slug:"thread-sleep-和locksupport-park-的区别",normalizedTitle:"thread.sleep()和locksupport.park()的区别",charIndex:455},{level:3,title:"Object.wait()和LockSupport.park()的区别",slug:"object-wait-和locksupport-park-的区别",normalizedTitle:"object.wait()和locksupport.park()的区别",charIndex:499},{level:3,title:"LockSupport.park()会释放锁资源吗?",slug:"locksupport-park-会释放锁资源吗",normalizedTitle:"locksupport.park()会释放锁资源吗?",charIndex:614},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:646}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"JUC锁: LockSupport详解 带着BAT大厂的面试问题去理解 LockSupport简介 LockSupport源码分析 类的属性 类的构造函数 核心函数分析 LockSupport示例说明 使用wait/notify实现线程同步 使用park/unpark实现线程同步 中断响应 更深入的理解 Thread.sleep()和Object.wait()的区别 Object.wait()和Condition.await()的区别 Thread.sleep()和LockSupport.park()的区别 Object.wait()和LockSupport.park()的区别 LockSupport.park()会释放锁资源吗? 参考文章",content:'# JUC锁: LockSupport详解\n\n> LockSupport是锁中的基础，是一个提供锁机制的工具类，所以先对其进行分析。\n\n * JUC锁: LockSupport详解\n   * 带着BAT大厂的面试问题去理解\n   * LockSupport简介\n   * LockSupport源码分析\n     * 类的属性\n     * 类的构造函数\n     * 核心函数分析\n       * park函数\n       * parkNanos函数\n       * parkUntil函数\n       * unpark函数\n   * LockSupport示例说明\n     * 使用wait/notify实现线程同步\n     * 使用park/unpark实现线程同步\n     * 中断响应\n   * 更深入的理解\n     * Thread.sleep()和Object.wait()的区别\n     * Object.wait()和Condition.await()的区别\n     * Thread.sleep()和LockSupport.park()的区别\n     * Object.wait()和LockSupport.park()的区别\n       * 如果在wait()之前执行了notify()会怎样?\n       * 如果在park()之前执行了unpark()会怎样?\n     * LockSupport.park()会释放锁资源吗?\n   * 参考文章\n\n\n# 带着BAT大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 为什么LockSupport也是核心基础类? AQS框架借助于两个类：Unsafe(提供CAS操作)和LockSupport(提供park/unpark操作)\n * 写出分别通过wait/notify和LockSupport的park/unpark实现同步?\n * LockSupport.park()会释放锁资源吗? 那么Condition.await()呢?\n * Thread.sleep()、Object.wait()、Condition.await()、LockSupport.park()的区别? 重点\n * 如果在wait()之前执行了notify()会怎样?\n * 如果在park()之前执行了unpark()会怎样?\n\n\n# LockSupport简介\n\nLockSupport用来创建锁和其他同步类的基本线程阻塞原语。简而言之，当调用LockSupport.park时，表示当前线程将会等待，直至获得许可，当调用LockSupport.unpark时，必须把等待获得许可的线程作为参数进行传递，好让此线程继续运行。\n\n\n# LockSupport源码分析\n\n\n# 类的属性\n\npublic class LockSupport {\n    // Hotspot implementation via intrinsics API\n    private static final sun.misc.Unsafe UNSAFE;\n    // 表示内存偏移地址\n    private static final long parkBlockerOffset;\n    // 表示内存偏移地址\n    private static final long SEED;\n    // 表示内存偏移地址\n    private static final long PROBE;\n    // 表示内存偏移地址\n    private static final long SECONDARY;\n    \n    static {\n        try {\n            // 获取Unsafe实例\n            UNSAFE = sun.misc.Unsafe.getUnsafe();\n            // 线程类类型\n            Class<?> tk = Thread.class;\n            // 获取Thread的parkBlocker字段的内存偏移地址\n            parkBlockerOffset = UNSAFE.objectFieldOffset\n                (tk.getDeclaredField("parkBlocker"));\n            // 获取Thread的threadLocalRandomSeed字段的内存偏移地址\n            SEED = UNSAFE.objectFieldOffset\n                (tk.getDeclaredField("threadLocalRandomSeed"));\n            // 获取Thread的threadLocalRandomProbe字段的内存偏移地址\n            PROBE = UNSAFE.objectFieldOffset\n                (tk.getDeclaredField("threadLocalRandomProbe"));\n            // 获取Thread的threadLocalRandomSecondarySeed字段的内存偏移地址\n            SECONDARY = UNSAFE.objectFieldOffset\n                (tk.getDeclaredField("threadLocalRandomSecondarySeed"));\n        } catch (Exception ex) { throw new Error(ex); }\n    }\n}\n\n\n说明: UNSAFE字段表示sun.misc.Unsafe类，查看其源码，点击在这里，一般程序中不允许直接调用，而long型的表示实例对象相应字段在内存中的偏移地址，可以通过该偏移地址获取或者设置该字段的值。\n\n\n# 类的构造函数\n\n// 私有构造函数，无法被实例化\nprivate LockSupport() {}\n\n\n说明: LockSupport只有一个私有构造函数，无法被实例化。\n\n\n# 核心函数分析\n\n在分析LockSupport函数之前，先引入sun.misc.Unsafe类中的park和unpark函数，因为LockSupport的核心函数都是基于Unsafe类中定义的park和unpark函数，下面给出两个函数的定义:\n\npublic native void park(boolean isAbsolute, long time);\npublic native void unpark(Thread thread);\n\n\n说明: 对两个函数的说明如下:\n\n * park函数，阻塞线程，并且该线程在下列情况发生之前都会被阻塞: ① 调用unpark函数，释放该线程的许可。② 该线程被中断。③ 设置的时间到了。并且，当time为绝对时间时，isAbsolute为true，否则，isAbsolute为false。当time为0时，表示无限等待，直到unpark发生。\n\n * unpark函数，释放线程的许可，即激活调用park后阻塞的线程。这个函数不是安全的，调用这个函数时要确保线程依旧存活。\n\n# park函数\n\npark函数有两个重载版本，方法摘要如下\n\npublic static void park()；\npublic static void park(Object blocker)；\n\n\n说明: 两个函数的区别在于park()函数没有没有blocker，即没有设置线程的parkBlocker字段。park(Object)型函数如下。\n\npublic static void park(Object blocker) {\n    // 获取当前线程\n    Thread t = Thread.currentThread();\n    // 设置Blocker\n    setBlocker(t, blocker);\n    // 获取许可\n    UNSAFE.park(false, 0L);\n    // 重新可运行后再此设置Blocker\n    setBlocker(t, null);\n}\n\n\n说明: 调用park函数时，首先获取当前线程，然后设置当前线程的parkBlocker字段，即调用setBlocker函数，之后调用Unsafe类的park函数，之后再调用setBlocker函数。那么问题来了，为什么要在此park函数中要调用两次setBlocker函数呢? 原因其实很简单，调用park函数时，当前线程首先设置好parkBlocker字段，然后再调用Unsafe的park函数，此后，当前线程就已经阻塞了，等待该线程的unpark函数被调用，所以后面的一个setBlocker函数无法运行，unpark函数被调用，该线程获得许可后，就可以继续运行了，也就运行第二个setBlocker，把该线程的parkBlocker字段设置为null，这样就完成了整个park函数的逻辑。如果没有第二个setBlocker，那么之后没有调用park(Object blocker)，而直接调用getBlocker函数，得到的还是前一个park(Object blocker)设置的blocker，显然是不符合逻辑的。总之，必须要保证在park(Object blocker)整个函数执行完后，该线程的parkBlocker字段又恢复为null。所以，park(Object)型函数里必须要调用setBlocker函数两次。setBlocker方法如下。\n\nprivate static void setBlocker(Thread t, Object arg) {\n    // 设置线程t的parkBlocker字段的值为arg\n    UNSAFE.putObject(t, parkBlockerOffset, arg);\n}\n\n\n说明: 此方法用于设置线程t的parkBlocker字段的值为arg。\n\n另外一个无参重载版本，park()函数如下。\n\npublic static void park() {\n    // 获取许可，设置时间为无限长，直到可以获取许可\n    UNSAFE.park(false, 0L);\n}\n\n\n说明: 调用了park函数后，会禁用当前线程，除非许可可用。在以下三种情况之一发生之前，当前线程都将处于休眠状态，即下列情况发生时，当前线程会获取许可，可以继续运行。\n\n * 其他某个线程将当前线程作为目标调用 unpark。\n * 其他某个线程中断当前线程。\n * 该调用不合逻辑地(即毫无理由地)返回。\n\n# parkNanos函数\n\n此函数表示在许可可用前禁用当前线程，并最多等待指定的等待时间。具体函数如下。\n\npublic static void parkNanos(Object blocker, long nanos) {\n    if (nanos > 0) { // 时间大于0\n        // 获取当前线程\n        Thread t = Thread.currentThread();\n        // 设置Blocker\n        setBlocker(t, blocker);\n        // 获取许可，并设置了时间\n        UNSAFE.park(false, nanos);\n        // 设置许可\n        setBlocker(t, null);\n    }\n}\n\n\n说明: 该函数也是调用了两次setBlocker函数，nanos参数表示相对时间，表示等待多长时间。\n\n# parkUntil函数\n\n此函数表示在指定的时限前禁用当前线程，除非许可可用, 具体函数如下:\n\npublic static void parkUntil(Object blocker, long deadline) {\n    // 获取当前线程\n    Thread t = Thread.currentThread();\n    // 设置Blocker\n    setBlocker(t, blocker);\n    UNSAFE.park(true, deadline);\n    // 设置Blocker为null\n    setBlocker(t, null);\n}\n\n\n说明: 该函数也调用了两次setBlocker函数，deadline参数表示绝对时间，表示指定的时间。\n\n# unpark函数\n\n此函数表示如果给定线程的许可尚不可用，则使其可用。如果线程在 park 上受阻塞，则它将解除其阻塞状态。否则，保证下一次调用 park 不会受阻塞。如果给定线程尚未启动，则无法保证此操作有任何效果。具体函数如下:\n\npublic static void unpark(Thread thread) {\n    if (thread != null) // 线程为不空\n        UNSAFE.unpark(thread); // 释放该线程许可\n}\n\n\n说明: 释放许可，指定线程可以继续运行。\n\n\n# LockSupport示例说明\n\n\n# 使用wait/notify实现线程同步\n\nclass MyThread extends Thread {\n    \n    public void run() {\n        synchronized (this) {\n            System.out.println("before notify");            \n            notify();\n            System.out.println("after notify");    \n        }\n    }\n}\n\npublic class WaitAndNotifyDemo {\n    public static void main(String[] args) throws InterruptedException {\n        MyThread myThread = new MyThread();            \n        synchronized (myThread) {\n            try {        \n                myThread.start();\n                // 主线程睡眠3s\n                Thread.sleep(3000);\n                System.out.println("before wait");\n                // 阻塞主线程\n                myThread.wait();\n                System.out.println("after wait");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }            \n        }        \n    }\n}\n\n\n运行结果\n\nbefore wait\nbefore notify\nafter notify\nafter wait\n\n\n说明: 具体的流程图如下\n\n\n\n使用wait/notify实现同步时，必须先调用wait，后调用notify，如果先调用notify，再调用wait，将起不了作用。具体代码如下\n\nclass MyThread extends Thread {\n    public void run() {\n        synchronized (this) {\n            System.out.println("before notify");            \n            notify();\n            System.out.println("after notify");    \n        }\n    }\n}\n\npublic class WaitAndNotifyDemo {\n    public static void main(String[] args) throws InterruptedException {\n        MyThread myThread = new MyThread();        \n        myThread.start();\n        // 主线程睡眠3s\n        Thread.sleep(3000);\n        synchronized (myThread) {\n            try {        \n                System.out.println("before wait");\n                // 阻塞主线程\n                myThread.wait();\n                System.out.println("after wait");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }            \n        }        \n    }\n}\n\n\n运行结果:\n\nbefore notify\nafter notify\nbefore wait\n\n\n说明: 由于先调用了notify，再调用的wait，此时主线程还是会一直阻塞。\n\n\n# 使用park/unpark实现线程同步\n\nimport java.util.concurrent.locks.LockSupport;\n\nclass MyThread extends Thread {\n    private Object object;\n\n    public MyThread(Object object) {\n        this.object = object;\n    }\n\n    public void run() {\n        System.out.println("before unpark");\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        // 获取blocker\n        System.out.println("Blocker info " + LockSupport.getBlocker((Thread) object));\n        // 释放许可\n        LockSupport.unpark((Thread) object);\n        // 休眠500ms，保证先执行park中的setBlocker(t, null);\n        try {\n            Thread.sleep(500);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        // 再次获取blocker\n        System.out.println("Blocker info " + LockSupport.getBlocker((Thread) object));\n\n        System.out.println("after unpark");\n    }\n}\n\npublic class test {\n    public static void main(String[] args) {\n        MyThread myThread = new MyThread(Thread.currentThread());\n        myThread.start();\n        System.out.println("before park");\n        // 获取许可\n        LockSupport.park("ParkAndUnparkDemo");\n        System.out.println("after park");\n    }\n}\n\n\n运行结果:\n\nbefore park\nbefore unpark\nBlocker info ParkAndUnparkDemo\nafter park\nBlocker info null\nafter unpark\n\n\n说明: 本程序先执行park，然后在执行unpark，进行同步，并且在unpark的前后都调用了getBlocker，可以看到两次的结果不一样，并且第二次调用的结果为null，这是因为在调用unpark之后，执行了Lock.park(Object blocker)函数中的setBlocker(t, null)函数，所以第二次调用getBlocker时为null。\n\n上例是先调用park，然后调用unpark，现在修改程序，先调用unpark，然后调用park，看能不能正确同步。具体代码如下\n\nimport java.util.concurrent.locks.LockSupport;\n\nclass MyThread extends Thread {\n    private Object object;\n\n    public MyThread(Object object) {\n        this.object = object;\n    }\n\n    public void run() {\n        System.out.println("before unpark");        \n        // 释放许可\n        LockSupport.unpark((Thread) object);\n        System.out.println("after unpark");\n    }\n}\n\npublic class ParkAndUnparkDemo {\n    public static void main(String[] args) {\n        MyThread myThread = new MyThread(Thread.currentThread());\n        myThread.start();\n        try {\n            // 主线程睡眠3s\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println("before park");\n        // 获取许可\n        LockSupport.park("ParkAndUnparkDemo");\n        System.out.println("after park");\n    }\n}\n\n\n运行结果:\n\nbefore unpark\nafter unpark\nbefore park\nafter park\n\n\n说明: 可以看到，在先调用unpark，再调用park时，仍能够正确实现同步，不会造成由wait/notify调用顺序不当所引起的阻塞。因此park/unpark相比wait/notify更加的灵活。\n\n\n# 中断响应\n\n看下面示例\n\nimport java.util.concurrent.locks.LockSupport;\n\nclass MyThread extends Thread {\n    private Object object;\n\n    public MyThread(Object object) {\n        this.object = object;\n    }\n\n    public void run() {\n        System.out.println("before interrupt");        \n        try {\n            // 休眠3s\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }    \n        Thread thread = (Thread) object;\n        // 中断线程\n        thread.interrupt();\n        System.out.println("after interrupt");\n    }\n}\n\npublic class InterruptDemo {\n    public static void main(String[] args) {\n        MyThread myThread = new MyThread(Thread.currentThread());\n        myThread.start();\n        System.out.println("before park");\n        // 获取许可\n        LockSupport.park("ParkAndUnparkDemo");\n        System.out.println("after park");\n    }\n}\n\n\n运行结果:\n\nbefore park\nbefore interrupt\nafter interrupt\nafter park\n\n\n说明: 可以看到，在主线程调用park阻塞后，在myThread线程中发出了中断信号，此时主线程会继续运行，也就是说明此时interrupt起到的作用与unpark一样。\n\n\n# 更深入的理解\n\n\n# Thread.sleep()和Object.wait()的区别\n\n首先，我们先来看看Thread.sleep()和Object.wait()的区别，这是一个烂大街的题目了，大家应该都能说上来两点。\n\n * Thread.sleep()不会释放占有的锁，Object.wait()会释放占有的锁；\n * Thread.sleep()必须传入时间，Object.wait()可传可不传，不传表示一直阻塞下去；\n * Thread.sleep()到时间了会自动唤醒，然后继续执行；\n * Object.wait()不带时间的，需要另一个线程使用Object.notify()唤醒；\n * Object.wait()带时间的，假如没有被notify，到时间了会自动唤醒，这时又分好两种情况，一是立即获取到了锁，线程自然会继续执行；二是没有立即获取锁，线程进入同步队列等待获取锁；\n\n其实，他们俩最大的区别就是Thread.sleep()不会释放锁资源，Object.wait()会释放锁资源。\n\n\n# Object.wait()和Condition.await()的区别\n\nObject.wait()和Condition.await()的原理是基本一致的，不同的是Condition.await()底层是调用LockSupport.park()来实现阻塞当前线程的。\n\n实际上，它在阻塞当前线程之前还干了两件事，一是把当前线程添加到条件队列中，二是“完全”释放锁，也就是让state状态变量变为0，然后才是调用LockSupport.park()阻塞当前线程。\n\n\n# Thread.sleep()和LockSupport.park()的区别\n\nLockSupport.park()还有几个兄弟方法——parkNanos()、parkUtil()等，我们这里说的park()方法统称这一类方法。\n\n * 从功能上来说，Thread.sleep()和LockSupport.park()方法类似，都是阻塞当前线程的执行，且都不会释放当前线程占有的锁资源；\n * Thread.sleep()没法从外部唤醒，只能自己醒过来；\n * LockSupport.park()方法可以被另一个线程调用LockSupport.unpark()方法唤醒；\n * Thread.sleep()方法声明上抛出了InterruptedException中断异常，所以调用者需要捕获这个异常或者再抛出；\n * LockSupport.park()方法不需要捕获中断异常；\n * Thread.sleep()本身就是一个native方法；\n * LockSupport.park()底层是调用的Unsafe的native方法；\n\n\n# Object.wait()和LockSupport.park()的区别\n\n二者都会阻塞当前线程的运行，他们有什么区别呢? 经过上面的分析相信你一定很清楚了，真的吗? 往下看！\n\n * Object.wait()方法需要在synchronized块中执行；\n * LockSupport.park()可以在任意地方执行；\n * Object.wait()方法声明抛出了中断异常，调用者需要捕获或者再抛出；\n * LockSupport.park()不需要捕获中断异常；\n * Object.wait()不带超时的，需要另一个线程执行notify()来唤醒，但不一定继续执行后续内容；\n * LockSupport.park()不带超时的，需要另一个线程执行unpark()来唤醒，一定会继续执行后续内容；\n\npark()/unpark()底层的原理是“二元信号量”，你可以把它相像成只有一个许可证的Semaphore，只不过这个信号量在重复执行unpark()的时候也不会再增加许可证，最多只有一个许可证。\n\n# 如果在wait()之前执行了notify()会怎样?\n\n如果当前的线程不是此对象锁的所有者，却调用该对象的notify()或wait()方法时抛出IllegalMonitorStateException异常；\n\n如果当前线程是此对象锁的所有者，wait()将一直阻塞，因为后续将没有其它notify()唤醒它。\n\n# 如果在park()之前执行了unpark()会怎样?\n\n线程不会被阻塞，直接跳过park()，继续执行后续内容\n\n\n# LockSupport.park()会释放锁资源吗?\n\n不会，它只负责阻塞当前线程，释放锁资源实际上是在Condition的await()方法中实现的。\n\n\n# 参考文章\n\n * 文章主要参考自leesf的https://www.cnblogs.com/leesf456/p/5347293.html，在此基础上做了增改。\n * https://blog.csdn.net/tangtong1/article/details/102829724\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-lock-LockSupport.html',normalizedContent:'# juc锁: locksupport详解\n\n> locksupport是锁中的基础，是一个提供锁机制的工具类，所以先对其进行分析。\n\n * juc锁: locksupport详解\n   * 带着bat大厂的面试问题去理解\n   * locksupport简介\n   * locksupport源码分析\n     * 类的属性\n     * 类的构造函数\n     * 核心函数分析\n       * park函数\n       * parknanos函数\n       * parkuntil函数\n       * unpark函数\n   * locksupport示例说明\n     * 使用wait/notify实现线程同步\n     * 使用park/unpark实现线程同步\n     * 中断响应\n   * 更深入的理解\n     * thread.sleep()和object.wait()的区别\n     * object.wait()和condition.await()的区别\n     * thread.sleep()和locksupport.park()的区别\n     * object.wait()和locksupport.park()的区别\n       * 如果在wait()之前执行了notify()会怎样?\n       * 如果在park()之前执行了unpark()会怎样?\n     * locksupport.park()会释放锁资源吗?\n   * 参考文章\n\n\n# 带着bat大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 为什么locksupport也是核心基础类? aqs框架借助于两个类：unsafe(提供cas操作)和locksupport(提供park/unpark操作)\n * 写出分别通过wait/notify和locksupport的park/unpark实现同步?\n * locksupport.park()会释放锁资源吗? 那么condition.await()呢?\n * thread.sleep()、object.wait()、condition.await()、locksupport.park()的区别? 重点\n * 如果在wait()之前执行了notify()会怎样?\n * 如果在park()之前执行了unpark()会怎样?\n\n\n# locksupport简介\n\nlocksupport用来创建锁和其他同步类的基本线程阻塞原语。简而言之，当调用locksupport.park时，表示当前线程将会等待，直至获得许可，当调用locksupport.unpark时，必须把等待获得许可的线程作为参数进行传递，好让此线程继续运行。\n\n\n# locksupport源码分析\n\n\n# 类的属性\n\npublic class locksupport {\n    // hotspot implementation via intrinsics api\n    private static final sun.misc.unsafe unsafe;\n    // 表示内存偏移地址\n    private static final long parkblockeroffset;\n    // 表示内存偏移地址\n    private static final long seed;\n    // 表示内存偏移地址\n    private static final long probe;\n    // 表示内存偏移地址\n    private static final long secondary;\n    \n    static {\n        try {\n            // 获取unsafe实例\n            unsafe = sun.misc.unsafe.getunsafe();\n            // 线程类类型\n            class<?> tk = thread.class;\n            // 获取thread的parkblocker字段的内存偏移地址\n            parkblockeroffset = unsafe.objectfieldoffset\n                (tk.getdeclaredfield("parkblocker"));\n            // 获取thread的threadlocalrandomseed字段的内存偏移地址\n            seed = unsafe.objectfieldoffset\n                (tk.getdeclaredfield("threadlocalrandomseed"));\n            // 获取thread的threadlocalrandomprobe字段的内存偏移地址\n            probe = unsafe.objectfieldoffset\n                (tk.getdeclaredfield("threadlocalrandomprobe"));\n            // 获取thread的threadlocalrandomsecondaryseed字段的内存偏移地址\n            secondary = unsafe.objectfieldoffset\n                (tk.getdeclaredfield("threadlocalrandomsecondaryseed"));\n        } catch (exception ex) { throw new error(ex); }\n    }\n}\n\n\n说明: unsafe字段表示sun.misc.unsafe类，查看其源码，点击在这里，一般程序中不允许直接调用，而long型的表示实例对象相应字段在内存中的偏移地址，可以通过该偏移地址获取或者设置该字段的值。\n\n\n# 类的构造函数\n\n// 私有构造函数，无法被实例化\nprivate locksupport() {}\n\n\n说明: locksupport只有一个私有构造函数，无法被实例化。\n\n\n# 核心函数分析\n\n在分析locksupport函数之前，先引入sun.misc.unsafe类中的park和unpark函数，因为locksupport的核心函数都是基于unsafe类中定义的park和unpark函数，下面给出两个函数的定义:\n\npublic native void park(boolean isabsolute, long time);\npublic native void unpark(thread thread);\n\n\n说明: 对两个函数的说明如下:\n\n * park函数，阻塞线程，并且该线程在下列情况发生之前都会被阻塞: ① 调用unpark函数，释放该线程的许可。② 该线程被中断。③ 设置的时间到了。并且，当time为绝对时间时，isabsolute为true，否则，isabsolute为false。当time为0时，表示无限等待，直到unpark发生。\n\n * unpark函数，释放线程的许可，即激活调用park后阻塞的线程。这个函数不是安全的，调用这个函数时要确保线程依旧存活。\n\n# park函数\n\npark函数有两个重载版本，方法摘要如下\n\npublic static void park()；\npublic static void park(object blocker)；\n\n\n说明: 两个函数的区别在于park()函数没有没有blocker，即没有设置线程的parkblocker字段。park(object)型函数如下。\n\npublic static void park(object blocker) {\n    // 获取当前线程\n    thread t = thread.currentthread();\n    // 设置blocker\n    setblocker(t, blocker);\n    // 获取许可\n    unsafe.park(false, 0l);\n    // 重新可运行后再此设置blocker\n    setblocker(t, null);\n}\n\n\n说明: 调用park函数时，首先获取当前线程，然后设置当前线程的parkblocker字段，即调用setblocker函数，之后调用unsafe类的park函数，之后再调用setblocker函数。那么问题来了，为什么要在此park函数中要调用两次setblocker函数呢? 原因其实很简单，调用park函数时，当前线程首先设置好parkblocker字段，然后再调用unsafe的park函数，此后，当前线程就已经阻塞了，等待该线程的unpark函数被调用，所以后面的一个setblocker函数无法运行，unpark函数被调用，该线程获得许可后，就可以继续运行了，也就运行第二个setblocker，把该线程的parkblocker字段设置为null，这样就完成了整个park函数的逻辑。如果没有第二个setblocker，那么之后没有调用park(object blocker)，而直接调用getblocker函数，得到的还是前一个park(object blocker)设置的blocker，显然是不符合逻辑的。总之，必须要保证在park(object blocker)整个函数执行完后，该线程的parkblocker字段又恢复为null。所以，park(object)型函数里必须要调用setblocker函数两次。setblocker方法如下。\n\nprivate static void setblocker(thread t, object arg) {\n    // 设置线程t的parkblocker字段的值为arg\n    unsafe.putobject(t, parkblockeroffset, arg);\n}\n\n\n说明: 此方法用于设置线程t的parkblocker字段的值为arg。\n\n另外一个无参重载版本，park()函数如下。\n\npublic static void park() {\n    // 获取许可，设置时间为无限长，直到可以获取许可\n    unsafe.park(false, 0l);\n}\n\n\n说明: 调用了park函数后，会禁用当前线程，除非许可可用。在以下三种情况之一发生之前，当前线程都将处于休眠状态，即下列情况发生时，当前线程会获取许可，可以继续运行。\n\n * 其他某个线程将当前线程作为目标调用 unpark。\n * 其他某个线程中断当前线程。\n * 该调用不合逻辑地(即毫无理由地)返回。\n\n# parknanos函数\n\n此函数表示在许可可用前禁用当前线程，并最多等待指定的等待时间。具体函数如下。\n\npublic static void parknanos(object blocker, long nanos) {\n    if (nanos > 0) { // 时间大于0\n        // 获取当前线程\n        thread t = thread.currentthread();\n        // 设置blocker\n        setblocker(t, blocker);\n        // 获取许可，并设置了时间\n        unsafe.park(false, nanos);\n        // 设置许可\n        setblocker(t, null);\n    }\n}\n\n\n说明: 该函数也是调用了两次setblocker函数，nanos参数表示相对时间，表示等待多长时间。\n\n# parkuntil函数\n\n此函数表示在指定的时限前禁用当前线程，除非许可可用, 具体函数如下:\n\npublic static void parkuntil(object blocker, long deadline) {\n    // 获取当前线程\n    thread t = thread.currentthread();\n    // 设置blocker\n    setblocker(t, blocker);\n    unsafe.park(true, deadline);\n    // 设置blocker为null\n    setblocker(t, null);\n}\n\n\n说明: 该函数也调用了两次setblocker函数，deadline参数表示绝对时间，表示指定的时间。\n\n# unpark函数\n\n此函数表示如果给定线程的许可尚不可用，则使其可用。如果线程在 park 上受阻塞，则它将解除其阻塞状态。否则，保证下一次调用 park 不会受阻塞。如果给定线程尚未启动，则无法保证此操作有任何效果。具体函数如下:\n\npublic static void unpark(thread thread) {\n    if (thread != null) // 线程为不空\n        unsafe.unpark(thread); // 释放该线程许可\n}\n\n\n说明: 释放许可，指定线程可以继续运行。\n\n\n# locksupport示例说明\n\n\n# 使用wait/notify实现线程同步\n\nclass mythread extends thread {\n    \n    public void run() {\n        synchronized (this) {\n            system.out.println("before notify");            \n            notify();\n            system.out.println("after notify");    \n        }\n    }\n}\n\npublic class waitandnotifydemo {\n    public static void main(string[] args) throws interruptedexception {\n        mythread mythread = new mythread();            \n        synchronized (mythread) {\n            try {        \n                mythread.start();\n                // 主线程睡眠3s\n                thread.sleep(3000);\n                system.out.println("before wait");\n                // 阻塞主线程\n                mythread.wait();\n                system.out.println("after wait");\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }            \n        }        \n    }\n}\n\n\n运行结果\n\nbefore wait\nbefore notify\nafter notify\nafter wait\n\n\n说明: 具体的流程图如下\n\n\n\n使用wait/notify实现同步时，必须先调用wait，后调用notify，如果先调用notify，再调用wait，将起不了作用。具体代码如下\n\nclass mythread extends thread {\n    public void run() {\n        synchronized (this) {\n            system.out.println("before notify");            \n            notify();\n            system.out.println("after notify");    \n        }\n    }\n}\n\npublic class waitandnotifydemo {\n    public static void main(string[] args) throws interruptedexception {\n        mythread mythread = new mythread();        \n        mythread.start();\n        // 主线程睡眠3s\n        thread.sleep(3000);\n        synchronized (mythread) {\n            try {        \n                system.out.println("before wait");\n                // 阻塞主线程\n                mythread.wait();\n                system.out.println("after wait");\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }            \n        }        \n    }\n}\n\n\n运行结果:\n\nbefore notify\nafter notify\nbefore wait\n\n\n说明: 由于先调用了notify，再调用的wait，此时主线程还是会一直阻塞。\n\n\n# 使用park/unpark实现线程同步\n\nimport java.util.concurrent.locks.locksupport;\n\nclass mythread extends thread {\n    private object object;\n\n    public mythread(object object) {\n        this.object = object;\n    }\n\n    public void run() {\n        system.out.println("before unpark");\n        try {\n            thread.sleep(1000);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n        // 获取blocker\n        system.out.println("blocker info " + locksupport.getblocker((thread) object));\n        // 释放许可\n        locksupport.unpark((thread) object);\n        // 休眠500ms，保证先执行park中的setblocker(t, null);\n        try {\n            thread.sleep(500);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n        // 再次获取blocker\n        system.out.println("blocker info " + locksupport.getblocker((thread) object));\n\n        system.out.println("after unpark");\n    }\n}\n\npublic class test {\n    public static void main(string[] args) {\n        mythread mythread = new mythread(thread.currentthread());\n        mythread.start();\n        system.out.println("before park");\n        // 获取许可\n        locksupport.park("parkandunparkdemo");\n        system.out.println("after park");\n    }\n}\n\n\n运行结果:\n\nbefore park\nbefore unpark\nblocker info parkandunparkdemo\nafter park\nblocker info null\nafter unpark\n\n\n说明: 本程序先执行park，然后在执行unpark，进行同步，并且在unpark的前后都调用了getblocker，可以看到两次的结果不一样，并且第二次调用的结果为null，这是因为在调用unpark之后，执行了lock.park(object blocker)函数中的setblocker(t, null)函数，所以第二次调用getblocker时为null。\n\n上例是先调用park，然后调用unpark，现在修改程序，先调用unpark，然后调用park，看能不能正确同步。具体代码如下\n\nimport java.util.concurrent.locks.locksupport;\n\nclass mythread extends thread {\n    private object object;\n\n    public mythread(object object) {\n        this.object = object;\n    }\n\n    public void run() {\n        system.out.println("before unpark");        \n        // 释放许可\n        locksupport.unpark((thread) object);\n        system.out.println("after unpark");\n    }\n}\n\npublic class parkandunparkdemo {\n    public static void main(string[] args) {\n        mythread mythread = new mythread(thread.currentthread());\n        mythread.start();\n        try {\n            // 主线程睡眠3s\n            thread.sleep(3000);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n        system.out.println("before park");\n        // 获取许可\n        locksupport.park("parkandunparkdemo");\n        system.out.println("after park");\n    }\n}\n\n\n运行结果:\n\nbefore unpark\nafter unpark\nbefore park\nafter park\n\n\n说明: 可以看到，在先调用unpark，再调用park时，仍能够正确实现同步，不会造成由wait/notify调用顺序不当所引起的阻塞。因此park/unpark相比wait/notify更加的灵活。\n\n\n# 中断响应\n\n看下面示例\n\nimport java.util.concurrent.locks.locksupport;\n\nclass mythread extends thread {\n    private object object;\n\n    public mythread(object object) {\n        this.object = object;\n    }\n\n    public void run() {\n        system.out.println("before interrupt");        \n        try {\n            // 休眠3s\n            thread.sleep(3000);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }    \n        thread thread = (thread) object;\n        // 中断线程\n        thread.interrupt();\n        system.out.println("after interrupt");\n    }\n}\n\npublic class interruptdemo {\n    public static void main(string[] args) {\n        mythread mythread = new mythread(thread.currentthread());\n        mythread.start();\n        system.out.println("before park");\n        // 获取许可\n        locksupport.park("parkandunparkdemo");\n        system.out.println("after park");\n    }\n}\n\n\n运行结果:\n\nbefore park\nbefore interrupt\nafter interrupt\nafter park\n\n\n说明: 可以看到，在主线程调用park阻塞后，在mythread线程中发出了中断信号，此时主线程会继续运行，也就是说明此时interrupt起到的作用与unpark一样。\n\n\n# 更深入的理解\n\n\n# thread.sleep()和object.wait()的区别\n\n首先，我们先来看看thread.sleep()和object.wait()的区别，这是一个烂大街的题目了，大家应该都能说上来两点。\n\n * thread.sleep()不会释放占有的锁，object.wait()会释放占有的锁；\n * thread.sleep()必须传入时间，object.wait()可传可不传，不传表示一直阻塞下去；\n * thread.sleep()到时间了会自动唤醒，然后继续执行；\n * object.wait()不带时间的，需要另一个线程使用object.notify()唤醒；\n * object.wait()带时间的，假如没有被notify，到时间了会自动唤醒，这时又分好两种情况，一是立即获取到了锁，线程自然会继续执行；二是没有立即获取锁，线程进入同步队列等待获取锁；\n\n其实，他们俩最大的区别就是thread.sleep()不会释放锁资源，object.wait()会释放锁资源。\n\n\n# object.wait()和condition.await()的区别\n\nobject.wait()和condition.await()的原理是基本一致的，不同的是condition.await()底层是调用locksupport.park()来实现阻塞当前线程的。\n\n实际上，它在阻塞当前线程之前还干了两件事，一是把当前线程添加到条件队列中，二是“完全”释放锁，也就是让state状态变量变为0，然后才是调用locksupport.park()阻塞当前线程。\n\n\n# thread.sleep()和locksupport.park()的区别\n\nlocksupport.park()还有几个兄弟方法——parknanos()、parkutil()等，我们这里说的park()方法统称这一类方法。\n\n * 从功能上来说，thread.sleep()和locksupport.park()方法类似，都是阻塞当前线程的执行，且都不会释放当前线程占有的锁资源；\n * thread.sleep()没法从外部唤醒，只能自己醒过来；\n * locksupport.park()方法可以被另一个线程调用locksupport.unpark()方法唤醒；\n * thread.sleep()方法声明上抛出了interruptedexception中断异常，所以调用者需要捕获这个异常或者再抛出；\n * locksupport.park()方法不需要捕获中断异常；\n * thread.sleep()本身就是一个native方法；\n * locksupport.park()底层是调用的unsafe的native方法；\n\n\n# object.wait()和locksupport.park()的区别\n\n二者都会阻塞当前线程的运行，他们有什么区别呢? 经过上面的分析相信你一定很清楚了，真的吗? 往下看！\n\n * object.wait()方法需要在synchronized块中执行；\n * locksupport.park()可以在任意地方执行；\n * object.wait()方法声明抛出了中断异常，调用者需要捕获或者再抛出；\n * locksupport.park()不需要捕获中断异常；\n * object.wait()不带超时的，需要另一个线程执行notify()来唤醒，但不一定继续执行后续内容；\n * locksupport.park()不带超时的，需要另一个线程执行unpark()来唤醒，一定会继续执行后续内容；\n\npark()/unpark()底层的原理是“二元信号量”，你可以把它相像成只有一个许可证的semaphore，只不过这个信号量在重复执行unpark()的时候也不会再增加许可证，最多只有一个许可证。\n\n# 如果在wait()之前执行了notify()会怎样?\n\n如果当前的线程不是此对象锁的所有者，却调用该对象的notify()或wait()方法时抛出illegalmonitorstateexception异常；\n\n如果当前线程是此对象锁的所有者，wait()将一直阻塞，因为后续将没有其它notify()唤醒它。\n\n# 如果在park()之前执行了unpark()会怎样?\n\n线程不会被阻塞，直接跳过park()，继续执行后续内容\n\n\n# locksupport.park()会释放锁资源吗?\n\n不会，它只负责阻塞当前线程，释放锁资源实际上是在condition的await()方法中实现的。\n\n\n# 参考文章\n\n * 文章主要参考自leesf的https://www.cnblogs.com/leesf456/p/5347293.html，在此基础上做了增改。\n * https://blog.csdn.net/tangtong1/article/details/102829724\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-lock-locksupport.html',charsets:{cjk:!0}},{title:"关键字: synchronized详解",frontmatter:{},regularPath:"/java/thread/java-thread-x-key-synchronized.html",relativePath:"java/thread/java-thread-x-key-synchronized.md",key:"v-e8b8e8e8",path:"/java/thread/java-thread-x-key-synchronized.html",headers:[{level:2,title:"关键字: synchronized详解",slug:"关键字-synchronized详解",normalizedTitle:"关键字: synchronized详解",charIndex:2},{level:2,title:"带着BAT大厂的面试问题去理解Synchronized",slug:"带着bat大厂的面试问题去理解synchronized",normalizedTitle:"带着bat大厂的面试问题去理解synchronized",charIndex:181},{level:2,title:"Synchronized的使用",slug:"synchronized的使用",normalizedTitle:"synchronized的使用",charIndex:214},{level:3,title:"对象锁",slug:"对象锁",normalizedTitle:"对象锁",charIndex:237},{level:3,title:"类锁",slug:"类锁",normalizedTitle:"类锁",charIndex:336},{level:2,title:"Synchronized原理分析",slug:"synchronized原理分析",normalizedTitle:"synchronized原理分析",charIndex:406},{level:3,title:"加锁和释放锁的原理",slug:"加锁和释放锁的原理",normalizedTitle:"加锁和释放锁的原理",charIndex:430},{level:3,title:"可重入原理：加锁次数计数器",slug:"可重入原理-加锁次数计数器",normalizedTitle:"可重入原理：加锁次数计数器",charIndex:447},{level:3,title:"保证可见性的原理：内存模型和happens-before规则",slug:"保证可见性的原理-内存模型和happens-before规则",normalizedTitle:"保证可见性的原理：内存模型和happens-before规则",charIndex:468},{level:2,title:"JVM中锁的优化",slug:"jvm中锁的优化",normalizedTitle:"jvm中锁的优化",charIndex:504},{level:3,title:"锁的类型",slug:"锁的类型",normalizedTitle:"锁的类型",charIndex:520},{level:3,title:"自旋锁与自适应自旋锁",slug:"自旋锁与自适应自旋锁",normalizedTitle:"自旋锁与自适应自旋锁",charIndex:532},{level:3,title:"锁消除",slug:"锁消除",normalizedTitle:"锁消除",charIndex:579},{level:3,title:"锁粗化",slug:"锁粗化",normalizedTitle:"锁粗化",charIndex:590},{level:3,title:"轻量级锁",slug:"轻量级锁",normalizedTitle:"轻量级锁",charIndex:601},{level:3,title:"偏向锁",slug:"偏向锁",normalizedTitle:"偏向锁",charIndex:629},{level:3,title:"锁的优缺点对比",slug:"锁的优缺点对比",normalizedTitle:"锁的优缺点对比",charIndex:656},{level:2,title:"Synchronized与Lock",slug:"synchronized与lock",normalizedTitle:"synchronized与lock",charIndex:669},{level:3,title:"synchronized的缺陷",slug:"synchronized的缺陷",normalizedTitle:"synchronized的缺陷",charIndex:694},{level:3,title:"Lock解决相应问题",slug:"lock解决相应问题",normalizedTitle:"lock解决相应问题",charIndex:717},{level:2,title:"再深入理解",slug:"再深入理解",normalizedTitle:"再深入理解",charIndex:733},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:744}],lastUpdated:"2023/4/10 22:14:07",lastUpdatedTimestamp:1681136047e3,headersStr:"关键字: synchronized详解 带着BAT大厂的面试问题去理解Synchronized Synchronized的使用 对象锁 类锁 Synchronized原理分析 加锁和释放锁的原理 可重入原理：加锁次数计数器 保证可见性的原理：内存模型和happens-before规则 JVM中锁的优化 锁的类型 自旋锁与自适应自旋锁 锁消除 锁粗化 轻量级锁 偏向锁 锁的优缺点对比 Synchronized与Lock synchronized的缺陷 Lock解决相应问题 再深入理解 参考文章",content:'# 关键字: synchronized详解\n\n> 在C程序代码中我们可以利用操作系统提供的互斥锁来实现同步块的互斥访问及线程的阻塞及唤醒等工作。在Java中除了提供Lock API外还在语法层面上提供了synchronized关键字来实现互斥同步原语, 本文将对synchronized关键字详细分析。\n\n * 关键字: synchronized详解\n   * 带着BAT大厂的面试问题去理解Synchronized\n   * Synchronized的使用\n     * 对象锁\n       * 代码块形式：手动指定锁定对象，也可是是this,也可以是自定义的锁\n       * 方法锁形式：synchronized修饰普通方法，锁对象默认为this\n     * 类锁\n       * synchronize修饰静态方法\n       * synchronized指定锁对象为Class对象\n   * Synchronized原理分析\n     * 加锁和释放锁的原理\n     * 可重入原理：加锁次数计数器\n     * 保证可见性的原理：内存模型和happens-before规则\n   * JVM中锁的优化\n     * 锁的类型\n     * 自旋锁与自适应自旋锁\n       * 自旋锁\n       * 自适应自旋锁\n     * 锁消除\n     * 锁粗化\n     * 轻量级锁\n       * 轻量级锁加锁\n     * 偏向锁\n       * 偏向锁的撤销\n     * 锁的优缺点对比\n   * Synchronized与Lock\n     * synchronized的缺陷\n     * Lock解决相应问题\n   * 再深入理解\n   * 参考文章\n\n\n# 带着BAT大厂的面试问题去理解Synchronized\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解synchronized。\n\n * Synchronized可以作用在哪里? 分别通过对象锁和类锁进行举例。\n * Synchronized本质上是通过什么保证线程安全的? 分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理。\n * Synchronized由什么样的缺陷? Java Lock是怎么弥补这些缺陷的。\n * Synchronized和Lock的对比，和选择?\n * Synchronized在使用时有何注意事项?\n * Synchronized修饰的方法在抛出异常时,会释放锁吗?\n * 多个线程等待同一个Synchronized锁的时候，JVM如何选择下一个获取锁的线程?\n * Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法?\n * 我想更加灵活的控制锁的释放和获取(现在释放锁和获取锁的时机都被规定死了)，怎么办?\n * 什么是锁的升级和降级? 什么是JVM里的偏斜锁、轻量级锁、重量级锁?\n * 不同的JDK中对Synchronized有何优化?\n\n\n# Synchronized的使用\n\n在应用Sychronized关键字时需要把握如下注意点：\n\n * 一把锁只能同时被一个线程获取，没有获得锁的线程只能等待；\n * 每个实例都对应有自己的一把锁(this),不同实例之间互不影响；例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象公用同一把锁\n * synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁\n\n\n# 对象锁\n\n包括方法锁(默认锁对象为this,当前实例对象)和同步代码块锁(自己指定锁对象)\n\n# 代码块形式：手动指定锁定对象，也可是是this,也可以是自定义的锁\n\n * 示例1\n\npublic class SynchronizedObjectLock implements Runnable {\n    static SynchronizedObjectLock instance = new SynchronizedObjectLock();\n\n    @Override\n    public void run() {\n        // 同步代码块形式——锁为this,两个线程使用的锁是一样的,线程1必须要等到线程0释放了该锁后，才能执行\n        synchronized (this) {\n            System.out.println("我是线程" + Thread.currentThread().getName());\n            try {\n                Thread.sleep(3000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + "结束");\n        }\n    }\n\n    public static void main(String[] args) {\n        Thread t1 = new Thread(instance);\n        Thread t2 = new Thread(instance);\n        t1.start();\n        t2.start();\n    }\n}\n\n\n输出结果：\n\n我是线程Thread-0\nThread-0结束\n我是线程Thread-1\nThread-1结束\n\n\n * 示例2\n\npublic class SynchronizedObjectLock implements Runnable {\n    static SynchronizedObjectLock instance = new SynchronizedObjectLock();\n    // 创建2把锁\n    Object block1 = new Object();\n    Object block2 = new Object();\n\n    @Override\n    public void run() {\n        // 这个代码块使用的是第一把锁，当他释放后，后面的代码块由于使用的是第二把锁，因此可以马上执行\n        synchronized (block1) {\n            System.out.println("block1锁,我是线程" + Thread.currentThread().getName());\n            try {\n                Thread.sleep(3000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println("block1锁,"+Thread.currentThread().getName() + "结束");\n        }\n\n        synchronized (block2) {\n            System.out.println("block2锁,我是线程" + Thread.currentThread().getName());\n            try {\n                Thread.sleep(3000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println("block2锁,"+Thread.currentThread().getName() + "结束");\n        }\n    }\n\n    public static void main(String[] args) {\n        Thread t1 = new Thread(instance);\n        Thread t2 = new Thread(instance);\n        t1.start();\n        t2.start();\n    }\n}\n\n\n输出结果：\n\nblock1锁,我是线程Thread-0\nblock1锁,Thread-0结束\nblock2锁,我是线程Thread-0　　// 可以看到当第一个线程在执行完第一段同步代码块之后，第二个同步代码块可以马上得到执行，因为他们使用的锁不是同一把\nblock1锁,我是线程Thread-1\nblock2锁,Thread-0结束\nblock1锁,Thread-1结束\nblock2锁,我是线程Thread-1\nblock2锁,Thread-1结束\n\n\n# 方法锁形式：synchronized修饰普通方法，锁对象默认为this\n\npublic class SynchronizedObjectLock implements Runnable {\n    static SynchronizedObjectLock instance = new SynchronizedObjectLock();\n\n    @Override\n    public void run() {\n        method();\n    }\n\n    public synchronized void method() {\n        System.out.println("我是线程" + Thread.currentThread().getName());\n        try {\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + "结束");\n    }\n\n    public static void main(String[] args) {\n        Thread t1 = new Thread(instance);\n        Thread t2 = new Thread(instance);\n        t1.start();\n        t2.start();\n    }\n}\n\n\n输出结果：\n\n我是线程Thread-0\nThread-0结束\n我是线程Thread-1\nThread-1结束\n\n\n\n# 类锁\n\n指synchronized修饰静态的方法或指定锁对象为Class对象\n\n# synchronized修饰静态方法\n\n * 示例1\n\npublic class SynchronizedObjectLock implements Runnable {\n    static SynchronizedObjectLock instance1 = new SynchronizedObjectLock();\n    static SynchronizedObjectLock instance2 = new SynchronizedObjectLock();\n\n    @Override\n    public void run() {\n        method();\n    }\n\n    // synchronized用在普通方法上，默认的锁就是this，当前实例\n    public synchronized void method() {\n        System.out.println("我是线程" + Thread.currentThread().getName());\n        try {\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + "结束");\n    }\n\n    public static void main(String[] args) {\n        // t1和t2对应的this是两个不同的实例，所以代码不会串行\n        Thread t1 = new Thread(instance1);\n        Thread t2 = new Thread(instance2);\n        t1.start();\n        t2.start();\n    }\n}\n\n\n输出结果：\n\n我是线程Thread-0\n我是线程Thread-1\nThread-1结束\nThread-0结束\n\n\n * 示例2\n\npublic class SynchronizedObjectLock implements Runnable {\n    static SynchronizedObjectLock instance1 = new SynchronizedObjectLock();\n    static SynchronizedObjectLock instance2 = new SynchronizedObjectLock();\n\n    @Override\n    public void run() {\n        method();\n    }\n\n    // synchronized用在静态方法上，默认的锁就是当前所在的Class类，所以无论是哪个线程访问它，需要的锁都只有一把\n    public static synchronized void method() {\n        System.out.println("我是线程" + Thread.currentThread().getName());\n        try {\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + "结束");\n    }\n\n    public static void main(String[] args) {\n        Thread t1 = new Thread(instance1);\n        Thread t2 = new Thread(instance2);\n        t1.start();\n        t2.start();\n    }\n}\n\n\n输出结果：\n\n我是线程Thread-0\nThread-0结束\n我是线程Thread-1\nThread-1结束\n\n\n# synchronized指定锁对象为Class对象\n\npublic class SynchronizedObjectLock implements Runnable {\n    static SynchronizedObjectLock instance1 = new SynchronizedObjectLock();\n    static SynchronizedObjectLock instance2 = new SynchronizedObjectLock();\n\n    @Override\n    public void run() {\n        // 所有线程需要的锁都是同一把\n        synchronized(SynchronizedObjectLock.class){\n            System.out.println("我是线程" + Thread.currentThread().getName());\n            try {\n                Thread.sleep(3000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + "结束");\n        }\n    }\n\n    public static void main(String[] args) {\n        Thread t1 = new Thread(instance1);\n        Thread t2 = new Thread(instance2);\n        t1.start();\n        t2.start();\n    }\n}\n\n\n输出结果：\n\n我是线程Thread-0\nThread-0结束\n我是线程Thread-1\nThread-1结束\n\n\n\n# Synchronized原理分析\n\n\n# 加锁和释放锁的原理\n\n> 现象、时机(内置锁this)、深入JVM看字节码(反编译看monitor指令)\n\n深入JVM看字节码，创建如下的代码：\n\npublic class SynchronizedDemo2 {\n\n    Object object = new Object();\n    public void method1() {\n        synchronized (object) {\n\n        }\n        method2();\n    }\n\n    private static void method2() {\n\n    }\n}\n\n\n使用javac命令进行编译生成.class文件\n\n>javac SynchronizedDemo2.java\n\n\n使用javap命令反编译查看.class文件的信息\n\n>javap -verbose SynchronizedDemo2.class\n\n\n得到如下的信息：\n\n\n\n关注红色方框里的monitorenter和monitorexit即可。\n\nMonitorenter和Monitorexit指令，会让对象在执行，使其锁计数器加1或者减1。每一个对象在同一时间只与一个monitor(锁)相关联，而一个monitor在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的Monitor锁的所有权的时候，monitorenter指令会发生如下3中情况之一：\n\n * monitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待\n * 如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加\n * 这把锁已经被别的线程获取了，等待锁释放\n\nmonitorexit指令：释放对于monitor的所有权，释放过程很简单，就是讲monitor的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该monitor的所有权，即释放锁。\n\n下图表现了对象，对象监视器，同步队列以及执行线程状态之间的关系：\n\n\n\n该图可以看出，任意线程对Object的访问，首先要获得Object的监视器，如果获取失败，该线程就进入同步状态，线程状态变为BLOCKED，当Object的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器。\n\n\n# 可重入原理：加锁次数计数器\n\n * 什么是可重入？可重入锁？\n\n可重入：（来源于维基百科）若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。\n\n可重入锁：又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。\n\n * 看如下的例子\n\npublic class SynchronizedDemo {\n\n    public static void main(String[] args) {\n        SynchronizedDemo demo =  new SynchronizedDemo();\n        demo.method1();\n    }\n\n    private synchronized void method1() {\n        System.out.println(Thread.currentThread().getId() + ": method1()");\n        method2();\n    }\n\n    private synchronized void method2() {\n        System.out.println(Thread.currentThread().getId()+ ": method2()");\n        method3();\n    }\n\n    private synchronized void method3() {\n        System.out.println(Thread.currentThread().getId()+ ": method3()");\n    }\n}\n\n\n结合前文中加锁和释放锁的原理，不难理解：\n\n * 执行monitorenter获取锁\n   * （monitor计数器=0，可获取锁）\n   * 执行method1()方法，monitor计数器+1 -> 1 （获取到锁）\n   * 执行method2()方法，monitor计数器+1 -> 2\n   * 执行method3()方法，monitor计数器+1 -> 3\n * 执行monitorexit命令\n   * method3()方法执行完，monitor计数器-1 -> 2\n   * method2()方法执行完，monitor计数器-1 -> 1\n   * method2()方法执行完，monitor计数器-1 -> 0 （释放了锁）\n   * （monitor计数器=0，锁被释放了）\n\n这就是Synchronized的重入性，即在同一锁程中，每个对象拥有一个monitor计数器，当线程获取该对象锁后，monitor计数器就会加一，释放锁后就会将monitor计数器减一，线程不需要再次获取同一把锁。\n\n\n# 保证可见性的原理：内存模型和happens-before规则\n\nSynchronized的happens-before规则，即监视器锁规则：对同一个监视器的解锁，happens-before于对该监视器的加锁。继续来看代码：\n\npublic class MonitorDemo {\n    private int a = 0;\n\n    public synchronized void writer() {     // 1\n        a++;                                // 2\n    }                                       // 3\n\n    public synchronized void reader() {    // 4\n        int i = a;                         // 5\n    }                                      // 6\n}\n\n\n该代码的happens-before关系如图所示：\n\n\n\n在图中每一个箭头连接的两个节点就代表之间的happens-before关系，黑色的是通过程序顺序规则推导出来，红色的为监视器锁规则推导而出：线程A释放锁happens-before线程B加锁，蓝色的则是通过程序顺序规则和监视器锁规则推测出来happens-befor关系，通过传递性规则进一步推导的happens-before关系。现在我们来重点关注2 happens-before 5，通过这个关系我们可以得出什么?\n\n根据happens-before的定义中的一条:如果A happens-before B，则A的执行结果对B可见，并且A的执行顺序先于B。线程A先对共享变量A进行加一，由2 happens-before 5关系可知线程A的执行结果对线程B可见即线程B所读取到的a的值为1。\n\n\n# JVM中锁的优化\n\n简单来说在JVM中monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的，但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的；然而在现实中的大部分情况下，同步方法是运行在单线程环境(无锁竞争环境)如果每次都调用Mutex Lock那么将严重的影响程序的性能。不过在jdk1.6中对锁的实现引入了大量的优化，如锁粗化(Lock Coarsening)、锁消除(Lock Elimination)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)、适应性自旋(Adaptive Spinning)等技术来减少锁操作的开销。\n\n * 锁粗化(Lock Coarsening)：也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。\n\n * 锁消除(Lock Elimination)：通过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，通过逃逸分析也可以在线程本的Stack上进行对象空间的分配(同时还可以减少Heap上的垃圾收集开销)。\n\n * 轻量级锁(Lightweight Locking)：这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态(即单线程执行环境)，在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒(具体处理步骤下面详细讨论)。\n\n * 偏向锁(Biased Locking)：是为了在无锁竞争的情况下避免在锁获取过程中执行不必要的CAS原子指令，因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟。\n\n * 适应性自旋(Adaptive Spinning)：当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入与monitor相关联的操作系统重量级锁(mutex semaphore)前会进入忙等待(Spinning)然后再次尝试，当尝试一定的次数后如果仍然没有成功则调用与该monitor关联的semaphore(即互斥锁)进入到阻塞状态。\n\n> 下面来详细讲解下，先从Synchronied同步锁开始讲起：\n\n\n# 锁的类型\n\n在Java SE 1.6里Synchronied同步锁，一共有四种状态：无锁、偏向锁、轻量级锁、重量级锁，它会随着竞争情况逐渐升级。锁可以升级但是不可以降级，目的是为了提供获取锁和释放锁的效率。\n\n> 锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的)\n\n\n# 自旋锁与自适应自旋锁\n\n# 自旋锁\n\n> 引入背景：大家都知道，在没有加入锁优化时，Synchronized是一个非常“胖大”的家伙。在多线程竞争锁时，当一个线程获取锁时，它会阻塞所有正在竞争的线程，这样对性能带来了极大的影响。在挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作对系统的并发性能带来了很大的压力。同时HotSpot团队注意到在很多情况下，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和回复阻塞线程并不值得。在如今多处理器环境下，完全可以让另一个没有获取到锁的线程在门外等待一会(自旋)，但不放弃CPU的执行时间。等待持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需要让线程执行一个忙循环(自旋)，这便是自旋锁由来的原因。\n\n自旋锁早在JDK1.4 中就引入了，只是当时默认时关闭的。在JDK 1.6后默认为开启状态。自旋锁本质上与阻塞并不相同，先不考虑其对多处理器的要求，如果锁占用的时间非常的短，那么自旋锁的性能会非常的好，相反，其会带来更多的性能开销(因为在线程自旋时，始终会占用CPU的时间片，如果锁占用的时间太长，那么自旋的线程会白白消耗掉CPU资源)。因此自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获取到锁，就应该使用传统的方式去挂起线程了，在JDK定义中，自旋锁默认的自旋次数为10次，用户可以使用参数-XX:PreBlockSpin来更改。\n\n可是现在又出现了一个问题：如果线程锁在线程自旋刚结束就释放掉了锁，那么是不是有点得不偿失。所以这时候我们需要更加聪明的锁来实现更加灵活的自旋。来提高并发的性能。(这里则需要自适应自旋锁！)\n\n# 自适应自旋锁\n\n在JDK 1.6中引入了自适应自旋锁。这就意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋 时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么JVM会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。比如增加到100此循环。相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，JVM对程序的锁的状态预测会越来越准确，JVM也会越来越聪明。\n\n\n# 锁消除\n\n锁消除是指虚拟机即时编译器再运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。意思就是：JVM会判断再一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那JVM就把它们当作栈上数据对待，认为这些数据是线程独有的，不需要加同步。此时就会进行锁消除。\n\n当然在实际开发中，我们很清楚的知道哪些是线程独有的，不需要加同步锁，但是在Java API中有很多方法都是加了同步的，那么此时JVM会判断这段代码是否需要加锁。如果数据并不会逃逸，则会进行锁消除。比如如下操作：在操作String类型数据时，由于String是一个不可变类，对字符串的连接操作总是通过生成的新的String对象来进行的。因此Javac编译器会对String连接做自动优化。在JDK 1.5之前会使用StringBuffer对象的连续append()操作，在JDK 1.5及以后的版本中，会转化为StringBuidler对象的连续append()操作。\n\npublic static String test03(String s1, String s2, String s3) {\n    String s = s1 + s2 + s3;\n    return s;\n}\n\n\n上述代码使用javap 编译结果\n\n\n\n众所周知，StringBuilder不是安全同步的，但是在上述代码中，JVM判断该段代码并不会逃逸，则将该代码带默认为线程独有的资源，并不需要同步，所以执行了锁消除操作。(还有Vector中的各种操作也可实现锁消除。在没有逃逸出数据安全防卫内)\n\n\n# 锁粗化\n\n原则上，我们都知道在加同步锁时，尽可能的将同步块的作用范围限制到尽量小的范围(只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小。在存在锁同步竞争中，也可以使得等待锁的线程尽早的拿到锁)。\n\n大部分上述情况是完美正确的，但是如果存在连串的一系列操作都对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体中的，那即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能操作。\n\n这里贴上根据上述Javap 编译的情况编写的实例java类\n\npublic static String test04(String s1, String s2, String s3) {\n    StringBuffer sb = new StringBuffer();\n    sb.append(s1);\n    sb.append(s2);\n    sb.append(s3);\n    return sb.toString();\n}\n\n\n在上述的连续append()操作中就属于这类情况。JVM会检测到这样一连串的操作都是对同一个对象加锁，那么JVM会将加锁同步的范围扩展(粗化)到整个一系列操作的 外部，使整个一连串的append()操作只需要加锁一次就可以了。\n\n\n# 轻量级锁\n\n在JDK 1.6之后引入的轻量级锁，需要注意的是轻量级锁并不是替代重量级锁的，而是对在大多数情况下同步块并不会有竞争出现提出的一种优化。它可以减少重量级锁对线程的阻塞带来的线程开销。从而提高并发性能。\n\n如果要理解轻量级锁，那么必须先要了解HotSpot虚拟机中对象头的内存布局。上面介绍Java对象头也详细介绍过。在对象头中(Object Header)存在两部分。第一部分用于存储对象自身的运行时数据，HashCode、GC Age、锁标记位、是否为偏向锁。等。一般为32位或者64位(视操作系统位数定)。官方称之为Mark Word，它是实现轻量级锁和偏向锁的关键。 另外一部分存储的是指向方法区对象类型数据的指针(Klass Point)，如果对象是数组的话，还会有一个额外的部分用于存储数据的长度。\n\n# 轻量级锁加锁\n\n在线程执行同步块之前，JVM会先在当前线程的栈帧中创建一个名为锁记录(Lock Record)的空间，用于存储锁对象目前的Mark Word的拷贝(JVM会将对象头中的Mark Word拷贝到锁记录中，官方称为Displaced Mark Ward)这个时候线程堆栈与对象头的状态如图：\n\n\n\n如上图所示：如果当前对象没有被锁定，那么锁标志位为01状态，JVM在执行当前线程时，首先会在当前线程栈帧中创建锁记录Lock Record的空间用于存储锁对象目前的Mark Word的拷贝。\n\n然后，虚拟机使用CAS操作将标记字段Mark Word拷贝到锁记录中，并且将Mark Word更新为指向Lock Record的指针。如果更新成功了，那么这个线程就拥用了该对象的锁，并且对象Mark Word的锁标志位更新为(Mark Word中最后的2bit)00，即表示此对象处于轻量级锁定状态，如图：\n\n\n\n如果这个更新操作失败，JVM会检查当前的Mark Word中是否存在指向当前线程的栈帧的指针，如果有，说明该锁已经被获取，可以直接调用。如果没有，则说明该锁被其他线程抢占了，如果有两条以上的线程竞争同一个锁，那轻量级锁就不再有效，直接膨胀为重量级锁，没有获得锁的线程会被阻塞。此时，锁的标志位为10.Mark Word中存储的指向重量级锁的指针。\n\n轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头中，如果成功，则表示没有发生竞争关系。如果失败，表示当前锁存在竞争关系。锁就会膨胀成重量级锁。两个线程同时争夺锁，导致锁膨胀的流程图如下：\n\n\n\n\n# 偏向锁\n\n> 引入背景：在大多实际环境下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，那么在同一个线程反复获取所释放锁中，其中并还没有锁的竞争，那么这样看上去，多次的获取锁和释放锁带来了很多不必要的性能开销和上下文切换。\n\n为了解决这一问题，HotSpot的作者在Java SE 1.6 中对Synchronized进行了优化，引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁。只需要简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁。\n\n\n\n# 偏向锁的撤销\n\n偏向锁使用了一种等待竞争出现才会释放锁的机制。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。但是偏向锁的撤销需要等到全局安全点(就是当前线程没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，直接将对象头设置为无锁状态。如果线程活着，JVM会遍历栈帧中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁。\n\n\n\n\n# 锁的优缺点对比\n\n锁      优点                                            缺点                                      使用场景\n偏向锁    加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距   如果线程间存在锁竞争，会带来额外的锁撤销的消耗                 适用于只有一个线程访问同步块的场景\n轻量级锁   竞争的线程不会阻塞，提高了响应速度                             如线程始终得不到锁竞争的线程，使用自旋会消耗CPU性能             追求响应时间，同步块执行速度非常快\n重量级锁   线程竞争不适用自旋，不会消耗CPU                             线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗   追求吞吐量，同步块执行速度较长\n\n\n# Synchronized与Lock\n\n\n# synchronized的缺陷\n\n * 效率低：锁的释放情况少，只有代码执行完毕或者异常结束才会释放锁；试图获取锁的时候不能设定超时，不能中断一个正在使用锁的线程，相对而言，Lock可以中断和设置超时\n\n * 不够灵活：加锁和释放的时机单一，每个锁仅有一个单一的条件(某个对象)，相对而言，读写锁更加灵活\n\n * 无法知道是否成功获得锁，相对而言，Lock可以拿到状态，如果成功获取锁，....，如果获取失败，.....\n\n\n# Lock解决相应问题\n\nLock类这里不做过多解释，主要看里面的4个方法:\n\n * lock(): 加锁\n * unlock(): 解锁\n * tryLock(): 尝试获取锁，返回一个boolean值\n * tryLock(long,TimeUtil): 尝试获取锁，可以设置超时\n\nSynchronized加锁只与一个条件(是否获取锁)相关联，不灵活，后来Condition与Lock的结合解决了这个问题。\n\n多线程竞争一个锁时，其余未得到锁的线程只能不停的尝试获得锁，而不能中断。高并发的情况下会导致性能下降。ReentrantLock的lockInterruptibly()方法可以优先考虑响应中断。 一个线程等待时间过长，它可以中断自己，然后ReentrantLock响应这个中断，不再让这个线程继续等待。有了这个机制，使用ReentrantLock时就不会像synchronized那样产生死锁了。\n\n> ReentrantLock为常用类，它是一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。详细分析请看: JUC锁: ReentrantLock详解\n\n\n# 再深入理解\n\nsynchronized是通过软件(JVM)实现的，简单易用，即使在JDK5之后有了Lock，仍然被广泛的使用。\n\n * 使用Synchronized有哪些要注意的？\n   \n   * 锁对象不能为空，因为锁的信息都保存在对象头里\n   * 作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错\n   * 避免死锁\n   * 在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错\n\n * synchronized是公平锁吗？\n\nsynchronized实际上是非公平的，新来的线程有可能立即获得监视器，而在等待区中等候已久的线程可能再次等待，这样有利于提高性能，但是也可能会导致饥饿现象。\n\n\n# 参考文章\n\n+《深入理解Java虚拟机》 +《Java并发编程的艺术》\n\n * https://juejin.im/post/5ae6dc04f265da0ba351d3ff\n * https://www.cnblogs.com/javaminer/p/3889023.html\n * https://www.jianshu.com/p/dab7745c0954\n * https://www.cnblogs.com/wuchaodzxx/p/6867546.html\n * https://www.cnblogs.com/xyabk/p/10901291.html\n * https://www.jianshu.com/p/64240319ed60\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html',normalizedContent:'# 关键字: synchronized详解\n\n> 在c程序代码中我们可以利用操作系统提供的互斥锁来实现同步块的互斥访问及线程的阻塞及唤醒等工作。在java中除了提供lock api外还在语法层面上提供了synchronized关键字来实现互斥同步原语, 本文将对synchronized关键字详细分析。\n\n * 关键字: synchronized详解\n   * 带着bat大厂的面试问题去理解synchronized\n   * synchronized的使用\n     * 对象锁\n       * 代码块形式：手动指定锁定对象，也可是是this,也可以是自定义的锁\n       * 方法锁形式：synchronized修饰普通方法，锁对象默认为this\n     * 类锁\n       * synchronize修饰静态方法\n       * synchronized指定锁对象为class对象\n   * synchronized原理分析\n     * 加锁和释放锁的原理\n     * 可重入原理：加锁次数计数器\n     * 保证可见性的原理：内存模型和happens-before规则\n   * jvm中锁的优化\n     * 锁的类型\n     * 自旋锁与自适应自旋锁\n       * 自旋锁\n       * 自适应自旋锁\n     * 锁消除\n     * 锁粗化\n     * 轻量级锁\n       * 轻量级锁加锁\n     * 偏向锁\n       * 偏向锁的撤销\n     * 锁的优缺点对比\n   * synchronized与lock\n     * synchronized的缺陷\n     * lock解决相应问题\n   * 再深入理解\n   * 参考文章\n\n\n# 带着bat大厂的面试问题去理解synchronized\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解synchronized。\n\n * synchronized可以作用在哪里? 分别通过对象锁和类锁进行举例。\n * synchronized本质上是通过什么保证线程安全的? 分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理。\n * synchronized由什么样的缺陷? java lock是怎么弥补这些缺陷的。\n * synchronized和lock的对比，和选择?\n * synchronized在使用时有何注意事项?\n * synchronized修饰的方法在抛出异常时,会释放锁吗?\n * 多个线程等待同一个synchronized锁的时候，jvm如何选择下一个获取锁的线程?\n * synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法?\n * 我想更加灵活的控制锁的释放和获取(现在释放锁和获取锁的时机都被规定死了)，怎么办?\n * 什么是锁的升级和降级? 什么是jvm里的偏斜锁、轻量级锁、重量级锁?\n * 不同的jdk中对synchronized有何优化?\n\n\n# synchronized的使用\n\n在应用sychronized关键字时需要把握如下注意点：\n\n * 一把锁只能同时被一个线程获取，没有获得锁的线程只能等待；\n * 每个实例都对应有自己的一把锁(this),不同实例之间互不影响；例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象公用同一把锁\n * synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁\n\n\n# 对象锁\n\n包括方法锁(默认锁对象为this,当前实例对象)和同步代码块锁(自己指定锁对象)\n\n# 代码块形式：手动指定锁定对象，也可是是this,也可以是自定义的锁\n\n * 示例1\n\npublic class synchronizedobjectlock implements runnable {\n    static synchronizedobjectlock instance = new synchronizedobjectlock();\n\n    @override\n    public void run() {\n        // 同步代码块形式——锁为this,两个线程使用的锁是一样的,线程1必须要等到线程0释放了该锁后，才能执行\n        synchronized (this) {\n            system.out.println("我是线程" + thread.currentthread().getname());\n            try {\n                thread.sleep(3000);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n            system.out.println(thread.currentthread().getname() + "结束");\n        }\n    }\n\n    public static void main(string[] args) {\n        thread t1 = new thread(instance);\n        thread t2 = new thread(instance);\n        t1.start();\n        t2.start();\n    }\n}\n\n\n输出结果：\n\n我是线程thread-0\nthread-0结束\n我是线程thread-1\nthread-1结束\n\n\n * 示例2\n\npublic class synchronizedobjectlock implements runnable {\n    static synchronizedobjectlock instance = new synchronizedobjectlock();\n    // 创建2把锁\n    object block1 = new object();\n    object block2 = new object();\n\n    @override\n    public void run() {\n        // 这个代码块使用的是第一把锁，当他释放后，后面的代码块由于使用的是第二把锁，因此可以马上执行\n        synchronized (block1) {\n            system.out.println("block1锁,我是线程" + thread.currentthread().getname());\n            try {\n                thread.sleep(3000);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n            system.out.println("block1锁,"+thread.currentthread().getname() + "结束");\n        }\n\n        synchronized (block2) {\n            system.out.println("block2锁,我是线程" + thread.currentthread().getname());\n            try {\n                thread.sleep(3000);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n            system.out.println("block2锁,"+thread.currentthread().getname() + "结束");\n        }\n    }\n\n    public static void main(string[] args) {\n        thread t1 = new thread(instance);\n        thread t2 = new thread(instance);\n        t1.start();\n        t2.start();\n    }\n}\n\n\n输出结果：\n\nblock1锁,我是线程thread-0\nblock1锁,thread-0结束\nblock2锁,我是线程thread-0　　// 可以看到当第一个线程在执行完第一段同步代码块之后，第二个同步代码块可以马上得到执行，因为他们使用的锁不是同一把\nblock1锁,我是线程thread-1\nblock2锁,thread-0结束\nblock1锁,thread-1结束\nblock2锁,我是线程thread-1\nblock2锁,thread-1结束\n\n\n# 方法锁形式：synchronized修饰普通方法，锁对象默认为this\n\npublic class synchronizedobjectlock implements runnable {\n    static synchronizedobjectlock instance = new synchronizedobjectlock();\n\n    @override\n    public void run() {\n        method();\n    }\n\n    public synchronized void method() {\n        system.out.println("我是线程" + thread.currentthread().getname());\n        try {\n            thread.sleep(3000);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n        system.out.println(thread.currentthread().getname() + "结束");\n    }\n\n    public static void main(string[] args) {\n        thread t1 = new thread(instance);\n        thread t2 = new thread(instance);\n        t1.start();\n        t2.start();\n    }\n}\n\n\n输出结果：\n\n我是线程thread-0\nthread-0结束\n我是线程thread-1\nthread-1结束\n\n\n\n# 类锁\n\n指synchronized修饰静态的方法或指定锁对象为class对象\n\n# synchronized修饰静态方法\n\n * 示例1\n\npublic class synchronizedobjectlock implements runnable {\n    static synchronizedobjectlock instance1 = new synchronizedobjectlock();\n    static synchronizedobjectlock instance2 = new synchronizedobjectlock();\n\n    @override\n    public void run() {\n        method();\n    }\n\n    // synchronized用在普通方法上，默认的锁就是this，当前实例\n    public synchronized void method() {\n        system.out.println("我是线程" + thread.currentthread().getname());\n        try {\n            thread.sleep(3000);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n        system.out.println(thread.currentthread().getname() + "结束");\n    }\n\n    public static void main(string[] args) {\n        // t1和t2对应的this是两个不同的实例，所以代码不会串行\n        thread t1 = new thread(instance1);\n        thread t2 = new thread(instance2);\n        t1.start();\n        t2.start();\n    }\n}\n\n\n输出结果：\n\n我是线程thread-0\n我是线程thread-1\nthread-1结束\nthread-0结束\n\n\n * 示例2\n\npublic class synchronizedobjectlock implements runnable {\n    static synchronizedobjectlock instance1 = new synchronizedobjectlock();\n    static synchronizedobjectlock instance2 = new synchronizedobjectlock();\n\n    @override\n    public void run() {\n        method();\n    }\n\n    // synchronized用在静态方法上，默认的锁就是当前所在的class类，所以无论是哪个线程访问它，需要的锁都只有一把\n    public static synchronized void method() {\n        system.out.println("我是线程" + thread.currentthread().getname());\n        try {\n            thread.sleep(3000);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n        system.out.println(thread.currentthread().getname() + "结束");\n    }\n\n    public static void main(string[] args) {\n        thread t1 = new thread(instance1);\n        thread t2 = new thread(instance2);\n        t1.start();\n        t2.start();\n    }\n}\n\n\n输出结果：\n\n我是线程thread-0\nthread-0结束\n我是线程thread-1\nthread-1结束\n\n\n# synchronized指定锁对象为class对象\n\npublic class synchronizedobjectlock implements runnable {\n    static synchronizedobjectlock instance1 = new synchronizedobjectlock();\n    static synchronizedobjectlock instance2 = new synchronizedobjectlock();\n\n    @override\n    public void run() {\n        // 所有线程需要的锁都是同一把\n        synchronized(synchronizedobjectlock.class){\n            system.out.println("我是线程" + thread.currentthread().getname());\n            try {\n                thread.sleep(3000);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n            system.out.println(thread.currentthread().getname() + "结束");\n        }\n    }\n\n    public static void main(string[] args) {\n        thread t1 = new thread(instance1);\n        thread t2 = new thread(instance2);\n        t1.start();\n        t2.start();\n    }\n}\n\n\n输出结果：\n\n我是线程thread-0\nthread-0结束\n我是线程thread-1\nthread-1结束\n\n\n\n# synchronized原理分析\n\n\n# 加锁和释放锁的原理\n\n> 现象、时机(内置锁this)、深入jvm看字节码(反编译看monitor指令)\n\n深入jvm看字节码，创建如下的代码：\n\npublic class synchronizeddemo2 {\n\n    object object = new object();\n    public void method1() {\n        synchronized (object) {\n\n        }\n        method2();\n    }\n\n    private static void method2() {\n\n    }\n}\n\n\n使用javac命令进行编译生成.class文件\n\n>javac synchronizeddemo2.java\n\n\n使用javap命令反编译查看.class文件的信息\n\n>javap -verbose synchronizeddemo2.class\n\n\n得到如下的信息：\n\n\n\n关注红色方框里的monitorenter和monitorexit即可。\n\nmonitorenter和monitorexit指令，会让对象在执行，使其锁计数器加1或者减1。每一个对象在同一时间只与一个monitor(锁)相关联，而一个monitor在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的monitor锁的所有权的时候，monitorenter指令会发生如下3中情况之一：\n\n * monitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待\n * 如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加\n * 这把锁已经被别的线程获取了，等待锁释放\n\nmonitorexit指令：释放对于monitor的所有权，释放过程很简单，就是讲monitor的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该monitor的所有权，即释放锁。\n\n下图表现了对象，对象监视器，同步队列以及执行线程状态之间的关系：\n\n\n\n该图可以看出，任意线程对object的访问，首先要获得object的监视器，如果获取失败，该线程就进入同步状态，线程状态变为blocked，当object的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器。\n\n\n# 可重入原理：加锁次数计数器\n\n * 什么是可重入？可重入锁？\n\n可重入：（来源于维基百科）若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。\n\n可重入锁：又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。\n\n * 看如下的例子\n\npublic class synchronizeddemo {\n\n    public static void main(string[] args) {\n        synchronizeddemo demo =  new synchronizeddemo();\n        demo.method1();\n    }\n\n    private synchronized void method1() {\n        system.out.println(thread.currentthread().getid() + ": method1()");\n        method2();\n    }\n\n    private synchronized void method2() {\n        system.out.println(thread.currentthread().getid()+ ": method2()");\n        method3();\n    }\n\n    private synchronized void method3() {\n        system.out.println(thread.currentthread().getid()+ ": method3()");\n    }\n}\n\n\n结合前文中加锁和释放锁的原理，不难理解：\n\n * 执行monitorenter获取锁\n   * （monitor计数器=0，可获取锁）\n   * 执行method1()方法，monitor计数器+1 -> 1 （获取到锁）\n   * 执行method2()方法，monitor计数器+1 -> 2\n   * 执行method3()方法，monitor计数器+1 -> 3\n * 执行monitorexit命令\n   * method3()方法执行完，monitor计数器-1 -> 2\n   * method2()方法执行完，monitor计数器-1 -> 1\n   * method2()方法执行完，monitor计数器-1 -> 0 （释放了锁）\n   * （monitor计数器=0，锁被释放了）\n\n这就是synchronized的重入性，即在同一锁程中，每个对象拥有一个monitor计数器，当线程获取该对象锁后，monitor计数器就会加一，释放锁后就会将monitor计数器减一，线程不需要再次获取同一把锁。\n\n\n# 保证可见性的原理：内存模型和happens-before规则\n\nsynchronized的happens-before规则，即监视器锁规则：对同一个监视器的解锁，happens-before于对该监视器的加锁。继续来看代码：\n\npublic class monitordemo {\n    private int a = 0;\n\n    public synchronized void writer() {     // 1\n        a++;                                // 2\n    }                                       // 3\n\n    public synchronized void reader() {    // 4\n        int i = a;                         // 5\n    }                                      // 6\n}\n\n\n该代码的happens-before关系如图所示：\n\n\n\n在图中每一个箭头连接的两个节点就代表之间的happens-before关系，黑色的是通过程序顺序规则推导出来，红色的为监视器锁规则推导而出：线程a释放锁happens-before线程b加锁，蓝色的则是通过程序顺序规则和监视器锁规则推测出来happens-befor关系，通过传递性规则进一步推导的happens-before关系。现在我们来重点关注2 happens-before 5，通过这个关系我们可以得出什么?\n\n根据happens-before的定义中的一条:如果a happens-before b，则a的执行结果对b可见，并且a的执行顺序先于b。线程a先对共享变量a进行加一，由2 happens-before 5关系可知线程a的执行结果对线程b可见即线程b所读取到的a的值为1。\n\n\n# jvm中锁的优化\n\n简单来说在jvm中monitorenter和monitorexit字节码依赖于底层的操作系统的mutex lock来实现的，但是由于使用mutex lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的；然而在现实中的大部分情况下，同步方法是运行在单线程环境(无锁竞争环境)如果每次都调用mutex lock那么将严重的影响程序的性能。不过在jdk1.6中对锁的实现引入了大量的优化，如锁粗化(lock coarsening)、锁消除(lock elimination)、轻量级锁(lightweight locking)、偏向锁(biased locking)、适应性自旋(adaptive spinning)等技术来减少锁操作的开销。\n\n * 锁粗化(lock coarsening)：也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。\n\n * 锁消除(lock elimination)：通过运行时jit编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，通过逃逸分析也可以在线程本的stack上进行对象空间的分配(同时还可以减少heap上的垃圾收集开销)。\n\n * 轻量级锁(lightweight locking)：这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态(即单线程执行环境)，在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条cas原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行cas指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒(具体处理步骤下面详细讨论)。\n\n * 偏向锁(biased locking)：是为了在无锁竞争的情况下避免在锁获取过程中执行不必要的cas原子指令，因为cas原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟。\n\n * 适应性自旋(adaptive spinning)：当线程在获取轻量级锁的过程中执行cas操作失败时，在进入与monitor相关联的操作系统重量级锁(mutex semaphore)前会进入忙等待(spinning)然后再次尝试，当尝试一定的次数后如果仍然没有成功则调用与该monitor关联的semaphore(即互斥锁)进入到阻塞状态。\n\n> 下面来详细讲解下，先从synchronied同步锁开始讲起：\n\n\n# 锁的类型\n\n在java se 1.6里synchronied同步锁，一共有四种状态：无锁、偏向锁、轻量级锁、重量级锁，它会随着竞争情况逐渐升级。锁可以升级但是不可以降级，目的是为了提供获取锁和释放锁的效率。\n\n> 锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的)\n\n\n# 自旋锁与自适应自旋锁\n\n# 自旋锁\n\n> 引入背景：大家都知道，在没有加入锁优化时，synchronized是一个非常“胖大”的家伙。在多线程竞争锁时，当一个线程获取锁时，它会阻塞所有正在竞争的线程，这样对性能带来了极大的影响。在挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作对系统的并发性能带来了很大的压力。同时hotspot团队注意到在很多情况下，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和回复阻塞线程并不值得。在如今多处理器环境下，完全可以让另一个没有获取到锁的线程在门外等待一会(自旋)，但不放弃cpu的执行时间。等待持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需要让线程执行一个忙循环(自旋)，这便是自旋锁由来的原因。\n\n自旋锁早在jdk1.4 中就引入了，只是当时默认时关闭的。在jdk 1.6后默认为开启状态。自旋锁本质上与阻塞并不相同，先不考虑其对多处理器的要求，如果锁占用的时间非常的短，那么自旋锁的性能会非常的好，相反，其会带来更多的性能开销(因为在线程自旋时，始终会占用cpu的时间片，如果锁占用的时间太长，那么自旋的线程会白白消耗掉cpu资源)。因此自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获取到锁，就应该使用传统的方式去挂起线程了，在jdk定义中，自旋锁默认的自旋次数为10次，用户可以使用参数-xx:preblockspin来更改。\n\n可是现在又出现了一个问题：如果线程锁在线程自旋刚结束就释放掉了锁，那么是不是有点得不偿失。所以这时候我们需要更加聪明的锁来实现更加灵活的自旋。来提高并发的性能。(这里则需要自适应自旋锁！)\n\n# 自适应自旋锁\n\n在jdk 1.6中引入了自适应自旋锁。这就意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋 时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么jvm会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。比如增加到100此循环。相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，jvm对程序的锁的状态预测会越来越准确，jvm也会越来越聪明。\n\n\n# 锁消除\n\n锁消除是指虚拟机即时编译器再运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。意思就是：jvm会判断再一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那jvm就把它们当作栈上数据对待，认为这些数据是线程独有的，不需要加同步。此时就会进行锁消除。\n\n当然在实际开发中，我们很清楚的知道哪些是线程独有的，不需要加同步锁，但是在java api中有很多方法都是加了同步的，那么此时jvm会判断这段代码是否需要加锁。如果数据并不会逃逸，则会进行锁消除。比如如下操作：在操作string类型数据时，由于string是一个不可变类，对字符串的连接操作总是通过生成的新的string对象来进行的。因此javac编译器会对string连接做自动优化。在jdk 1.5之前会使用stringbuffer对象的连续append()操作，在jdk 1.5及以后的版本中，会转化为stringbuidler对象的连续append()操作。\n\npublic static string test03(string s1, string s2, string s3) {\n    string s = s1 + s2 + s3;\n    return s;\n}\n\n\n上述代码使用javap 编译结果\n\n\n\n众所周知，stringbuilder不是安全同步的，但是在上述代码中，jvm判断该段代码并不会逃逸，则将该代码带默认为线程独有的资源，并不需要同步，所以执行了锁消除操作。(还有vector中的各种操作也可实现锁消除。在没有逃逸出数据安全防卫内)\n\n\n# 锁粗化\n\n原则上，我们都知道在加同步锁时，尽可能的将同步块的作用范围限制到尽量小的范围(只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小。在存在锁同步竞争中，也可以使得等待锁的线程尽早的拿到锁)。\n\n大部分上述情况是完美正确的，但是如果存在连串的一系列操作都对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体中的，那即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能操作。\n\n这里贴上根据上述javap 编译的情况编写的实例java类\n\npublic static string test04(string s1, string s2, string s3) {\n    stringbuffer sb = new stringbuffer();\n    sb.append(s1);\n    sb.append(s2);\n    sb.append(s3);\n    return sb.tostring();\n}\n\n\n在上述的连续append()操作中就属于这类情况。jvm会检测到这样一连串的操作都是对同一个对象加锁，那么jvm会将加锁同步的范围扩展(粗化)到整个一系列操作的 外部，使整个一连串的append()操作只需要加锁一次就可以了。\n\n\n# 轻量级锁\n\n在jdk 1.6之后引入的轻量级锁，需要注意的是轻量级锁并不是替代重量级锁的，而是对在大多数情况下同步块并不会有竞争出现提出的一种优化。它可以减少重量级锁对线程的阻塞带来的线程开销。从而提高并发性能。\n\n如果要理解轻量级锁，那么必须先要了解hotspot虚拟机中对象头的内存布局。上面介绍java对象头也详细介绍过。在对象头中(object header)存在两部分。第一部分用于存储对象自身的运行时数据，hashcode、gc age、锁标记位、是否为偏向锁。等。一般为32位或者64位(视操作系统位数定)。官方称之为mark word，它是实现轻量级锁和偏向锁的关键。 另外一部分存储的是指向方法区对象类型数据的指针(klass point)，如果对象是数组的话，还会有一个额外的部分用于存储数据的长度。\n\n# 轻量级锁加锁\n\n在线程执行同步块之前，jvm会先在当前线程的栈帧中创建一个名为锁记录(lock record)的空间，用于存储锁对象目前的mark word的拷贝(jvm会将对象头中的mark word拷贝到锁记录中，官方称为displaced mark ward)这个时候线程堆栈与对象头的状态如图：\n\n\n\n如上图所示：如果当前对象没有被锁定，那么锁标志位为01状态，jvm在执行当前线程时，首先会在当前线程栈帧中创建锁记录lock record的空间用于存储锁对象目前的mark word的拷贝。\n\n然后，虚拟机使用cas操作将标记字段mark word拷贝到锁记录中，并且将mark word更新为指向lock record的指针。如果更新成功了，那么这个线程就拥用了该对象的锁，并且对象mark word的锁标志位更新为(mark word中最后的2bit)00，即表示此对象处于轻量级锁定状态，如图：\n\n\n\n如果这个更新操作失败，jvm会检查当前的mark word中是否存在指向当前线程的栈帧的指针，如果有，说明该锁已经被获取，可以直接调用。如果没有，则说明该锁被其他线程抢占了，如果有两条以上的线程竞争同一个锁，那轻量级锁就不再有效，直接膨胀为重量级锁，没有获得锁的线程会被阻塞。此时，锁的标志位为10.mark word中存储的指向重量级锁的指针。\n\n轻量级解锁时，会使用原子的cas操作将displaced mark word替换回到对象头中，如果成功，则表示没有发生竞争关系。如果失败，表示当前锁存在竞争关系。锁就会膨胀成重量级锁。两个线程同时争夺锁，导致锁膨胀的流程图如下：\n\n\n\n\n# 偏向锁\n\n> 引入背景：在大多实际环境下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，那么在同一个线程反复获取所释放锁中，其中并还没有锁的竞争，那么这样看上去，多次的获取锁和释放锁带来了很多不必要的性能开销和上下文切换。\n\n为了解决这一问题，hotspot的作者在java se 1.6 中对synchronized进行了优化，引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程id，以后该线程在进入和退出同步块时不需要进行cas操作来加锁和解锁。只需要简单的测试一下对象头的mark word里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁。\n\n\n\n# 偏向锁的撤销\n\n偏向锁使用了一种等待竞争出现才会释放锁的机制。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。但是偏向锁的撤销需要等到全局安全点(就是当前线程没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，直接将对象头设置为无锁状态。如果线程活着，jvm会遍历栈帧中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁。\n\n\n\n\n# 锁的优缺点对比\n\n锁      优点                                            缺点                                      使用场景\n偏向锁    加锁和解锁不需要cas操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距   如果线程间存在锁竞争，会带来额外的锁撤销的消耗                 适用于只有一个线程访问同步块的场景\n轻量级锁   竞争的线程不会阻塞，提高了响应速度                             如线程始终得不到锁竞争的线程，使用自旋会消耗cpu性能             追求响应时间，同步块执行速度非常快\n重量级锁   线程竞争不适用自旋，不会消耗cpu                             线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗   追求吞吐量，同步块执行速度较长\n\n\n# synchronized与lock\n\n\n# synchronized的缺陷\n\n * 效率低：锁的释放情况少，只有代码执行完毕或者异常结束才会释放锁；试图获取锁的时候不能设定超时，不能中断一个正在使用锁的线程，相对而言，lock可以中断和设置超时\n\n * 不够灵活：加锁和释放的时机单一，每个锁仅有一个单一的条件(某个对象)，相对而言，读写锁更加灵活\n\n * 无法知道是否成功获得锁，相对而言，lock可以拿到状态，如果成功获取锁，....，如果获取失败，.....\n\n\n# lock解决相应问题\n\nlock类这里不做过多解释，主要看里面的4个方法:\n\n * lock(): 加锁\n * unlock(): 解锁\n * trylock(): 尝试获取锁，返回一个boolean值\n * trylock(long,timeutil): 尝试获取锁，可以设置超时\n\nsynchronized加锁只与一个条件(是否获取锁)相关联，不灵活，后来condition与lock的结合解决了这个问题。\n\n多线程竞争一个锁时，其余未得到锁的线程只能不停的尝试获得锁，而不能中断。高并发的情况下会导致性能下降。reentrantlock的lockinterruptibly()方法可以优先考虑响应中断。 一个线程等待时间过长，它可以中断自己，然后reentrantlock响应这个中断，不再让这个线程继续等待。有了这个机制，使用reentrantlock时就不会像synchronized那样产生死锁了。\n\n> reentrantlock为常用类，它是一个可重入的互斥锁 lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。详细分析请看: juc锁: reentrantlock详解\n\n\n# 再深入理解\n\nsynchronized是通过软件(jvm)实现的，简单易用，即使在jdk5之后有了lock，仍然被广泛的使用。\n\n * 使用synchronized有哪些要注意的？\n   \n   * 锁对象不能为空，因为锁的信息都保存在对象头里\n   * 作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错\n   * 避免死锁\n   * 在能选择的情况下，既不要用lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错\n\n * synchronized是公平锁吗？\n\nsynchronized实际上是非公平的，新来的线程有可能立即获得监视器，而在等待区中等候已久的线程可能再次等待，这样有利于提高性能，但是也可能会导致饥饿现象。\n\n\n# 参考文章\n\n+《深入理解java虚拟机》 +《java并发编程的艺术》\n\n * https://juejin.im/post/5ae6dc04f265da0ba351d3ff\n * https://www.cnblogs.com/javaminer/p/3889023.html\n * https://www.jianshu.com/p/dab7745c0954\n * https://www.cnblogs.com/wuchaodzxx/p/6867546.html\n * https://www.cnblogs.com/xyabk/p/10901291.html\n * https://www.jianshu.com/p/64240319ed60\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html',charsets:{cjk:!0}},{title:"JUC锁: ReentrantLock详解",frontmatter:{},regularPath:"/java/thread/java-thread-x-lock-ReentrantLock.html",relativePath:"java/thread/java-thread-x-lock-ReentrantLock.md",key:"v-4212a3b8",path:"/java/thread/java-thread-x-lock-ReentrantLock.html",headers:[{level:2,title:"JUC锁: ReentrantLock详解",slug:"juc锁-reentrantlock详解",normalizedTitle:"juc锁: reentrantlock详解",charIndex:2},{level:2,title:"带着BAT大厂的面试问题去理解",slug:"带着bat大厂的面试问题去理解",normalizedTitle:"带着bat大厂的面试问题去理解",charIndex:150},{level:2,title:"ReentrantLock源码分析",slug:"reentrantlock源码分析",normalizedTitle:"reentrantlock源码分析",charIndex:171},{level:3,title:"类的继承关系",slug:"类的继承关系",normalizedTitle:"类的继承关系",charIndex:196},{level:3,title:"类的内部类",slug:"类的内部类",normalizedTitle:"类的内部类",charIndex:210},{level:3,title:"类的属性",slug:"类的属性",normalizedTitle:"类的属性",charIndex:223},{level:3,title:"类的构造函数",slug:"类的构造函数",normalizedTitle:"类的构造函数",charIndex:235},{level:3,title:"核心函数分析",slug:"核心函数分析",normalizedTitle:"核心函数分析",charIndex:249},{level:2,title:"示例分析",slug:"示例分析",normalizedTitle:"示例分析",charIndex:261},{level:3,title:"公平锁",slug:"公平锁",normalizedTitle:"公平锁",charIndex:273},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:282}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"JUC锁: ReentrantLock详解 带着BAT大厂的面试问题去理解 ReentrantLock源码分析 类的继承关系 类的内部类 类的属性 类的构造函数 核心函数分析 示例分析 公平锁 参考文章",content:'# JUC锁: ReentrantLock详解\n\n> 可重入锁ReentrantLock的底层是通过AbstractQueuedSynchronizer实现，所以先要学习上一章节AbstractQueuedSynchronizer详解。\n\n * JUC锁: ReentrantLock详解\n   * 带着BAT大厂的面试问题去理解\n   * ReentrantLock源码分析\n     * 类的继承关系\n     * 类的内部类\n     * 类的属性\n     * 类的构造函数\n     * 核心函数分析\n   * 示例分析\n     * 公平锁\n   * 参考文章\n\n\n# 带着BAT大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 什么是可重入，什么是可重入锁? 它用来解决什么问题?\n * ReentrantLock的核心是AQS，那么它怎么来实现的，继承吗? 说说其类内部结构关系。\n * ReentrantLock是如何实现公平锁的?\n * ReentrantLock是如何实现非公平锁的?\n * ReentrantLock默认实现的是公平还是非公平锁?\n * 使用ReentrantLock实现公平和非公平锁的示例?\n * ReentrantLock和Synchronized的对比?\n\n\n# ReentrantLock源码分析\n\n\n# 类的继承关系\n\nReentrantLock实现了Lock接口，Lock接口中定义了lock与unlock相关操作，并且还存在newCondition方法，表示生成一个条件。\n\npublic class ReentrantLock implements Lock, java.io.Serializable\n\n\n\n# 类的内部类\n\nReentrantLock总共有三个内部类，并且三个内部类是紧密相关的，下面先看三个类的关系。\n\n\n\n说明: ReentrantLock类内部总共存在Sync、NonfairSync、FairSync三个类，NonfairSync与FairSync类继承自Sync类，Sync类继承自AbstractQueuedSynchronizer抽象类。下面逐个进行分析。\n\n * Sync类\n\nSync类的源码如下:\n\nabstract static class Sync extends AbstractQueuedSynchronizer {\n    // 序列号\n    private static final long serialVersionUID = -5179523762034025860L;\n    \n    // 获取锁\n    abstract void lock();\n    \n    // 非公平方式获取\n    final boolean nonfairTryAcquire(int acquires) {\n        // 当前线程\n        final Thread current = Thread.currentThread();\n        // 获取状态\n        int c = getState();\n        if (c == 0) { // 表示没有线程正在竞争该锁\n            if (compareAndSetState(0, acquires)) { // 比较并设置状态成功，状态0表示锁没有被占用\n                // 设置当前线程独占\n                setExclusiveOwnerThread(current); \n                return true; // 成功\n            }\n        }\n        else if (current == getExclusiveOwnerThread()) { // 当前线程拥有该锁\n            int nextc = c + acquires; // 增加重入次数\n            if (nextc < 0) // overflow\n                throw new Error("Maximum lock count exceeded");\n            // 设置状态\n            setState(nextc); \n            // 成功\n            return true; \n        }\n        // 失败\n        return false;\n    }\n    \n    // 试图在共享模式下获取对象状态，此方法应该查询是否允许它在共享模式下获取对象状态，如果允许，则获取它\n    protected final boolean tryRelease(int releases) {\n        int c = getState() - releases;\n        if (Thread.currentThread() != getExclusiveOwnerThread()) // 当前线程不为独占线程\n            throw new IllegalMonitorStateException(); // 抛出异常\n        // 释放标识\n        boolean free = false; \n        if (c == 0) {\n            free = true;\n            // 已经释放，清空独占\n            setExclusiveOwnerThread(null); \n        }\n        // 设置标识\n        setState(c); \n        return free; \n    }\n    \n    // 判断资源是否被当前线程占有\n    protected final boolean isHeldExclusively() {\n        // While we must in general read state before owner,\n        // we don\'t need to do so to check if current thread is owner\n        return getExclusiveOwnerThread() == Thread.currentThread();\n    }\n\n    // 新生一个条件\n    final ConditionObject newCondition() {\n        return new ConditionObject();\n    }\n\n    // Methods relayed from outer class\n    // 返回资源的占用线程\n    final Thread getOwner() {        \n        return getState() == 0 ? null : getExclusiveOwnerThread();\n    }\n    // 返回状态\n    final int getHoldCount() {            \n        return isHeldExclusively() ? getState() : 0;\n    }\n\n    // 资源是否被占用\n    final boolean isLocked() {        \n        return getState() != 0;\n    }\n\n    /**\n        * Reconstitutes the instance from a stream (that is, deserializes it).\n        */\n    // 自定义反序列化逻辑\n    private void readObject(java.io.ObjectInputStream s)\n        throws java.io.IOException, ClassNotFoundException {\n        s.defaultReadObject();\n        setState(0); // reset to unlocked state\n    }\n}　　\n\n\nSync类存在如下方法和作用如下。\n\n\n\n * NonfairSync类\n\nNonfairSync类继承了Sync类，表示采用非公平策略获取锁，其实现了Sync类中抽象的lock方法，源码如下:\n\n// 非公平锁\nstatic final class NonfairSync extends Sync {\n    // 版本号\n    private static final long serialVersionUID = 7316153563782823691L;\n\n    // 获得锁\n    final void lock() {\n        if (compareAndSetState(0, 1)) // 比较并设置状态成功，状态0表示锁没有被占用\n            // 把当前线程设置独占了锁\n            setExclusiveOwnerThread(Thread.currentThread());\n        else // 锁已经被占用，或者set失败\n            // 以独占模式获取对象，忽略中断\n            acquire(1); \n    }\n\n    protected final boolean tryAcquire(int acquires) {\n        return nonfairTryAcquire(acquires);\n    }\n}\n\n\n说明: 从lock方法的源码可知，每一次都尝试获取锁，而并不会按照公平等待的原则进行等待，让等待时间最久的线程获得锁。\n\n * FairSyn类\n\nFairSync类也继承了Sync类，表示采用公平策略获取锁，其实现了Sync类中的抽象lock方法，源码如下:\n\n// 公平锁\nstatic final class FairSync extends Sync {\n    // 版本序列化\n    private static final long serialVersionUID = -3000897897090466540L;\n\n    final void lock() {\n        // 以独占模式获取对象，忽略中断\n        acquire(1);\n    }\n\n    /**\n        * Fair version of tryAcquire.  Don\'t grant access unless\n        * recursive call or no waiters or is first.\n        */\n    // 尝试公平获取锁\n    protected final boolean tryAcquire(int acquires) {\n        // 获取当前线程\n        final Thread current = Thread.currentThread();\n        // 获取状态\n        int c = getState();\n        if (c == 0) { // 状态为0\n            if (!hasQueuedPredecessors() &&\n                compareAndSetState(0, acquires)) { // 不存在已经等待更久的线程并且比较并且设置状态成功\n                // 设置当前线程独占\n                setExclusiveOwnerThread(current);\n                return true;\n            }\n        }\n        else if (current == getExclusiveOwnerThread()) { // 状态不为0，即资源已经被线程占据\n            // 下一个状态\n            int nextc = c + acquires;\n            if (nextc < 0) // 超过了int的表示范围\n                throw new Error("Maximum lock count exceeded");\n            // 设置状态\n            setState(nextc);\n            return true;\n        }\n        return false;\n    }\n}\n\n\n说明: 跟踪lock方法的源码可知，当资源空闲时，它总是会先判断sync队列(AbstractQueuedSynchronizer中的数据结构)是否有等待时间更长的线程，如果存在，则将该线程加入到等待队列的尾部，实现了公平获取原则。其中，FairSync类的lock的方法调用如下，只给出了主要的方法。\n\n\n\n说明: 可以看出只要资源被其他线程占用，该线程就会添加到sync queue中的尾部，而不会先尝试获取资源。这也是和Nonfair最大的区别，Nonfair每一次都会尝试去获取资源，如果此时该资源恰好被释放，则会被当前线程获取，这就造成了不公平的现象，当获取不成功，再加入队列尾部。\n\n\n# 类的属性\n\nReentrantLock类的sync非常重要，对ReentrantLock类的操作大部分都直接转化为对Sync和AbstractQueuedSynchronizer类的操作。\n\npublic class ReentrantLock implements Lock, java.io.Serializable {\n    // 序列号\n    private static final long serialVersionUID = 7373984872572414699L;    \n    // 同步队列\n    private final Sync sync;\n}\n\n\n\n# 类的构造函数\n\n * ReentrantLock()型构造函数\n\n默认是采用的非公平策略获取锁\n\npublic ReentrantLock() {\n    // 默认非公平策略\n    sync = new NonfairSync();\n}\n\n\n * ReentrantLock(boolean)型构造函数\n\n可以传递参数确定采用公平策略或者是非公平策略，参数为true表示公平策略，否则，采用非公平策略:\n\npublic ReentrantLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n}\n\n\n\n# 核心函数分析\n\n通过分析ReentrantLock的源码，可知对其操作都转化为对Sync对象的操作，由于Sync继承了AQS，所以基本上都可以转化为对AQS的操作。如将ReentrantLock的lock函数转化为对Sync的lock函数的调用，而具体会根据采用的策略(如公平策略或者非公平策略)的不同而调用到Sync的不同子类。\n\n所以可知，在ReentrantLock的背后，是AQS对其服务提供了支持，由于之前我们分析AQS的核心源码，遂不再累赘。下面还是通过例子来更进一步分析源码。\n\n\n# 示例分析\n\n\n# 公平锁\n\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\nclass MyThread extends Thread {\n    private Lock lock;\n    public MyThread(String name, Lock lock) {\n        super(name);\n        this.lock = lock;\n    }\n    \n    public void run () {\n        lock.lock();\n        try {\n            System.out.println(Thread.currentThread() + " running");\n            try {\n                Thread.sleep(500);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\npublic class AbstractQueuedSynchronizerDemo {\n    public static void main(String[] args) throws InterruptedException {\n        Lock lock = new ReentrantLock(true);\n        \n        MyThread t1 = new MyThread("t1", lock);        \n        MyThread t2 = new MyThread("t2", lock);\n        MyThread t3 = new MyThread("t3", lock);\n        t1.start();\n        t2.start();    \n        t3.start();\n    }\n}\n\n\n运行结果(某一次):\n\nThread[t1,5,main] running\nThread[t2,5,main] running\nThread[t3,5,main] running\n\n\n说明: 该示例使用的是公平策略，由结果可知，可能会存在如下一种时序。\n\n\n\n说明: 首先，t1线程的lock操作 -> t2线程的lock操作 -> t3线程的lock操作 -> t1线程的unlock操作 -> t2线程的unlock操作 -> t3线程的unlock操作。根据这个时序图来进一步分析源码的工作流程。\n\n * t1线程执行lock.lock，下图给出了方法调用中的主要方法。\n\n\n\n说明: 由调用流程可知，t1线程成功获取了资源，可以继续执行。\n\n * t2线程执行lock.lock，下图给出了方法调用中的主要方法。\n\n\n\n说明: 由上图可知，最后的结果是t2线程会被禁止，因为调用了LockSupport.park。\n\n * t3线程执行lock.lock，下图给出了方法调用中的主要方法。\n\n\n\n说明: 由上图可知，最后的结果是t3线程会被禁止，因为调用了LockSupport.park。\n\n * t1线程调用了lock.unlock，下图给出了方法调用中的主要方法。\n\n\n\n说明: 如上图所示，最后，head的状态会变为0，t2线程会被unpark，即t2线程可以继续运行。此时t3线程还是被禁止。\n\n * t2获得cpu资源，继续运行，由于t2之前被park了，现在需要恢复之前的状态，下图给出了方法调用中的主要方法。\n\n\n\n说明: 在setHead函数中会将head设置为之前head的下一个结点，并且将pre域与thread域都设置为null，在acquireQueued返回之前，sync queue就只有两个结点了。\n\n * t2执行lock.unlock，下图给出了方法调用中的主要方法。\n\n\n\n说明: 由上图可知，最终unpark t3线程，让t3线程可以继续运行。\n\n * t3线程获取cpu资源，恢复之前的状态，继续运行。\n\n\n\n说明: 最终达到的状态是sync queue中只剩下了一个结点，并且该节点除了状态为0外，其余均为null。\n\n * t3执行lock.unlock，下图给出了方法调用中的主要方法。\n\n\n\n说明: 最后的状态和之前的状态是一样的，队列中有一个空节点，头节点为尾节点均指向它。\n\n使用公平策略和Condition的情况可以参考上一篇关于AQS的源码示例分析部分，不再累赘。\n\n\n# 参考文章\n\n * 文章主要参考自leesf的https://www.cnblogs.com/leesf456/p/5383609.html，在此基础上做了增改。\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-lock-ReentrantLock.html',normalizedContent:'# juc锁: reentrantlock详解\n\n> 可重入锁reentrantlock的底层是通过abstractqueuedsynchronizer实现，所以先要学习上一章节abstractqueuedsynchronizer详解。\n\n * juc锁: reentrantlock详解\n   * 带着bat大厂的面试问题去理解\n   * reentrantlock源码分析\n     * 类的继承关系\n     * 类的内部类\n     * 类的属性\n     * 类的构造函数\n     * 核心函数分析\n   * 示例分析\n     * 公平锁\n   * 参考文章\n\n\n# 带着bat大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 什么是可重入，什么是可重入锁? 它用来解决什么问题?\n * reentrantlock的核心是aqs，那么它怎么来实现的，继承吗? 说说其类内部结构关系。\n * reentrantlock是如何实现公平锁的?\n * reentrantlock是如何实现非公平锁的?\n * reentrantlock默认实现的是公平还是非公平锁?\n * 使用reentrantlock实现公平和非公平锁的示例?\n * reentrantlock和synchronized的对比?\n\n\n# reentrantlock源码分析\n\n\n# 类的继承关系\n\nreentrantlock实现了lock接口，lock接口中定义了lock与unlock相关操作，并且还存在newcondition方法，表示生成一个条件。\n\npublic class reentrantlock implements lock, java.io.serializable\n\n\n\n# 类的内部类\n\nreentrantlock总共有三个内部类，并且三个内部类是紧密相关的，下面先看三个类的关系。\n\n\n\n说明: reentrantlock类内部总共存在sync、nonfairsync、fairsync三个类，nonfairsync与fairsync类继承自sync类，sync类继承自abstractqueuedsynchronizer抽象类。下面逐个进行分析。\n\n * sync类\n\nsync类的源码如下:\n\nabstract static class sync extends abstractqueuedsynchronizer {\n    // 序列号\n    private static final long serialversionuid = -5179523762034025860l;\n    \n    // 获取锁\n    abstract void lock();\n    \n    // 非公平方式获取\n    final boolean nonfairtryacquire(int acquires) {\n        // 当前线程\n        final thread current = thread.currentthread();\n        // 获取状态\n        int c = getstate();\n        if (c == 0) { // 表示没有线程正在竞争该锁\n            if (compareandsetstate(0, acquires)) { // 比较并设置状态成功，状态0表示锁没有被占用\n                // 设置当前线程独占\n                setexclusiveownerthread(current); \n                return true; // 成功\n            }\n        }\n        else if (current == getexclusiveownerthread()) { // 当前线程拥有该锁\n            int nextc = c + acquires; // 增加重入次数\n            if (nextc < 0) // overflow\n                throw new error("maximum lock count exceeded");\n            // 设置状态\n            setstate(nextc); \n            // 成功\n            return true; \n        }\n        // 失败\n        return false;\n    }\n    \n    // 试图在共享模式下获取对象状态，此方法应该查询是否允许它在共享模式下获取对象状态，如果允许，则获取它\n    protected final boolean tryrelease(int releases) {\n        int c = getstate() - releases;\n        if (thread.currentthread() != getexclusiveownerthread()) // 当前线程不为独占线程\n            throw new illegalmonitorstateexception(); // 抛出异常\n        // 释放标识\n        boolean free = false; \n        if (c == 0) {\n            free = true;\n            // 已经释放，清空独占\n            setexclusiveownerthread(null); \n        }\n        // 设置标识\n        setstate(c); \n        return free; \n    }\n    \n    // 判断资源是否被当前线程占有\n    protected final boolean isheldexclusively() {\n        // while we must in general read state before owner,\n        // we don\'t need to do so to check if current thread is owner\n        return getexclusiveownerthread() == thread.currentthread();\n    }\n\n    // 新生一个条件\n    final conditionobject newcondition() {\n        return new conditionobject();\n    }\n\n    // methods relayed from outer class\n    // 返回资源的占用线程\n    final thread getowner() {        \n        return getstate() == 0 ? null : getexclusiveownerthread();\n    }\n    // 返回状态\n    final int getholdcount() {            \n        return isheldexclusively() ? getstate() : 0;\n    }\n\n    // 资源是否被占用\n    final boolean islocked() {        \n        return getstate() != 0;\n    }\n\n    /**\n        * reconstitutes the instance from a stream (that is, deserializes it).\n        */\n    // 自定义反序列化逻辑\n    private void readobject(java.io.objectinputstream s)\n        throws java.io.ioexception, classnotfoundexception {\n        s.defaultreadobject();\n        setstate(0); // reset to unlocked state\n    }\n}　　\n\n\nsync类存在如下方法和作用如下。\n\n\n\n * nonfairsync类\n\nnonfairsync类继承了sync类，表示采用非公平策略获取锁，其实现了sync类中抽象的lock方法，源码如下:\n\n// 非公平锁\nstatic final class nonfairsync extends sync {\n    // 版本号\n    private static final long serialversionuid = 7316153563782823691l;\n\n    // 获得锁\n    final void lock() {\n        if (compareandsetstate(0, 1)) // 比较并设置状态成功，状态0表示锁没有被占用\n            // 把当前线程设置独占了锁\n            setexclusiveownerthread(thread.currentthread());\n        else // 锁已经被占用，或者set失败\n            // 以独占模式获取对象，忽略中断\n            acquire(1); \n    }\n\n    protected final boolean tryacquire(int acquires) {\n        return nonfairtryacquire(acquires);\n    }\n}\n\n\n说明: 从lock方法的源码可知，每一次都尝试获取锁，而并不会按照公平等待的原则进行等待，让等待时间最久的线程获得锁。\n\n * fairsyn类\n\nfairsync类也继承了sync类，表示采用公平策略获取锁，其实现了sync类中的抽象lock方法，源码如下:\n\n// 公平锁\nstatic final class fairsync extends sync {\n    // 版本序列化\n    private static final long serialversionuid = -3000897897090466540l;\n\n    final void lock() {\n        // 以独占模式获取对象，忽略中断\n        acquire(1);\n    }\n\n    /**\n        * fair version of tryacquire.  don\'t grant access unless\n        * recursive call or no waiters or is first.\n        */\n    // 尝试公平获取锁\n    protected final boolean tryacquire(int acquires) {\n        // 获取当前线程\n        final thread current = thread.currentthread();\n        // 获取状态\n        int c = getstate();\n        if (c == 0) { // 状态为0\n            if (!hasqueuedpredecessors() &&\n                compareandsetstate(0, acquires)) { // 不存在已经等待更久的线程并且比较并且设置状态成功\n                // 设置当前线程独占\n                setexclusiveownerthread(current);\n                return true;\n            }\n        }\n        else if (current == getexclusiveownerthread()) { // 状态不为0，即资源已经被线程占据\n            // 下一个状态\n            int nextc = c + acquires;\n            if (nextc < 0) // 超过了int的表示范围\n                throw new error("maximum lock count exceeded");\n            // 设置状态\n            setstate(nextc);\n            return true;\n        }\n        return false;\n    }\n}\n\n\n说明: 跟踪lock方法的源码可知，当资源空闲时，它总是会先判断sync队列(abstractqueuedsynchronizer中的数据结构)是否有等待时间更长的线程，如果存在，则将该线程加入到等待队列的尾部，实现了公平获取原则。其中，fairsync类的lock的方法调用如下，只给出了主要的方法。\n\n\n\n说明: 可以看出只要资源被其他线程占用，该线程就会添加到sync queue中的尾部，而不会先尝试获取资源。这也是和nonfair最大的区别，nonfair每一次都会尝试去获取资源，如果此时该资源恰好被释放，则会被当前线程获取，这就造成了不公平的现象，当获取不成功，再加入队列尾部。\n\n\n# 类的属性\n\nreentrantlock类的sync非常重要，对reentrantlock类的操作大部分都直接转化为对sync和abstractqueuedsynchronizer类的操作。\n\npublic class reentrantlock implements lock, java.io.serializable {\n    // 序列号\n    private static final long serialversionuid = 7373984872572414699l;    \n    // 同步队列\n    private final sync sync;\n}\n\n\n\n# 类的构造函数\n\n * reentrantlock()型构造函数\n\n默认是采用的非公平策略获取锁\n\npublic reentrantlock() {\n    // 默认非公平策略\n    sync = new nonfairsync();\n}\n\n\n * reentrantlock(boolean)型构造函数\n\n可以传递参数确定采用公平策略或者是非公平策略，参数为true表示公平策略，否则，采用非公平策略:\n\npublic reentrantlock(boolean fair) {\n    sync = fair ? new fairsync() : new nonfairsync();\n}\n\n\n\n# 核心函数分析\n\n通过分析reentrantlock的源码，可知对其操作都转化为对sync对象的操作，由于sync继承了aqs，所以基本上都可以转化为对aqs的操作。如将reentrantlock的lock函数转化为对sync的lock函数的调用，而具体会根据采用的策略(如公平策略或者非公平策略)的不同而调用到sync的不同子类。\n\n所以可知，在reentrantlock的背后，是aqs对其服务提供了支持，由于之前我们分析aqs的核心源码，遂不再累赘。下面还是通过例子来更进一步分析源码。\n\n\n# 示例分析\n\n\n# 公平锁\n\nimport java.util.concurrent.locks.lock;\nimport java.util.concurrent.locks.reentrantlock;\n\nclass mythread extends thread {\n    private lock lock;\n    public mythread(string name, lock lock) {\n        super(name);\n        this.lock = lock;\n    }\n    \n    public void run () {\n        lock.lock();\n        try {\n            system.out.println(thread.currentthread() + " running");\n            try {\n                thread.sleep(500);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\npublic class abstractqueuedsynchronizerdemo {\n    public static void main(string[] args) throws interruptedexception {\n        lock lock = new reentrantlock(true);\n        \n        mythread t1 = new mythread("t1", lock);        \n        mythread t2 = new mythread("t2", lock);\n        mythread t3 = new mythread("t3", lock);\n        t1.start();\n        t2.start();    \n        t3.start();\n    }\n}\n\n\n运行结果(某一次):\n\nthread[t1,5,main] running\nthread[t2,5,main] running\nthread[t3,5,main] running\n\n\n说明: 该示例使用的是公平策略，由结果可知，可能会存在如下一种时序。\n\n\n\n说明: 首先，t1线程的lock操作 -> t2线程的lock操作 -> t3线程的lock操作 -> t1线程的unlock操作 -> t2线程的unlock操作 -> t3线程的unlock操作。根据这个时序图来进一步分析源码的工作流程。\n\n * t1线程执行lock.lock，下图给出了方法调用中的主要方法。\n\n\n\n说明: 由调用流程可知，t1线程成功获取了资源，可以继续执行。\n\n * t2线程执行lock.lock，下图给出了方法调用中的主要方法。\n\n\n\n说明: 由上图可知，最后的结果是t2线程会被禁止，因为调用了locksupport.park。\n\n * t3线程执行lock.lock，下图给出了方法调用中的主要方法。\n\n\n\n说明: 由上图可知，最后的结果是t3线程会被禁止，因为调用了locksupport.park。\n\n * t1线程调用了lock.unlock，下图给出了方法调用中的主要方法。\n\n\n\n说明: 如上图所示，最后，head的状态会变为0，t2线程会被unpark，即t2线程可以继续运行。此时t3线程还是被禁止。\n\n * t2获得cpu资源，继续运行，由于t2之前被park了，现在需要恢复之前的状态，下图给出了方法调用中的主要方法。\n\n\n\n说明: 在sethead函数中会将head设置为之前head的下一个结点，并且将pre域与thread域都设置为null，在acquirequeued返回之前，sync queue就只有两个结点了。\n\n * t2执行lock.unlock，下图给出了方法调用中的主要方法。\n\n\n\n说明: 由上图可知，最终unpark t3线程，让t3线程可以继续运行。\n\n * t3线程获取cpu资源，恢复之前的状态，继续运行。\n\n\n\n说明: 最终达到的状态是sync queue中只剩下了一个结点，并且该节点除了状态为0外，其余均为null。\n\n * t3执行lock.unlock，下图给出了方法调用中的主要方法。\n\n\n\n说明: 最后的状态和之前的状态是一样的，队列中有一个空节点，头节点为尾节点均指向它。\n\n使用公平策略和condition的情况可以参考上一篇关于aqs的源码示例分析部分，不再累赘。\n\n\n# 参考文章\n\n * 文章主要参考自leesf的https://www.cnblogs.com/leesf456/p/5383609.html，在此基础上做了增改。\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-lock-reentrantlock.html',charsets:{cjk:!0}},{title:"JUC锁: 锁核心类AQS详解",frontmatter:{},regularPath:"/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html",relativePath:"java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.md",key:"v-2bc4f624",path:"/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html",headers:[{level:2,title:"JUC锁: 锁核心类AQS详解",slug:"juc锁-锁核心类aqs详解",normalizedTitle:"juc锁: 锁核心类aqs详解",charIndex:2},{level:2,title:"带着BAT大厂的面试问题去理解",slug:"带着bat大厂的面试问题去理解",normalizedTitle:"带着bat大厂的面试问题去理解",charIndex:125},{level:2,title:"AbstractQueuedSynchronizer简介",slug:"abstractqueuedsynchronizer简介",normalizedTitle:"abstractqueuedsynchronizer简介",charIndex:146},{level:3,title:"AQS 核心思想",slug:"aqs-核心思想",normalizedTitle:"aqs 核心思想",charIndex:182},{level:3,title:"AQS 对资源的共享方式",slug:"aqs-对资源的共享方式",normalizedTitle:"aqs 对资源的共享方式",charIndex:198},{level:3,title:"AQS底层使用了模板方法模式",slug:"aqs底层使用了模板方法模式",normalizedTitle:"aqs底层使用了模板方法模式",charIndex:218},{level:2,title:"AbstractQueuedSynchronizer数据结构",slug:"abstractqueuedsynchronizer数据结构",normalizedTitle:"abstractqueuedsynchronizer数据结构",charIndex:238},{level:2,title:"AbstractQueuedSynchronizer源码分析",slug:"abstractqueuedsynchronizer源码分析",normalizedTitle:"abstractqueuedsynchronizer源码分析",charIndex:274},{level:3,title:"类的继承关系",slug:"类的继承关系",normalizedTitle:"类的继承关系",charIndex:312},{level:3,title:"类的内部类 - Node类",slug:"类的内部类-node类",normalizedTitle:"类的内部类 - node类",charIndex:326},{level:3,title:"类的内部类 - ConditionObject类",slug:"类的内部类-conditionobject类",normalizedTitle:"类的内部类 - conditionobject类",charIndex:347},{level:3,title:"类的属性",slug:"类的属性",normalizedTitle:"类的属性",charIndex:379},{level:3,title:"类的构造方法",slug:"类的构造方法",normalizedTitle:"类的构造方法",charIndex:391},{level:3,title:"类的核心方法 - acquire方法",slug:"类的核心方法-acquire方法",normalizedTitle:"类的核心方法 - acquire方法",charIndex:405},{level:3,title:"类的核心方法 - release方法",slug:"类的核心方法-release方法",normalizedTitle:"类的核心方法 - release方法",charIndex:431},{level:2,title:"AbstractQueuedSynchronizer示例详解一",slug:"abstractqueuedsynchronizer示例详解一",normalizedTitle:"abstractqueuedsynchronizer示例详解一",charIndex:455},{level:2,title:"AbstractQueuedSynchronizer示例详解二",slug:"abstractqueuedsynchronizer示例详解二",normalizedTitle:"abstractqueuedsynchronizer示例详解二",charIndex:492},{level:2,title:"AbstractQueuedSynchronizer总结",slug:"abstractqueuedsynchronizer总结",normalizedTitle:"abstractqueuedsynchronizer总结",charIndex:529},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:563}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"JUC锁: 锁核心类AQS详解 带着BAT大厂的面试问题去理解 AbstractQueuedSynchronizer简介 AQS 核心思想 AQS 对资源的共享方式 AQS底层使用了模板方法模式 AbstractQueuedSynchronizer数据结构 AbstractQueuedSynchronizer源码分析 类的继承关系 类的内部类 - Node类 类的内部类 - ConditionObject类 类的属性 类的构造方法 类的核心方法 - acquire方法 类的核心方法 - release方法 AbstractQueuedSynchronizer示例详解一 AbstractQueuedSynchronizer示例详解二 AbstractQueuedSynchronizer总结 参考文章",content:'# JUC锁: 锁核心类AQS详解\n\n> AbstractQueuedSynchronizer抽象类是核心，需要重点掌握。它提供了一个基于FIFO队列，可以用于构建锁或者其他相关同步装置的基础框架。\n\n * JUC锁: 锁核心类AQS详解\n   * 带着BAT大厂的面试问题去理解\n   * AbstractQueuedSynchronizer简介\n     * AQS 核心思想\n     * AQS 对资源的共享方式\n     * AQS底层使用了模板方法模式\n   * AbstractQueuedSynchronizer数据结构\n   * AbstractQueuedSynchronizer源码分析\n     * 类的继承关系\n     * 类的内部类 - Node类\n     * 类的内部类 - ConditionObject类\n     * 类的属性\n     * 类的构造方法\n     * 类的核心方法 - acquire方法\n     * 类的核心方法 - release方法\n   * AbstractQueuedSynchronizer示例详解一\n   * AbstractQueuedSynchronizer示例详解二\n   * AbstractQueuedSynchronizer总结\n   * 参考文章\n\n\n# 带着BAT大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 什么是AQS? 为什么它是核心?\n * AQS的核心思想是什么? 它是怎么实现的? 底层数据结构等\n * AQS有哪些核心的方法?\n * AQS定义什么样的资源获取方式? AQS定义了两种资源获取方式：独占(只有一个线程能访问执行，又根据是否按队列的顺序分为公平锁和非公平锁，如ReentrantLock) 和共享(多个线程可同时访问执行，如Semaphore、CountDownLatch、 CyclicBarrier )。ReentrantReadWriteLock可以看成是组合式，允许多个线程同时对某一资源进行读。\n * AQS底层使用了什么样的设计模式? 模板\n * AQS的应用示例?\n\n\n# AbstractQueuedSynchronizer简介\n\nAQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。\n\n\n# AQS 核心思想\n\nAQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。\n\n> CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点(Node)来实现锁的分配。\n\nAQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。\n\nprivate volatile int state;//共享变量，使用volatile修饰保证线程可见性\n\n\n状态信息通过procted类型的getState，setState，compareAndSetState进行操作\n\n//返回同步状态的当前值\nprotected final int getState() {  \n        return state;\n}\n // 设置同步状态的值\nprotected final void setState(int newState) { \n        state = newState;\n}\n//原子地(CAS操作)将同步状态值设置为给定值update如果当前同步状态的值等于expect(期望值)\nprotected final boolean compareAndSetState(int expect, int update) {\n        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\n}\n\n\n\n# AQS 对资源的共享方式\n\nAQS定义两种资源共享方式\n\n * Exclusive(独占)：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：\n   * 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁\n   * 非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的\n * Share(共享)：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。\n\nReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。\n\n不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护(如获取资源失败入队/唤醒出队等)，AQS已经在上层已经帮我们实现好了。\n\n\n# AQS底层使用了模板方法模式\n\n> 同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样(模板方法模式很经典的一个应用)：\n\n使用者继承AbstractQueuedSynchronizer并重写指定的方法。(这些重写方法很简单，无非是对于共享资源state的获取和释放) 将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。\n\n这和我们以往通过实现接口的方式有很大区别，模板方法模式请参看：设计模式行为型 - 模板方法(Template Method)详解\n\nAQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：\n\nisHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。\ntryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。\ntryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。\ntryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\ntryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。\n\n\n默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。\n\n以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0(即释放锁)为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的(state会累加)，这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。\n\n\n# AbstractQueuedSynchronizer数据结构\n\nAbstractQueuedSynchronizer类底层的数据结构是使用CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点(Node)来实现锁的分配。其中Sync queue，即同步队列，是双向链表，包括head结点和tail结点，head结点主要用作后续的调度。而Condition queue不是必须的，其是一个单向链表，只有当使用Condition时，才会存在此单向链表。并且可能会有多个Condition queue。\n\n\n\n\n# AbstractQueuedSynchronizer源码分析\n\n\n# 类的继承关系\n\nAbstractQueuedSynchronizer继承自AbstractOwnableSynchronizer抽象类，并且实现了Serializable接口，可以进行序列化。\n\npublic abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable\n\n\n其中AbstractOwnableSynchronizer抽象类的源码如下:\n\npublic abstract class AbstractOwnableSynchronizer implements java.io.Serializable {\n    \n    // 版本序列号\n    private static final long serialVersionUID = 3737899427754241961L;\n    // 构造方法\n    protected AbstractOwnableSynchronizer() { }\n    // 独占模式下的线程\n    private transient Thread exclusiveOwnerThread;\n    \n    // 设置独占线程 \n    protected final void setExclusiveOwnerThread(Thread thread) {\n        exclusiveOwnerThread = thread;\n    }\n    \n    // 获取独占线程 \n    protected final Thread getExclusiveOwnerThread() {\n        return exclusiveOwnerThread;\n    }\n}\n\n\nAbstractOwnableSynchronizer抽象类中，可以设置独占资源线程和获取独占资源线程。分别为setExclusiveOwnerThread与getExclusiveOwnerThread方法，这两个方法会被子类调用。\n\n> AbstractQueuedSynchronizer类有两个内部类，分别为Node类与ConditionObject类。下面分别做介绍。\n\n\n# 类的内部类 - Node类\n\nstatic final class Node {\n    // 模式，分为共享与独占\n    // 共享模式\n    static final Node SHARED = new Node();\n    // 独占模式\n    static final Node EXCLUSIVE = null;        \n    // 结点状态\n    // CANCELLED，值为1，表示当前的线程被取消\n    // SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark\n    // CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中\n    // PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行\n    // 值为0，表示当前节点在sync队列中，等待着获取锁\n    static final int CANCELLED =  1;\n    static final int SIGNAL    = -1;\n    static final int CONDITION = -2;\n    static final int PROPAGATE = -3;        \n\n    // 结点状态\n    volatile int waitStatus;        \n    // 前驱结点\n    volatile Node prev;    \n    // 后继结点\n    volatile Node next;        \n    // 结点所对应的线程\n    volatile Thread thread;        \n    // 下一个等待者\n    Node nextWaiter;\n    \n    // 结点是否在共享模式下等待\n    final boolean isShared() {\n        return nextWaiter == SHARED;\n    }\n    \n    // 获取前驱结点，若前驱结点为空，抛出异常\n    final Node predecessor() throws NullPointerException {\n        // 保存前驱结点\n        Node p = prev; \n        if (p == null) // 前驱结点为空，抛出异常\n            throw new NullPointerException();\n        else // 前驱结点不为空，返回\n            return p;\n    }\n    \n    // 无参构造方法\n    Node() {    // Used to establish initial head or SHARED marker\n    }\n    \n    // 构造方法\n        Node(Thread thread, Node mode) {    // Used by addWaiter\n        this.nextWaiter = mode;\n        this.thread = thread;\n    }\n    \n    // 构造方法\n    Node(Thread thread, int waitStatus) { // Used by Condition\n        this.waitStatus = waitStatus;\n        this.thread = thread;\n    }\n}\n\n\n每个线程被阻塞的线程都会被封装成一个Node结点，放入队列。每个节点包含了一个Thread类型的引用，并且每个节点都存在一个状态，具体状态如下。\n\n * CANCELLED，值为1，表示当前的线程被取消。\n\n * SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，需要进行unpark操作。\n\n * CONDITION，值为-2，表示当前节点在等待condition，也就是在condition queue中。\n\n * PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行。\n\n * 值为0，表示当前节点在sync queue中，等待着获取锁。\n\n\n# 类的内部类 - ConditionObject类\n\n这个类有点长，耐心看下:\n\n// 内部类\npublic class ConditionObject implements Condition, java.io.Serializable {\n    // 版本号\n    private static final long serialVersionUID = 1173984872572414699L;\n    /** First node of condition queue. */\n    // condition队列的头节点\n    private transient Node firstWaiter;\n    /** Last node of condition queue. */\n    // condition队列的尾结点\n    private transient Node lastWaiter;\n\n    /**\n        * Creates a new {@code ConditionObject} instance.\n        */\n    // 构造方法\n    public ConditionObject() { }\n\n    // Internal methods\n\n    /**\n        * Adds a new waiter to wait queue.\n        * @return its new wait node\n        */\n    // 添加新的waiter到wait队列\n    private Node addConditionWaiter() {\n        // 保存尾结点\n        Node t = lastWaiter;\n        // If lastWaiter is cancelled, clean out.\n        if (t != null && t.waitStatus != Node.CONDITION) { // 尾结点不为空，并且尾结点的状态不为CONDITION\n            // 清除状态为CONDITION的结点\n            unlinkCancelledWaiters(); \n            // 将最后一个结点重新赋值给t\n            t = lastWaiter;\n        }\n        // 新建一个结点\n        Node node = new Node(Thread.currentThread(), Node.CONDITION);\n        if (t == null) // 尾结点为空\n            // 设置condition队列的头节点\n            firstWaiter = node;\n        else // 尾结点不为空\n            // 设置为节点的nextWaiter域为node结点\n            t.nextWaiter = node;\n        // 更新condition队列的尾结点\n        lastWaiter = node;\n        return node;\n    }\n\n    /**\n        * Removes and transfers nodes until hit non-cancelled one or\n        * null. Split out from signal in part to encourage compilers\n        * to inline the case of no waiters.\n        * @param first (non-null) the first node on condition queue\n        */\n    private void doSignal(Node first) {\n        // 循环\n        do {\n            if ( (firstWaiter = first.nextWaiter) == null) // 该节点的nextWaiter为空\n                // 设置尾结点为空\n                lastWaiter = null;\n            // 设置first结点的nextWaiter域\n            first.nextWaiter = null;\n        } while (!transferForSignal(first) &&\n                    (first = firstWaiter) != null); // 将结点从condition队列转移到sync队列失败并且condition队列中的头节点不为空，一直循环\n    }\n\n    /**\n        * Removes and transfers all nodes.\n        * @param first (non-null) the first node on condition queue\n        */\n    private void doSignalAll(Node first) {\n        // condition队列的头节点尾结点都设置为空\n        lastWaiter = firstWaiter = null;\n        // 循环\n        do {\n            // 获取first结点的nextWaiter域结点\n            Node next = first.nextWaiter;\n            // 设置first结点的nextWaiter域为空\n            first.nextWaiter = null;\n            // 将first结点从condition队列转移到sync队列\n            transferForSignal(first);\n            // 重新设置first\n            first = next;\n        } while (first != null);\n    }\n\n    /**\n        * Unlinks cancelled waiter nodes from condition queue.\n        * Called only while holding lock. This is called when\n        * cancellation occurred during condition wait, and upon\n        * insertion of a new waiter when lastWaiter is seen to have\n        * been cancelled. This method is needed to avoid garbage\n        * retention in the absence of signals. So even though it may\n        * require a full traversal, it comes into play only when\n        * timeouts or cancellations occur in the absence of\n        * signals. It traverses all nodes rather than stopping at a\n        * particular target to unlink all pointers to garbage nodes\n        * without requiring many re-traversals during cancellation\n        * storms.\n        */\n    // 从condition队列中清除状态为CANCEL的结点\n    private void unlinkCancelledWaiters() {\n        // 保存condition队列头节点\n        Node t = firstWaiter;\n        Node trail = null;\n        while (t != null) { // t不为空\n            // 下一个结点\n            Node next = t.nextWaiter;\n            if (t.waitStatus != Node.CONDITION) { // t结点的状态不为CONDTION状态\n                // 设置t节点的nextWaiter域为空\n                t.nextWaiter = null;\n                if (trail == null) // trail为空\n                    // 重新设置condition队列的头节点\n                    firstWaiter = next;\n                else // trail不为空\n                    // 设置trail结点的nextWaiter域为next结点\n                    trail.nextWaiter = next;\n                if (next == null) // next结点为空\n                    // 设置condition队列的尾结点\n                    lastWaiter = trail;\n            }\n            else // t结点的状态为CONDTION状态\n                // 设置trail结点\n                trail = t;\n            // 设置t结点\n            t = next;\n        }\n    }\n\n    // public methods\n\n    /**\n        * Moves the longest-waiting thread, if one exists, from the\n        * wait queue for this condition to the wait queue for the\n        * owning lock.\n        *\n        * @throws IllegalMonitorStateException if {@link #isHeldExclusively}\n        *         returns {@code false}\n        */\n    // 唤醒一个等待线程。如果所有的线程都在等待此条件，则选择其中的一个唤醒。在从 await 返回之前，该线程必须重新获取锁。\n    public final void signal() {\n        if (!isHeldExclusively()) // 不被当前线程独占，抛出异常\n            throw new IllegalMonitorStateException();\n        // 保存condition队列头节点\n        Node first = firstWaiter;\n        if (first != null) // 头节点不为空\n            // 唤醒一个等待线程\n            doSignal(first);\n    }\n\n    /**\n        * Moves all threads from the wait queue for this condition to\n        * the wait queue for the owning lock.\n        *\n        * @throws IllegalMonitorStateException if {@link #isHeldExclusively}\n        *         returns {@code false}\n        */\n    // 唤醒所有等待线程。如果所有的线程都在等待此条件，则唤醒所有线程。在从 await 返回之前，每个线程都必须重新获取锁。\n    public final void signalAll() {\n        if (!isHeldExclusively()) // 不被当前线程独占，抛出异常\n            throw new IllegalMonitorStateException();\n        // 保存condition队列头节点\n        Node first = firstWaiter;\n        if (first != null) // 头节点不为空\n            // 唤醒所有等待线程\n            doSignalAll(first);\n    }\n\n    /**\n        * Implements uninterruptible condition wait.\n        * <ol>\n        * <li> Save lock state returned by {@link #getState}.\n        * <li> Invoke {@link #release} with saved state as argument,\n        *      throwing IllegalMonitorStateException if it fails.\n        * <li> Block until signalled.\n        * <li> Reacquire by invoking specialized version of\n        *      {@link #acquire} with saved state as argument.\n        * </ol>\n        */\n    // 等待，当前线程在接到信号之前一直处于等待状态，不响应中断\n    public final void awaitUninterruptibly() {\n        // 添加一个结点到等待队列\n        Node node = addConditionWaiter();\n        // 获取释放的状态\n        int savedState = fullyRelease(node);\n        boolean interrupted = false;\n        while (!isOnSyncQueue(node)) { // \n            // 阻塞当前线程\n            LockSupport.park(this);\n            if (Thread.interrupted()) // 当前线程被中断\n                // 设置interrupted状态\n                interrupted = true; \n        }\n        if (acquireQueued(node, savedState) || interrupted) // \n            selfInterrupt();\n    }\n\n    /*\n        * For interruptible waits, we need to track whether to throw\n        * InterruptedException, if interrupted while blocked on\n        * condition, versus reinterrupt current thread, if\n        * interrupted while blocked waiting to re-acquire.\n        */\n\n    /** Mode meaning to reinterrupt on exit from wait */\n    private static final int REINTERRUPT =  1;\n    /** Mode meaning to throw InterruptedException on exit from wait */\n    private static final int THROW_IE    = -1;\n\n    /**\n        * Checks for interrupt, returning THROW_IE if interrupted\n        * before signalled, REINTERRUPT if after signalled, or\n        * 0 if not interrupted.\n        */\n    private int checkInterruptWhileWaiting(Node node) {\n        return Thread.interrupted() ?\n            (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :\n            0; \n    }\n\n    /**\n        * Throws InterruptedException, reinterrupts current thread, or\n        * does nothing, depending on mode.\n        */\n    private void reportInterruptAfterWait(int interruptMode)\n        throws InterruptedException {\n        if (interruptMode == THROW_IE)\n            throw new InterruptedException();\n        else if (interruptMode == REINTERRUPT)\n            selfInterrupt();\n    }\n\n    /**\n        * Implements interruptible condition wait.\n        * <ol>\n        * <li> If current thread is interrupted, throw InterruptedException.\n        * <li> Save lock state returned by {@link #getState}.\n        * <li> Invoke {@link #release} with saved state as argument,\n        *      throwing IllegalMonitorStateException if it fails.\n        * <li> Block until signalled or interrupted.\n        * <li> Reacquire by invoking specialized version of\n        *      {@link #acquire} with saved state as argument.\n        * <li> If interrupted while blocked in step 4, throw InterruptedException.\n        * </ol>\n        */\n    // // 等待，当前线程在接到信号或被中断之前一直处于等待状态\n    public final void await() throws InterruptedException {\n        if (Thread.interrupted()) // 当前线程被中断，抛出异常\n            throw new InterruptedException();\n        // 在wait队列上添加一个结点\n        Node node = addConditionWaiter();\n        // \n        int savedState = fullyRelease(node);\n        int interruptMode = 0;\n        while (!isOnSyncQueue(node)) {\n            // 阻塞当前线程\n            LockSupport.park(this);\n            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) // 检查结点等待时的中断类型\n                break;\n        }\n        if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n            interruptMode = REINTERRUPT;\n        if (node.nextWaiter != null) // clean up if cancelled\n            unlinkCancelledWaiters();\n        if (interruptMode != 0)\n            reportInterruptAfterWait(interruptMode);\n    }\n\n    /**\n        * Implements timed condition wait.\n        * <ol>\n        * <li> If current thread is interrupted, throw InterruptedException.\n        * <li> Save lock state returned by {@link #getState}.\n        * <li> Invoke {@link #release} with saved state as argument,\n        *      throwing IllegalMonitorStateException if it fails.\n        * <li> Block until signalled, interrupted, or timed out.\n        * <li> Reacquire by invoking specialized version of\n        *      {@link #acquire} with saved state as argument.\n        * <li> If interrupted while blocked in step 4, throw InterruptedException.\n        * </ol>\n        */\n    // 等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态 \n    public final long awaitNanos(long nanosTimeout)\n            throws InterruptedException {\n        if (Thread.interrupted())\n            throw new InterruptedException();\n        Node node = addConditionWaiter();\n        int savedState = fullyRelease(node);\n        final long deadline = System.nanoTime() + nanosTimeout;\n        int interruptMode = 0;\n        while (!isOnSyncQueue(node)) {\n            if (nanosTimeout <= 0L) {\n                transferAfterCancelledWait(node);\n                break;\n            }\n            if (nanosTimeout >= spinForTimeoutThreshold)\n                LockSupport.parkNanos(this, nanosTimeout);\n            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n                break;\n            nanosTimeout = deadline - System.nanoTime();\n        }\n        if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n            interruptMode = REINTERRUPT;\n        if (node.nextWaiter != null)\n            unlinkCancelledWaiters();\n        if (interruptMode != 0)\n            reportInterruptAfterWait(interruptMode);\n        return deadline - System.nanoTime();\n    }\n\n    /**\n        * Implements absolute timed condition wait.\n        * <ol>\n        * <li> If current thread is interrupted, throw InterruptedException.\n        * <li> Save lock state returned by {@link #getState}.\n        * <li> Invoke {@link #release} with saved state as argument,\n        *      throwing IllegalMonitorStateException if it fails.\n        * <li> Block until signalled, interrupted, or timed out.\n        * <li> Reacquire by invoking specialized version of\n        *      {@link #acquire} with saved state as argument.\n        * <li> If interrupted while blocked in step 4, throw InterruptedException.\n        * <li> If timed out while blocked in step 4, return false, else true.\n        * </ol>\n        */\n    // 等待，当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态\n    public final boolean awaitUntil(Date deadline)\n            throws InterruptedException {\n        long abstime = deadline.getTime();\n        if (Thread.interrupted())\n            throw new InterruptedException();\n        Node node = addConditionWaiter();\n        int savedState = fullyRelease(node);\n        boolean timedout = false;\n        int interruptMode = 0;\n        while (!isOnSyncQueue(node)) {\n            if (System.currentTimeMillis() > abstime) {\n                timedout = transferAfterCancelledWait(node);\n                break;\n            }\n            LockSupport.parkUntil(this, abstime);\n            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n                break;\n        }\n        if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n            interruptMode = REINTERRUPT;\n        if (node.nextWaiter != null)\n            unlinkCancelledWaiters();\n        if (interruptMode != 0)\n            reportInterruptAfterWait(interruptMode);\n        return !timedout;\n    }\n\n    /**\n        * Implements timed condition wait.\n        * <ol>\n        * <li> If current thread is interrupted, throw InterruptedException.\n        * <li> Save lock state returned by {@link #getState}.\n        * <li> Invoke {@link #release} with saved state as argument,\n        *      throwing IllegalMonitorStateException if it fails.\n        * <li> Block until signalled, interrupted, or timed out.\n        * <li> Reacquire by invoking specialized version of\n        *      {@link #acquire} with saved state as argument.\n        * <li> If interrupted while blocked in step 4, throw InterruptedException.\n        * <li> If timed out while blocked in step 4, return false, else true.\n        * </ol>\n        */\n    // 等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。此方法在行为上等效于: awaitNanos(unit.toNanos(time)) > 0\n    public final boolean await(long time, TimeUnit unit)\n            throws InterruptedException {\n        long nanosTimeout = unit.toNanos(time);\n        if (Thread.interrupted())\n            throw new InterruptedException();\n        Node node = addConditionWaiter();\n        int savedState = fullyRelease(node);\n        final long deadline = System.nanoTime() + nanosTimeout;\n        boolean timedout = false;\n        int interruptMode = 0;\n        while (!isOnSyncQueue(node)) {\n            if (nanosTimeout <= 0L) {\n                timedout = transferAfterCancelledWait(node);\n                break;\n            }\n            if (nanosTimeout >= spinForTimeoutThreshold)\n                LockSupport.parkNanos(this, nanosTimeout);\n            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n                break;\n            nanosTimeout = deadline - System.nanoTime();\n        }\n        if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n            interruptMode = REINTERRUPT;\n        if (node.nextWaiter != null)\n            unlinkCancelledWaiters();\n        if (interruptMode != 0)\n            reportInterruptAfterWait(interruptMode);\n        return !timedout;\n    }\n\n    //  support for instrumentation\n\n    /**\n        * Returns true if this condition was created by the given\n        * synchronization object.\n        *\n        * @return {@code true} if owned\n        */\n    final boolean isOwnedBy(AbstractQueuedSynchronizer sync) {\n        return sync == AbstractQueuedSynchronizer.this;\n    }\n\n    /**\n        * Queries whether any threads are waiting on this condition.\n        * Implements {@link AbstractQueuedSynchronizer#hasWaiters(ConditionObject)}.\n        *\n        * @return {@code true} if there are any waiting threads\n        * @throws IllegalMonitorStateException if {@link #isHeldExclusively}\n        *         returns {@code false}\n        */\n    //  查询是否有正在等待此条件的任何线程\n    protected final boolean hasWaiters() {\n        if (!isHeldExclusively())\n            throw new IllegalMonitorStateException();\n        for (Node w = firstWaiter; w != null; w = w.nextWaiter) {\n            if (w.waitStatus == Node.CONDITION)\n                return true;\n        }\n        return false;\n    }\n\n    /**\n        * Returns an estimate of the number of threads waiting on\n        * this condition.\n        * Implements {@link AbstractQueuedSynchronizer#getWaitQueueLength(ConditionObject)}.\n        *\n        * @return the estimated number of waiting threads\n        * @throws IllegalMonitorStateException if {@link #isHeldExclusively}\n        *         returns {@code false}\n        */\n    // 返回正在等待此条件的线程数估计值\n    protected final int getWaitQueueLength() {\n        if (!isHeldExclusively())\n            throw new IllegalMonitorStateException();\n        int n = 0;\n        for (Node w = firstWaiter; w != null; w = w.nextWaiter) {\n            if (w.waitStatus == Node.CONDITION)\n                ++n;\n        }\n        return n;\n    }\n\n    /**\n        * Returns a collection containing those threads that may be\n        * waiting on this Condition.\n        * Implements {@link AbstractQueuedSynchronizer#getWaitingThreads(ConditionObject)}.\n        *\n        * @return the collection of threads\n        * @throws IllegalMonitorStateException if {@link #isHeldExclusively}\n        *         returns {@code false}\n        */\n    // 返回包含那些可能正在等待此条件的线程集合\n    protected final Collection<Thread> getWaitingThreads() {\n        if (!isHeldExclusively())\n            throw new IllegalMonitorStateException();\n        ArrayList<Thread> list = new ArrayList<Thread>();\n        for (Node w = firstWaiter; w != null; w = w.nextWaiter) {\n            if (w.waitStatus == Node.CONDITION) {\n                Thread t = w.thread;\n                if (t != null)\n                    list.add(t);\n            }\n        }\n        return list;\n    }\n}\n\n\n此类实现了Condition接口，Condition接口定义了条件操作规范，具体如下\n\npublic interface Condition {\n\n    // 等待，当前线程在接到信号或被中断之前一直处于等待状态\n    void await() throws InterruptedException;\n    \n    // 等待，当前线程在接到信号之前一直处于等待状态，不响应中断\n    void awaitUninterruptibly();\n    \n    //等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态 \n    long awaitNanos(long nanosTimeout) throws InterruptedException;\n    \n    // 等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。此方法在行为上等效于: awaitNanos(unit.toNanos(time)) > 0\n    boolean await(long time, TimeUnit unit) throws InterruptedException;\n    \n    // 等待，当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态\n    boolean awaitUntil(Date deadline) throws InterruptedException;\n    \n    // 唤醒一个等待线程。如果所有的线程都在等待此条件，则选择其中的一个唤醒。在从 await 返回之前，该线程必须重新获取锁。\n    void signal();\n    \n    // 唤醒所有等待线程。如果所有的线程都在等待此条件，则唤醒所有线程。在从 await 返回之前，每个线程都必须重新获取锁。\n    void signalAll();\n}\n\n\nCondition接口中定义了await、signal方法，用来等待条件、释放条件。之后会详细分析CondtionObject的源码。\n\n\n# 类的属性\n\n属性中包含了头节点head，尾结点tail，状态state、自旋时间spinForTimeoutThreshold，还有AbstractQueuedSynchronizer抽象的属性在内存中的偏移地址，通过该偏移地址，可以获取和设置该属性的值，同时还包括一个静态初始化块，用于加载内存偏移地址。\n\npublic abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer\n    implements java.io.Serializable {    \n    // 版本号\n    private static final long serialVersionUID = 7373984972572414691L;    \n    // 头节点\n    private transient volatile Node head;    \n    // 尾结点\n    private transient volatile Node tail;    \n    // 状态\n    private volatile int state;    \n    // 自旋时间\n    static final long spinForTimeoutThreshold = 1000L;\n    \n    // Unsafe类实例\n    private static final Unsafe unsafe = Unsafe.getUnsafe();\n    // state内存偏移地址\n    private static final long stateOffset;\n    // head内存偏移地址\n    private static final long headOffset;\n    // state内存偏移地址\n    private static final long tailOffset;\n    // tail内存偏移地址\n    private static final long waitStatusOffset;\n    // next内存偏移地址\n    private static final long nextOffset;\n    // 静态初始化块\n    static {\n        try {\n            stateOffset = unsafe.objectFieldOffset\n                (AbstractQueuedSynchronizer.class.getDeclaredField("state"));\n            headOffset = unsafe.objectFieldOffset\n                (AbstractQueuedSynchronizer.class.getDeclaredField("head"));\n            tailOffset = unsafe.objectFieldOffset\n                (AbstractQueuedSynchronizer.class.getDeclaredField("tail"));\n            waitStatusOffset = unsafe.objectFieldOffset\n                (Node.class.getDeclaredField("waitStatus"));\n            nextOffset = unsafe.objectFieldOffset\n                (Node.class.getDeclaredField("next"));\n\n        } catch (Exception ex) { throw new Error(ex); }\n    }\n}\n\n\n\n# 类的构造方法\n\n此类构造方法为从抽象构造方法，供子类调用。\n\nprotected AbstractQueuedSynchronizer() { }    \n\n\n\n# 类的核心方法 - acquire方法\n\n该方法以独占模式获取(资源)，忽略中断，即线程在aquire过程中，中断此线程是无效的。源码如下:\n\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n\n\n由上述源码可以知道，当一个线程调用acquire时，调用方法流程如下\n\n\n\n * 首先调用tryAcquire方法，调用此方法的线程会试图在独占模式下获取对象状态。此方法应该查询是否允许它在独占模式下获取对象状态，如果允许，则获取它。在AbstractQueuedSynchronizer源码中默认会抛出一个异常，即需要子类去重写此方法完成自己的逻辑。之后会进行分析。\n\n * 若tryAcquire失败，则调用addWaiter方法，addWaiter方法完成的功能是将调用此方法的线程封装成为一个结点并放入Sync queue。\n\n * 调用acquireQueued方法，此方法完成的功能是Sync queue中的结点不断尝试获取资源，若成功，则返回true，否则，返回false。\n\n * 由于tryAcquire默认实现是抛出异常，所以此时，不进行分析，之后会结合一个例子进行分析。\n\n首先分析addWaiter方法\n\n// 添加等待者\nprivate Node addWaiter(Node mode) {\n    // 新生成一个结点，默认为独占模式\n    Node node = new Node(Thread.currentThread(), mode);\n    // Try the fast path of enq; backup to full enq on failure\n    // 保存尾结点\n    Node pred = tail;\n    if (pred != null) { // 尾结点不为空，即已经被初始化\n        // 将node结点的prev域连接到尾结点\n        node.prev = pred; \n        if (compareAndSetTail(pred, node)) { // 比较pred是否为尾结点，是则将尾结点设置为node \n            // 设置尾结点的next域为node\n            pred.next = node;\n            return node; // 返回新生成的结点\n        }\n    }\n    enq(node); // 尾结点为空(即还没有被初始化过)，或者是compareAndSetTail操作失败，则入队列\n    return node;\n}\n\n\naddWaiter方法使用快速添加的方式往sync queue尾部添加结点，如果sync queue队列还没有初始化，则会使用enq插入队列中，enq方法源码如下\n\nprivate Node enq(final Node node) {\n    for (;;) { // 无限循环，确保结点能够成功入队列\n        // 保存尾结点\n        Node t = tail;\n        if (t == null) { // 尾结点为空，即还没被初始化\n            if (compareAndSetHead(new Node())) // 头节点为空，并设置头节点为新生成的结点\n                tail = head; // 头节点与尾结点都指向同一个新生结点\n        } else { // 尾结点不为空，即已经被初始化过\n            // 将node结点的prev域连接到尾结点\n            node.prev = t; \n            if (compareAndSetTail(t, node)) { // 比较结点t是否为尾结点，若是则将尾结点设置为node\n                // 设置尾结点的next域为node\n                t.next = node; \n                return t; // 返回尾结点\n            }\n        }\n    }\n}\n\n\nenq方法会使用无限循环来确保节点的成功插入。\n\n现在，分析acquireQueue方法。其源码如下\n\n// sync队列中的结点在独占且忽略中断的模式下获取(资源)\nfinal boolean acquireQueued(final Node node, int arg) {\n    // 标志\n    boolean failed = true;\n    try {\n        // 中断标志\n        boolean interrupted = false;\n        for (;;) { // 无限循环\n            // 获取node节点的前驱结点\n            final Node p = node.predecessor(); \n            if (p == head && tryAcquire(arg)) { // 前驱为头节点并且成功获得锁\n                setHead(node); // 设置头节点\n                p.next = null; // help GC\n                failed = false; // 设置标志\n                return interrupted; \n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n\n\n首先获取当前节点的前驱节点，如果前驱节点是头节点并且能够获取(资源)，代表该当前节点能够占有锁，设置头节点为当前节点，返回。否则，调用shouldParkAfterFailedAcquire和parkAndCheckInterrupt方法，首先，我们看shouldParkAfterFailedAcquire方法，代码如下\n\n// 当获取(资源)失败后，检查并且更新结点状态\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    // 获取前驱结点的状态\n    int ws = pred.waitStatus;\n    if (ws == Node.SIGNAL) // 状态为SIGNAL，为-1\n        /*\n            * This node has already set status asking a release\n            * to signal it, so it can safely park.\n            */\n        // 可以进行park操作\n        return true; \n    if (ws > 0) { // 表示状态为CANCELLED，为1\n        /*\n            * Predecessor was cancelled. Skip over predecessors and\n            * indicate retry.\n            */\n        do {\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus > 0); // 找到pred结点前面最近的一个状态不为CANCELLED的结点\n        // 赋值pred结点的next域\n        pred.next = node; \n    } else { // 为PROPAGATE -3 或者是0 表示无状态,(为CONDITION -2时，表示此节点在condition queue中) \n        /*\n            * waitStatus must be 0 or PROPAGATE.  Indicate that we\n            * need a signal, but don\'t park yet.  Caller will need to\n            * retry to make sure it cannot acquire before parking.\n            */\n        // 比较并设置前驱结点的状态为SIGNAL\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL); \n    }\n    // 不能进行park操作\n    return false;\n}\n\n\n只有当该节点的前驱结点的状态为SIGNAL时，才可以对该结点所封装的线程进行park操作。否则，将不能进行park操作。再看parkAndCheckInterrupt方法，源码如下\n\n// 进行park操作并且返回该线程是否被中断\nprivate final boolean parkAndCheckInterrupt() {\n    // 在许可可用之前禁用当前线程，并且设置了blocker\n    LockSupport.park(this);\n    return Thread.interrupted(); // 当前线程是否已被中断，并清除中断标记位\n}\n\n\nparkAndCheckInterrupt方法里的逻辑是首先执行park操作，即禁用当前线程，然后返回该线程是否已经被中断。再看final块中的cancelAcquire方法，其源码如下\n\n// 取消继续获取(资源)\nprivate void cancelAcquire(Node node) {\n    // Ignore if node doesn\'t exist\n    // node为空，返回\n    if (node == null)\n        return;\n    // 设置node结点的thread为空\n    node.thread = null;\n\n    // Skip cancelled predecessors\n    // 保存node的前驱结点\n    Node pred = node.prev;\n    while (pred.waitStatus > 0) // 找到node前驱结点中第一个状态小于0的结点，即不为CANCELLED状态的结点\n        node.prev = pred = pred.prev;\n\n    // predNext is the apparent node to unsplice. CASes below will\n    // fail if not, in which case, we lost race vs another cancel\n    // or signal, so no further action is necessary.\n    // 获取pred结点的下一个结点\n    Node predNext = pred.next;\n\n    // Can use unconditional write instead of CAS here.\n    // After this atomic step, other Nodes can skip past us.\n    // Before, we are free of interference from other threads.\n    // 设置node结点的状态为CANCELLED\n    node.waitStatus = Node.CANCELLED;\n\n    // If we are the tail, remove ourselves.\n    if (node == tail && compareAndSetTail(node, pred)) { // node结点为尾结点，则设置尾结点为pred结点\n        // 比较并设置pred结点的next节点为null\n        compareAndSetNext(pred, predNext, null); \n    } else { // node结点不为尾结点，或者比较设置不成功\n        // If successor needs signal, try to set pred\'s next-link\n        // so it will get one. Otherwise wake it up to propagate.\n        int ws;\n        if (pred != head &&\n            ((ws = pred.waitStatus) == Node.SIGNAL ||\n                (ws <= 0 && compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &&\n            pred.thread != null) { // (pred结点不为头节点，并且pred结点的状态为SIGNAL)或者 \n                                // pred结点状态小于等于0，并且比较并设置等待状态为SIGNAL成功，并且pred结点所封装的线程不为空\n            // 保存结点的后继\n            Node next = node.next;\n            if (next != null && next.waitStatus <= 0) // 后继不为空并且后继的状态小于等于0\n                compareAndSetNext(pred, predNext, next); // 比较并设置pred.next = next;\n        } else {\n            unparkSuccessor(node); // 释放node的前一个结点\n        }\n\n        node.next = node; // help GC\n    }\n}\n\n\n该方法完成的功能就是取消当前线程对资源的获取，即设置该结点的状态为CANCELLED，接着我们再看unparkSuccessor方法，源码如下\n\n// 释放后继结点\nprivate void unparkSuccessor(Node node) {\n    /*\n        * If status is negative (i.e., possibly needing signal) try\n        * to clear in anticipation of signalling.  It is OK if this\n        * fails or if status is changed by waiting thread.\n        */\n    // 获取node结点的等待状态\n    int ws = node.waitStatus;\n    if (ws < 0) // 状态值小于0，为SIGNAL -1 或 CONDITION -2 或 PROPAGATE -3\n        // 比较并且设置结点等待状态，设置为0\n        compareAndSetWaitStatus(node, ws, 0);\n\n    /*\n        * Thread to unpark is held in successor, which is normally\n        * just the next node.  But if cancelled or apparently null,\n        * traverse backwards from tail to find the actual\n        * non-cancelled successor.\n        */\n    // 获取node节点的下一个结点\n    Node s = node.next;\n    if (s == null || s.waitStatus > 0) { // 下一个结点为空或者下一个节点的等待状态大于0，即为CANCELLED\n        // s赋值为空\n        s = null; \n        // 从尾结点开始从后往前开始遍历\n        for (Node t = tail; t != null && t != node; t = t.prev)\n            if (t.waitStatus <= 0) // 找到等待状态小于等于0的结点，找到最前的状态小于等于0的结点\n                // 保存结点\n                s = t;\n    }\n    if (s != null) // 该结点不为为空，释放许可\n        LockSupport.unpark(s.thread);\n}\n\n\n该方法的作用就是为了释放node节点的后继结点。\n\n对于cancelAcquire与unparkSuccessor方法，如下示意图可以清晰的表示:\n\n\n\n其中node为参数，在执行完cancelAcquire方法后的效果就是unpark了s结点所包含的t4线程。\n\n现在，再来看acquireQueued方法的整个的逻辑。逻辑如下:\n\n * 判断结点的前驱是否为head并且是否成功获取(资源)。\n * 若步骤1均满足，则设置结点为head，之后会判断是否finally模块，然后返回。\n * 若步骤2不满足，则判断是否需要park当前线程，是否需要park当前线程的逻辑是判断结点的前驱结点的状态是否为SIGNAL，若是，则park当前结点，否则，不进行park操作。\n * 若park了当前线程，之后某个线程对本线程unpark后，并且本线程也获得机会运行。那么，将会继续进行步骤①的判断。\n\n\n# 类的核心方法 - release方法\n\n以独占模式释放对象，其源码如下:\n\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) { // 释放成功\n        // 保存头节点\n        Node h = head; \n        if (h != null && h.waitStatus != 0) // 头节点不为空并且头节点状态不为0\n            unparkSuccessor(h); //释放头节点的后继结点\n        return true;\n    }\n    return false;\n}\n\n\n其中，tryRelease的默认实现是抛出异常，需要具体的子类实现，如果tryRelease成功，那么如果头节点不为空并且头节点的状态不为0，则释放头节点的后继结点，unparkSuccessor方法已经分析过，不再累赘。\n\n对于其他方法我们也可以分析，与前面分析的方法大同小异，所以，不再累赘。\n\n\n# AbstractQueuedSynchronizer示例详解一\n\n借助下面示例来分析AbstractQueuedSyncrhonizer内部的工作机制。示例源码如下\n\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\nclass MyThread extends Thread {\n    private Lock lock;\n    public MyThread(String name, Lock lock) {\n        super(name);\n        this.lock = lock;\n    }\n    \n    public void run () {\n        lock.lock();\n        try {\n            System.out.println(Thread.currentThread() + " running");\n        } finally {\n            lock.unlock();\n        }\n    }\n}\npublic class AbstractQueuedSynchronizerDemo {\n    public static void main(String[] args) {\n        Lock lock = new ReentrantLock();\n        \n        MyThread t1 = new MyThread("t1", lock);\n        MyThread t2 = new MyThread("t2", lock);\n        t1.start();\n        t2.start();    \n    }\n}\n\n\n运行结果(可能的一种):\n\nThread[t1,5,main] running\nThread[t2,5,main] running\n\n\n结果分析: 从示例可知，线程t1与t2共用了一把锁，即同一个lock。可能会存在如下一种时序。\n\n\n\n说明: 首先线程t1先执行lock.lock操作，然后t2执行lock.lock操作，然后t1执行lock.unlock操作，最后t2执行lock.unlock操作。基于这样的时序，分析AbstractQueuedSynchronizer内部的工作机制。\n\n * t1线程调用lock.lock方法，其方法调用顺序如下，只给出了主要的方法调用。\n\n\n\n说明: 其中，前面的部分表示哪个类，后面是具体的类中的哪个方法，AQS表示AbstractQueuedSynchronizer类，AOS表示AbstractOwnableSynchronizer类。\n\n * t2线程调用lock.lock方法，其方法调用顺序如下，只给出了主要的方法调用。\n\n\n\n说明: 经过一系列的方法调用，最后达到的状态是禁用t2线程，因为调用了LockSupport.park。\n\n * t1线程调用lock.unlock，其方法调用顺序如下，只给出了主要的方法调用。\n\n\n\n说明: t1线程中调用lock.unlock后，经过一系列的调用，最终的状态是释放了许可，因为调用了LockSupport.unpark。这时，t2线程就可以继续运行了。此时，会继续恢复t2线程运行环境，继续执行LockSupport.park后面的语句，即进一步调用如下。\n\n\n\n说明: 在上一步调用了LockSupport.unpark后，t2线程恢复运行，则运行parkAndCheckInterrupt，之后，继续运行acquireQueued方法，最后达到的状态是头节点head与尾结点tail均指向了t2线程所在的结点，并且之前的头节点已经从sync队列中断开了。\n\n * t2线程调用lock.unlock，其方法调用顺序如下，只给出了主要的方法调用。\n\n\n\n说明: t2线程执行lock.unlock后，最终达到的状态还是与之前的状态一样。\n\n\n# AbstractQueuedSynchronizer示例详解二\n\n下面我们结合Condition实现生产者与消费者，来进一步分析AbstractQueuedSynchronizer的内部工作机制。\n\n * Depot(仓库)类\n\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class Depot {\n    private int size;\n    private int capacity;\n    private Lock lock;\n    private Condition fullCondition;\n    private Condition emptyCondition;\n    \n    public Depot(int capacity) {\n        this.capacity = capacity;    \n        lock = new ReentrantLock();\n        fullCondition = lock.newCondition();\n        emptyCondition = lock.newCondition();\n    }\n    \n    public void produce(int no) {\n        lock.lock();\n        int left = no;\n        try {\n            while (left > 0) {\n                while (size >= capacity)  {\n                    System.out.println(Thread.currentThread() + " before await");\n                    fullCondition.await();\n                    System.out.println(Thread.currentThread() + " after await");\n                }\n                int inc = (left + size) > capacity ? (capacity - size) : left;\n                left -= inc;\n                size += inc;\n                System.out.println("produce = " + inc + ", size = " + size);\n                emptyCondition.signal();\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n    \n    public void consume(int no) {\n        lock.lock();\n        int left = no;\n        try {            \n            while (left > 0) {\n                while (size <= 0) {\n                    System.out.println(Thread.currentThread() + " before await");\n                    emptyCondition.await();\n                    System.out.println(Thread.currentThread() + " after await");\n                }\n                int dec = (size - left) > 0 ? left : size;\n                left -= dec;\n                size -= dec;\n                System.out.println("consume = " + dec + ", size = " + size);\n                fullCondition.signal();\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\n\n * 测试类\n\nclass Consumer {\n    private Depot depot;\n    public Consumer(Depot depot) {\n        this.depot = depot;\n    }\n    \n    public void consume(int no) {\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                depot.consume(no);\n            }\n        }, no + " consume thread").start();\n    }\n}\n\nclass Producer {\n    private Depot depot;\n    public Producer(Depot depot) {\n        this.depot = depot;\n    }\n    \n    public void produce(int no) {\n        new Thread(new Runnable() {\n            \n            @Override\n            public void run() {\n                depot.produce(no);\n            }\n        }, no + " produce thread").start();\n    }\n}\n\npublic class ReentrantLockDemo {\n    public static void main(String[] args) throws InterruptedException {\n        Depot depot = new Depot(500);\n        new Producer(depot).produce(500);\n        new Producer(depot).produce(200);\n        new Consumer(depot).consume(500);\n        new Consumer(depot).consume(200);\n    }\n}\n\n\n * 运行结果(可能的一种):\n\nproduce = 500, size = 500\nThread[200 produce thread,5,main] before await\nconsume = 500, size = 0\nThread[200 consume thread,5,main] before await\nThread[200 produce thread,5,main] after await\nproduce = 200, size = 200\nThread[200 consume thread,5,main] after await\nconsume = 200, size = 0\n\n\n说明: 根据结果，我们猜测一种可能的时序如下\n\n\n\n说明: p1代表produce 500的那个线程，p2代表produce 200的那个线程，c1代表consume 500的那个线程，c2代表consume 200的那个线程。\n\n * p1线程调用lock.lock，获得锁，继续运行，方法调用顺序在前面已经给出。\n * p2线程调用lock.lock，由前面的分析可得到如下的最终状态。\n\n\n\n说明: p2线程调用lock.lock后，会禁止p2线程的继续运行，因为执行了LockSupport.park操作。\n\n * c1线程调用lock.lock，由前面的分析得到如下的最终状态。\n\n\n\n说明: 最终c1线程会在sync queue队列的尾部，并且其结点的前驱结点(包含p2的结点)的waitStatus变为了SIGNAL。\n\n * c2线程调用lock.lock，由前面的分析得到如下的最终状态。\n\n\n\n说明: 最终c1线程会在sync queue队列的尾部，并且其结点的前驱结点(包含c1的结点)的waitStatus变为了SIGNAL。\n\n * p1线程执行emptyCondition.signal，其方法调用顺序如下，只给出了主要的方法调用。\n\n\n\n说明: AQS.CO表示AbstractQueuedSynchronizer.ConditionObject类。此时调用signal方法不会产生任何其他效果。\n\n * p1线程执行lock.unlock，根据前面的分析可知，最终的状态如下。\n\n\n\n说明: 此时，p2线程所在的结点为头节点，并且其他两个线程(c1、c2)依旧被禁止，所以，此时p2线程继续运行，执行用户逻辑。\n\n * p2线程执行fullCondition.await，其方法调用顺序如下，只给出了主要的方法调用。\n\n\n\n说明: 最终到达的状态是新生成了一个结点，包含了p2线程，此结点在condition queue中；并且sync queue中p2线程被禁止了，因为在执行了LockSupport.park操作。从方法一些调用可知，在await操作中线程会释放锁资源，供其他线程获取。同时，head结点后继结点的包含的线程的许可被释放了，故其可以继续运行。由于此时，只有c1线程可以运行，故运行c1。\n\n * 继续运行c1线程，c1线程由于之前被park了，所以此时恢复，继续之前的步骤，即还是执行前面提到的acquireQueued方法，之后，c1判断自己的前驱结点为head，并且可以获取锁资源，最终到达的状态如下。\n\n\n\n说明: 其中，head设置为包含c1线程的结点，c1继续运行。\n\n * c1线程执行fullCondtion.signal，其方法调用顺序如下，只给出了主要的方法调用。\n\n\n\n说明: signal方法达到的最终结果是将包含p2线程的结点从condition queue中转移到sync queue中，之后condition queue为null，之前的尾结点的状态变为SIGNAL。\n\n * c1线程执行lock.unlock操作，根据之前的分析，经历的状态变化如下。\n\n\n\n说明: 最终c2线程会获取锁资源，继续运行用户逻辑。\n\n * c2线程执行emptyCondition.await，由前面的第七步分析，可知最终的状态如下。\n\n\n\n说明: await操作将会生成一个结点放入condition queue中与之前的一个condition queue是不相同的，并且unpark头节点后面的结点，即包含线程p2的结点。\n\n * p2线程被unpark，故可以继续运行，经过CPU调度后，p2继续运行，之后p2线程在AQS:await方法中被park，继续AQS.CO:await方法的运行，其方法调用顺序如下，只给出了主要的方法调用。\n\n\n\n * p2继续运行，执行emptyCondition.signal，根据第九步分析可知，最终到达的状态如下。\n\n\n\n说明: 最终，将condition queue中的结点转移到sync queue中，并添加至尾部，condition queue会为空，并且将head的状态设置为SIGNAL。\n\n * p2线程执行lock.unlock操作，根据前面的分析可知，最后的到达的状态如下。\n\n\n\n说明: unlock操作会释放c2线程的许可，并且将头节点设置为c2线程所在的结点。\n\n * c2线程继续运行，执行fullCondition. signal，由于此时fullCondition的condition queue已经不存在任何结点了，故其不会产生作用。\n\n * c2执行lock.unlock，由于c2是sync队列中最后一个结点，故其不会再调用unparkSuccessor了，直接返回true。即整个流程就完成了。\n\n\n# AbstractQueuedSynchronizer总结\n\n对于AbstractQueuedSynchronizer的分析，最核心的就是sync queue的分析。\n\n * 每一个结点都是由前一个结点唤醒\n * 当结点发现前驱结点是head并且尝试获取成功，则会轮到该线程运行。\n * condition queue中的结点向sync queue中转移是通过signal操作完成的。\n * 当结点的状态为SIGNAL时，表示后面的结点需要运行。\n\n\n# 参考文章\n\n * 文章主要参考自leesf的https://www.cnblogs.com/leesf456/p/5350186.html，在此基础上做了增改。\n * http://ifeve.com/introduce-abstractqueuedsynchronizer/\n * http://blog.csdn.net/chen77716/article/details/6641477\n * https://blog.csdn.net/mulinsen77/article/details/84583716\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html',normalizedContent:'# juc锁: 锁核心类aqs详解\n\n> abstractqueuedsynchronizer抽象类是核心，需要重点掌握。它提供了一个基于fifo队列，可以用于构建锁或者其他相关同步装置的基础框架。\n\n * juc锁: 锁核心类aqs详解\n   * 带着bat大厂的面试问题去理解\n   * abstractqueuedsynchronizer简介\n     * aqs 核心思想\n     * aqs 对资源的共享方式\n     * aqs底层使用了模板方法模式\n   * abstractqueuedsynchronizer数据结构\n   * abstractqueuedsynchronizer源码分析\n     * 类的继承关系\n     * 类的内部类 - node类\n     * 类的内部类 - conditionobject类\n     * 类的属性\n     * 类的构造方法\n     * 类的核心方法 - acquire方法\n     * 类的核心方法 - release方法\n   * abstractqueuedsynchronizer示例详解一\n   * abstractqueuedsynchronizer示例详解二\n   * abstractqueuedsynchronizer总结\n   * 参考文章\n\n\n# 带着bat大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 什么是aqs? 为什么它是核心?\n * aqs的核心思想是什么? 它是怎么实现的? 底层数据结构等\n * aqs有哪些核心的方法?\n * aqs定义什么样的资源获取方式? aqs定义了两种资源获取方式：独占(只有一个线程能访问执行，又根据是否按队列的顺序分为公平锁和非公平锁，如reentrantlock) 和共享(多个线程可同时访问执行，如semaphore、countdownlatch、 cyclicbarrier )。reentrantreadwritelock可以看成是组合式，允许多个线程同时对某一资源进行读。\n * aqs底层使用了什么样的设计模式? 模板\n * aqs的应用示例?\n\n\n# abstractqueuedsynchronizer简介\n\naqs是一个用来构建锁和同步器的框架，使用aqs能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的reentrantlock，semaphore，其他的诸如reentrantreadwritelock，synchronousqueue，futuretask等等皆是基于aqs的。当然，我们自己也能利用aqs非常轻松容易地构造出符合我们自己需求的同步器。\n\n\n# aqs 核心思想\n\naqs核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制aqs是用clh队列锁实现的，即将暂时获取不到锁的线程加入到队列中。\n\n> clh(craig,landin,and hagersten)队列是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)。aqs是将每条请求共享资源的线程封装成一个clh锁队列的一个结点(node)来实现锁的分配。\n\naqs使用一个int成员变量来表示同步状态，通过内置的fifo队列来完成获取资源线程的排队工作。aqs使用cas对该同步状态进行原子操作实现对其值的修改。\n\nprivate volatile int state;//共享变量，使用volatile修饰保证线程可见性\n\n\n状态信息通过procted类型的getstate，setstate，compareandsetstate进行操作\n\n//返回同步状态的当前值\nprotected final int getstate() {  \n        return state;\n}\n // 设置同步状态的值\nprotected final void setstate(int newstate) { \n        state = newstate;\n}\n//原子地(cas操作)将同步状态值设置为给定值update如果当前同步状态的值等于expect(期望值)\nprotected final boolean compareandsetstate(int expect, int update) {\n        return unsafe.compareandswapint(this, stateoffset, expect, update);\n}\n\n\n\n# aqs 对资源的共享方式\n\naqs定义两种资源共享方式\n\n * exclusive(独占)：只有一个线程能执行，如reentrantlock。又可分为公平锁和非公平锁：\n   * 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁\n   * 非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的\n * share(共享)：多个线程可同时执行，如semaphore/countdownlatch。semaphore、countdownlatch、 cyclicbarrier、readwritelock 我们都会在后面讲到。\n\nreentrantreadwritelock 可以看成是组合式，因为reentrantreadwritelock也就是读写锁允许多个线程同时对某一资源进行读。\n\n不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护(如获取资源失败入队/唤醒出队等)，aqs已经在上层已经帮我们实现好了。\n\n\n# aqs底层使用了模板方法模式\n\n> 同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样(模板方法模式很经典的一个应用)：\n\n使用者继承abstractqueuedsynchronizer并重写指定的方法。(这些重写方法很简单，无非是对于共享资源state的获取和释放) 将aqs组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。\n\n这和我们以往通过实现接口的方式有很大区别，模板方法模式请参看：设计模式行为型 - 模板方法(template method)详解\n\naqs使用了模板方法模式，自定义同步器时需要重写下面几个aqs提供的模板方法：\n\nisheldexclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。\ntryacquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。\ntryrelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。\ntryacquireshared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\ntryreleaseshared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。\n\n\n默认情况下，每个方法都抛出 unsupportedoperationexception。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。aqs类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。\n\n以reentrantlock为例，state初始化为0，表示未锁定状态。a线程lock()时，会调用tryacquire()独占该锁并将state+1。此后，其他线程再tryacquire()时就会失败，直到a线程unlock()到state=0(即释放锁)为止，其它线程才有机会获取该锁。当然，释放锁之前，a线程自己是可以重复获取此锁的(state会累加)，这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。\n\n\n# abstractqueuedsynchronizer数据结构\n\nabstractqueuedsynchronizer类底层的数据结构是使用clh(craig,landin,and hagersten)队列是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)。aqs是将每条请求共享资源的线程封装成一个clh锁队列的一个结点(node)来实现锁的分配。其中sync queue，即同步队列，是双向链表，包括head结点和tail结点，head结点主要用作后续的调度。而condition queue不是必须的，其是一个单向链表，只有当使用condition时，才会存在此单向链表。并且可能会有多个condition queue。\n\n\n\n\n# abstractqueuedsynchronizer源码分析\n\n\n# 类的继承关系\n\nabstractqueuedsynchronizer继承自abstractownablesynchronizer抽象类，并且实现了serializable接口，可以进行序列化。\n\npublic abstract class abstractqueuedsynchronizer extends abstractownablesynchronizer implements java.io.serializable\n\n\n其中abstractownablesynchronizer抽象类的源码如下:\n\npublic abstract class abstractownablesynchronizer implements java.io.serializable {\n    \n    // 版本序列号\n    private static final long serialversionuid = 3737899427754241961l;\n    // 构造方法\n    protected abstractownablesynchronizer() { }\n    // 独占模式下的线程\n    private transient thread exclusiveownerthread;\n    \n    // 设置独占线程 \n    protected final void setexclusiveownerthread(thread thread) {\n        exclusiveownerthread = thread;\n    }\n    \n    // 获取独占线程 \n    protected final thread getexclusiveownerthread() {\n        return exclusiveownerthread;\n    }\n}\n\n\nabstractownablesynchronizer抽象类中，可以设置独占资源线程和获取独占资源线程。分别为setexclusiveownerthread与getexclusiveownerthread方法，这两个方法会被子类调用。\n\n> abstractqueuedsynchronizer类有两个内部类，分别为node类与conditionobject类。下面分别做介绍。\n\n\n# 类的内部类 - node类\n\nstatic final class node {\n    // 模式，分为共享与独占\n    // 共享模式\n    static final node shared = new node();\n    // 独占模式\n    static final node exclusive = null;        \n    // 结点状态\n    // cancelled，值为1，表示当前的线程被取消\n    // signal，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark\n    // condition，值为-2，表示当前节点在等待condition，也就是在condition队列中\n    // propagate，值为-3，表示当前场景下后续的acquireshared能够得以执行\n    // 值为0，表示当前节点在sync队列中，等待着获取锁\n    static final int cancelled =  1;\n    static final int signal    = -1;\n    static final int condition = -2;\n    static final int propagate = -3;        \n\n    // 结点状态\n    volatile int waitstatus;        \n    // 前驱结点\n    volatile node prev;    \n    // 后继结点\n    volatile node next;        \n    // 结点所对应的线程\n    volatile thread thread;        \n    // 下一个等待者\n    node nextwaiter;\n    \n    // 结点是否在共享模式下等待\n    final boolean isshared() {\n        return nextwaiter == shared;\n    }\n    \n    // 获取前驱结点，若前驱结点为空，抛出异常\n    final node predecessor() throws nullpointerexception {\n        // 保存前驱结点\n        node p = prev; \n        if (p == null) // 前驱结点为空，抛出异常\n            throw new nullpointerexception();\n        else // 前驱结点不为空，返回\n            return p;\n    }\n    \n    // 无参构造方法\n    node() {    // used to establish initial head or shared marker\n    }\n    \n    // 构造方法\n        node(thread thread, node mode) {    // used by addwaiter\n        this.nextwaiter = mode;\n        this.thread = thread;\n    }\n    \n    // 构造方法\n    node(thread thread, int waitstatus) { // used by condition\n        this.waitstatus = waitstatus;\n        this.thread = thread;\n    }\n}\n\n\n每个线程被阻塞的线程都会被封装成一个node结点，放入队列。每个节点包含了一个thread类型的引用，并且每个节点都存在一个状态，具体状态如下。\n\n * cancelled，值为1，表示当前的线程被取消。\n\n * signal，值为-1，表示当前节点的后继节点包含的线程需要运行，需要进行unpark操作。\n\n * condition，值为-2，表示当前节点在等待condition，也就是在condition queue中。\n\n * propagate，值为-3，表示当前场景下后续的acquireshared能够得以执行。\n\n * 值为0，表示当前节点在sync queue中，等待着获取锁。\n\n\n# 类的内部类 - conditionobject类\n\n这个类有点长，耐心看下:\n\n// 内部类\npublic class conditionobject implements condition, java.io.serializable {\n    // 版本号\n    private static final long serialversionuid = 1173984872572414699l;\n    /** first node of condition queue. */\n    // condition队列的头节点\n    private transient node firstwaiter;\n    /** last node of condition queue. */\n    // condition队列的尾结点\n    private transient node lastwaiter;\n\n    /**\n        * creates a new {@code conditionobject} instance.\n        */\n    // 构造方法\n    public conditionobject() { }\n\n    // internal methods\n\n    /**\n        * adds a new waiter to wait queue.\n        * @return its new wait node\n        */\n    // 添加新的waiter到wait队列\n    private node addconditionwaiter() {\n        // 保存尾结点\n        node t = lastwaiter;\n        // if lastwaiter is cancelled, clean out.\n        if (t != null && t.waitstatus != node.condition) { // 尾结点不为空，并且尾结点的状态不为condition\n            // 清除状态为condition的结点\n            unlinkcancelledwaiters(); \n            // 将最后一个结点重新赋值给t\n            t = lastwaiter;\n        }\n        // 新建一个结点\n        node node = new node(thread.currentthread(), node.condition);\n        if (t == null) // 尾结点为空\n            // 设置condition队列的头节点\n            firstwaiter = node;\n        else // 尾结点不为空\n            // 设置为节点的nextwaiter域为node结点\n            t.nextwaiter = node;\n        // 更新condition队列的尾结点\n        lastwaiter = node;\n        return node;\n    }\n\n    /**\n        * removes and transfers nodes until hit non-cancelled one or\n        * null. split out from signal in part to encourage compilers\n        * to inline the case of no waiters.\n        * @param first (non-null) the first node on condition queue\n        */\n    private void dosignal(node first) {\n        // 循环\n        do {\n            if ( (firstwaiter = first.nextwaiter) == null) // 该节点的nextwaiter为空\n                // 设置尾结点为空\n                lastwaiter = null;\n            // 设置first结点的nextwaiter域\n            first.nextwaiter = null;\n        } while (!transferforsignal(first) &&\n                    (first = firstwaiter) != null); // 将结点从condition队列转移到sync队列失败并且condition队列中的头节点不为空，一直循环\n    }\n\n    /**\n        * removes and transfers all nodes.\n        * @param first (non-null) the first node on condition queue\n        */\n    private void dosignalall(node first) {\n        // condition队列的头节点尾结点都设置为空\n        lastwaiter = firstwaiter = null;\n        // 循环\n        do {\n            // 获取first结点的nextwaiter域结点\n            node next = first.nextwaiter;\n            // 设置first结点的nextwaiter域为空\n            first.nextwaiter = null;\n            // 将first结点从condition队列转移到sync队列\n            transferforsignal(first);\n            // 重新设置first\n            first = next;\n        } while (first != null);\n    }\n\n    /**\n        * unlinks cancelled waiter nodes from condition queue.\n        * called only while holding lock. this is called when\n        * cancellation occurred during condition wait, and upon\n        * insertion of a new waiter when lastwaiter is seen to have\n        * been cancelled. this method is needed to avoid garbage\n        * retention in the absence of signals. so even though it may\n        * require a full traversal, it comes into play only when\n        * timeouts or cancellations occur in the absence of\n        * signals. it traverses all nodes rather than stopping at a\n        * particular target to unlink all pointers to garbage nodes\n        * without requiring many re-traversals during cancellation\n        * storms.\n        */\n    // 从condition队列中清除状态为cancel的结点\n    private void unlinkcancelledwaiters() {\n        // 保存condition队列头节点\n        node t = firstwaiter;\n        node trail = null;\n        while (t != null) { // t不为空\n            // 下一个结点\n            node next = t.nextwaiter;\n            if (t.waitstatus != node.condition) { // t结点的状态不为condtion状态\n                // 设置t节点的nextwaiter域为空\n                t.nextwaiter = null;\n                if (trail == null) // trail为空\n                    // 重新设置condition队列的头节点\n                    firstwaiter = next;\n                else // trail不为空\n                    // 设置trail结点的nextwaiter域为next结点\n                    trail.nextwaiter = next;\n                if (next == null) // next结点为空\n                    // 设置condition队列的尾结点\n                    lastwaiter = trail;\n            }\n            else // t结点的状态为condtion状态\n                // 设置trail结点\n                trail = t;\n            // 设置t结点\n            t = next;\n        }\n    }\n\n    // public methods\n\n    /**\n        * moves the longest-waiting thread, if one exists, from the\n        * wait queue for this condition to the wait queue for the\n        * owning lock.\n        *\n        * @throws illegalmonitorstateexception if {@link #isheldexclusively}\n        *         returns {@code false}\n        */\n    // 唤醒一个等待线程。如果所有的线程都在等待此条件，则选择其中的一个唤醒。在从 await 返回之前，该线程必须重新获取锁。\n    public final void signal() {\n        if (!isheldexclusively()) // 不被当前线程独占，抛出异常\n            throw new illegalmonitorstateexception();\n        // 保存condition队列头节点\n        node first = firstwaiter;\n        if (first != null) // 头节点不为空\n            // 唤醒一个等待线程\n            dosignal(first);\n    }\n\n    /**\n        * moves all threads from the wait queue for this condition to\n        * the wait queue for the owning lock.\n        *\n        * @throws illegalmonitorstateexception if {@link #isheldexclusively}\n        *         returns {@code false}\n        */\n    // 唤醒所有等待线程。如果所有的线程都在等待此条件，则唤醒所有线程。在从 await 返回之前，每个线程都必须重新获取锁。\n    public final void signalall() {\n        if (!isheldexclusively()) // 不被当前线程独占，抛出异常\n            throw new illegalmonitorstateexception();\n        // 保存condition队列头节点\n        node first = firstwaiter;\n        if (first != null) // 头节点不为空\n            // 唤醒所有等待线程\n            dosignalall(first);\n    }\n\n    /**\n        * implements uninterruptible condition wait.\n        * <ol>\n        * <li> save lock state returned by {@link #getstate}.\n        * <li> invoke {@link #release} with saved state as argument,\n        *      throwing illegalmonitorstateexception if it fails.\n        * <li> block until signalled.\n        * <li> reacquire by invoking specialized version of\n        *      {@link #acquire} with saved state as argument.\n        * </ol>\n        */\n    // 等待，当前线程在接到信号之前一直处于等待状态，不响应中断\n    public final void awaituninterruptibly() {\n        // 添加一个结点到等待队列\n        node node = addconditionwaiter();\n        // 获取释放的状态\n        int savedstate = fullyrelease(node);\n        boolean interrupted = false;\n        while (!isonsyncqueue(node)) { // \n            // 阻塞当前线程\n            locksupport.park(this);\n            if (thread.interrupted()) // 当前线程被中断\n                // 设置interrupted状态\n                interrupted = true; \n        }\n        if (acquirequeued(node, savedstate) || interrupted) // \n            selfinterrupt();\n    }\n\n    /*\n        * for interruptible waits, we need to track whether to throw\n        * interruptedexception, if interrupted while blocked on\n        * condition, versus reinterrupt current thread, if\n        * interrupted while blocked waiting to re-acquire.\n        */\n\n    /** mode meaning to reinterrupt on exit from wait */\n    private static final int reinterrupt =  1;\n    /** mode meaning to throw interruptedexception on exit from wait */\n    private static final int throw_ie    = -1;\n\n    /**\n        * checks for interrupt, returning throw_ie if interrupted\n        * before signalled, reinterrupt if after signalled, or\n        * 0 if not interrupted.\n        */\n    private int checkinterruptwhilewaiting(node node) {\n        return thread.interrupted() ?\n            (transferaftercancelledwait(node) ? throw_ie : reinterrupt) :\n            0; \n    }\n\n    /**\n        * throws interruptedexception, reinterrupts current thread, or\n        * does nothing, depending on mode.\n        */\n    private void reportinterruptafterwait(int interruptmode)\n        throws interruptedexception {\n        if (interruptmode == throw_ie)\n            throw new interruptedexception();\n        else if (interruptmode == reinterrupt)\n            selfinterrupt();\n    }\n\n    /**\n        * implements interruptible condition wait.\n        * <ol>\n        * <li> if current thread is interrupted, throw interruptedexception.\n        * <li> save lock state returned by {@link #getstate}.\n        * <li> invoke {@link #release} with saved state as argument,\n        *      throwing illegalmonitorstateexception if it fails.\n        * <li> block until signalled or interrupted.\n        * <li> reacquire by invoking specialized version of\n        *      {@link #acquire} with saved state as argument.\n        * <li> if interrupted while blocked in step 4, throw interruptedexception.\n        * </ol>\n        */\n    // // 等待，当前线程在接到信号或被中断之前一直处于等待状态\n    public final void await() throws interruptedexception {\n        if (thread.interrupted()) // 当前线程被中断，抛出异常\n            throw new interruptedexception();\n        // 在wait队列上添加一个结点\n        node node = addconditionwaiter();\n        // \n        int savedstate = fullyrelease(node);\n        int interruptmode = 0;\n        while (!isonsyncqueue(node)) {\n            // 阻塞当前线程\n            locksupport.park(this);\n            if ((interruptmode = checkinterruptwhilewaiting(node)) != 0) // 检查结点等待时的中断类型\n                break;\n        }\n        if (acquirequeued(node, savedstate) && interruptmode != throw_ie)\n            interruptmode = reinterrupt;\n        if (node.nextwaiter != null) // clean up if cancelled\n            unlinkcancelledwaiters();\n        if (interruptmode != 0)\n            reportinterruptafterwait(interruptmode);\n    }\n\n    /**\n        * implements timed condition wait.\n        * <ol>\n        * <li> if current thread is interrupted, throw interruptedexception.\n        * <li> save lock state returned by {@link #getstate}.\n        * <li> invoke {@link #release} with saved state as argument,\n        *      throwing illegalmonitorstateexception if it fails.\n        * <li> block until signalled, interrupted, or timed out.\n        * <li> reacquire by invoking specialized version of\n        *      {@link #acquire} with saved state as argument.\n        * <li> if interrupted while blocked in step 4, throw interruptedexception.\n        * </ol>\n        */\n    // 等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态 \n    public final long awaitnanos(long nanostimeout)\n            throws interruptedexception {\n        if (thread.interrupted())\n            throw new interruptedexception();\n        node node = addconditionwaiter();\n        int savedstate = fullyrelease(node);\n        final long deadline = system.nanotime() + nanostimeout;\n        int interruptmode = 0;\n        while (!isonsyncqueue(node)) {\n            if (nanostimeout <= 0l) {\n                transferaftercancelledwait(node);\n                break;\n            }\n            if (nanostimeout >= spinfortimeoutthreshold)\n                locksupport.parknanos(this, nanostimeout);\n            if ((interruptmode = checkinterruptwhilewaiting(node)) != 0)\n                break;\n            nanostimeout = deadline - system.nanotime();\n        }\n        if (acquirequeued(node, savedstate) && interruptmode != throw_ie)\n            interruptmode = reinterrupt;\n        if (node.nextwaiter != null)\n            unlinkcancelledwaiters();\n        if (interruptmode != 0)\n            reportinterruptafterwait(interruptmode);\n        return deadline - system.nanotime();\n    }\n\n    /**\n        * implements absolute timed condition wait.\n        * <ol>\n        * <li> if current thread is interrupted, throw interruptedexception.\n        * <li> save lock state returned by {@link #getstate}.\n        * <li> invoke {@link #release} with saved state as argument,\n        *      throwing illegalmonitorstateexception if it fails.\n        * <li> block until signalled, interrupted, or timed out.\n        * <li> reacquire by invoking specialized version of\n        *      {@link #acquire} with saved state as argument.\n        * <li> if interrupted while blocked in step 4, throw interruptedexception.\n        * <li> if timed out while blocked in step 4, return false, else true.\n        * </ol>\n        */\n    // 等待，当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态\n    public final boolean awaituntil(date deadline)\n            throws interruptedexception {\n        long abstime = deadline.gettime();\n        if (thread.interrupted())\n            throw new interruptedexception();\n        node node = addconditionwaiter();\n        int savedstate = fullyrelease(node);\n        boolean timedout = false;\n        int interruptmode = 0;\n        while (!isonsyncqueue(node)) {\n            if (system.currenttimemillis() > abstime) {\n                timedout = transferaftercancelledwait(node);\n                break;\n            }\n            locksupport.parkuntil(this, abstime);\n            if ((interruptmode = checkinterruptwhilewaiting(node)) != 0)\n                break;\n        }\n        if (acquirequeued(node, savedstate) && interruptmode != throw_ie)\n            interruptmode = reinterrupt;\n        if (node.nextwaiter != null)\n            unlinkcancelledwaiters();\n        if (interruptmode != 0)\n            reportinterruptafterwait(interruptmode);\n        return !timedout;\n    }\n\n    /**\n        * implements timed condition wait.\n        * <ol>\n        * <li> if current thread is interrupted, throw interruptedexception.\n        * <li> save lock state returned by {@link #getstate}.\n        * <li> invoke {@link #release} with saved state as argument,\n        *      throwing illegalmonitorstateexception if it fails.\n        * <li> block until signalled, interrupted, or timed out.\n        * <li> reacquire by invoking specialized version of\n        *      {@link #acquire} with saved state as argument.\n        * <li> if interrupted while blocked in step 4, throw interruptedexception.\n        * <li> if timed out while blocked in step 4, return false, else true.\n        * </ol>\n        */\n    // 等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。此方法在行为上等效于: awaitnanos(unit.tonanos(time)) > 0\n    public final boolean await(long time, timeunit unit)\n            throws interruptedexception {\n        long nanostimeout = unit.tonanos(time);\n        if (thread.interrupted())\n            throw new interruptedexception();\n        node node = addconditionwaiter();\n        int savedstate = fullyrelease(node);\n        final long deadline = system.nanotime() + nanostimeout;\n        boolean timedout = false;\n        int interruptmode = 0;\n        while (!isonsyncqueue(node)) {\n            if (nanostimeout <= 0l) {\n                timedout = transferaftercancelledwait(node);\n                break;\n            }\n            if (nanostimeout >= spinfortimeoutthreshold)\n                locksupport.parknanos(this, nanostimeout);\n            if ((interruptmode = checkinterruptwhilewaiting(node)) != 0)\n                break;\n            nanostimeout = deadline - system.nanotime();\n        }\n        if (acquirequeued(node, savedstate) && interruptmode != throw_ie)\n            interruptmode = reinterrupt;\n        if (node.nextwaiter != null)\n            unlinkcancelledwaiters();\n        if (interruptmode != 0)\n            reportinterruptafterwait(interruptmode);\n        return !timedout;\n    }\n\n    //  support for instrumentation\n\n    /**\n        * returns true if this condition was created by the given\n        * synchronization object.\n        *\n        * @return {@code true} if owned\n        */\n    final boolean isownedby(abstractqueuedsynchronizer sync) {\n        return sync == abstractqueuedsynchronizer.this;\n    }\n\n    /**\n        * queries whether any threads are waiting on this condition.\n        * implements {@link abstractqueuedsynchronizer#haswaiters(conditionobject)}.\n        *\n        * @return {@code true} if there are any waiting threads\n        * @throws illegalmonitorstateexception if {@link #isheldexclusively}\n        *         returns {@code false}\n        */\n    //  查询是否有正在等待此条件的任何线程\n    protected final boolean haswaiters() {\n        if (!isheldexclusively())\n            throw new illegalmonitorstateexception();\n        for (node w = firstwaiter; w != null; w = w.nextwaiter) {\n            if (w.waitstatus == node.condition)\n                return true;\n        }\n        return false;\n    }\n\n    /**\n        * returns an estimate of the number of threads waiting on\n        * this condition.\n        * implements {@link abstractqueuedsynchronizer#getwaitqueuelength(conditionobject)}.\n        *\n        * @return the estimated number of waiting threads\n        * @throws illegalmonitorstateexception if {@link #isheldexclusively}\n        *         returns {@code false}\n        */\n    // 返回正在等待此条件的线程数估计值\n    protected final int getwaitqueuelength() {\n        if (!isheldexclusively())\n            throw new illegalmonitorstateexception();\n        int n = 0;\n        for (node w = firstwaiter; w != null; w = w.nextwaiter) {\n            if (w.waitstatus == node.condition)\n                ++n;\n        }\n        return n;\n    }\n\n    /**\n        * returns a collection containing those threads that may be\n        * waiting on this condition.\n        * implements {@link abstractqueuedsynchronizer#getwaitingthreads(conditionobject)}.\n        *\n        * @return the collection of threads\n        * @throws illegalmonitorstateexception if {@link #isheldexclusively}\n        *         returns {@code false}\n        */\n    // 返回包含那些可能正在等待此条件的线程集合\n    protected final collection<thread> getwaitingthreads() {\n        if (!isheldexclusively())\n            throw new illegalmonitorstateexception();\n        arraylist<thread> list = new arraylist<thread>();\n        for (node w = firstwaiter; w != null; w = w.nextwaiter) {\n            if (w.waitstatus == node.condition) {\n                thread t = w.thread;\n                if (t != null)\n                    list.add(t);\n            }\n        }\n        return list;\n    }\n}\n\n\n此类实现了condition接口，condition接口定义了条件操作规范，具体如下\n\npublic interface condition {\n\n    // 等待，当前线程在接到信号或被中断之前一直处于等待状态\n    void await() throws interruptedexception;\n    \n    // 等待，当前线程在接到信号之前一直处于等待状态，不响应中断\n    void awaituninterruptibly();\n    \n    //等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态 \n    long awaitnanos(long nanostimeout) throws interruptedexception;\n    \n    // 等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。此方法在行为上等效于: awaitnanos(unit.tonanos(time)) > 0\n    boolean await(long time, timeunit unit) throws interruptedexception;\n    \n    // 等待，当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态\n    boolean awaituntil(date deadline) throws interruptedexception;\n    \n    // 唤醒一个等待线程。如果所有的线程都在等待此条件，则选择其中的一个唤醒。在从 await 返回之前，该线程必须重新获取锁。\n    void signal();\n    \n    // 唤醒所有等待线程。如果所有的线程都在等待此条件，则唤醒所有线程。在从 await 返回之前，每个线程都必须重新获取锁。\n    void signalall();\n}\n\n\ncondition接口中定义了await、signal方法，用来等待条件、释放条件。之后会详细分析condtionobject的源码。\n\n\n# 类的属性\n\n属性中包含了头节点head，尾结点tail，状态state、自旋时间spinfortimeoutthreshold，还有abstractqueuedsynchronizer抽象的属性在内存中的偏移地址，通过该偏移地址，可以获取和设置该属性的值，同时还包括一个静态初始化块，用于加载内存偏移地址。\n\npublic abstract class abstractqueuedsynchronizer extends abstractownablesynchronizer\n    implements java.io.serializable {    \n    // 版本号\n    private static final long serialversionuid = 7373984972572414691l;    \n    // 头节点\n    private transient volatile node head;    \n    // 尾结点\n    private transient volatile node tail;    \n    // 状态\n    private volatile int state;    \n    // 自旋时间\n    static final long spinfortimeoutthreshold = 1000l;\n    \n    // unsafe类实例\n    private static final unsafe unsafe = unsafe.getunsafe();\n    // state内存偏移地址\n    private static final long stateoffset;\n    // head内存偏移地址\n    private static final long headoffset;\n    // state内存偏移地址\n    private static final long tailoffset;\n    // tail内存偏移地址\n    private static final long waitstatusoffset;\n    // next内存偏移地址\n    private static final long nextoffset;\n    // 静态初始化块\n    static {\n        try {\n            stateoffset = unsafe.objectfieldoffset\n                (abstractqueuedsynchronizer.class.getdeclaredfield("state"));\n            headoffset = unsafe.objectfieldoffset\n                (abstractqueuedsynchronizer.class.getdeclaredfield("head"));\n            tailoffset = unsafe.objectfieldoffset\n                (abstractqueuedsynchronizer.class.getdeclaredfield("tail"));\n            waitstatusoffset = unsafe.objectfieldoffset\n                (node.class.getdeclaredfield("waitstatus"));\n            nextoffset = unsafe.objectfieldoffset\n                (node.class.getdeclaredfield("next"));\n\n        } catch (exception ex) { throw new error(ex); }\n    }\n}\n\n\n\n# 类的构造方法\n\n此类构造方法为从抽象构造方法，供子类调用。\n\nprotected abstractqueuedsynchronizer() { }    \n\n\n\n# 类的核心方法 - acquire方法\n\n该方法以独占模式获取(资源)，忽略中断，即线程在aquire过程中，中断此线程是无效的。源码如下:\n\npublic final void acquire(int arg) {\n    if (!tryacquire(arg) && acquirequeued(addwaiter(node.exclusive), arg))\n        selfinterrupt();\n}\n\n\n由上述源码可以知道，当一个线程调用acquire时，调用方法流程如下\n\n\n\n * 首先调用tryacquire方法，调用此方法的线程会试图在独占模式下获取对象状态。此方法应该查询是否允许它在独占模式下获取对象状态，如果允许，则获取它。在abstractqueuedsynchronizer源码中默认会抛出一个异常，即需要子类去重写此方法完成自己的逻辑。之后会进行分析。\n\n * 若tryacquire失败，则调用addwaiter方法，addwaiter方法完成的功能是将调用此方法的线程封装成为一个结点并放入sync queue。\n\n * 调用acquirequeued方法，此方法完成的功能是sync queue中的结点不断尝试获取资源，若成功，则返回true，否则，返回false。\n\n * 由于tryacquire默认实现是抛出异常，所以此时，不进行分析，之后会结合一个例子进行分析。\n\n首先分析addwaiter方法\n\n// 添加等待者\nprivate node addwaiter(node mode) {\n    // 新生成一个结点，默认为独占模式\n    node node = new node(thread.currentthread(), mode);\n    // try the fast path of enq; backup to full enq on failure\n    // 保存尾结点\n    node pred = tail;\n    if (pred != null) { // 尾结点不为空，即已经被初始化\n        // 将node结点的prev域连接到尾结点\n        node.prev = pred; \n        if (compareandsettail(pred, node)) { // 比较pred是否为尾结点，是则将尾结点设置为node \n            // 设置尾结点的next域为node\n            pred.next = node;\n            return node; // 返回新生成的结点\n        }\n    }\n    enq(node); // 尾结点为空(即还没有被初始化过)，或者是compareandsettail操作失败，则入队列\n    return node;\n}\n\n\naddwaiter方法使用快速添加的方式往sync queue尾部添加结点，如果sync queue队列还没有初始化，则会使用enq插入队列中，enq方法源码如下\n\nprivate node enq(final node node) {\n    for (;;) { // 无限循环，确保结点能够成功入队列\n        // 保存尾结点\n        node t = tail;\n        if (t == null) { // 尾结点为空，即还没被初始化\n            if (compareandsethead(new node())) // 头节点为空，并设置头节点为新生成的结点\n                tail = head; // 头节点与尾结点都指向同一个新生结点\n        } else { // 尾结点不为空，即已经被初始化过\n            // 将node结点的prev域连接到尾结点\n            node.prev = t; \n            if (compareandsettail(t, node)) { // 比较结点t是否为尾结点，若是则将尾结点设置为node\n                // 设置尾结点的next域为node\n                t.next = node; \n                return t; // 返回尾结点\n            }\n        }\n    }\n}\n\n\nenq方法会使用无限循环来确保节点的成功插入。\n\n现在，分析acquirequeue方法。其源码如下\n\n// sync队列中的结点在独占且忽略中断的模式下获取(资源)\nfinal boolean acquirequeued(final node node, int arg) {\n    // 标志\n    boolean failed = true;\n    try {\n        // 中断标志\n        boolean interrupted = false;\n        for (;;) { // 无限循环\n            // 获取node节点的前驱结点\n            final node p = node.predecessor(); \n            if (p == head && tryacquire(arg)) { // 前驱为头节点并且成功获得锁\n                sethead(node); // 设置头节点\n                p.next = null; // help gc\n                failed = false; // 设置标志\n                return interrupted; \n            }\n            if (shouldparkafterfailedacquire(p, node) &&\n                parkandcheckinterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelacquire(node);\n    }\n}\n\n\n首先获取当前节点的前驱节点，如果前驱节点是头节点并且能够获取(资源)，代表该当前节点能够占有锁，设置头节点为当前节点，返回。否则，调用shouldparkafterfailedacquire和parkandcheckinterrupt方法，首先，我们看shouldparkafterfailedacquire方法，代码如下\n\n// 当获取(资源)失败后，检查并且更新结点状态\nprivate static boolean shouldparkafterfailedacquire(node pred, node node) {\n    // 获取前驱结点的状态\n    int ws = pred.waitstatus;\n    if (ws == node.signal) // 状态为signal，为-1\n        /*\n            * this node has already set status asking a release\n            * to signal it, so it can safely park.\n            */\n        // 可以进行park操作\n        return true; \n    if (ws > 0) { // 表示状态为cancelled，为1\n        /*\n            * predecessor was cancelled. skip over predecessors and\n            * indicate retry.\n            */\n        do {\n            node.prev = pred = pred.prev;\n        } while (pred.waitstatus > 0); // 找到pred结点前面最近的一个状态不为cancelled的结点\n        // 赋值pred结点的next域\n        pred.next = node; \n    } else { // 为propagate -3 或者是0 表示无状态,(为condition -2时，表示此节点在condition queue中) \n        /*\n            * waitstatus must be 0 or propagate.  indicate that we\n            * need a signal, but don\'t park yet.  caller will need to\n            * retry to make sure it cannot acquire before parking.\n            */\n        // 比较并设置前驱结点的状态为signal\n        compareandsetwaitstatus(pred, ws, node.signal); \n    }\n    // 不能进行park操作\n    return false;\n}\n\n\n只有当该节点的前驱结点的状态为signal时，才可以对该结点所封装的线程进行park操作。否则，将不能进行park操作。再看parkandcheckinterrupt方法，源码如下\n\n// 进行park操作并且返回该线程是否被中断\nprivate final boolean parkandcheckinterrupt() {\n    // 在许可可用之前禁用当前线程，并且设置了blocker\n    locksupport.park(this);\n    return thread.interrupted(); // 当前线程是否已被中断，并清除中断标记位\n}\n\n\nparkandcheckinterrupt方法里的逻辑是首先执行park操作，即禁用当前线程，然后返回该线程是否已经被中断。再看final块中的cancelacquire方法，其源码如下\n\n// 取消继续获取(资源)\nprivate void cancelacquire(node node) {\n    // ignore if node doesn\'t exist\n    // node为空，返回\n    if (node == null)\n        return;\n    // 设置node结点的thread为空\n    node.thread = null;\n\n    // skip cancelled predecessors\n    // 保存node的前驱结点\n    node pred = node.prev;\n    while (pred.waitstatus > 0) // 找到node前驱结点中第一个状态小于0的结点，即不为cancelled状态的结点\n        node.prev = pred = pred.prev;\n\n    // prednext is the apparent node to unsplice. cases below will\n    // fail if not, in which case, we lost race vs another cancel\n    // or signal, so no further action is necessary.\n    // 获取pred结点的下一个结点\n    node prednext = pred.next;\n\n    // can use unconditional write instead of cas here.\n    // after this atomic step, other nodes can skip past us.\n    // before, we are free of interference from other threads.\n    // 设置node结点的状态为cancelled\n    node.waitstatus = node.cancelled;\n\n    // if we are the tail, remove ourselves.\n    if (node == tail && compareandsettail(node, pred)) { // node结点为尾结点，则设置尾结点为pred结点\n        // 比较并设置pred结点的next节点为null\n        compareandsetnext(pred, prednext, null); \n    } else { // node结点不为尾结点，或者比较设置不成功\n        // if successor needs signal, try to set pred\'s next-link\n        // so it will get one. otherwise wake it up to propagate.\n        int ws;\n        if (pred != head &&\n            ((ws = pred.waitstatus) == node.signal ||\n                (ws <= 0 && compareandsetwaitstatus(pred, ws, node.signal))) &&\n            pred.thread != null) { // (pred结点不为头节点，并且pred结点的状态为signal)或者 \n                                // pred结点状态小于等于0，并且比较并设置等待状态为signal成功，并且pred结点所封装的线程不为空\n            // 保存结点的后继\n            node next = node.next;\n            if (next != null && next.waitstatus <= 0) // 后继不为空并且后继的状态小于等于0\n                compareandsetnext(pred, prednext, next); // 比较并设置pred.next = next;\n        } else {\n            unparksuccessor(node); // 释放node的前一个结点\n        }\n\n        node.next = node; // help gc\n    }\n}\n\n\n该方法完成的功能就是取消当前线程对资源的获取，即设置该结点的状态为cancelled，接着我们再看unparksuccessor方法，源码如下\n\n// 释放后继结点\nprivate void unparksuccessor(node node) {\n    /*\n        * if status is negative (i.e., possibly needing signal) try\n        * to clear in anticipation of signalling.  it is ok if this\n        * fails or if status is changed by waiting thread.\n        */\n    // 获取node结点的等待状态\n    int ws = node.waitstatus;\n    if (ws < 0) // 状态值小于0，为signal -1 或 condition -2 或 propagate -3\n        // 比较并且设置结点等待状态，设置为0\n        compareandsetwaitstatus(node, ws, 0);\n\n    /*\n        * thread to unpark is held in successor, which is normally\n        * just the next node.  but if cancelled or apparently null,\n        * traverse backwards from tail to find the actual\n        * non-cancelled successor.\n        */\n    // 获取node节点的下一个结点\n    node s = node.next;\n    if (s == null || s.waitstatus > 0) { // 下一个结点为空或者下一个节点的等待状态大于0，即为cancelled\n        // s赋值为空\n        s = null; \n        // 从尾结点开始从后往前开始遍历\n        for (node t = tail; t != null && t != node; t = t.prev)\n            if (t.waitstatus <= 0) // 找到等待状态小于等于0的结点，找到最前的状态小于等于0的结点\n                // 保存结点\n                s = t;\n    }\n    if (s != null) // 该结点不为为空，释放许可\n        locksupport.unpark(s.thread);\n}\n\n\n该方法的作用就是为了释放node节点的后继结点。\n\n对于cancelacquire与unparksuccessor方法，如下示意图可以清晰的表示:\n\n\n\n其中node为参数，在执行完cancelacquire方法后的效果就是unpark了s结点所包含的t4线程。\n\n现在，再来看acquirequeued方法的整个的逻辑。逻辑如下:\n\n * 判断结点的前驱是否为head并且是否成功获取(资源)。\n * 若步骤1均满足，则设置结点为head，之后会判断是否finally模块，然后返回。\n * 若步骤2不满足，则判断是否需要park当前线程，是否需要park当前线程的逻辑是判断结点的前驱结点的状态是否为signal，若是，则park当前结点，否则，不进行park操作。\n * 若park了当前线程，之后某个线程对本线程unpark后，并且本线程也获得机会运行。那么，将会继续进行步骤①的判断。\n\n\n# 类的核心方法 - release方法\n\n以独占模式释放对象，其源码如下:\n\npublic final boolean release(int arg) {\n    if (tryrelease(arg)) { // 释放成功\n        // 保存头节点\n        node h = head; \n        if (h != null && h.waitstatus != 0) // 头节点不为空并且头节点状态不为0\n            unparksuccessor(h); //释放头节点的后继结点\n        return true;\n    }\n    return false;\n}\n\n\n其中，tryrelease的默认实现是抛出异常，需要具体的子类实现，如果tryrelease成功，那么如果头节点不为空并且头节点的状态不为0，则释放头节点的后继结点，unparksuccessor方法已经分析过，不再累赘。\n\n对于其他方法我们也可以分析，与前面分析的方法大同小异，所以，不再累赘。\n\n\n# abstractqueuedsynchronizer示例详解一\n\n借助下面示例来分析abstractqueuedsyncrhonizer内部的工作机制。示例源码如下\n\nimport java.util.concurrent.locks.lock;\nimport java.util.concurrent.locks.reentrantlock;\n\nclass mythread extends thread {\n    private lock lock;\n    public mythread(string name, lock lock) {\n        super(name);\n        this.lock = lock;\n    }\n    \n    public void run () {\n        lock.lock();\n        try {\n            system.out.println(thread.currentthread() + " running");\n        } finally {\n            lock.unlock();\n        }\n    }\n}\npublic class abstractqueuedsynchronizerdemo {\n    public static void main(string[] args) {\n        lock lock = new reentrantlock();\n        \n        mythread t1 = new mythread("t1", lock);\n        mythread t2 = new mythread("t2", lock);\n        t1.start();\n        t2.start();    \n    }\n}\n\n\n运行结果(可能的一种):\n\nthread[t1,5,main] running\nthread[t2,5,main] running\n\n\n结果分析: 从示例可知，线程t1与t2共用了一把锁，即同一个lock。可能会存在如下一种时序。\n\n\n\n说明: 首先线程t1先执行lock.lock操作，然后t2执行lock.lock操作，然后t1执行lock.unlock操作，最后t2执行lock.unlock操作。基于这样的时序，分析abstractqueuedsynchronizer内部的工作机制。\n\n * t1线程调用lock.lock方法，其方法调用顺序如下，只给出了主要的方法调用。\n\n\n\n说明: 其中，前面的部分表示哪个类，后面是具体的类中的哪个方法，aqs表示abstractqueuedsynchronizer类，aos表示abstractownablesynchronizer类。\n\n * t2线程调用lock.lock方法，其方法调用顺序如下，只给出了主要的方法调用。\n\n\n\n说明: 经过一系列的方法调用，最后达到的状态是禁用t2线程，因为调用了locksupport.park。\n\n * t1线程调用lock.unlock，其方法调用顺序如下，只给出了主要的方法调用。\n\n\n\n说明: t1线程中调用lock.unlock后，经过一系列的调用，最终的状态是释放了许可，因为调用了locksupport.unpark。这时，t2线程就可以继续运行了。此时，会继续恢复t2线程运行环境，继续执行locksupport.park后面的语句，即进一步调用如下。\n\n\n\n说明: 在上一步调用了locksupport.unpark后，t2线程恢复运行，则运行parkandcheckinterrupt，之后，继续运行acquirequeued方法，最后达到的状态是头节点head与尾结点tail均指向了t2线程所在的结点，并且之前的头节点已经从sync队列中断开了。\n\n * t2线程调用lock.unlock，其方法调用顺序如下，只给出了主要的方法调用。\n\n\n\n说明: t2线程执行lock.unlock后，最终达到的状态还是与之前的状态一样。\n\n\n# abstractqueuedsynchronizer示例详解二\n\n下面我们结合condition实现生产者与消费者，来进一步分析abstractqueuedsynchronizer的内部工作机制。\n\n * depot(仓库)类\n\nimport java.util.concurrent.locks.condition;\nimport java.util.concurrent.locks.lock;\nimport java.util.concurrent.locks.reentrantlock;\n\npublic class depot {\n    private int size;\n    private int capacity;\n    private lock lock;\n    private condition fullcondition;\n    private condition emptycondition;\n    \n    public depot(int capacity) {\n        this.capacity = capacity;    \n        lock = new reentrantlock();\n        fullcondition = lock.newcondition();\n        emptycondition = lock.newcondition();\n    }\n    \n    public void produce(int no) {\n        lock.lock();\n        int left = no;\n        try {\n            while (left > 0) {\n                while (size >= capacity)  {\n                    system.out.println(thread.currentthread() + " before await");\n                    fullcondition.await();\n                    system.out.println(thread.currentthread() + " after await");\n                }\n                int inc = (left + size) > capacity ? (capacity - size) : left;\n                left -= inc;\n                size += inc;\n                system.out.println("produce = " + inc + ", size = " + size);\n                emptycondition.signal();\n            }\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n    \n    public void consume(int no) {\n        lock.lock();\n        int left = no;\n        try {            \n            while (left > 0) {\n                while (size <= 0) {\n                    system.out.println(thread.currentthread() + " before await");\n                    emptycondition.await();\n                    system.out.println(thread.currentthread() + " after await");\n                }\n                int dec = (size - left) > 0 ? left : size;\n                left -= dec;\n                size -= dec;\n                system.out.println("consume = " + dec + ", size = " + size);\n                fullcondition.signal();\n            }\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\n\n * 测试类\n\nclass consumer {\n    private depot depot;\n    public consumer(depot depot) {\n        this.depot = depot;\n    }\n    \n    public void consume(int no) {\n        new thread(new runnable() {\n            @override\n            public void run() {\n                depot.consume(no);\n            }\n        }, no + " consume thread").start();\n    }\n}\n\nclass producer {\n    private depot depot;\n    public producer(depot depot) {\n        this.depot = depot;\n    }\n    \n    public void produce(int no) {\n        new thread(new runnable() {\n            \n            @override\n            public void run() {\n                depot.produce(no);\n            }\n        }, no + " produce thread").start();\n    }\n}\n\npublic class reentrantlockdemo {\n    public static void main(string[] args) throws interruptedexception {\n        depot depot = new depot(500);\n        new producer(depot).produce(500);\n        new producer(depot).produce(200);\n        new consumer(depot).consume(500);\n        new consumer(depot).consume(200);\n    }\n}\n\n\n * 运行结果(可能的一种):\n\nproduce = 500, size = 500\nthread[200 produce thread,5,main] before await\nconsume = 500, size = 0\nthread[200 consume thread,5,main] before await\nthread[200 produce thread,5,main] after await\nproduce = 200, size = 200\nthread[200 consume thread,5,main] after await\nconsume = 200, size = 0\n\n\n说明: 根据结果，我们猜测一种可能的时序如下\n\n\n\n说明: p1代表produce 500的那个线程，p2代表produce 200的那个线程，c1代表consume 500的那个线程，c2代表consume 200的那个线程。\n\n * p1线程调用lock.lock，获得锁，继续运行，方法调用顺序在前面已经给出。\n * p2线程调用lock.lock，由前面的分析可得到如下的最终状态。\n\n\n\n说明: p2线程调用lock.lock后，会禁止p2线程的继续运行，因为执行了locksupport.park操作。\n\n * c1线程调用lock.lock，由前面的分析得到如下的最终状态。\n\n\n\n说明: 最终c1线程会在sync queue队列的尾部，并且其结点的前驱结点(包含p2的结点)的waitstatus变为了signal。\n\n * c2线程调用lock.lock，由前面的分析得到如下的最终状态。\n\n\n\n说明: 最终c1线程会在sync queue队列的尾部，并且其结点的前驱结点(包含c1的结点)的waitstatus变为了signal。\n\n * p1线程执行emptycondition.signal，其方法调用顺序如下，只给出了主要的方法调用。\n\n\n\n说明: aqs.co表示abstractqueuedsynchronizer.conditionobject类。此时调用signal方法不会产生任何其他效果。\n\n * p1线程执行lock.unlock，根据前面的分析可知，最终的状态如下。\n\n\n\n说明: 此时，p2线程所在的结点为头节点，并且其他两个线程(c1、c2)依旧被禁止，所以，此时p2线程继续运行，执行用户逻辑。\n\n * p2线程执行fullcondition.await，其方法调用顺序如下，只给出了主要的方法调用。\n\n\n\n说明: 最终到达的状态是新生成了一个结点，包含了p2线程，此结点在condition queue中；并且sync queue中p2线程被禁止了，因为在执行了locksupport.park操作。从方法一些调用可知，在await操作中线程会释放锁资源，供其他线程获取。同时，head结点后继结点的包含的线程的许可被释放了，故其可以继续运行。由于此时，只有c1线程可以运行，故运行c1。\n\n * 继续运行c1线程，c1线程由于之前被park了，所以此时恢复，继续之前的步骤，即还是执行前面提到的acquirequeued方法，之后，c1判断自己的前驱结点为head，并且可以获取锁资源，最终到达的状态如下。\n\n\n\n说明: 其中，head设置为包含c1线程的结点，c1继续运行。\n\n * c1线程执行fullcondtion.signal，其方法调用顺序如下，只给出了主要的方法调用。\n\n\n\n说明: signal方法达到的最终结果是将包含p2线程的结点从condition queue中转移到sync queue中，之后condition queue为null，之前的尾结点的状态变为signal。\n\n * c1线程执行lock.unlock操作，根据之前的分析，经历的状态变化如下。\n\n\n\n说明: 最终c2线程会获取锁资源，继续运行用户逻辑。\n\n * c2线程执行emptycondition.await，由前面的第七步分析，可知最终的状态如下。\n\n\n\n说明: await操作将会生成一个结点放入condition queue中与之前的一个condition queue是不相同的，并且unpark头节点后面的结点，即包含线程p2的结点。\n\n * p2线程被unpark，故可以继续运行，经过cpu调度后，p2继续运行，之后p2线程在aqs:await方法中被park，继续aqs.co:await方法的运行，其方法调用顺序如下，只给出了主要的方法调用。\n\n\n\n * p2继续运行，执行emptycondition.signal，根据第九步分析可知，最终到达的状态如下。\n\n\n\n说明: 最终，将condition queue中的结点转移到sync queue中，并添加至尾部，condition queue会为空，并且将head的状态设置为signal。\n\n * p2线程执行lock.unlock操作，根据前面的分析可知，最后的到达的状态如下。\n\n\n\n说明: unlock操作会释放c2线程的许可，并且将头节点设置为c2线程所在的结点。\n\n * c2线程继续运行，执行fullcondition. signal，由于此时fullcondition的condition queue已经不存在任何结点了，故其不会产生作用。\n\n * c2执行lock.unlock，由于c2是sync队列中最后一个结点，故其不会再调用unparksuccessor了，直接返回true。即整个流程就完成了。\n\n\n# abstractqueuedsynchronizer总结\n\n对于abstractqueuedsynchronizer的分析，最核心的就是sync queue的分析。\n\n * 每一个结点都是由前一个结点唤醒\n * 当结点发现前驱结点是head并且尝试获取成功，则会轮到该线程运行。\n * condition queue中的结点向sync queue中转移是通过signal操作完成的。\n * 当结点的状态为signal时，表示后面的结点需要运行。\n\n\n# 参考文章\n\n * 文章主要参考自leesf的https://www.cnblogs.com/leesf456/p/5350186.html，在此基础上做了增改。\n * http://ifeve.com/introduce-abstractqueuedsynchronizer/\n * http://blog.csdn.net/chen77716/article/details/6641477\n * https://blog.csdn.net/mulinsen77/article/details/84583716\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-lock-abstractqueuedsynchronizer.html',charsets:{cjk:!0}},{title:"JUC锁: ReentrantReadWriteLock详解",frontmatter:{},regularPath:"/java/thread/java-thread-x-lock-ReentrantReadWriteLock.html",relativePath:"java/thread/java-thread-x-lock-ReentrantReadWriteLock.md",key:"v-a53cce24",path:"/java/thread/java-thread-x-lock-ReentrantReadWriteLock.html",headers:[{level:2,title:"JUC锁: ReentrantReadWriteLock详解",slug:"juc锁-reentrantreadwritelock详解",normalizedTitle:"juc锁: reentrantreadwritelock详解",charIndex:2},{level:2,title:"带着BAT大厂的面试问题去理解",slug:"带着bat大厂的面试问题去理解",normalizedTitle:"带着bat大厂的面试问题去理解",charIndex:178},{level:2,title:"ReentrantReadWriteLock数据结构",slug:"reentrantreadwritelock数据结构",normalizedTitle:"reentrantreadwritelock数据结构",charIndex:199},{level:2,title:"ReentrantReadWriteLock源码分析",slug:"reentrantreadwritelock源码分析",normalizedTitle:"reentrantreadwritelock源码分析",charIndex:231},{level:3,title:"类的继承关系",slug:"类的继承关系",normalizedTitle:"类的继承关系",charIndex:265},{level:3,title:"类的内部类",slug:"类的内部类",normalizedTitle:"类的内部类",charIndex:279},{level:3,title:"内部类 - Sync类",slug:"内部类-sync类",normalizedTitle:"内部类 - sync类",charIndex:292},{level:3,title:"内部类 - Sync核心函数分析",slug:"内部类-sync核心函数分析",normalizedTitle:"内部类 - sync核心函数分析",charIndex:311},{level:3,title:"类的属性",slug:"类的属性",normalizedTitle:"类的属性",charIndex:335},{level:3,title:"类的构造函数",slug:"类的构造函数",normalizedTitle:"类的构造函数",charIndex:347},{level:3,title:"核心函数分析",slug:"核心函数分析",normalizedTitle:"核心函数分析",charIndex:321},{level:2,title:"ReentrantReadWriteLock示例",slug:"reentrantreadwritelock示例",normalizedTitle:"reentrantreadwritelock示例",charIndex:373},{level:2,title:"更深入理解",slug:"更深入理解",normalizedTitle:"更深入理解",charIndex:403},{level:3,title:"什么是锁升降级?",slug:"什么是锁升降级",normalizedTitle:"什么是锁升降级?",charIndex:416},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:430}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"JUC锁: ReentrantReadWriteLock详解 带着BAT大厂的面试问题去理解 ReentrantReadWriteLock数据结构 ReentrantReadWriteLock源码分析 类的继承关系 类的内部类 内部类 - Sync类 内部类 - Sync核心函数分析 类的属性 类的构造函数 核心函数分析 ReentrantReadWriteLock示例 更深入理解 什么是锁升降级? 参考文章",content:'# JUC锁: ReentrantReadWriteLock详解\n\n> ReentrantReadWriteLock表示可重入读写锁，ReentrantReadWriteLock中包含了两种锁，读锁ReadLock和写锁WriteLock，可以通过这两种锁实现线程间的同步。\n\n * JUC锁: ReentrantReadWriteLock详解\n   * 带着BAT大厂的面试问题去理解\n   * ReentrantReadWriteLock数据结构\n   * ReentrantReadWriteLock源码分析\n     * 类的继承关系\n     * 类的内部类\n     * 内部类 - Sync类\n     * 内部类 - Sync核心函数分析\n     * 类的属性\n     * 类的构造函数\n     * 核心函数分析\n   * ReentrantReadWriteLock示例\n   * 更深入理解\n     * 什么是锁升降级?\n   * 参考文章\n\n\n# 带着BAT大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 为了有了ReentrantLock还需要ReentrantReadWriteLock?\n * ReentrantReadWriteLock底层实现原理?\n * ReentrantReadWriteLock底层读写状态如何设计的? 高16位为读锁，低16位为写锁\n * 读锁和写锁的最大数量是多少?\n * 本地线程计数器ThreadLocalHoldCounter是用来做什么的?\n * 缓存计数器HoldCounter是用来做什么的?\n * 写锁的获取与释放是怎么实现的?\n * 读锁的获取与释放是怎么实现的?\n * RentrantReadWriteLock为什么不支持锁升级?\n * 什么是锁的升降级? RentrantReadWriteLock为什么不支持锁升级?\n\n\n# ReentrantReadWriteLock数据结构\n\nReentrantReadWriteLock底层是基于ReentrantLock和AbstractQueuedSynchronizer来实现的，所以，ReentrantReadWriteLock的数据结构也依托于AQS的数据结构。\n\n\n# ReentrantReadWriteLock源码分析\n\n\n# 类的继承关系\n\npublic class ReentrantReadWriteLock implements ReadWriteLock, java.io.Serializable {}\n\n\n说明: 可以看到，ReentrantReadWriteLock实现了ReadWriteLock接口，ReadWriteLock接口定义了获取读锁和写锁的规范，具体需要实现类去实现；同时其还实现了Serializable接口，表示可以进行序列化，在源代码中可以看到ReentrantReadWriteLock实现了自己的序列化逻辑。\n\n\n# 类的内部类\n\nReentrantReadWriteLock有五个内部类，五个内部类之间也是相互关联的。内部类的关系如下图所示。\n\n\n\n说明: 如上图所示，Sync继承自AQS、NonfairSync继承自Sync类、FairSync继承自Sync类；ReadLock实现了Lock接口、WriteLock也实现了Lock接口。\n\n\n# 内部类 - Sync类\n\n * 类的继承关系\n\nabstract static class Sync extends AbstractQueuedSynchronizer {}\n\n\n说明: Sync抽象类继承自AQS抽象类，Sync类提供了对ReentrantReadWriteLock的支持。\n\n * 类的内部类\n\nSync类内部存在两个内部类，分别为HoldCounter和ThreadLocalHoldCounter，其中HoldCounter主要与读锁配套使用，其中，HoldCounter源码如下。\n\n// 计数器\nstatic final class HoldCounter {\n    // 计数\n    int count = 0;\n    // Use id, not reference, to avoid garbage retention\n    // 获取当前线程的TID属性的值\n    final long tid = getThreadId(Thread.currentThread());\n}\n\n\n说明: HoldCounter主要有两个属性，count和tid，其中count表示某个读线程重入的次数，tid表示该线程的tid字段的值，该字段可以用来唯一标识一个线程。ThreadLocalHoldCounter的源码如下\n\n// 本地线程计数器\nstatic final class ThreadLocalHoldCounter\n    extends ThreadLocal<HoldCounter> {\n    // 重写初始化方法，在没有进行set的情况下，获取的都是该HoldCounter值\n    public HoldCounter initialValue() {\n        return new HoldCounter();\n    }\n}\n\n\n说明: ThreadLocalHoldCounter重写了ThreadLocal的initialValue方法，ThreadLocal类可以将线程与对象相关联。在没有进行set的情况下，get到的均是initialValue方法里面生成的那个HolderCounter对象。\n\n * 类的属性\n\nabstract static class Sync extends AbstractQueuedSynchronizer {\n    // 版本序列号\n    private static final long serialVersionUID = 6317671515068378041L;        \n    // 高16位为读锁，低16位为写锁\n    static final int SHARED_SHIFT   = 16;\n    // 读锁单位\n    static final int SHARED_UNIT    = (1 << SHARED_SHIFT);\n    // 读锁最大数量\n    static final int MAX_COUNT      = (1 << SHARED_SHIFT) - 1;\n    // 写锁最大数量\n    static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;\n    // 本地线程计数器\n    private transient ThreadLocalHoldCounter readHolds;\n    // 缓存的计数器\n    private transient HoldCounter cachedHoldCounter;\n    // 第一个读线程\n    private transient Thread firstReader = null;\n    // 第一个读线程的计数\n    private transient int firstReaderHoldCount;\n}\n\n\n说明: 该属性中包括了读锁、写锁线程的最大量。本地线程计数器等。\n\n * 类的构造函数\n\n// 构造函数\nSync() {\n    // 本地线程计数器\n    readHolds = new ThreadLocalHoldCounter();\n    // 设置AQS的状态\n    setState(getState()); // ensures visibility of readHolds\n}\n\n\n说明: 在Sync的构造函数中设置了本地线程计数器和AQS的状态state。\n\n\n# 内部类 - Sync核心函数分析\n\n对ReentrantReadWriteLock对象的操作绝大多数都转发至Sync对象进行处理。下面对Sync类中的重点函数进行分析\n\n * sharedCount函数\n\n表示占有读锁的线程数量，源码如下\n\nstatic int sharedCount(int c)    { return c >>> SHARED_SHIFT; }\n\n\n说明: 直接将state右移16位，就可以得到读锁的线程数量，因为state的高16位表示读锁，对应的低十六位表示写锁数量。\n\n * exclusiveCount函数\n\n表示占有写锁的线程数量，源码如下\n\nstatic int exclusiveCount(int c) { return c & EXCLUSIVE_MASK; }\n\n\n说明: 直接将状态state和(2^16 - 1)做与运算，其等效于将state模上2^16。写锁数量由state的低十六位表示。\n\n * tryRelease函数\n\n/*\n* Note that tryRelease and tryAcquire can be called by\n* Conditions. So it is possible that their arguments contain\n* both read and write holds that are all released during a\n* condition wait and re-established in tryAcquire.\n*/\n\nprotected final boolean tryRelease(int releases) {\n    // 判断是否伪独占线程\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    // 计算释放资源后的写锁的数量\n    int nextc = getState() - releases;\n    boolean free = exclusiveCount(nextc) == 0; // 是否释放成功\n    if (free)\n        setExclusiveOwnerThread(null); // 设置独占线程为空\n    setState(nextc); // 设置状态\n    return free;\n}\n\n\n说明: 此函数用于释放写锁资源，首先会判断该线程是否为独占线程，若不为独占线程，则抛出异常，否则，计算释放资源后的写锁的数量，若为0，表示成功释放，资源不将被占用，否则，表示资源还被占用。其函数流程图如下。\n\n\n\n * tryAcquire函数\n\nprotected final boolean tryAcquire(int acquires) {\n    /*\n        * Walkthrough:\n        * 1. If read count nonzero or write count nonzero\n        *    and owner is a different thread, fail.\n        * 2. If count would saturate, fail. (This can only\n        *    happen if count is already nonzero.)\n        * 3. Otherwise, this thread is eligible for lock if\n        *    it is either a reentrant acquire or\n        *    queue policy allows it. If so, update state\n        *    and set owner.\n        */\n    // 获取当前线程\n    Thread current = Thread.currentThread();\n    // 获取状态\n    int c = getState();\n    // 写线程数量\n    int w = exclusiveCount(c);\n    if (c != 0) { // 状态不为0\n        // (Note: if c != 0 and w == 0 then shared count != 0)\n        if (w == 0 || current != getExclusiveOwnerThread()) // 写线程数量为0或者当前线程没有占有独占资源\n            return false;\n        if (w + exclusiveCount(acquires) > MAX_COUNT) // 判断是否超过最高写线程数量\n            throw new Error("Maximum lock count exceeded");\n        // Reentrant acquire\n        // 设置AQS状态\n        setState(c + acquires);\n        return true;\n    }\n    if (writerShouldBlock() ||\n        !compareAndSetState(c, c + acquires)) // 写线程是否应该被阻塞\n        return false;\n    // 设置独占线程\n    setExclusiveOwnerThread(current);\n    return true;\n}\n\n\n说明: 此函数用于获取写锁，首先会获取state，判断是否为0，若为0，表示此时没有读锁线程，再判断写线程是否应该被阻塞，而在非公平策略下总是不会被阻塞，在公平策略下会进行判断(判断同步队列中是否有等待时间更长的线程，若存在，则需要被阻塞，否则，无需阻塞)，之后在设置状态state，然后返回true。若state不为0，则表示此时存在读锁或写锁线程，若写锁线程数量为0或者当前线程为独占锁线程，则返回false，表示不成功，否则，判断写锁线程的重入次数是否大于了最大值，若是，则抛出异常，否则，设置状态state，返回true，表示成功。其函数流程图如下\n\n\n\n * tryReleaseShared函数\n\nprotected final boolean tryReleaseShared(int unused) {\n    // 获取当前线程\n    Thread current = Thread.currentThread();\n    if (firstReader == current) { // 当前线程为第一个读线程\n        // assert firstReaderHoldCount > 0;\n        if (firstReaderHoldCount == 1) // 读线程占用的资源数为1\n            firstReader = null;\n        else // 减少占用的资源\n            firstReaderHoldCount--;\n    } else { // 当前线程不为第一个读线程\n        // 获取缓存的计数器\n        HoldCounter rh = cachedHoldCounter;\n        if (rh == null || rh.tid != getThreadId(current)) // 计数器为空或者计数器的tid不为当前正在运行的线程的tid\n            // 获取当前线程对应的计数器\n            rh = readHolds.get();\n        // 获取计数\n        int count = rh.count;\n        if (count <= 1) { // 计数小于等于1\n            // 移除\n            readHolds.remove();\n            if (count <= 0) // 计数小于等于0，抛出异常\n                throw unmatchedUnlockException();\n        }\n        // 减少计数\n        --rh.count;\n    }\n    for (;;) { // 无限循环\n        // 获取状态\n        int c = getState();\n        // 获取状态\n        int nextc = c - SHARED_UNIT;\n        if (compareAndSetState(c, nextc)) // 比较并进行设置\n            // Releasing the read lock has no effect on readers,\n            // but it may allow waiting writers to proceed if\n            // both read and write locks are now free.\n            return nextc == 0;\n    }\n}\n\n\n说明: 此函数表示读锁线程释放锁。首先判断当前线程是否为第一个读线程firstReader，若是，则判断第一个读线程占有的资源数firstReaderHoldCount是否为1，若是，则设置第一个读线程firstReader为空，否则，将第一个读线程占有的资源数firstReaderHoldCount减1；若当前线程不是第一个读线程，那么首先会获取缓存计数器(上一个读锁线程对应的计数器 )，若计数器为空或者tid不等于当前线程的tid值，则获取当前线程的计数器，如果计数器的计数count小于等于1，则移除当前线程对应的计数器，如果计数器的计数count小于等于0，则抛出异常，之后再减少计数即可。无论何种情况，都会进入无限循环，该循环可以确保成功设置状态state。其流程图如下\n\n\n\n * tryAcquireShared函数\n\nprivate IllegalMonitorStateException unmatchedUnlockException() {\n    return new IllegalMonitorStateException(\n        "attempt to unlock read lock, not locked by current thread");\n}\n\n// 共享模式下获取资源\nprotected final int tryAcquireShared(int unused) {\n    /*\n        * Walkthrough:\n        * 1. If write lock held by another thread, fail.\n        * 2. Otherwise, this thread is eligible for\n        *    lock wrt state, so ask if it should block\n        *    because of queue policy. If not, try\n        *    to grant by CASing state and updating count.\n        *    Note that step does not check for reentrant\n        *    acquires, which is postponed to full version\n        *    to avoid having to check hold count in\n        *    the more typical non-reentrant case.\n        * 3. If step 2 fails either because thread\n        *    apparently not eligible or CAS fails or count\n        *    saturated, chain to version with full retry loop.\n        */\n    // 获取当前线程\n    Thread current = Thread.currentThread();\n    // 获取状态\n    int c = getState();\n    if (exclusiveCount(c) != 0 &&\n        getExclusiveOwnerThread() != current) // 写线程数不为0并且占有资源的不是当前线程\n        return -1;\n    // 读锁数量\n    int r = sharedCount(c);\n    if (!readerShouldBlock() &&\n        r < MAX_COUNT &&\n        compareAndSetState(c, c + SHARED_UNIT)) { // 读线程是否应该被阻塞、并且小于最大值、并且比较设置成功\n        if (r == 0) { // 读锁数量为0\n            // 设置第一个读线程\n            firstReader = current;\n            // 读线程占用的资源数为1\n            firstReaderHoldCount = 1;\n        } else if (firstReader == current) { // 当前线程为第一个读线程\n            // 占用资源数加1\n            firstReaderHoldCount++;\n        } else { // 读锁数量不为0并且不为当前线程\n            // 获取计数器\n            HoldCounter rh = cachedHoldCounter;\n            if (rh == null || rh.tid != getThreadId(current)) // 计数器为空或者计数器的tid不为当前正在运行的线程的tid\n                // 获取当前线程对应的计数器\n                cachedHoldCounter = rh = readHolds.get();\n            else if (rh.count == 0) // 计数为0\n                // 设置\n                readHolds.set(rh);\n            rh.count++;\n        }\n        return 1;\n    }\n    return fullTryAcquireShared(current);\n}\n\n\n说明: 此函数表示读锁线程获取读锁。首先判断写锁是否为0并且当前线程不占有独占锁，直接返回；否则，判断读线程是否需要被阻塞并且读锁数量是否小于最大值并且比较设置状态成功，若当前没有读锁，则设置第一个读线程firstReader和firstReaderHoldCount；若当前线程线程为第一个读线程，则增加firstReaderHoldCount；否则，将设置当前线程对应的HoldCounter对象的值。流程图如下。\n\n\n\n * fullTryAcquireShared函数\n\nfinal int fullTryAcquireShared(Thread current) {\n    /*\n        * This code is in part redundant with that in\n        * tryAcquireShared but is simpler overall by not\n        * complicating tryAcquireShared with interactions between\n        * retries and lazily reading hold counts.\n        */\n    HoldCounter rh = null;\n    for (;;) { // 无限循环\n        // 获取状态\n        int c = getState();\n        if (exclusiveCount(c) != 0) { // 写线程数量不为0\n            if (getExclusiveOwnerThread() != current) // 不为当前线程\n                return -1;\n            // else we hold the exclusive lock; blocking here\n            // would cause deadlock.\n        } else if (readerShouldBlock()) { // 写线程数量为0并且读线程被阻塞\n            // Make sure we\'re not acquiring read lock reentrantly\n            if (firstReader == current) { // 当前线程为第一个读线程\n                // assert firstReaderHoldCount > 0;\n            } else { // 当前线程不为第一个读线程\n                if (rh == null) { // 计数器不为空\n                    // \n                    rh = cachedHoldCounter;\n                    if (rh == null || rh.tid != getThreadId(current)) { // 计数器为空或者计数器的tid不为当前正在运行的线程的tid\n                        rh = readHolds.get();\n                        if (rh.count == 0)\n                            readHolds.remove();\n                    }\n                }\n                if (rh.count == 0)\n                    return -1;\n            }\n        }\n        if (sharedCount(c) == MAX_COUNT) // 读锁数量为最大值，抛出异常\n            throw new Error("Maximum lock count exceeded");\n        if (compareAndSetState(c, c + SHARED_UNIT)) { // 比较并且设置成功\n            if (sharedCount(c) == 0) { // 读线程数量为0\n                // 设置第一个读线程\n                firstReader = current;\n                // \n                firstReaderHoldCount = 1;\n            } else if (firstReader == current) {\n                firstReaderHoldCount++;\n            } else {\n                if (rh == null)\n                    rh = cachedHoldCounter;\n                if (rh == null || rh.tid != getThreadId(current))\n                    rh = readHolds.get();\n                else if (rh.count == 0)\n                    readHolds.set(rh);\n                rh.count++;\n                cachedHoldCounter = rh; // cache for release\n            }\n            return 1;\n        }\n    }\n}\n\n\n说明: 在tryAcquireShared函数中，如果下列三个条件不满足(读线程是否应该被阻塞、小于最大值、比较设置成功)则会进行fullTryAcquireShared函数中，它用来保证相关操作可以成功。其逻辑与tryAcquireShared逻辑类似，不再累赘。\n\n而其他内部类的操作基本上都是转化到了对Sync对象的操作，在此不再累赘。\n\n\n# 类的属性\n\npublic class ReentrantReadWriteLock\n        implements ReadWriteLock, java.io.Serializable {\n    // 版本序列号    \n    private static final long serialVersionUID = -6992448646407690164L;    \n    // 读锁\n    private final ReentrantReadWriteLock.ReadLock readerLock;\n    // 写锁\n    private final ReentrantReadWriteLock.WriteLock writerLock;\n    // 同步队列\n    final Sync sync;\n    \n    private static final sun.misc.Unsafe UNSAFE;\n    // 线程ID的偏移地址\n    private static final long TID_OFFSET;\n    static {\n        try {\n            UNSAFE = sun.misc.Unsafe.getUnsafe();\n            Class<?> tk = Thread.class;\n            // 获取线程的tid字段的内存地址\n            TID_OFFSET = UNSAFE.objectFieldOffset\n                (tk.getDeclaredField("tid"));\n        } catch (Exception e) {\n            throw new Error(e);\n        }\n    }\n}\n\n\n说明: 可以看到ReentrantReadWriteLock属性包括了一个ReentrantReadWriteLock.ReadLock对象，表示读锁；一个ReentrantReadWriteLock.WriteLock对象，表示写锁；一个Sync对象，表示同步队列。\n\n\n# 类的构造函数\n\n * ReentrantReadWriteLock()型构造函数\n\npublic ReentrantReadWriteLock() {\n    this(false);\n}\n\n\n说明: 此构造函数会调用另外一个有参构造函数。\n\n * ReentrantReadWriteLock(boolean)型构造函数\n\npublic ReentrantReadWriteLock(boolean fair) {\n    // 公平策略或者是非公平策略\n    sync = fair ? new FairSync() : new NonfairSync();\n    // 读锁\n    readerLock = new ReadLock(this);\n    // 写锁\n    writerLock = new WriteLock(this);\n}\n\n\n说明: 可以指定设置公平策略或者非公平策略，并且该构造函数中生成了读锁与写锁两个对象。\n\n\n# 核心函数分析\n\n对ReentrantReadWriteLock的操作基本上都转化为了对Sync对象的操作，而Sync的函数已经分析过，不再累赘。\n\n\n# ReentrantReadWriteLock示例\n\n下面给出了一个使用ReentrantReadWriteLock的示例，源代码如下。\n\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\nclass ReadThread extends Thread {\n    private ReentrantReadWriteLock rrwLock;\n    \n    public ReadThread(String name, ReentrantReadWriteLock rrwLock) {\n        super(name);\n        this.rrwLock = rrwLock;\n    }\n    \n    public void run() {\n        System.out.println(Thread.currentThread().getName() + " trying to lock");\n        try {\n            rrwLock.readLock().lock();\n            System.out.println(Thread.currentThread().getName() + " lock successfully");\n            Thread.sleep(5000);        \n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            rrwLock.readLock().unlock();\n            System.out.println(Thread.currentThread().getName() + " unlock successfully");\n        }\n    }\n}\n\nclass WriteThread extends Thread {\n    private ReentrantReadWriteLock rrwLock;\n    \n    public WriteThread(String name, ReentrantReadWriteLock rrwLock) {\n        super(name);\n        this.rrwLock = rrwLock;\n    }\n    \n    public void run() {\n        System.out.println(Thread.currentThread().getName() + " trying to lock");\n        try {\n            rrwLock.writeLock().lock();\n            System.out.println(Thread.currentThread().getName() + " lock successfully");    \n        } finally {\n            rrwLock.writeLock().unlock();\n            System.out.println(Thread.currentThread().getName() + " unlock successfully");\n        }\n    }\n}\n\npublic class ReentrantReadWriteLockDemo {\n    public static void main(String[] args) {\n        ReentrantReadWriteLock rrwLock = new ReentrantReadWriteLock();\n        ReadThread rt1 = new ReadThread("rt1", rrwLock);\n        ReadThread rt2 = new ReadThread("rt2", rrwLock);\n        WriteThread wt1 = new WriteThread("wt1", rrwLock);\n        rt1.start();\n        rt2.start();\n        wt1.start();\n    } \n}\n\n\n运行结果(某一次):\n\nrt1 trying to lock\nrt2 trying to lock\nwt1 trying to lock\nrt1 lock successfully\nrt2 lock successfully\nrt1 unlock successfully\nrt2 unlock successfully\nwt1 lock successfully\nwt1 unlock successfully\n\n\n说明: 程序中生成了一个ReentrantReadWriteLock对象，并且设置了两个读线程，一个写线程。根据结果，可能存在如下的时序图。\n\n\n\n * rt1线程执行rrwLock.readLock().lock操作，主要的函数调用如下。\n\n\n\n说明: 此时，AQS的状态state为2^16 次方，即表示此时读线程数量为1。\n\n * rt2线程执行rrwLock.readLock().lock操作，主要的函数调用如下。\n\n\n\n说明: 此时，AQS的状态state为2 * 2^16次方，即表示此时读线程数量为2。\n\n * wt1线程执行rrwLock.writeLock().lock操作，主要的函数调用如下。\n\n\n\n说明: 此时，在同步队列Sync queue中存在两个结点，并且wt1线程会被禁止运行。\n\n * rt1线程执行rrwLock.readLock().unlock操作，主要的函数调用如下。\n\n\n\n说明: 此时，AQS的state为2^16次方，表示还有一个读线程。\n\n * rt2线程执行rrwLock.readLock().unlock操作，主要的函数调用如下。\n\n\n\n说明: 当rt2线程执行unlock操作后，AQS的state为0，并且wt1线程将会被unpark，其获得CPU资源就可以运行。\n\n * wt1线程获得CPU资源，继续运行，需要恢复。由于之前acquireQueued函数中的parkAndCheckInterrupt函数中被禁止的，所以，恢复到parkAndCheckInterrupt函数中，主要的函数调用如下\n\n\n\n说明: 最后，sync queue队列中只有一个结点，并且头节点尾节点均指向它，AQS的state值为1，表示此时有一个写线程。\n\n * wt1执行rrwLock.writeLock().unlock操作，主要的函数调用如下。\n\n\n\n说明: 此时，AQS的state为0，表示没有任何读线程或者写线程了。并且Sync queue结构与上一个状态的结构相同，没有变化。\n\n\n# 更深入理解\n\n\n# 什么是锁升降级?\n\n锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住(当前拥有的)写锁，再获取到读锁，随后释放(先前拥有的)写锁的过程。\n\n接下来看一个锁降级的示例。因为数据不常变化，所以多个线程可以并发地进行数据处理，当数据变更后，如果当前线程感知到数据变化，则进行数据的准备工作，同时其他处理线程被阻塞，直到当前线程完成数据的准备工作，如代码如下所示：\n\npublic void processData() {\n    readLock.lock();\n    if (!update) {\n        // 必须先释放读锁\n        readLock.unlock();\n        // 锁降级从写锁获取到开始\n        writeLock.lock();\n        try {\n            if (!update) {\n                // 准备数据的流程(略)\n                update = true;\n            }\n            readLock.lock();\n        } finally {\n            writeLock.unlock();\n        }\n        // 锁降级完成，写锁降级为读锁\n    }\n    try {\n        // 使用数据的流程(略)\n    } finally {\n        readLock.unlock();\n    }\n}\n\n\n上述示例中，当数据发生变更后，update变量(布尔类型且volatile修饰)被设置为false，此时所有访问processData()方法的线程都能够感知到变化，但只有一个线程能够获取到写锁，其他线程会被阻塞在读锁和写锁的lock()方法上。当前线程获取写锁完成数据准备之后，再获取读锁，随后释放写锁，完成锁降级。\n\n锁降级中读锁的获取是否必要呢? 答案是必要的。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程(记作线程T)获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。\n\nRentrantReadWriteLock不支持锁升级(把持读锁、获取写锁，最后释放读锁的过程)。目的也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。\n\n\n# 参考文章\n\n * 文章主要参考自leesf的https://www.cnblogs.com/leesf456/p/5419132.html，在此基础上做了增改。\n * https://blog.csdn.net/jiankunking/article/details/83954263\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-lock-ReentrantReadWriteLock.html',normalizedContent:'# juc锁: reentrantreadwritelock详解\n\n> reentrantreadwritelock表示可重入读写锁，reentrantreadwritelock中包含了两种锁，读锁readlock和写锁writelock，可以通过这两种锁实现线程间的同步。\n\n * juc锁: reentrantreadwritelock详解\n   * 带着bat大厂的面试问题去理解\n   * reentrantreadwritelock数据结构\n   * reentrantreadwritelock源码分析\n     * 类的继承关系\n     * 类的内部类\n     * 内部类 - sync类\n     * 内部类 - sync核心函数分析\n     * 类的属性\n     * 类的构造函数\n     * 核心函数分析\n   * reentrantreadwritelock示例\n   * 更深入理解\n     * 什么是锁升降级?\n   * 参考文章\n\n\n# 带着bat大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 为了有了reentrantlock还需要reentrantreadwritelock?\n * reentrantreadwritelock底层实现原理?\n * reentrantreadwritelock底层读写状态如何设计的? 高16位为读锁，低16位为写锁\n * 读锁和写锁的最大数量是多少?\n * 本地线程计数器threadlocalholdcounter是用来做什么的?\n * 缓存计数器holdcounter是用来做什么的?\n * 写锁的获取与释放是怎么实现的?\n * 读锁的获取与释放是怎么实现的?\n * rentrantreadwritelock为什么不支持锁升级?\n * 什么是锁的升降级? rentrantreadwritelock为什么不支持锁升级?\n\n\n# reentrantreadwritelock数据结构\n\nreentrantreadwritelock底层是基于reentrantlock和abstractqueuedsynchronizer来实现的，所以，reentrantreadwritelock的数据结构也依托于aqs的数据结构。\n\n\n# reentrantreadwritelock源码分析\n\n\n# 类的继承关系\n\npublic class reentrantreadwritelock implements readwritelock, java.io.serializable {}\n\n\n说明: 可以看到，reentrantreadwritelock实现了readwritelock接口，readwritelock接口定义了获取读锁和写锁的规范，具体需要实现类去实现；同时其还实现了serializable接口，表示可以进行序列化，在源代码中可以看到reentrantreadwritelock实现了自己的序列化逻辑。\n\n\n# 类的内部类\n\nreentrantreadwritelock有五个内部类，五个内部类之间也是相互关联的。内部类的关系如下图所示。\n\n\n\n说明: 如上图所示，sync继承自aqs、nonfairsync继承自sync类、fairsync继承自sync类；readlock实现了lock接口、writelock也实现了lock接口。\n\n\n# 内部类 - sync类\n\n * 类的继承关系\n\nabstract static class sync extends abstractqueuedsynchronizer {}\n\n\n说明: sync抽象类继承自aqs抽象类，sync类提供了对reentrantreadwritelock的支持。\n\n * 类的内部类\n\nsync类内部存在两个内部类，分别为holdcounter和threadlocalholdcounter，其中holdcounter主要与读锁配套使用，其中，holdcounter源码如下。\n\n// 计数器\nstatic final class holdcounter {\n    // 计数\n    int count = 0;\n    // use id, not reference, to avoid garbage retention\n    // 获取当前线程的tid属性的值\n    final long tid = getthreadid(thread.currentthread());\n}\n\n\n说明: holdcounter主要有两个属性，count和tid，其中count表示某个读线程重入的次数，tid表示该线程的tid字段的值，该字段可以用来唯一标识一个线程。threadlocalholdcounter的源码如下\n\n// 本地线程计数器\nstatic final class threadlocalholdcounter\n    extends threadlocal<holdcounter> {\n    // 重写初始化方法，在没有进行set的情况下，获取的都是该holdcounter值\n    public holdcounter initialvalue() {\n        return new holdcounter();\n    }\n}\n\n\n说明: threadlocalholdcounter重写了threadlocal的initialvalue方法，threadlocal类可以将线程与对象相关联。在没有进行set的情况下，get到的均是initialvalue方法里面生成的那个holdercounter对象。\n\n * 类的属性\n\nabstract static class sync extends abstractqueuedsynchronizer {\n    // 版本序列号\n    private static final long serialversionuid = 6317671515068378041l;        \n    // 高16位为读锁，低16位为写锁\n    static final int shared_shift   = 16;\n    // 读锁单位\n    static final int shared_unit    = (1 << shared_shift);\n    // 读锁最大数量\n    static final int max_count      = (1 << shared_shift) - 1;\n    // 写锁最大数量\n    static final int exclusive_mask = (1 << shared_shift) - 1;\n    // 本地线程计数器\n    private transient threadlocalholdcounter readholds;\n    // 缓存的计数器\n    private transient holdcounter cachedholdcounter;\n    // 第一个读线程\n    private transient thread firstreader = null;\n    // 第一个读线程的计数\n    private transient int firstreaderholdcount;\n}\n\n\n说明: 该属性中包括了读锁、写锁线程的最大量。本地线程计数器等。\n\n * 类的构造函数\n\n// 构造函数\nsync() {\n    // 本地线程计数器\n    readholds = new threadlocalholdcounter();\n    // 设置aqs的状态\n    setstate(getstate()); // ensures visibility of readholds\n}\n\n\n说明: 在sync的构造函数中设置了本地线程计数器和aqs的状态state。\n\n\n# 内部类 - sync核心函数分析\n\n对reentrantreadwritelock对象的操作绝大多数都转发至sync对象进行处理。下面对sync类中的重点函数进行分析\n\n * sharedcount函数\n\n表示占有读锁的线程数量，源码如下\n\nstatic int sharedcount(int c)    { return c >>> shared_shift; }\n\n\n说明: 直接将state右移16位，就可以得到读锁的线程数量，因为state的高16位表示读锁，对应的低十六位表示写锁数量。\n\n * exclusivecount函数\n\n表示占有写锁的线程数量，源码如下\n\nstatic int exclusivecount(int c) { return c & exclusive_mask; }\n\n\n说明: 直接将状态state和(2^16 - 1)做与运算，其等效于将state模上2^16。写锁数量由state的低十六位表示。\n\n * tryrelease函数\n\n/*\n* note that tryrelease and tryacquire can be called by\n* conditions. so it is possible that their arguments contain\n* both read and write holds that are all released during a\n* condition wait and re-established in tryacquire.\n*/\n\nprotected final boolean tryrelease(int releases) {\n    // 判断是否伪独占线程\n    if (!isheldexclusively())\n        throw new illegalmonitorstateexception();\n    // 计算释放资源后的写锁的数量\n    int nextc = getstate() - releases;\n    boolean free = exclusivecount(nextc) == 0; // 是否释放成功\n    if (free)\n        setexclusiveownerthread(null); // 设置独占线程为空\n    setstate(nextc); // 设置状态\n    return free;\n}\n\n\n说明: 此函数用于释放写锁资源，首先会判断该线程是否为独占线程，若不为独占线程，则抛出异常，否则，计算释放资源后的写锁的数量，若为0，表示成功释放，资源不将被占用，否则，表示资源还被占用。其函数流程图如下。\n\n\n\n * tryacquire函数\n\nprotected final boolean tryacquire(int acquires) {\n    /*\n        * walkthrough:\n        * 1. if read count nonzero or write count nonzero\n        *    and owner is a different thread, fail.\n        * 2. if count would saturate, fail. (this can only\n        *    happen if count is already nonzero.)\n        * 3. otherwise, this thread is eligible for lock if\n        *    it is either a reentrant acquire or\n        *    queue policy allows it. if so, update state\n        *    and set owner.\n        */\n    // 获取当前线程\n    thread current = thread.currentthread();\n    // 获取状态\n    int c = getstate();\n    // 写线程数量\n    int w = exclusivecount(c);\n    if (c != 0) { // 状态不为0\n        // (note: if c != 0 and w == 0 then shared count != 0)\n        if (w == 0 || current != getexclusiveownerthread()) // 写线程数量为0或者当前线程没有占有独占资源\n            return false;\n        if (w + exclusivecount(acquires) > max_count) // 判断是否超过最高写线程数量\n            throw new error("maximum lock count exceeded");\n        // reentrant acquire\n        // 设置aqs状态\n        setstate(c + acquires);\n        return true;\n    }\n    if (writershouldblock() ||\n        !compareandsetstate(c, c + acquires)) // 写线程是否应该被阻塞\n        return false;\n    // 设置独占线程\n    setexclusiveownerthread(current);\n    return true;\n}\n\n\n说明: 此函数用于获取写锁，首先会获取state，判断是否为0，若为0，表示此时没有读锁线程，再判断写线程是否应该被阻塞，而在非公平策略下总是不会被阻塞，在公平策略下会进行判断(判断同步队列中是否有等待时间更长的线程，若存在，则需要被阻塞，否则，无需阻塞)，之后在设置状态state，然后返回true。若state不为0，则表示此时存在读锁或写锁线程，若写锁线程数量为0或者当前线程为独占锁线程，则返回false，表示不成功，否则，判断写锁线程的重入次数是否大于了最大值，若是，则抛出异常，否则，设置状态state，返回true，表示成功。其函数流程图如下\n\n\n\n * tryreleaseshared函数\n\nprotected final boolean tryreleaseshared(int unused) {\n    // 获取当前线程\n    thread current = thread.currentthread();\n    if (firstreader == current) { // 当前线程为第一个读线程\n        // assert firstreaderholdcount > 0;\n        if (firstreaderholdcount == 1) // 读线程占用的资源数为1\n            firstreader = null;\n        else // 减少占用的资源\n            firstreaderholdcount--;\n    } else { // 当前线程不为第一个读线程\n        // 获取缓存的计数器\n        holdcounter rh = cachedholdcounter;\n        if (rh == null || rh.tid != getthreadid(current)) // 计数器为空或者计数器的tid不为当前正在运行的线程的tid\n            // 获取当前线程对应的计数器\n            rh = readholds.get();\n        // 获取计数\n        int count = rh.count;\n        if (count <= 1) { // 计数小于等于1\n            // 移除\n            readholds.remove();\n            if (count <= 0) // 计数小于等于0，抛出异常\n                throw unmatchedunlockexception();\n        }\n        // 减少计数\n        --rh.count;\n    }\n    for (;;) { // 无限循环\n        // 获取状态\n        int c = getstate();\n        // 获取状态\n        int nextc = c - shared_unit;\n        if (compareandsetstate(c, nextc)) // 比较并进行设置\n            // releasing the read lock has no effect on readers,\n            // but it may allow waiting writers to proceed if\n            // both read and write locks are now free.\n            return nextc == 0;\n    }\n}\n\n\n说明: 此函数表示读锁线程释放锁。首先判断当前线程是否为第一个读线程firstreader，若是，则判断第一个读线程占有的资源数firstreaderholdcount是否为1，若是，则设置第一个读线程firstreader为空，否则，将第一个读线程占有的资源数firstreaderholdcount减1；若当前线程不是第一个读线程，那么首先会获取缓存计数器(上一个读锁线程对应的计数器 )，若计数器为空或者tid不等于当前线程的tid值，则获取当前线程的计数器，如果计数器的计数count小于等于1，则移除当前线程对应的计数器，如果计数器的计数count小于等于0，则抛出异常，之后再减少计数即可。无论何种情况，都会进入无限循环，该循环可以确保成功设置状态state。其流程图如下\n\n\n\n * tryacquireshared函数\n\nprivate illegalmonitorstateexception unmatchedunlockexception() {\n    return new illegalmonitorstateexception(\n        "attempt to unlock read lock, not locked by current thread");\n}\n\n// 共享模式下获取资源\nprotected final int tryacquireshared(int unused) {\n    /*\n        * walkthrough:\n        * 1. if write lock held by another thread, fail.\n        * 2. otherwise, this thread is eligible for\n        *    lock wrt state, so ask if it should block\n        *    because of queue policy. if not, try\n        *    to grant by casing state and updating count.\n        *    note that step does not check for reentrant\n        *    acquires, which is postponed to full version\n        *    to avoid having to check hold count in\n        *    the more typical non-reentrant case.\n        * 3. if step 2 fails either because thread\n        *    apparently not eligible or cas fails or count\n        *    saturated, chain to version with full retry loop.\n        */\n    // 获取当前线程\n    thread current = thread.currentthread();\n    // 获取状态\n    int c = getstate();\n    if (exclusivecount(c) != 0 &&\n        getexclusiveownerthread() != current) // 写线程数不为0并且占有资源的不是当前线程\n        return -1;\n    // 读锁数量\n    int r = sharedcount(c);\n    if (!readershouldblock() &&\n        r < max_count &&\n        compareandsetstate(c, c + shared_unit)) { // 读线程是否应该被阻塞、并且小于最大值、并且比较设置成功\n        if (r == 0) { // 读锁数量为0\n            // 设置第一个读线程\n            firstreader = current;\n            // 读线程占用的资源数为1\n            firstreaderholdcount = 1;\n        } else if (firstreader == current) { // 当前线程为第一个读线程\n            // 占用资源数加1\n            firstreaderholdcount++;\n        } else { // 读锁数量不为0并且不为当前线程\n            // 获取计数器\n            holdcounter rh = cachedholdcounter;\n            if (rh == null || rh.tid != getthreadid(current)) // 计数器为空或者计数器的tid不为当前正在运行的线程的tid\n                // 获取当前线程对应的计数器\n                cachedholdcounter = rh = readholds.get();\n            else if (rh.count == 0) // 计数为0\n                // 设置\n                readholds.set(rh);\n            rh.count++;\n        }\n        return 1;\n    }\n    return fulltryacquireshared(current);\n}\n\n\n说明: 此函数表示读锁线程获取读锁。首先判断写锁是否为0并且当前线程不占有独占锁，直接返回；否则，判断读线程是否需要被阻塞并且读锁数量是否小于最大值并且比较设置状态成功，若当前没有读锁，则设置第一个读线程firstreader和firstreaderholdcount；若当前线程线程为第一个读线程，则增加firstreaderholdcount；否则，将设置当前线程对应的holdcounter对象的值。流程图如下。\n\n\n\n * fulltryacquireshared函数\n\nfinal int fulltryacquireshared(thread current) {\n    /*\n        * this code is in part redundant with that in\n        * tryacquireshared but is simpler overall by not\n        * complicating tryacquireshared with interactions between\n        * retries and lazily reading hold counts.\n        */\n    holdcounter rh = null;\n    for (;;) { // 无限循环\n        // 获取状态\n        int c = getstate();\n        if (exclusivecount(c) != 0) { // 写线程数量不为0\n            if (getexclusiveownerthread() != current) // 不为当前线程\n                return -1;\n            // else we hold the exclusive lock; blocking here\n            // would cause deadlock.\n        } else if (readershouldblock()) { // 写线程数量为0并且读线程被阻塞\n            // make sure we\'re not acquiring read lock reentrantly\n            if (firstreader == current) { // 当前线程为第一个读线程\n                // assert firstreaderholdcount > 0;\n            } else { // 当前线程不为第一个读线程\n                if (rh == null) { // 计数器不为空\n                    // \n                    rh = cachedholdcounter;\n                    if (rh == null || rh.tid != getthreadid(current)) { // 计数器为空或者计数器的tid不为当前正在运行的线程的tid\n                        rh = readholds.get();\n                        if (rh.count == 0)\n                            readholds.remove();\n                    }\n                }\n                if (rh.count == 0)\n                    return -1;\n            }\n        }\n        if (sharedcount(c) == max_count) // 读锁数量为最大值，抛出异常\n            throw new error("maximum lock count exceeded");\n        if (compareandsetstate(c, c + shared_unit)) { // 比较并且设置成功\n            if (sharedcount(c) == 0) { // 读线程数量为0\n                // 设置第一个读线程\n                firstreader = current;\n                // \n                firstreaderholdcount = 1;\n            } else if (firstreader == current) {\n                firstreaderholdcount++;\n            } else {\n                if (rh == null)\n                    rh = cachedholdcounter;\n                if (rh == null || rh.tid != getthreadid(current))\n                    rh = readholds.get();\n                else if (rh.count == 0)\n                    readholds.set(rh);\n                rh.count++;\n                cachedholdcounter = rh; // cache for release\n            }\n            return 1;\n        }\n    }\n}\n\n\n说明: 在tryacquireshared函数中，如果下列三个条件不满足(读线程是否应该被阻塞、小于最大值、比较设置成功)则会进行fulltryacquireshared函数中，它用来保证相关操作可以成功。其逻辑与tryacquireshared逻辑类似，不再累赘。\n\n而其他内部类的操作基本上都是转化到了对sync对象的操作，在此不再累赘。\n\n\n# 类的属性\n\npublic class reentrantreadwritelock\n        implements readwritelock, java.io.serializable {\n    // 版本序列号    \n    private static final long serialversionuid = -6992448646407690164l;    \n    // 读锁\n    private final reentrantreadwritelock.readlock readerlock;\n    // 写锁\n    private final reentrantreadwritelock.writelock writerlock;\n    // 同步队列\n    final sync sync;\n    \n    private static final sun.misc.unsafe unsafe;\n    // 线程id的偏移地址\n    private static final long tid_offset;\n    static {\n        try {\n            unsafe = sun.misc.unsafe.getunsafe();\n            class<?> tk = thread.class;\n            // 获取线程的tid字段的内存地址\n            tid_offset = unsafe.objectfieldoffset\n                (tk.getdeclaredfield("tid"));\n        } catch (exception e) {\n            throw new error(e);\n        }\n    }\n}\n\n\n说明: 可以看到reentrantreadwritelock属性包括了一个reentrantreadwritelock.readlock对象，表示读锁；一个reentrantreadwritelock.writelock对象，表示写锁；一个sync对象，表示同步队列。\n\n\n# 类的构造函数\n\n * reentrantreadwritelock()型构造函数\n\npublic reentrantreadwritelock() {\n    this(false);\n}\n\n\n说明: 此构造函数会调用另外一个有参构造函数。\n\n * reentrantreadwritelock(boolean)型构造函数\n\npublic reentrantreadwritelock(boolean fair) {\n    // 公平策略或者是非公平策略\n    sync = fair ? new fairsync() : new nonfairsync();\n    // 读锁\n    readerlock = new readlock(this);\n    // 写锁\n    writerlock = new writelock(this);\n}\n\n\n说明: 可以指定设置公平策略或者非公平策略，并且该构造函数中生成了读锁与写锁两个对象。\n\n\n# 核心函数分析\n\n对reentrantreadwritelock的操作基本上都转化为了对sync对象的操作，而sync的函数已经分析过，不再累赘。\n\n\n# reentrantreadwritelock示例\n\n下面给出了一个使用reentrantreadwritelock的示例，源代码如下。\n\nimport java.util.concurrent.locks.reentrantreadwritelock;\n\nclass readthread extends thread {\n    private reentrantreadwritelock rrwlock;\n    \n    public readthread(string name, reentrantreadwritelock rrwlock) {\n        super(name);\n        this.rrwlock = rrwlock;\n    }\n    \n    public void run() {\n        system.out.println(thread.currentthread().getname() + " trying to lock");\n        try {\n            rrwlock.readlock().lock();\n            system.out.println(thread.currentthread().getname() + " lock successfully");\n            thread.sleep(5000);        \n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        } finally {\n            rrwlock.readlock().unlock();\n            system.out.println(thread.currentthread().getname() + " unlock successfully");\n        }\n    }\n}\n\nclass writethread extends thread {\n    private reentrantreadwritelock rrwlock;\n    \n    public writethread(string name, reentrantreadwritelock rrwlock) {\n        super(name);\n        this.rrwlock = rrwlock;\n    }\n    \n    public void run() {\n        system.out.println(thread.currentthread().getname() + " trying to lock");\n        try {\n            rrwlock.writelock().lock();\n            system.out.println(thread.currentthread().getname() + " lock successfully");    \n        } finally {\n            rrwlock.writelock().unlock();\n            system.out.println(thread.currentthread().getname() + " unlock successfully");\n        }\n    }\n}\n\npublic class reentrantreadwritelockdemo {\n    public static void main(string[] args) {\n        reentrantreadwritelock rrwlock = new reentrantreadwritelock();\n        readthread rt1 = new readthread("rt1", rrwlock);\n        readthread rt2 = new readthread("rt2", rrwlock);\n        writethread wt1 = new writethread("wt1", rrwlock);\n        rt1.start();\n        rt2.start();\n        wt1.start();\n    } \n}\n\n\n运行结果(某一次):\n\nrt1 trying to lock\nrt2 trying to lock\nwt1 trying to lock\nrt1 lock successfully\nrt2 lock successfully\nrt1 unlock successfully\nrt2 unlock successfully\nwt1 lock successfully\nwt1 unlock successfully\n\n\n说明: 程序中生成了一个reentrantreadwritelock对象，并且设置了两个读线程，一个写线程。根据结果，可能存在如下的时序图。\n\n\n\n * rt1线程执行rrwlock.readlock().lock操作，主要的函数调用如下。\n\n\n\n说明: 此时，aqs的状态state为2^16 次方，即表示此时读线程数量为1。\n\n * rt2线程执行rrwlock.readlock().lock操作，主要的函数调用如下。\n\n\n\n说明: 此时，aqs的状态state为2 * 2^16次方，即表示此时读线程数量为2。\n\n * wt1线程执行rrwlock.writelock().lock操作，主要的函数调用如下。\n\n\n\n说明: 此时，在同步队列sync queue中存在两个结点，并且wt1线程会被禁止运行。\n\n * rt1线程执行rrwlock.readlock().unlock操作，主要的函数调用如下。\n\n\n\n说明: 此时，aqs的state为2^16次方，表示还有一个读线程。\n\n * rt2线程执行rrwlock.readlock().unlock操作，主要的函数调用如下。\n\n\n\n说明: 当rt2线程执行unlock操作后，aqs的state为0，并且wt1线程将会被unpark，其获得cpu资源就可以运行。\n\n * wt1线程获得cpu资源，继续运行，需要恢复。由于之前acquirequeued函数中的parkandcheckinterrupt函数中被禁止的，所以，恢复到parkandcheckinterrupt函数中，主要的函数调用如下\n\n\n\n说明: 最后，sync queue队列中只有一个结点，并且头节点尾节点均指向它，aqs的state值为1，表示此时有一个写线程。\n\n * wt1执行rrwlock.writelock().unlock操作，主要的函数调用如下。\n\n\n\n说明: 此时，aqs的state为0，表示没有任何读线程或者写线程了。并且sync queue结构与上一个状态的结构相同，没有变化。\n\n\n# 更深入理解\n\n\n# 什么是锁升降级?\n\n锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住(当前拥有的)写锁，再获取到读锁，随后释放(先前拥有的)写锁的过程。\n\n接下来看一个锁降级的示例。因为数据不常变化，所以多个线程可以并发地进行数据处理，当数据变更后，如果当前线程感知到数据变化，则进行数据的准备工作，同时其他处理线程被阻塞，直到当前线程完成数据的准备工作，如代码如下所示：\n\npublic void processdata() {\n    readlock.lock();\n    if (!update) {\n        // 必须先释放读锁\n        readlock.unlock();\n        // 锁降级从写锁获取到开始\n        writelock.lock();\n        try {\n            if (!update) {\n                // 准备数据的流程(略)\n                update = true;\n            }\n            readlock.lock();\n        } finally {\n            writelock.unlock();\n        }\n        // 锁降级完成，写锁降级为读锁\n    }\n    try {\n        // 使用数据的流程(略)\n    } finally {\n        readlock.unlock();\n    }\n}\n\n\n上述示例中，当数据发生变更后，update变量(布尔类型且volatile修饰)被设置为false，此时所有访问processdata()方法的线程都能够感知到变化，但只有一个线程能够获取到写锁，其他线程会被阻塞在读锁和写锁的lock()方法上。当前线程获取写锁完成数据准备之后，再获取读锁，随后释放写锁，完成锁降级。\n\n锁降级中读锁的获取是否必要呢? 答案是必要的。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程(记作线程t)获取了写锁并修改了数据，那么当前线程无法感知线程t的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程t将会被阻塞，直到当前线程使用数据并释放读锁之后，线程t才能获取写锁进行数据更新。\n\nrentrantreadwritelock不支持锁升级(把持读锁、获取写锁，最后释放读锁的过程)。目的也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。\n\n\n# 参考文章\n\n * 文章主要参考自leesf的https://www.cnblogs.com/leesf456/p/5419132.html，在此基础上做了增改。\n * https://blog.csdn.net/jiankunking/article/details/83954263\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-lock-reentrantreadwritelock.html',charsets:{cjk:!0}},{title:"Java并发 - Java中所有的锁",frontmatter:{},regularPath:"/java/thread/java-thread-x-lock-all.html",relativePath:"java/thread/java-thread-x-lock-all.md",key:"v-57973fdc",path:"/java/thread/java-thread-x-lock-all.html",headers:[{level:2,title:"Java并发 - Java中所有的锁",slug:"java并发-java中所有的锁",normalizedTitle:"java并发 - java中所有的锁",charIndex:2},{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:170},{level:2,title:"1\\. 乐观锁 VS 悲观锁",slug:"_1-乐观锁-vs-悲观锁",normalizedTitle:"1. 乐观锁 vs 悲观锁",charIndex:178},{level:2,title:"2\\. 自旋锁 VS 适应性自旋锁",slug:"_2-自旋锁-vs-适应性自旋锁",normalizedTitle:"2. 自旋锁 vs 适应性自旋锁",charIndex:197},{level:2,title:"3\\. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁",slug:"_3-无锁-vs-偏向锁-vs-轻量级锁-vs-重量级锁",normalizedTitle:"3. 无锁 vs 偏向锁 vs 轻量级锁 vs 重量级锁",charIndex:219},{level:2,title:"4\\. 公平锁 VS 非公平锁",slug:"_4-公平锁-vs-非公平锁",normalizedTitle:"4. 公平锁 vs 非公平锁",charIndex:253},{level:2,title:"5\\. 可重入锁 VS 非可重入锁",slug:"_5-可重入锁-vs-非可重入锁",normalizedTitle:"5. 可重入锁 vs 非可重入锁",charIndex:273},{level:2,title:"6\\. 独享锁(排他锁) VS 共享锁",slug:"_6-独享锁-排他锁-vs-共享锁",normalizedTitle:"6. 独享锁(排他锁) vs 共享锁",charIndex:295},{level:2,title:"结语",slug:"结语",normalizedTitle:"结语",charIndex:319},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:327},{level:2,title:"作者简介",slug:"作者简介",normalizedTitle:"作者简介",charIndex:337},{level:2,title:"文章来源",slug:"文章来源",normalizedTitle:"文章来源",charIndex:347}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java并发 - Java中所有的锁 前言 1\\. 乐观锁 VS 悲观锁 2\\. 自旋锁 VS 适应性自旋锁 3\\. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁 4\\. 公平锁 VS 非公平锁 5\\. 可重入锁 VS 非可重入锁 6\\. 独享锁(排他锁) VS 共享锁 结语 参考资料 作者简介 文章来源",content:'# Java并发 - Java中所有的锁\n\n> Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8和Netty 3.10.6）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。\n\n * Java并发 - Java中所有的锁\n   * 前言\n   * 1. 乐观锁 VS 悲观锁\n   * 2. 自旋锁 VS 适应性自旋锁\n   * 3. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁\n   * 4. 公平锁 VS 非公平锁\n   * 5. 可重入锁 VS 非可重入锁\n   * 6. 独享锁(排他锁) VS 共享锁\n   * 结语\n   * 参考资料\n   * 作者简介\n   * 文章来源\n\n\n# 前言\n\nJava提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8和Netty 3.10.6）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。\n\nJava中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍，帮助大家更快捷的理解相关知识。下面给出本文内容的总体分类目录：\n\n\n\n\n# 1. 乐观锁 VS 悲观锁\n\n> 乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。\n\n先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。\n\n而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。\n\n乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。\n\n\n\n根据从上面的概念描述我们可以发现：\n\n * 悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。\n * 乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。\n\n光说概念有些抽象，我们来看下乐观锁和悲观锁的调用方式示例：\n\n// ------------------------- 悲观锁的调用方式 -------------------------\n// synchronized\npublic synchronized void testMethod() {\n\t// 操作同步资源\n}\n// ReentrantLock\nprivate ReentrantLock lock = new ReentrantLock(); // 需要保证多个线程使用的是同一个锁\npublic void modifyPublicResources() {\n\tlock.lock();\n\t// 操作同步资源\n\tlock.unlock();\n}\n\n// ------------------------- 乐观锁的调用方式 -------------------------\nprivate AtomicInteger atomicInteger = new AtomicInteger();  // 需要保证多个线程使用的是同一个AtomicInteger\natomicInteger.incrementAndGet(); //执行自增1\n\n\n通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？具体可以参看JUC原子类: CAS, Unsafe和原子类详解。\n\n\n# 2. 自旋锁 VS 适应性自旋锁\n\n> 在介绍自旋锁前，我们需要介绍一些前提知识来帮助大家明白自旋锁的概念。\n\n阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。\n\n在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。\n\n而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。\n\n\n\n自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。\n\n自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。\n\n自旋锁相关可以看关键字 - synchronized详解 - 自旋锁与自适应自旋锁\n\n\n# 3. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁\n\n> 这四种锁是指锁的状态，专门针对synchronized的。在介绍这四种锁状态之前还需要介绍一些额外的知识。\n\n总结而言： 偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。\n\n\n\n相关可以看关键字 - synchronized详解 - 锁的类型\n\n\n# 4. 公平锁 VS 非公平锁\n\n公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。\n\n非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。\n\n直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。\n\n\n\n如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。\n\n但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示：\n\n\n\n更多请参看JUC - ReentrantLock详解。\n\n\n# 5. 可重入锁 VS 非可重入锁\n\n可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：\n\npublic class Widget {\n    public synchronized void doSomething() {\n        System.out.println("方法1执行...");\n        doOthers();\n    }\n\n    public synchronized void doOthers() {\n        System.out.println("方法2执行...");\n    }\n}\n\n\n在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。\n\n如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。\n\n而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。\n\n还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。\n\n\n\n但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。\n\n\n\n之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。\n\n首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。\n\n当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。\n\n释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。\n\n\n\n更多请参看：\n\n * JUC锁: LockSupport详解\n * JUC锁: AbstractQueuedSynchronizer详解\n * JUC锁 - ReentrantLock详解。\n * 关键字 - synchronized详解\n\n\n# 6. 独享锁(排他锁) VS 共享锁\n\n> 独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。\n\n独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。\n\n共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。\n\n独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。\n\n下图为ReentrantReadWriteLock的部分源码：\n\n\n\n我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。\n\n在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。\n\n更多请参看\n\n * JUC锁: ReentrantReadWriteLock详解\n\n\n# 结语\n\n本文Java中常用的锁以及常见的锁的概念进行了基本介绍，并从源码以及实际应用的角度进行了对比分析。限于篇幅以及个人水平，没有在本篇文章中对所有内容进行深层次的讲解。\n\n其实Java本身已经对锁本身进行了良好的封装，降低了研发同学在平时工作中的使用难度。但是研发同学也需要熟悉锁的底层原理，不同场景下选择最适合的锁。而且源码中的思路都是非常好的思路，也是值得大家去学习和借鉴的。\n\n\n# 参考资料\n\n * 《Java并发编程艺术》\n * Java中的锁\n * Java CAS 原理剖析\n * Java并发——关键字synchronized解析\n * Java synchronized原理总结\n * 聊聊并发（二）——Java SE1.6中的Synchronized\n * 深入理解读写锁—ReadWriteLock源码分析\n * 【JUC】JDK1.8源码分析之ReentrantReadWriteLock\n * Java多线程（十）之ReentrantReadWriteLock深入分析\n * Java–读写锁的实现原理\n\n\n# 作者简介\n\n家琪，美团点评后端工程师。2017 年加入美团点评，负责美团点评境内度假的业务开发。\n\n\n# 文章来源\n\n本文主要在美团技术团队家琪的文章基础上进行调整，以满足整体的知识体系。\n\n转载 https://www.pdai.tech/md/java/thread/java-thread-x-lock-all.html',normalizedContent:'# java并发 - java中所有的锁\n\n> java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自jdk 8和netty 3.10.6）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。\n\n * java并发 - java中所有的锁\n   * 前言\n   * 1. 乐观锁 vs 悲观锁\n   * 2. 自旋锁 vs 适应性自旋锁\n   * 3. 无锁 vs 偏向锁 vs 轻量级锁 vs 重量级锁\n   * 4. 公平锁 vs 非公平锁\n   * 5. 可重入锁 vs 非可重入锁\n   * 6. 独享锁(排他锁) vs 共享锁\n   * 结语\n   * 参考资料\n   * 作者简介\n   * 文章来源\n\n\n# 前言\n\njava提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自jdk 8和netty 3.10.6）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。\n\njava中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍，帮助大家更快捷的理解相关知识。下面给出本文内容的总体分类目录：\n\n\n\n\n# 1. 乐观锁 vs 悲观锁\n\n> 乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在java和数据库中都有此概念对应的实际应用。\n\n先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。java中，synchronized关键字和lock的实现类都是悲观锁。\n\n而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。\n\n乐观锁在java中是通过使用无锁编程来实现，最常采用的是cas算法，java原子类中的递增操作就通过cas自旋实现的。\n\n\n\n根据从上面的概念描述我们可以发现：\n\n * 悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。\n * 乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。\n\n光说概念有些抽象，我们来看下乐观锁和悲观锁的调用方式示例：\n\n// ------------------------- 悲观锁的调用方式 -------------------------\n// synchronized\npublic synchronized void testmethod() {\n\t// 操作同步资源\n}\n// reentrantlock\nprivate reentrantlock lock = new reentrantlock(); // 需要保证多个线程使用的是同一个锁\npublic void modifypublicresources() {\n\tlock.lock();\n\t// 操作同步资源\n\tlock.unlock();\n}\n\n// ------------------------- 乐观锁的调用方式 -------------------------\nprivate atomicinteger atomicinteger = new atomicinteger();  // 需要保证多个线程使用的是同一个atomicinteger\natomicinteger.incrementandget(); //执行自增1\n\n\n通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？具体可以参看juc原子类: cas, unsafe和原子类详解。\n\n\n# 2. 自旋锁 vs 适应性自旋锁\n\n> 在介绍自旋锁前，我们需要介绍一些前提知识来帮助大家明白自旋锁的概念。\n\n阻塞或唤醒一个java线程需要操作系统切换cpu状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。\n\n在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃cpu的执行时间，看看持有锁的线程是否很快就会释放锁。\n\n而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。\n\n\n\n自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-xx:preblockspin来更改）没有成功获得锁，就应当挂起线程。\n\n自旋锁的实现原理同样也是cas，atomicinteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。\n\n自旋锁相关可以看关键字 - synchronized详解 - 自旋锁与自适应自旋锁\n\n\n# 3. 无锁 vs 偏向锁 vs 轻量级锁 vs 重量级锁\n\n> 这四种锁是指锁的状态，专门针对synchronized的。在介绍这四种锁状态之前还需要介绍一些额外的知识。\n\n总结而言： 偏向锁通过对比mark word解决加锁问题，避免执行cas操作。而轻量级锁是通过用cas操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。\n\n\n\n相关可以看关键字 - synchronized详解 - 锁的类型\n\n\n# 4. 公平锁 vs 非公平锁\n\n公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，cpu唤醒阻塞线程的开销比非公平锁大。\n\n非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，cpu不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。\n\n直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。\n\n\n\n如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。\n\n但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示：\n\n\n\n更多请参看juc - reentrantlock详解。\n\n\n# 5. 可重入锁 vs 非可重入锁\n\n可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。java中reentrantlock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：\n\npublic class widget {\n    public synchronized void dosomething() {\n        system.out.println("方法1执行...");\n        doothers();\n    }\n\n    public synchronized void doothers() {\n        system.out.println("方法2执行...");\n    }\n}\n\n\n在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，dosomething()方法中调用doothers()方法。因为内置锁是可重入的，所以同一个线程在调用doothers()时可以直接获得当前对象的锁，进入doothers()进行操作。\n\n如果是一个不可重入锁，那么当前线程在调用doothers()之前需要将执行dosomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。\n\n而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。\n\n还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。\n\n\n\n但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。\n\n\n\n之前我们说过reentrantlock和synchronized都是重入锁，那么我们通过重入锁reentrantlock以及非可重入锁nonreentrantlock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。\n\n首先reentrantlock和nonreentrantlock都继承父类aqs，其父类aqs中维护了一个同步状态status来计数重入次数，status初始值为0。\n\n当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。\n\n释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。\n\n\n\n更多请参看：\n\n * juc锁: locksupport详解\n * juc锁: abstractqueuedsynchronizer详解\n * juc锁 - reentrantlock详解。\n * 关键字 - synchronized详解\n\n\n# 6. 独享锁(排他锁) vs 共享锁\n\n> 独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过reentrantlock和reentrantreadwritelock的源码来介绍独享锁和共享锁。\n\n独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程t对数据a加上排它锁后，则其他线程不能再对a加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。jdk中的synchronized和juc中lock的实现类就是互斥锁。\n\n共享锁是指该锁可被多个线程所持有。如果线程t对数据a加上共享锁后，则其他线程只能对a再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。\n\n独享锁与共享锁也是通过aqs来实现的，通过实现不同的方法，来实现独享或者共享。\n\n下图为reentrantreadwritelock的部分源码：\n\n\n\n我们看到reentrantreadwritelock有两把锁：readlock和writelock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现readlock和writelock是靠内部类sync实现的锁。sync是aqs的一个子类，这种结构在countdownlatch、reentrantlock、semaphore里面也都存在。\n\n在reentrantreadwritelock里面，读锁和写锁的锁主体都是sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以reentrantreadwritelock的并发性相比一般的互斥锁有了很大提升。\n\n更多请参看\n\n * juc锁: reentrantreadwritelock详解\n\n\n# 结语\n\n本文java中常用的锁以及常见的锁的概念进行了基本介绍，并从源码以及实际应用的角度进行了对比分析。限于篇幅以及个人水平，没有在本篇文章中对所有内容进行深层次的讲解。\n\n其实java本身已经对锁本身进行了良好的封装，降低了研发同学在平时工作中的使用难度。但是研发同学也需要熟悉锁的底层原理，不同场景下选择最适合的锁。而且源码中的思路都是非常好的思路，也是值得大家去学习和借鉴的。\n\n\n# 参考资料\n\n * 《java并发编程艺术》\n * java中的锁\n * java cas 原理剖析\n * java并发——关键字synchronized解析\n * java synchronized原理总结\n * 聊聊并发（二）——java se1.6中的synchronized\n * 深入理解读写锁—readwritelock源码分析\n * 【juc】jdk1.8源码分析之reentrantreadwritelock\n * java多线程（十）之reentrantreadwritelock深入分析\n * java–读写锁的实现原理\n\n\n# 作者简介\n\n家琪，美团点评后端工程师。2017 年加入美团点评，负责美团点评境内度假的业务开发。\n\n\n# 文章来源\n\n本文主要在美团技术团队家琪的文章基础上进行调整，以满足整体的知识体系。\n\n转载 https://www.pdai.tech/md/java/thread/java-thread-x-lock-all.html',charsets:{cjk:!0}},{title:"♥Java并发知识体系详解♥",frontmatter:{},regularPath:"/java/thread/java-thread-x-overview.html",relativePath:"java/thread/java-thread-x-overview.md",key:"v-3fa2451e",path:"/java/thread/java-thread-x-overview.html",headers:[{level:2,title:"♥Java并发知识体系详解♥",slug:"♥java并发知识体系详解♥",normalizedTitle:"♥java并发知识体系详解♥",charIndex:2},{level:2,title:"知识体系",slug:"知识体系",normalizedTitle:"知识体系",charIndex:9},{level:2,title:"相关文章",slug:"相关文章",normalizedTitle:"相关文章",charIndex:124},{level:2,title:"参考文档",slug:"参考文档",normalizedTitle:"参考文档",charIndex:134}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"♥Java并发知识体系详解♥ 知识体系 相关文章 参考文档",content:"# ♥Java并发知识体系详解♥\n\n> Java 并发相关知识体系详解，包含理论基础，线程基础，synchronized，volatile，final关键字, JUC框架等内容。\n\n * ♥Java并发知识体系详解♥\n   * 知识体系\n   * 相关文章\n   * 参考文档\n\n\n# 知识体系\n\n\n\n\n# 相关文章\n\n> A. Java进阶 - Java 并发之基础：首先全局的了解并发的知识体系，同时了解并发理论基础和线程基础，并发关键字等，这些是你理解Java并发框架的基础。@pdai\n\n * Java 并发 - 知识体系\n * Java 并发 - 理论基础\n   * 多线程的出现是要解决什么问题的?\n   * 线程不安全是指什么? 举例说明\n   * 并发出现线程不安全的本质什么? 可见性，原子性和有序性。\n   * Java是怎么解决并发问题的? 3个关键字，JMM和8个Happens-Before\n   * 线程安全是不是非真即假? 不是\n   * 线程安全有哪些实现思路?\n   * 如何理解并发和并行的区别?\n * Java 并发 - 线程基础\n   * 线程有哪几种状态? 分别说明从一种状态到另一种状态转变有哪些方式?\n   * 通常线程有哪几种使用方式?\n   * 基础线程机制有哪些?\n   * 线程的中断方式有哪些?\n   * 线程的互斥同步方式有哪些? 如何比较和选择?\n   * 线程之间有哪些协作方式?\n * Java并发 - Java中所有的锁\n   * Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。\n * 关键字: synchronized详解\n   * Synchronized可以作用在哪里? 分别通过对象锁和类锁进行举例。\n   * Synchronized本质上是通过什么保证线程安全的? 分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理。\n   * Synchronized由什么样的缺陷? Java Lock是怎么弥补这些缺陷的。\n   * Synchronized和Lock的对比，和选择?\n   * Synchronized在使用时有何注意事项?\n   * Synchronized修饰的方法在抛出异常时,会释放锁吗?\n   * 多个线程等待同一个Synchronized锁的时候，JVM如何选择下一个获取锁的线程?\n   * Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法?\n   * 我想更加灵活地控制锁的释放和获取(现在释放锁和获取锁的时机都被规定死了)，怎么办?\n   * 什么是锁的升级和降级? 什么是JVM里的偏斜锁、轻量级锁、重量级锁?\n   * 不同的JDK中对Synchronized有何优化?\n * 关键字: volatile详解\n   * volatile关键字的作用是什么?\n   * volatile能保证原子性吗?\n   * 之前32位机器上共享的long和double变量的为什么要用volatile? 现在64位机器上是否也要设置呢?\n   * i++为什么不能保证原子性?\n   * volatile是如何实现可见性的? 内存屏障。\n   * volatile是如何实现有序性的? happens-before等\n   * 说下volatile的应用场景?\n * 关键字: final详解\n   * 所有的final修饰的字段都是编译期常量吗?\n   * 如何理解private所修饰的方法是隐式的final?\n   * 说说final类型的类如何拓展? 比如String是final类型，我们想写个MyString复用所有String中方法，同时增加一个新的toMyString()的方法，应该如何做?\n   * final方法可以被重载吗? 可以\n   * 父类的final方法能不能够被子类重写? 不可以\n   * 说说final域重排序规则?\n   * 说说final的原理?\n   * 使用 final 的限制条件和局限性?\n   * 看本文最后的一个思考题\n\n> B. Java进阶 - Java 并发之J.U.C框架：然后需要对J.U.C框架五大类详细解读，包括：Lock框架，并发集合, 原子类, 线程池和工具类。@pdai\n\n * JUC - 类汇总和学习指南\n   * JUC框架包含几个部分?\n   * 每个部分有哪些核心的类?\n   * 最最核心的类有哪些?\n\n> B.1 Java进阶 - Java 并发之J.U.C框架【1/5】：CAS及原子类：从最核心的CAS, Unsafe和原子类开始分析。\n\n * JUC原子类: CAS, Unsafe和原子类详解\n   * 线程安全的实现方法有哪些?\n   * 什么是CAS?\n   * CAS使用示例，结合AtomicInteger给出示例?\n   * CAS会有哪些问题?\n   * 针对这这些问题，Java提供了哪几个解决的?\n   * AtomicInteger底层实现? CAS+volatile\n   * 请阐述你对Unsafe类的理解?\n   * 说说你对Java原子类的理解? 包含13个，4组分类，说说作用和使用场景。\n   * AtomicStampedReference是什么?\n   * AtomicStampedReference是怎么解决ABA的? 内部使用Pair来存储元素值及其版本号\n   * java中还有哪些类可以解决ABA的问题? AtomicMarkableReference\n\n> B.2 Java进阶 - Java 并发之J.U.C框架【2/5】：锁：然后分析JUC中锁。\n\n * JUC锁: LockSupport详解\n   * 为什么LockSupport也是核心基础类? AQS框架借助于两个类：Unsafe(提供CAS操作)和LockSupport(提供park/unpark操作)\n   * 写出分别通过wait/notify和LockSupport的park/unpark实现同步?\n   * LockSupport.park()会释放锁资源吗? 那么Condition.await()呢?\n   * Thread.sleep()、Object.wait()、Condition.await()、LockSupport.park()的区别? 重点\n   * 如果在wait()之前执行了notify()会怎样?\n   * 如果在park()之前执行了unpark()会怎样?\n * JUC锁: 锁核心类AQS详解\n   * 什么是AQS? 为什么它是核心?\n   * AQS的核心思想是什么? 它是怎么实现的? 底层数据结构等\n   * AQS有哪些核心的方法?\n   * AQS定义什么样的资源获取方式? AQS定义了两种资源获取方式：独占(只有一个线程能访问执行，又根据是否按队列的顺序分为公平锁和非公平锁，如ReentrantLock) 和共享(多个线程可同时访问执行，如Semaphore、CountDownLatch、 CyclicBarrier )。ReentrantReadWriteLock可以看成是组合式，允许多个线程同时对某一资源进行读。\n   * AQS底层使用了什么样的设计模式? 模板\n   * AQS的应用示例?\n * JUC锁: ReentrantLock详解\n   * 什么是可重入，什么是可重入锁? 它用来解决什么问题?\n   * ReentrantLock的核心是AQS，那么它怎么来实现的，继承吗? 说说其类内部结构关系。\n   * ReentrantLock是如何实现公平锁的?\n   * ReentrantLock是如何实现非公平锁的?\n   * ReentrantLock默认实现的是公平还是非公平锁?\n   * 使用ReentrantLock实现公平和非公平锁的示例?\n   * ReentrantLock和Synchronized的对比?\n * JUC锁: ReentrantReadWriteLock详解\n   * 为了有了ReentrantLock还需要ReentrantReadWriteLock?\n   * ReentrantReadWriteLock底层实现原理?\n   * ReentrantReadWriteLock底层读写状态如何设计的? 高16位为读锁，低16位为写锁\n   * 读锁和写锁的最大数量是多少?\n   * 本地线程计数器ThreadLocalHoldCounter是用来做什么的?\n   * 缓存计数器HoldCounter是用来做什么的?\n   * 写锁的获取与释放是怎么实现的?\n   * 读锁的获取与释放是怎么实现的?\n   * RentrantReadWriteLock为什么不支持锁升级?\n   * 什么是锁的升降级? RentrantReadWriteLock为什么不支持锁升级?\n\n> B.3 Java进阶 - Java 并发之J.U.C框架【3/5】：集合：再理解JUC中重要的支持并发的集合。\n\n * JUC集合: ConcurrentHashMap详解\n   * 为什么HashTable慢? 它的并发度是什么? 那么ConcurrentHashMap并发度是什么?\n   * ConcurrentHashMap在JDK1.7和JDK1.8中实现有什么差别? JDK1.8解決了JDK1.7中什么问题\n   * ConcurrentHashMap JDK1.7实现的原理是什么? 分段锁机制\n   * ConcurrentHashMap JDK1.8实现的原理是什么? 数组+链表+红黑树，CAS\n   * ConcurrentHashMap JDK1.7中Segment数(concurrencyLevel)默认值是多少? 为何一旦初始化就不可再扩容?\n   * ConcurrentHashMap JDK1.7说说其put的机制?\n   * ConcurrentHashMap JDK1.7是如何扩容的? rehash(注：segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry<K,V>[] 进行扩容)\n   * ConcurrentHashMap JDK1.8是如何扩容的? tryPresize\n   * ConcurrentHashMap JDK1.8链表转红黑树的时机是什么? 临界值为什么是8?\n   * ConcurrentHashMap JDK1.8是如何进行数据迁移的? transfer\n * JUC集合: CopyOnWriteArrayList详解\n   * 请先说说非并发集合中Fail-fast机制?\n   * 再为什么说ArrayList查询快而增删慢?\n   * 对比ArrayList说说CopyOnWriteArrayList的增删改查实现原理? COW基于拷贝\n   * 再说下弱一致性的迭代器原理是怎么样的? COWIterator<E>\n   * CopyOnWriteArrayList为什么并发安全且性能比Vector好?\n   * CopyOnWriteArrayList有何缺陷，说说其应用场景?\n * JUC集合: ConcurrentLinkedQueue详解\n   * 要想用线程安全的队列有哪些选择? Vector，Collections.synchronizedList( List<T> list), ConcurrentLinkedQueue等\n   * ConcurrentLinkedQueue实现的数据结构?\n   * ConcurrentLinkedQueue底层原理? 全程无锁(CAS)\n   * ConcurrentLinkedQueue的核心方法有哪些? offer()，poll()，peek()，isEmpty()等队列常用方法\n   * 说说ConcurrentLinkedQueue的HOPS(延迟更新的策略)的设计?\n   * ConcurrentLinkedQueue适合什么样的使用场景?\n * JUC集合: BlockingQueue详解\n   * 什么是BlockingDeque?\n   * BlockingQueue大家族有哪些? ArrayBlockingQueue, DelayQueue, LinkedBlockingQueue, SynchronousQueue...\n   * BlockingQueue适合用在什么样的场景?\n   * BlockingQueue常用的方法?\n   * BlockingQueue插入方法有哪些? 这些方法(add(o),offer(o),put(o),offer(o, timeout, timeunit))的区别是什么?\n   * BlockingDeque 与BlockingQueue有何关系，请对比下它们的方法?\n   * BlockingDeque适合用在什么样的场景?\n   * BlockingDeque大家族有哪些?\n   * BlockingDeque 与BlockingQueue实现例子?\n\n> B.4 Java进阶 - Java 并发之J.U.C框架【4/5】：线程池：再者分析JUC中非常常用的线程池等。\n\n * JUC线程池: FutureTask详解\n   * FutureTask用来解决什么问题的? 为什么会出现?\n   * FutureTask类结构关系怎么样的?\n   * FutureTask的线程安全是由什么保证的?\n   * FutureTask结果返回机制?\n   * FutureTask内部运行状态的转变?\n   * FutureTask通常会怎么用? 举例说明。\n * JUC线程池: ThreadPoolExecutor详解\n   * 为什么要有线程池?\n   * Java是实现和管理线程池有哪些方式? 请简单举例如何使用。\n   * 为什么很多公司不允许使用Executors去创建线程池? 那么推荐怎么使用呢?\n   * ThreadPoolExecutor有哪些核心的配置参数? 请简要说明\n   * ThreadPoolExecutor可以创建哪是哪三种线程池呢?\n   * 当队列满了并且worker的数量达到maxSize的时候，会怎么样?\n   * 说说ThreadPoolExecutor有哪些RejectedExecutionHandler策略? 默认是什么策略?\n   * 简要说下线程池的任务执行机制? execute –> addWorker –>runworker (getTask)\n   * 线程池中任务是如何提交的?\n   * 线程池中任务是如何关闭的?\n   * 在配置线程池的时候需要考虑哪些配置因素?\n   * 如何监控线程池的状态?\n * JUC线程池: ScheduledThreadPool详解\n   * ScheduledThreadPoolExecutor要解决什么样的问题?\n   * ScheduledThreadPoolExecutor相比ThreadPoolExecutor有哪些特性?\n   * ScheduledThreadPoolExecutor有什么样的数据结构，核心内部类和抽象类?\n   * ScheduledThreadPoolExecutor有哪两个关闭策略? 区别是什么?\n   * ScheduledThreadPoolExecutor中scheduleAtFixedRate 和 scheduleWithFixedDelay区别是什么?\n   * 为什么ThreadPoolExecutor 的调整策略却不适用于 ScheduledThreadPoolExecutor?\n   * Executors 提供了几种方法来构造 ScheduledThreadPoolExecutor?\n * JUC线程池: Fork/Join框架详解\n   * Fork/Join主要用来解决什么样的问题?\n   * Fork/Join框架是在哪个JDK版本中引入的?\n   * Fork/Join框架主要包含哪三个模块? 模块之间的关系是怎么样的?\n   * ForkJoinPool类继承关系?\n   * ForkJoinTask抽象类继承关系? 在实际运用中，我们一般都会继承 RecursiveTask 、RecursiveAction 或 CountedCompleter 来实现我们的业务需求，而不会直接继承 ForkJoinTask 类。\n   * 整个Fork/Join 框架的执行流程/运行机制是怎么样的?\n   * 具体阐述Fork/Join的分治思想和work-stealing 实现方式?\n   * 有哪些JDK源码中使用了Fork/Join思想?\n   * 如何使用Executors工具类创建ForkJoinPool?\n   * 写一个例子: 用ForkJoin方式实现1+2+3+...+100000?\n   * Fork/Join在使用时有哪些注意事项? 结合JDK中的斐波那契数列实例具体说明。\n\n> B.5 Java进阶 - Java 并发之J.U.C框架【5/5】：工具类：最后来看下JUC中有哪些工具类，以及线程隔离术ThreadLocal。\n\n * JUC工具类: CountDownLatch详解\n   * 什么是CountDownLatch?\n   * CountDownLatch底层实现原理?\n   * CountDownLatch一次可以唤醒几个任务? 多个\n   * CountDownLatch有哪些主要方法? await(),countDown()\n   * CountDownLatch适用于什么场景?\n   * 写道题：实现一个容器，提供两个方法，add，size 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束? 使用CountDownLatch 代替wait notify 好处。\n * JUC工具类: CyclicBarrier详解\n   * 什么是CyclicBarrier?\n   * CyclicBarrier底层实现原理?\n   * CountDownLatch和CyclicBarrier对比?\n   * CyclicBarrier的核心函数有哪些?\n   * CyclicBarrier适用于什么场景?\n * JUC工具类: Semaphore详解\n   * 什么是Semaphore?\n   * Semaphore内部原理?\n   * Semaphore常用方法有哪些? 如何实现线程同步和互斥的?\n   * Semaphore适合用在什么场景?\n   * 单独使用Semaphore是不会使用到AQS的条件队列?\n   * Semaphore中申请令牌(acquire)、释放令牌(release)的实现?\n   * Semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么?\n   * Semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么?\n   * Semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire(2)方法，此线程能够获取到足够的令牌并继续运行吗?\n   * Semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗?\n * JUC工具类: Phaser详解\n   * Phaser主要用来解决什么问题?\n   * Phaser与CyclicBarrier和CountDownLatch的区别是什么?\n   * 如果用CountDownLatch来实现Phaser的功能应该怎么实现?\n   * Phaser运行机制是什么样的?\n   * 给一个Phaser使用的示例?\n * JUC工具类: Exchanger详解\n   * Exchanger主要解决什么问题?\n   * 对比SynchronousQueue，为什么说Exchanger可被视为 SynchronousQueue 的双向形式?\n   * Exchanger在不同的JDK版本中实现有什么差别?\n   * Exchanger实现机制?\n   * Exchanger已经有了slot单节点，为什么会加入arena node数组? 什么时候会用到数组?\n   * arena可以确保不同的slot在arena中是不会相冲突的，那么是怎么保证的呢?\n   * 什么是伪共享，Exchanger中如何体现的?\n   * Exchanger实现举例\n * Java 并发 - ThreadLocal详解\n   * 什么是ThreadLocal? 用来解决什么问题的?\n   * 说说你对ThreadLocal的理解\n   * ThreadLocal是如何实现线程隔离的?\n   * 为什么ThreadLocal会造成内存泄露? 如何解决\n   * 还有哪些使用ThreadLocal的应用场景?\n\n> C. Java进阶 - Java 并发之 本质与模式：最后站在更高的角度看其本质(协作，分工和互斥)，同时总结上述知识点所使用的模式。@pdai\n\n * TODO：Java 并发 - 并发的本质：协作,分工和互斥\n * TODO：Java 并发 - 并发的模式梳理\n\n\n# 参考文档\n\n转载 https://www.pdai.tech/md/java/thread/java-thread-x-overview.html\n\n官方文档 https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html\n\n并发官方教程 https://docs.oracle.com/javase/tutorial/essential/concurrency/atomic.html\n\nDoug Lea并发编程文章全部译文 http://ifeve.com/doug-lea/\n\nJava并发知识点总结 https://github.com/CL0610/Java-concurrency\n\n线程与多线程必知必会(基础篇) https://zhuanlan.zhihu.com/p/33616143",normalizedContent:"# ♥java并发知识体系详解♥\n\n> java 并发相关知识体系详解，包含理论基础，线程基础，synchronized，volatile，final关键字, juc框架等内容。\n\n * ♥java并发知识体系详解♥\n   * 知识体系\n   * 相关文章\n   * 参考文档\n\n\n# 知识体系\n\n\n\n\n# 相关文章\n\n> a. java进阶 - java 并发之基础：首先全局的了解并发的知识体系，同时了解并发理论基础和线程基础，并发关键字等，这些是你理解java并发框架的基础。@pdai\n\n * java 并发 - 知识体系\n * java 并发 - 理论基础\n   * 多线程的出现是要解决什么问题的?\n   * 线程不安全是指什么? 举例说明\n   * 并发出现线程不安全的本质什么? 可见性，原子性和有序性。\n   * java是怎么解决并发问题的? 3个关键字，jmm和8个happens-before\n   * 线程安全是不是非真即假? 不是\n   * 线程安全有哪些实现思路?\n   * 如何理解并发和并行的区别?\n * java 并发 - 线程基础\n   * 线程有哪几种状态? 分别说明从一种状态到另一种状态转变有哪些方式?\n   * 通常线程有哪几种使用方式?\n   * 基础线程机制有哪些?\n   * 线程的中断方式有哪些?\n   * 线程的互斥同步方式有哪些? 如何比较和选择?\n   * 线程之间有哪些协作方式?\n * java并发 - java中所有的锁\n   * java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。\n * 关键字: synchronized详解\n   * synchronized可以作用在哪里? 分别通过对象锁和类锁进行举例。\n   * synchronized本质上是通过什么保证线程安全的? 分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理。\n   * synchronized由什么样的缺陷? java lock是怎么弥补这些缺陷的。\n   * synchronized和lock的对比，和选择?\n   * synchronized在使用时有何注意事项?\n   * synchronized修饰的方法在抛出异常时,会释放锁吗?\n   * 多个线程等待同一个synchronized锁的时候，jvm如何选择下一个获取锁的线程?\n   * synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法?\n   * 我想更加灵活地控制锁的释放和获取(现在释放锁和获取锁的时机都被规定死了)，怎么办?\n   * 什么是锁的升级和降级? 什么是jvm里的偏斜锁、轻量级锁、重量级锁?\n   * 不同的jdk中对synchronized有何优化?\n * 关键字: volatile详解\n   * volatile关键字的作用是什么?\n   * volatile能保证原子性吗?\n   * 之前32位机器上共享的long和double变量的为什么要用volatile? 现在64位机器上是否也要设置呢?\n   * i++为什么不能保证原子性?\n   * volatile是如何实现可见性的? 内存屏障。\n   * volatile是如何实现有序性的? happens-before等\n   * 说下volatile的应用场景?\n * 关键字: final详解\n   * 所有的final修饰的字段都是编译期常量吗?\n   * 如何理解private所修饰的方法是隐式的final?\n   * 说说final类型的类如何拓展? 比如string是final类型，我们想写个mystring复用所有string中方法，同时增加一个新的tomystring()的方法，应该如何做?\n   * final方法可以被重载吗? 可以\n   * 父类的final方法能不能够被子类重写? 不可以\n   * 说说final域重排序规则?\n   * 说说final的原理?\n   * 使用 final 的限制条件和局限性?\n   * 看本文最后的一个思考题\n\n> b. java进阶 - java 并发之j.u.c框架：然后需要对j.u.c框架五大类详细解读，包括：lock框架，并发集合, 原子类, 线程池和工具类。@pdai\n\n * juc - 类汇总和学习指南\n   * juc框架包含几个部分?\n   * 每个部分有哪些核心的类?\n   * 最最核心的类有哪些?\n\n> b.1 java进阶 - java 并发之j.u.c框架【1/5】：cas及原子类：从最核心的cas, unsafe和原子类开始分析。\n\n * juc原子类: cas, unsafe和原子类详解\n   * 线程安全的实现方法有哪些?\n   * 什么是cas?\n   * cas使用示例，结合atomicinteger给出示例?\n   * cas会有哪些问题?\n   * 针对这这些问题，java提供了哪几个解决的?\n   * atomicinteger底层实现? cas+volatile\n   * 请阐述你对unsafe类的理解?\n   * 说说你对java原子类的理解? 包含13个，4组分类，说说作用和使用场景。\n   * atomicstampedreference是什么?\n   * atomicstampedreference是怎么解决aba的? 内部使用pair来存储元素值及其版本号\n   * java中还有哪些类可以解决aba的问题? atomicmarkablereference\n\n> b.2 java进阶 - java 并发之j.u.c框架【2/5】：锁：然后分析juc中锁。\n\n * juc锁: locksupport详解\n   * 为什么locksupport也是核心基础类? aqs框架借助于两个类：unsafe(提供cas操作)和locksupport(提供park/unpark操作)\n   * 写出分别通过wait/notify和locksupport的park/unpark实现同步?\n   * locksupport.park()会释放锁资源吗? 那么condition.await()呢?\n   * thread.sleep()、object.wait()、condition.await()、locksupport.park()的区别? 重点\n   * 如果在wait()之前执行了notify()会怎样?\n   * 如果在park()之前执行了unpark()会怎样?\n * juc锁: 锁核心类aqs详解\n   * 什么是aqs? 为什么它是核心?\n   * aqs的核心思想是什么? 它是怎么实现的? 底层数据结构等\n   * aqs有哪些核心的方法?\n   * aqs定义什么样的资源获取方式? aqs定义了两种资源获取方式：独占(只有一个线程能访问执行，又根据是否按队列的顺序分为公平锁和非公平锁，如reentrantlock) 和共享(多个线程可同时访问执行，如semaphore、countdownlatch、 cyclicbarrier )。reentrantreadwritelock可以看成是组合式，允许多个线程同时对某一资源进行读。\n   * aqs底层使用了什么样的设计模式? 模板\n   * aqs的应用示例?\n * juc锁: reentrantlock详解\n   * 什么是可重入，什么是可重入锁? 它用来解决什么问题?\n   * reentrantlock的核心是aqs，那么它怎么来实现的，继承吗? 说说其类内部结构关系。\n   * reentrantlock是如何实现公平锁的?\n   * reentrantlock是如何实现非公平锁的?\n   * reentrantlock默认实现的是公平还是非公平锁?\n   * 使用reentrantlock实现公平和非公平锁的示例?\n   * reentrantlock和synchronized的对比?\n * juc锁: reentrantreadwritelock详解\n   * 为了有了reentrantlock还需要reentrantreadwritelock?\n   * reentrantreadwritelock底层实现原理?\n   * reentrantreadwritelock底层读写状态如何设计的? 高16位为读锁，低16位为写锁\n   * 读锁和写锁的最大数量是多少?\n   * 本地线程计数器threadlocalholdcounter是用来做什么的?\n   * 缓存计数器holdcounter是用来做什么的?\n   * 写锁的获取与释放是怎么实现的?\n   * 读锁的获取与释放是怎么实现的?\n   * rentrantreadwritelock为什么不支持锁升级?\n   * 什么是锁的升降级? rentrantreadwritelock为什么不支持锁升级?\n\n> b.3 java进阶 - java 并发之j.u.c框架【3/5】：集合：再理解juc中重要的支持并发的集合。\n\n * juc集合: concurrenthashmap详解\n   * 为什么hashtable慢? 它的并发度是什么? 那么concurrenthashmap并发度是什么?\n   * concurrenthashmap在jdk1.7和jdk1.8中实现有什么差别? jdk1.8解決了jdk1.7中什么问题\n   * concurrenthashmap jdk1.7实现的原理是什么? 分段锁机制\n   * concurrenthashmap jdk1.8实现的原理是什么? 数组+链表+红黑树，cas\n   * concurrenthashmap jdk1.7中segment数(concurrencylevel)默认值是多少? 为何一旦初始化就不可再扩容?\n   * concurrenthashmap jdk1.7说说其put的机制?\n   * concurrenthashmap jdk1.7是如何扩容的? rehash(注：segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 hashentry<k,v>[] 进行扩容)\n   * concurrenthashmap jdk1.8是如何扩容的? trypresize\n   * concurrenthashmap jdk1.8链表转红黑树的时机是什么? 临界值为什么是8?\n   * concurrenthashmap jdk1.8是如何进行数据迁移的? transfer\n * juc集合: copyonwritearraylist详解\n   * 请先说说非并发集合中fail-fast机制?\n   * 再为什么说arraylist查询快而增删慢?\n   * 对比arraylist说说copyonwritearraylist的增删改查实现原理? cow基于拷贝\n   * 再说下弱一致性的迭代器原理是怎么样的? cowiterator<e>\n   * copyonwritearraylist为什么并发安全且性能比vector好?\n   * copyonwritearraylist有何缺陷，说说其应用场景?\n * juc集合: concurrentlinkedqueue详解\n   * 要想用线程安全的队列有哪些选择? vector，collections.synchronizedlist( list<t> list), concurrentlinkedqueue等\n   * concurrentlinkedqueue实现的数据结构?\n   * concurrentlinkedqueue底层原理? 全程无锁(cas)\n   * concurrentlinkedqueue的核心方法有哪些? offer()，poll()，peek()，isempty()等队列常用方法\n   * 说说concurrentlinkedqueue的hops(延迟更新的策略)的设计?\n   * concurrentlinkedqueue适合什么样的使用场景?\n * juc集合: blockingqueue详解\n   * 什么是blockingdeque?\n   * blockingqueue大家族有哪些? arrayblockingqueue, delayqueue, linkedblockingqueue, synchronousqueue...\n   * blockingqueue适合用在什么样的场景?\n   * blockingqueue常用的方法?\n   * blockingqueue插入方法有哪些? 这些方法(add(o),offer(o),put(o),offer(o, timeout, timeunit))的区别是什么?\n   * blockingdeque 与blockingqueue有何关系，请对比下它们的方法?\n   * blockingdeque适合用在什么样的场景?\n   * blockingdeque大家族有哪些?\n   * blockingdeque 与blockingqueue实现例子?\n\n> b.4 java进阶 - java 并发之j.u.c框架【4/5】：线程池：再者分析juc中非常常用的线程池等。\n\n * juc线程池: futuretask详解\n   * futuretask用来解决什么问题的? 为什么会出现?\n   * futuretask类结构关系怎么样的?\n   * futuretask的线程安全是由什么保证的?\n   * futuretask结果返回机制?\n   * futuretask内部运行状态的转变?\n   * futuretask通常会怎么用? 举例说明。\n * juc线程池: threadpoolexecutor详解\n   * 为什么要有线程池?\n   * java是实现和管理线程池有哪些方式? 请简单举例如何使用。\n   * 为什么很多公司不允许使用executors去创建线程池? 那么推荐怎么使用呢?\n   * threadpoolexecutor有哪些核心的配置参数? 请简要说明\n   * threadpoolexecutor可以创建哪是哪三种线程池呢?\n   * 当队列满了并且worker的数量达到maxsize的时候，会怎么样?\n   * 说说threadpoolexecutor有哪些rejectedexecutionhandler策略? 默认是什么策略?\n   * 简要说下线程池的任务执行机制? execute –> addworker –>runworker (gettask)\n   * 线程池中任务是如何提交的?\n   * 线程池中任务是如何关闭的?\n   * 在配置线程池的时候需要考虑哪些配置因素?\n   * 如何监控线程池的状态?\n * juc线程池: scheduledthreadpool详解\n   * scheduledthreadpoolexecutor要解决什么样的问题?\n   * scheduledthreadpoolexecutor相比threadpoolexecutor有哪些特性?\n   * scheduledthreadpoolexecutor有什么样的数据结构，核心内部类和抽象类?\n   * scheduledthreadpoolexecutor有哪两个关闭策略? 区别是什么?\n   * scheduledthreadpoolexecutor中scheduleatfixedrate 和 schedulewithfixeddelay区别是什么?\n   * 为什么threadpoolexecutor 的调整策略却不适用于 scheduledthreadpoolexecutor?\n   * executors 提供了几种方法来构造 scheduledthreadpoolexecutor?\n * juc线程池: fork/join框架详解\n   * fork/join主要用来解决什么样的问题?\n   * fork/join框架是在哪个jdk版本中引入的?\n   * fork/join框架主要包含哪三个模块? 模块之间的关系是怎么样的?\n   * forkjoinpool类继承关系?\n   * forkjointask抽象类继承关系? 在实际运用中，我们一般都会继承 recursivetask 、recursiveaction 或 countedcompleter 来实现我们的业务需求，而不会直接继承 forkjointask 类。\n   * 整个fork/join 框架的执行流程/运行机制是怎么样的?\n   * 具体阐述fork/join的分治思想和work-stealing 实现方式?\n   * 有哪些jdk源码中使用了fork/join思想?\n   * 如何使用executors工具类创建forkjoinpool?\n   * 写一个例子: 用forkjoin方式实现1+2+3+...+100000?\n   * fork/join在使用时有哪些注意事项? 结合jdk中的斐波那契数列实例具体说明。\n\n> b.5 java进阶 - java 并发之j.u.c框架【5/5】：工具类：最后来看下juc中有哪些工具类，以及线程隔离术threadlocal。\n\n * juc工具类: countdownlatch详解\n   * 什么是countdownlatch?\n   * countdownlatch底层实现原理?\n   * countdownlatch一次可以唤醒几个任务? 多个\n   * countdownlatch有哪些主要方法? await(),countdown()\n   * countdownlatch适用于什么场景?\n   * 写道题：实现一个容器，提供两个方法，add，size 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束? 使用countdownlatch 代替wait notify 好处。\n * juc工具类: cyclicbarrier详解\n   * 什么是cyclicbarrier?\n   * cyclicbarrier底层实现原理?\n   * countdownlatch和cyclicbarrier对比?\n   * cyclicbarrier的核心函数有哪些?\n   * cyclicbarrier适用于什么场景?\n * juc工具类: semaphore详解\n   * 什么是semaphore?\n   * semaphore内部原理?\n   * semaphore常用方法有哪些? 如何实现线程同步和互斥的?\n   * semaphore适合用在什么场景?\n   * 单独使用semaphore是不会使用到aqs的条件队列?\n   * semaphore中申请令牌(acquire)、释放令牌(release)的实现?\n   * semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么?\n   * semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么?\n   * semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire(2)方法，此线程能够获取到足够的令牌并继续运行吗?\n   * semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗?\n * juc工具类: phaser详解\n   * phaser主要用来解决什么问题?\n   * phaser与cyclicbarrier和countdownlatch的区别是什么?\n   * 如果用countdownlatch来实现phaser的功能应该怎么实现?\n   * phaser运行机制是什么样的?\n   * 给一个phaser使用的示例?\n * juc工具类: exchanger详解\n   * exchanger主要解决什么问题?\n   * 对比synchronousqueue，为什么说exchanger可被视为 synchronousqueue 的双向形式?\n   * exchanger在不同的jdk版本中实现有什么差别?\n   * exchanger实现机制?\n   * exchanger已经有了slot单节点，为什么会加入arena node数组? 什么时候会用到数组?\n   * arena可以确保不同的slot在arena中是不会相冲突的，那么是怎么保证的呢?\n   * 什么是伪共享，exchanger中如何体现的?\n   * exchanger实现举例\n * java 并发 - threadlocal详解\n   * 什么是threadlocal? 用来解决什么问题的?\n   * 说说你对threadlocal的理解\n   * threadlocal是如何实现线程隔离的?\n   * 为什么threadlocal会造成内存泄露? 如何解决\n   * 还有哪些使用threadlocal的应用场景?\n\n> c. java进阶 - java 并发之 本质与模式：最后站在更高的角度看其本质(协作，分工和互斥)，同时总结上述知识点所使用的模式。@pdai\n\n * todo：java 并发 - 并发的本质：协作,分工和互斥\n * todo：java 并发 - 并发的模式梳理\n\n\n# 参考文档\n\n转载 https://www.pdai.tech/md/java/thread/java-thread-x-overview.html\n\n官方文档 https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html\n\n并发官方教程 https://docs.oracle.com/javase/tutorial/essential/concurrency/atomic.html\n\ndoug lea并发编程文章全部译文 http://ifeve.com/doug-lea/\n\njava并发知识点总结 https://github.com/cl0610/java-concurrency\n\n线程与多线程必知必会(基础篇) https://zhuanlan.zhihu.com/p/33616143",charsets:{cjk:!0}},{title:"♥Spring框架知识体系详解♥",frontmatter:{},regularPath:"/spring/basic/spring.html",relativePath:"spring/basic/spring.md",key:"v-88e9c230",path:"/spring/basic/spring.html",headers:[{level:2,title:"♥Spring框架知识体系详解♥",slug:"♥spring框架知识体系详解♥",normalizedTitle:"♥spring框架知识体系详解♥",charIndex:2},{level:2,title:"相关文章",slug:"相关文章",normalizedTitle:"相关文章",charIndex:98}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"♥Spring框架知识体系详解♥ 相关文章",content:"# ♥Spring框架知识体系详解♥\n\n提示\n\n本系列主要介绍Spring框架整体架构，Spring的核心IOC，AOP的案例和具体实现机制；以及SpringMVC框架的案例和实现机制。\n\n\n# 相关文章\n\n> 首先， 从Spring框架的整体架构和组成对整体框架有个认知。\n\n * Spring基础 - Spring和Spring框架组成\n   * Spring是什么？它是怎么诞生的？有哪些主要的组件和核心功能呢? 本文通过这几个问题帮助你构筑Spring和Spring Framework的整体认知。\n\n\n\n> 其次，通过案例引出Spring的核心（IoC和AOP），同时对IoC和AOP进行案例使用分析。\n\n * Spring基础 - Spring简单例子引入Spring的核心\n   * 上文中我们简单介绍了Spring和Spring Framework的组件，那么这些Spring Framework组件是如何配合工作的呢？本文主要承接上文，向你展示Spring Framework组件的典型应用场景和基于这个场景设计出的简单案例，并以此引出Spring的核心要点，比如IOC和AOP等；在此基础上还引入了不同的配置方式， 如XML，Java配置和注解方式的差异。\n\n\n\n * Spring基础 - Spring核心之控制反转(IOC)\n   * 在Spring基础 - Spring简单例子引入Spring的核心中向你展示了IoC的基础含义，同时以此发散了一些IoC相关知识点; 本节将在此基础上进一步解读IOC的含义以及IOC的使用方式\n\n\n\n * Spring基础 - Spring核心之面向切面编程(AOP)\n   * 在Spring基础 - Spring简单例子引入Spring的核心中向你展示了AOP的基础含义，同时以此发散了一些AOP相关知识点; 本节将在此基础上进一步解读AOP的含义以及AOP的使用方式。\n\n\n\n> 基于Spring框架和IOC，AOP的基础，为构建上层web应用，需要进一步学习SpringMVC。\n\n * Spring基础 - SpringMVC请求流程和案例\n   * 前文我们介绍了Spring框架和Spring框架中最为重要的两个技术点（IOC和AOP），那我们如何更好的构建上层的应用呢（比如web 应用），这便是SpringMVC；Spring MVC是Spring在Spring Container Core和AOP等技术基础上，遵循上述Web MVC的规范推出的web开发框架，目的是为了简化Java栈的web开发。 本文主要介绍SpringMVC的请求流程和基础案例的编写和运行。\n\n\n\n> Spring进阶 - IoC，AOP以及SpringMVC的源码分析\n\n * Spring进阶 - Spring IOC实现原理详解之IOC体系结构设计\n   * 在对IoC有了初步的认知后，我们开始对IOC的实现原理进行深入理解。本文将帮助你站在设计者的角度去看IOC最顶层的结构设计\n\n\n\n * Spring进阶 - Spring IOC实现原理详解之IOC初始化流程\n   * 上文，我们看了IOC设计要点和设计结构；紧接着这篇，我们可以看下源码的实现了：Spring如何实现将资源配置（以xml配置为例）通过加载，解析，生成BeanDefination并注册到IoC容器中的\n\n\n\n * Spring进阶 - Spring IOC实现原理详解之Bean实例化(生命周期,循环依赖等)\n   * 上文，我们看了IOC设计要点和设计结构；以及Spring如何实现将资源配置（以xml配置为例）通过加载，解析，生成BeanDefination并注册到IoC容器中的；容器中存放的是Bean的定义即BeanDefinition放到beanDefinitionMap中，本质上是一个ConcurrentHashMap<String, Object>；并且BeanDefinition接口中包含了这个类的Class信息以及是否是单例等。那么如何从BeanDefinition中实例化Bean对象呢，这是本文主要研究的内容？\n\n\n\n * Spring进阶 - Spring AOP实现原理详解之切面实现\n   * 前文，我们分析了Spring IOC的初始化过程和Bean的生命周期等，而Spring AOP也是基于IOC的Bean加载来实现的。本文主要介绍Spring AOP原理解析的切面实现过程(将切面类的所有切面方法根据使用的注解生成对应Advice，并将Advice连同切入点匹配器和切面类等信息一并封装到Advisor，为后续交给代理增强实现做准备的过程)。\n\n\n\n * Spring进阶 - Spring AOP实现原理详解之AOP代理\n   * 上文我们介绍了Spring AOP原理解析的切面实现过程(将切面类的所有切面方法根据使用的注解生成对应Advice，并将Advice连同切入点匹配器和切面类等信息一并封装到Advisor)。本文在此基础上继续介绍，代理（cglib代理和JDK代理）的实现过程。\n\n\n\n * Spring进阶 - Spring AOP实现原理详解之Cglib代理实现\n   * 我们在前文中已经介绍了SpringAOP的切面实现和创建动态代理的过程，那么动态代理是如何工作的呢？本文主要介绍Cglib动态代理的案例和SpringAOP实现的原理。\n\n\n\n * Spring进阶 - Spring AOP实现原理详解之JDK代理实现\n   * 上文我们学习了SpringAOP Cglib动态代理的实现，本文主要是SpringAOP JDK动态代理的案例和实现部分。\n\n\n\n * Spring进阶 - SpringMVC实现原理之DispatcherServlet初始化的过程\n   * 前文我们有了IOC的源码基础以及SpringMVC的基础，我们便可以进一步深入理解SpringMVC主要实现原理，包含DispatcherServlet的初始化过程和DispatcherServlet处理请求的过程的源码解析。本文是第一篇：DispatcherServlet的初始化过程的源码解析。\n\n\n\n * Spring进阶 - SpringMVC实现原理之DispatcherServlet处理请求的过程\n   * 前文我们有了IOC的源码基础以及SpringMVC的基础，我们便可以进一步深入理解SpringMVC主要实现原理，包含DispatcherServlet的初始化过程和DispatcherServlet处理请求的过程的源码解析。本文是第二篇：DispatcherServlet处理请求的过程的源码解析。\n\n\n\n * 转载 https://www.pdai.tech/md/spring/spring.html",normalizedContent:"# ♥spring框架知识体系详解♥\n\n提示\n\n本系列主要介绍spring框架整体架构，spring的核心ioc，aop的案例和具体实现机制；以及springmvc框架的案例和实现机制。\n\n\n# 相关文章\n\n> 首先， 从spring框架的整体架构和组成对整体框架有个认知。\n\n * spring基础 - spring和spring框架组成\n   * spring是什么？它是怎么诞生的？有哪些主要的组件和核心功能呢? 本文通过这几个问题帮助你构筑spring和spring framework的整体认知。\n\n\n\n> 其次，通过案例引出spring的核心（ioc和aop），同时对ioc和aop进行案例使用分析。\n\n * spring基础 - spring简单例子引入spring的核心\n   * 上文中我们简单介绍了spring和spring framework的组件，那么这些spring framework组件是如何配合工作的呢？本文主要承接上文，向你展示spring framework组件的典型应用场景和基于这个场景设计出的简单案例，并以此引出spring的核心要点，比如ioc和aop等；在此基础上还引入了不同的配置方式， 如xml，java配置和注解方式的差异。\n\n\n\n * spring基础 - spring核心之控制反转(ioc)\n   * 在spring基础 - spring简单例子引入spring的核心中向你展示了ioc的基础含义，同时以此发散了一些ioc相关知识点; 本节将在此基础上进一步解读ioc的含义以及ioc的使用方式\n\n\n\n * spring基础 - spring核心之面向切面编程(aop)\n   * 在spring基础 - spring简单例子引入spring的核心中向你展示了aop的基础含义，同时以此发散了一些aop相关知识点; 本节将在此基础上进一步解读aop的含义以及aop的使用方式。\n\n\n\n> 基于spring框架和ioc，aop的基础，为构建上层web应用，需要进一步学习springmvc。\n\n * spring基础 - springmvc请求流程和案例\n   * 前文我们介绍了spring框架和spring框架中最为重要的两个技术点（ioc和aop），那我们如何更好的构建上层的应用呢（比如web 应用），这便是springmvc；spring mvc是spring在spring container core和aop等技术基础上，遵循上述web mvc的规范推出的web开发框架，目的是为了简化java栈的web开发。 本文主要介绍springmvc的请求流程和基础案例的编写和运行。\n\n\n\n> spring进阶 - ioc，aop以及springmvc的源码分析\n\n * spring进阶 - spring ioc实现原理详解之ioc体系结构设计\n   * 在对ioc有了初步的认知后，我们开始对ioc的实现原理进行深入理解。本文将帮助你站在设计者的角度去看ioc最顶层的结构设计\n\n\n\n * spring进阶 - spring ioc实现原理详解之ioc初始化流程\n   * 上文，我们看了ioc设计要点和设计结构；紧接着这篇，我们可以看下源码的实现了：spring如何实现将资源配置（以xml配置为例）通过加载，解析，生成beandefination并注册到ioc容器中的\n\n\n\n * spring进阶 - spring ioc实现原理详解之bean实例化(生命周期,循环依赖等)\n   * 上文，我们看了ioc设计要点和设计结构；以及spring如何实现将资源配置（以xml配置为例）通过加载，解析，生成beandefination并注册到ioc容器中的；容器中存放的是bean的定义即beandefinition放到beandefinitionmap中，本质上是一个concurrenthashmap<string, object>；并且beandefinition接口中包含了这个类的class信息以及是否是单例等。那么如何从beandefinition中实例化bean对象呢，这是本文主要研究的内容？\n\n\n\n * spring进阶 - spring aop实现原理详解之切面实现\n   * 前文，我们分析了spring ioc的初始化过程和bean的生命周期等，而spring aop也是基于ioc的bean加载来实现的。本文主要介绍spring aop原理解析的切面实现过程(将切面类的所有切面方法根据使用的注解生成对应advice，并将advice连同切入点匹配器和切面类等信息一并封装到advisor，为后续交给代理增强实现做准备的过程)。\n\n\n\n * spring进阶 - spring aop实现原理详解之aop代理\n   * 上文我们介绍了spring aop原理解析的切面实现过程(将切面类的所有切面方法根据使用的注解生成对应advice，并将advice连同切入点匹配器和切面类等信息一并封装到advisor)。本文在此基础上继续介绍，代理（cglib代理和jdk代理）的实现过程。\n\n\n\n * spring进阶 - spring aop实现原理详解之cglib代理实现\n   * 我们在前文中已经介绍了springaop的切面实现和创建动态代理的过程，那么动态代理是如何工作的呢？本文主要介绍cglib动态代理的案例和springaop实现的原理。\n\n\n\n * spring进阶 - spring aop实现原理详解之jdk代理实现\n   * 上文我们学习了springaop cglib动态代理的实现，本文主要是springaop jdk动态代理的案例和实现部分。\n\n\n\n * spring进阶 - springmvc实现原理之dispatcherservlet初始化的过程\n   * 前文我们有了ioc的源码基础以及springmvc的基础，我们便可以进一步深入理解springmvc主要实现原理，包含dispatcherservlet的初始化过程和dispatcherservlet处理请求的过程的源码解析。本文是第一篇：dispatcherservlet的初始化过程的源码解析。\n\n\n\n * spring进阶 - springmvc实现原理之dispatcherservlet处理请求的过程\n   * 前文我们有了ioc的源码基础以及springmvc的基础，我们便可以进一步深入理解springmvc主要实现原理，包含dispatcherservlet的初始化过程和dispatcherservlet处理请求的过程的源码解析。本文是第二篇：dispatcherservlet处理请求的过程的源码解析。\n\n\n\n * 转载 https://www.pdai.tech/md/spring/spring.html",charsets:{cjk:!0}},{title:"Java 并发 - 线程基础",frontmatter:{},regularPath:"/java/thread/java-thread-x-thread-basic.html",relativePath:"java/thread/java-thread-x-thread-basic.md",key:"v-4ffe6dba",path:"/java/thread/java-thread-x-thread-basic.html",headers:[{level:2,title:"Java 并发 - 线程基础",slug:"java-并发-线程基础",normalizedTitle:"java 并发 - 线程基础",charIndex:2},{level:2,title:"带着BAT大厂的面试问题去理解",slug:"带着bat大厂的面试问题去理解",normalizedTitle:"带着bat大厂的面试问题去理解",charIndex:659},{level:2,title:"线程状态转换",slug:"线程状态转换",normalizedTitle:"线程状态转换",charIndex:85},{level:3,title:"新建(New)",slug:"新建-new",normalizedTitle:"新建(new)",charIndex:99},{level:3,title:"可运行(Runnable)",slug:"可运行-runnable",normalizedTitle:"可运行(runnable)",charIndex:114},{level:3,title:"阻塞(Blocking)",slug:"阻塞-blocking",normalizedTitle:"阻塞(blocking)",charIndex:135},{level:3,title:"无限期等待(Waiting)",slug:"无限期等待-waiting",normalizedTitle:"无限期等待(waiting)",charIndex:155},{level:3,title:"限期等待(Timed Waiting)",slug:"限期等待-timed-waiting",normalizedTitle:"限期等待(timed waiting)",charIndex:177},{level:3,title:"死亡(Terminated)",slug:"死亡-terminated",normalizedTitle:"死亡(terminated)",charIndex:204},{level:2,title:"线程使用方式",slug:"线程使用方式",normalizedTitle:"线程使用方式",charIndex:224},{level:3,title:"实现 Runnable 接口",slug:"实现-runnable-接口",normalizedTitle:"实现 runnable 接口",charIndex:238},{level:3,title:"实现 Callable 接口",slug:"实现-callable-接口",normalizedTitle:"实现 callable 接口",charIndex:260},{level:3,title:"继承 Thread 类",slug:"继承-thread-类",normalizedTitle:"继承 thread 类",charIndex:282},{level:3,title:"实现接口 VS 继承 Thread",slug:"实现接口-vs-继承-thread",normalizedTitle:"实现接口 vs 继承 thread",charIndex:301},{level:2,title:"基础线程机制",slug:"基础线程机制",normalizedTitle:"基础线程机制",charIndex:324},{level:3,title:"Executor",slug:"executor",normalizedTitle:"executor",charIndex:338},{level:3,title:"Daemon",slug:"daemon",normalizedTitle:"daemon",charIndex:354},{level:3,title:"sleep()",slug:"sleep",normalizedTitle:"sleep()",charIndex:368},{level:3,title:"yield()",slug:"yield",normalizedTitle:"yield()",charIndex:383},{level:2,title:"线程中断",slug:"线程中断",normalizedTitle:"线程中断",charIndex:396},{level:3,title:"InterruptedException",slug:"interruptedexception",normalizedTitle:"interruptedexception",charIndex:408},{level:3,title:"interrupted()",slug:"interrupted",normalizedTitle:"interrupted()",charIndex:436},{level:3,title:"Executor 的中断操作",slug:"executor-的中断操作",normalizedTitle:"executor 的中断操作",charIndex:457},{level:2,title:"线程互斥同步",slug:"线程互斥同步",normalizedTitle:"线程互斥同步",charIndex:477},{level:3,title:"synchronized",slug:"synchronized",normalizedTitle:"synchronized",charIndex:491},{level:3,title:"ReentrantLock",slug:"reentrantlock",normalizedTitle:"reentrantlock",charIndex:511},{level:3,title:"比较",slug:"比较",normalizedTitle:"比较",charIndex:532},{level:3,title:"使用选择",slug:"使用选择",normalizedTitle:"使用选择",charIndex:542},{level:2,title:"线程之间的协作",slug:"线程之间的协作",normalizedTitle:"线程之间的协作",charIndex:552},{level:3,title:"join()",slug:"join",normalizedTitle:"join()",charIndex:567},{level:3,title:"wait() notify() notifyAll()",slug:"wait-notify-notifyall",normalizedTitle:"wait() notify() notifyall()",charIndex:581},{level:3,title:"await() signal() signalAll()",slug:"await-signal-signalall",normalizedTitle:"await() signal() signalall()",charIndex:616},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:650}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java 并发 - 线程基础 带着BAT大厂的面试问题去理解 线程状态转换 新建(New) 可运行(Runnable) 阻塞(Blocking) 无限期等待(Waiting) 限期等待(Timed Waiting) 死亡(Terminated) 线程使用方式 实现 Runnable 接口 实现 Callable 接口 继承 Thread 类 实现接口 VS 继承 Thread 基础线程机制 Executor Daemon sleep() yield() 线程中断 InterruptedException interrupted() Executor 的中断操作 线程互斥同步 synchronized ReentrantLock 比较 使用选择 线程之间的协作 join() wait() notify() notifyAll() await() signal() signalAll() 参考文章",content:'# Java 并发 - 线程基础\n\n> 本文主要概要性的介绍线程的基础，为后面的章节深入介绍Java并发的知识提供基础。\n\n * Java 并发 - 线程基础\n   * 线程状态转换\n     * 新建(New)\n     * 可运行(Runnable)\n     * 阻塞(Blocking)\n     * 无限期等待(Waiting)\n     * 限期等待(Timed Waiting)\n     * 死亡(Terminated)\n   * 线程使用方式\n     * 实现 Runnable 接口\n     * 实现 Callable 接口\n     * 继承 Thread 类\n     * 实现接口 VS 继承 Thread\n   * 基础线程机制\n     * Executor\n     * Daemon\n     * sleep()\n     * yield()\n   * 线程中断\n     * InterruptedException\n     * interrupted()\n     * Executor 的中断操作\n   * 线程互斥同步\n     * synchronized\n     * ReentrantLock\n     * 比较\n     * 使用选择\n   * 线程之间的协作\n     * join()\n     * wait() notify() notifyAll()\n     * await() signal() signalAll()\n   * 参考文章\n\n\n# 带着BAT大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解线程基础。@pdai\n\n * 线程有哪几种状态? 分别说明从一种状态到另一种状态转变有哪些方式?\n * 通常线程有哪几种使用方式?\n * 基础线程机制有哪些?\n * 线程的中断方式有哪些?\n * 线程的互斥同步方式有哪些? 如何比较和选择?\n * 线程之间有哪些协作方式?\n\n\n# 线程状态转换\n\n\n\n\n# 新建(New)\n\n创建后尚未启动。\n\n\n# 可运行(Runnable)\n\n可能正在运行，也可能正在等待 CPU 时间片。\n\n包含了操作系统线程状态中的 Running 和 Ready。\n\n\n# 阻塞(Blocking)\n\n等待获取一个排它锁，如果其线程释放了锁就会结束此状态。\n\n\n# 无限期等待(Waiting)\n\n等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。\n\n进入方法                                退出方法\n没有设置 Timeout 参数的 Object.wait() 方法   Object.notify() / Object.notifyAll()\n没有设置 Timeout 参数的 Thread.join() 方法   被调用的线程执行完毕\nLockSupport.park() 方法               -\n\n\n# 限期等待(Timed Waiting)\n\n无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。\n\n调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。\n\n调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。\n\n睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。\n\n阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。\n\n进入方法                               退出方法\nThread.sleep() 方法                  时间结束\n设置了 Timeout 参数的 Object.wait() 方法   时间结束 / Object.notify() / Object.notifyAll()\n设置了 Timeout 参数的 Thread.join() 方法   时间结束 / 被调用的线程执行完毕\nLockSupport.parkNanos() 方法         -\nLockSupport.parkUntil() 方法         -\n\n\n# 死亡(Terminated)\n\n可以是线程结束任务之后自己结束，或者产生了异常而结束。\n\n\n# 线程使用方式\n\n有三种使用线程的方法:\n\n * 实现 Runnable 接口；\n * 实现 Callable 接口；\n * 继承 Thread 类。\n\n实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。\n\n\n# 实现 Runnable 接口\n\n需要实现 run() 方法。\n\n通过 Thread 调用 start() 方法来启动线程。\n\npublic class MyRunnable implements Runnable {\n    public void run() {\n        // ...\n    }\n}\n\n\npublic static void main(String[] args) {\n    MyRunnable instance = new MyRunnable();\n    Thread thread = new Thread(instance);\n    thread.start();\n}\n\n\n\n# 实现 Callable 接口\n\n与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。\n\npublic class MyCallable implements Callable<Integer> {\n    public Integer call() {\n        return 123;\n    }\n}\n\n\npublic static void main(String[] args) throws ExecutionException, InterruptedException {\n    MyCallable mc = new MyCallable();\n    FutureTask<Integer> ft = new FutureTask<>(mc);\n    Thread thread = new Thread(ft);\n    thread.start();\n    System.out.println(ft.get());\n}\n\n\n\n# 继承 Thread 类\n\n同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。\n\n当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。\n\npublic class MyThread extends Thread {\n    public void run() {\n        // ...\n    }\n}\n\n\npublic static void main(String[] args) {\n    MyThread mt = new MyThread();\n    mt.start();\n}\n\n\n\n# 实现接口 VS 继承 Thread\n\n实现接口会更好一些，因为:\n\n * Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；\n * 类可能只要求可执行就行，继承整个 Thread 类开销过大。\n\n\n# 基础线程机制\n\n\n# Executor\n\nExecutor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。\n\n主要有三种 Executor:\n\n * CachedThreadPool: 一个任务创建一个线程；\n * FixedThreadPool: 所有任务只能使用固定大小的线程；\n * SingleThreadExecutor: 相当于大小为 1 的 FixedThreadPool。\n\npublic static void main(String[] args) {\n    ExecutorService executorService = Executors.newCachedThreadPool();\n    for (int i = 0; i < 5; i++) {\n        executorService.execute(new MyRunnable());\n    }\n    executorService.shutdown();\n}\n\n\n\n# Daemon\n\n守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。\n\n当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。\n\nmain() 属于非守护线程。\n\n使用 setDaemon() 方法将一个线程设置为守护线程。\n\npublic static void main(String[] args) {\n    Thread thread = new Thread(new MyRunnable());\n    thread.setDaemon(true);\n}\n\n\n\n# sleep()\n\nThread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。\n\nsleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。\n\npublic void run() {\n    try {\n        Thread.sleep(3000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}\n\n\n\n# yield()\n\n对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。\n\npublic void run() {\n    Thread.yield();\n}\n\n\n\n# 线程中断\n\n一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。\n\n\n# InterruptedException\n\n通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。\n\n对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。\n\npublic class InterruptExample {\n\n    private static class MyThread1 extends Thread {\n        @Override\n        public void run() {\n            try {\n                Thread.sleep(2000);\n                System.out.println("Thread run");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n\npublic static void main(String[] args) throws InterruptedException {\n    Thread thread1 = new MyThread1();\n    thread1.start();\n    thread1.interrupt();\n    System.out.println("Main run");\n}\n\n\nMain run\njava.lang.InterruptedException: sleep interrupted\n    at java.lang.Thread.sleep(Native Method)\n    at InterruptExample.lambda$main$0(InterruptExample.java:5)\n    at InterruptExample$$Lambda$1/713338599.run(Unknown Source)\n    at java.lang.Thread.run(Thread.java:745)\n\n\n\n# interrupted()\n\n如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。\n\n但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。\n\npublic class InterruptExample {\n\n    private static class MyThread2 extends Thread {\n        @Override\n        public void run() {\n            while (!interrupted()) {\n                // ..\n            }\n            System.out.println("Thread end");\n        }\n    }\n}\n\n\npublic static void main(String[] args) throws InterruptedException {\n    Thread thread2 = new MyThread2();\n    thread2.start();\n    thread2.interrupt();\n}\n\n\n\n# Executor 的中断操作\n\n调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。\n\n以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。\n\npublic static void main(String[] args) {\n    ExecutorService executorService = Executors.newCachedThreadPool();\n    executorService.execute(() -> {\n        try {\n            Thread.sleep(2000);\n            System.out.println("Thread run");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    });\n    executorService.shutdownNow();\n    System.out.println("Main run");\n}\n\n\nMain run\njava.lang.InterruptedException: sleep interrupted\n    at java.lang.Thread.sleep(Native Method)\n    at ExecutorInterruptExample.lambda$main$0(ExecutorInterruptExample.java:9)\n    at ExecutorInterruptExample$$Lambda$1/1160460865.run(Unknown Source)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\n\n\n如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future<?> 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。\n\nFuture<?> future = executorService.submit(() -> {\n    // ..\n});\nfuture.cancel(true);\n\n\n\n# 线程互斥同步\n\nJava 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。\n\n\n# synchronized\n\n1. 同步一个代码块\n\npublic void func() {\n    synchronized (this) {\n        // ...\n    }\n}\n\n\n它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。\n\n对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。\n\npublic class SynchronizedExample {\n\n    public void func1() {\n        synchronized (this) {\n            for (int i = 0; i < 10; i++) {\n                System.out.print(i + " ");\n            }\n        }\n    }\n}\n\n\npublic static void main(String[] args) {\n    SynchronizedExample e1 = new SynchronizedExample();\n    ExecutorService executorService = Executors.newCachedThreadPool();\n    executorService.execute(() -> e1.func1());\n    executorService.execute(() -> e1.func1());\n}\n\n\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\n\n\n对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。\n\npublic static void main(String[] args) {\n    SynchronizedExample e1 = new SynchronizedExample();\n    SynchronizedExample e2 = new SynchronizedExample();\n    ExecutorService executorService = Executors.newCachedThreadPool();\n    executorService.execute(() -> e1.func1());\n    executorService.execute(() -> e2.func1());\n}\n\n\n0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9\n\n\n2. 同步一个方法\n\npublic synchronized void func () {\n    // ...\n}\n\n\n它和同步代码块一样，作用于同一个对象。\n\n3. 同步一个类\n\npublic void func() {\n    synchronized (SynchronizedExample.class) {\n        // ...\n    }\n}\n\n\n作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。\n\npublic class SynchronizedExample {\n\n    public void func2() {\n        synchronized (SynchronizedExample.class) {\n            for (int i = 0; i < 10; i++) {\n                System.out.print(i + " ");\n            }\n        }\n    }\n}\n\n\npublic static void main(String[] args) {\n    SynchronizedExample e1 = new SynchronizedExample();\n    SynchronizedExample e2 = new SynchronizedExample();\n    ExecutorService executorService = Executors.newCachedThreadPool();\n    executorService.execute(() -> e1.func2());\n    executorService.execute(() -> e2.func2());\n}\n\n\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\n\n\n4. 同步一个静态方法\n\npublic synchronized static void fun() {\n    // ...\n}\n\n\n作用于整个类。\n\n\n# ReentrantLock\n\nReentrantLock 是 java.util.concurrent(J.U.C)包中的锁。\n\npublic class LockExample {\n\n    private Lock lock = new ReentrantLock();\n\n    public void func() {\n        lock.lock();\n        try {\n            for (int i = 0; i < 10; i++) {\n                System.out.print(i + " ");\n            }\n        } finally {\n            lock.unlock(); // 确保释放锁，从而避免发生死锁。\n        }\n    }\n}\n\n\npublic static void main(String[] args) {\n    LockExample lockExample = new LockExample();\n    ExecutorService executorService = Executors.newCachedThreadPool();\n    executorService.execute(() -> lockExample.func());\n    executorService.execute(() -> lockExample.func());\n}\n\n\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\n\n\n\n# 比较\n\n1. 锁的实现\n\nsynchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。\n\n2. 性能\n\n新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。\n\n3. 等待可中断\n\n当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。\n\nReentrantLock 可中断，而 synchronized 不行。\n\n4. 公平锁\n\n公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。\n\nsynchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。\n\n5. 锁绑定多个条件\n\n一个 ReentrantLock 可以同时绑定多个 Condition 对象。\n\n\n# 使用选择\n\n除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。\n\n\n# 线程之间的协作\n\n当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。\n\n\n# join()\n\n在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。\n\n对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。\n\npublic class JoinExample {\n\n    private class A extends Thread {\n        @Override\n        public void run() {\n            System.out.println("A");\n        }\n    }\n\n    private class B extends Thread {\n\n        private A a;\n\n        B(A a) {\n            this.a = a;\n        }\n\n        @Override\n        public void run() {\n            try {\n                a.join();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println("B");\n        }\n    }\n\n    public void test() {\n        A a = new A();\n        B b = new B(a);\n        b.start();\n        a.start();\n    }\n}\n\n\npublic static void main(String[] args) {\n    JoinExample example = new JoinExample();\n    example.test();\n}\n\n\n\n# wait() notify() notifyAll()\n\n调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。\n\n它们都属于 Object 的一部分，而不属于 Thread。\n\n只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateExeception。\n\n使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。\n\npublic class WaitNotifyExample {\n    public synchronized void before() {\n        System.out.println("before");\n        notifyAll();\n    }\n\n    public synchronized void after() {\n        try {\n            wait();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println("after");\n    }\n}\n\n\npublic static void main(String[] args) {\n    ExecutorService executorService = Executors.newCachedThreadPool();\n    WaitNotifyExample example = new WaitNotifyExample();\n    executorService.execute(() -> example.after());\n    executorService.execute(() -> example.before());\n}\n\n\nwait() 和 sleep() 的区别\n\n * wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；\n * wait() 会释放锁，sleep() 不会。\n\n\n# await() signal() signalAll()\n\njava.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。\n\n使用 Lock 来获取一个 Condition 对象。\n\npublic class AwaitSignalExample {\n    private Lock lock = new ReentrantLock();\n    private Condition condition = lock.newCondition();\n\n    public void before() {\n        lock.lock();\n        try {\n            System.out.println("before");\n            condition.signalAll();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void after() {\n        lock.lock();\n        try {\n            condition.await();\n            System.out.println("after");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\n\npublic static void main(String[] args) {\n    ExecutorService executorService = Executors.newCachedThreadPool();\n    AwaitSignalExample example = new AwaitSignalExample();\n    executorService.execute(() -> example.after());\n    executorService.execute(() -> example.before());\n}\n\n\n\n# 参考文章\n\n转载 https://www.pdai.tech/md/java/thread/java-thread-x-thread-basic.html',normalizedContent:'# java 并发 - 线程基础\n\n> 本文主要概要性的介绍线程的基础，为后面的章节深入介绍java并发的知识提供基础。\n\n * java 并发 - 线程基础\n   * 线程状态转换\n     * 新建(new)\n     * 可运行(runnable)\n     * 阻塞(blocking)\n     * 无限期等待(waiting)\n     * 限期等待(timed waiting)\n     * 死亡(terminated)\n   * 线程使用方式\n     * 实现 runnable 接口\n     * 实现 callable 接口\n     * 继承 thread 类\n     * 实现接口 vs 继承 thread\n   * 基础线程机制\n     * executor\n     * daemon\n     * sleep()\n     * yield()\n   * 线程中断\n     * interruptedexception\n     * interrupted()\n     * executor 的中断操作\n   * 线程互斥同步\n     * synchronized\n     * reentrantlock\n     * 比较\n     * 使用选择\n   * 线程之间的协作\n     * join()\n     * wait() notify() notifyall()\n     * await() signal() signalall()\n   * 参考文章\n\n\n# 带着bat大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解线程基础。@pdai\n\n * 线程有哪几种状态? 分别说明从一种状态到另一种状态转变有哪些方式?\n * 通常线程有哪几种使用方式?\n * 基础线程机制有哪些?\n * 线程的中断方式有哪些?\n * 线程的互斥同步方式有哪些? 如何比较和选择?\n * 线程之间有哪些协作方式?\n\n\n# 线程状态转换\n\n\n\n\n# 新建(new)\n\n创建后尚未启动。\n\n\n# 可运行(runnable)\n\n可能正在运行，也可能正在等待 cpu 时间片。\n\n包含了操作系统线程状态中的 running 和 ready。\n\n\n# 阻塞(blocking)\n\n等待获取一个排它锁，如果其线程释放了锁就会结束此状态。\n\n\n# 无限期等待(waiting)\n\n等待其它线程显式地唤醒，否则不会被分配 cpu 时间片。\n\n进入方法                                退出方法\n没有设置 timeout 参数的 object.wait() 方法   object.notify() / object.notifyall()\n没有设置 timeout 参数的 thread.join() 方法   被调用的线程执行完毕\nlocksupport.park() 方法               -\n\n\n# 限期等待(timed waiting)\n\n无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。\n\n调用 thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。\n\n调用 object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。\n\n睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。\n\n阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 thread.sleep() 和 object.wait() 等方法进入。\n\n进入方法                               退出方法\nthread.sleep() 方法                  时间结束\n设置了 timeout 参数的 object.wait() 方法   时间结束 / object.notify() / object.notifyall()\n设置了 timeout 参数的 thread.join() 方法   时间结束 / 被调用的线程执行完毕\nlocksupport.parknanos() 方法         -\nlocksupport.parkuntil() 方法         -\n\n\n# 死亡(terminated)\n\n可以是线程结束任务之后自己结束，或者产生了异常而结束。\n\n\n# 线程使用方式\n\n有三种使用线程的方法:\n\n * 实现 runnable 接口；\n * 实现 callable 接口；\n * 继承 thread 类。\n\n实现 runnable 和 callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 thread 来调用。可以说任务是通过线程驱动从而执行的。\n\n\n# 实现 runnable 接口\n\n需要实现 run() 方法。\n\n通过 thread 调用 start() 方法来启动线程。\n\npublic class myrunnable implements runnable {\n    public void run() {\n        // ...\n    }\n}\n\n\npublic static void main(string[] args) {\n    myrunnable instance = new myrunnable();\n    thread thread = new thread(instance);\n    thread.start();\n}\n\n\n\n# 实现 callable 接口\n\n与 runnable 相比，callable 可以有返回值，返回值通过 futuretask 进行封装。\n\npublic class mycallable implements callable<integer> {\n    public integer call() {\n        return 123;\n    }\n}\n\n\npublic static void main(string[] args) throws executionexception, interruptedexception {\n    mycallable mc = new mycallable();\n    futuretask<integer> ft = new futuretask<>(mc);\n    thread thread = new thread(ft);\n    thread.start();\n    system.out.println(ft.get());\n}\n\n\n\n# 继承 thread 类\n\n同样也是需要实现 run() 方法，因为 thread 类也实现了 runable 接口。\n\n当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。\n\npublic class mythread extends thread {\n    public void run() {\n        // ...\n    }\n}\n\n\npublic static void main(string[] args) {\n    mythread mt = new mythread();\n    mt.start();\n}\n\n\n\n# 实现接口 vs 继承 thread\n\n实现接口会更好一些，因为:\n\n * java 不支持多重继承，因此继承了 thread 类就无法继承其它类，但是可以实现多个接口；\n * 类可能只要求可执行就行，继承整个 thread 类开销过大。\n\n\n# 基础线程机制\n\n\n# executor\n\nexecutor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。\n\n主要有三种 executor:\n\n * cachedthreadpool: 一个任务创建一个线程；\n * fixedthreadpool: 所有任务只能使用固定大小的线程；\n * singlethreadexecutor: 相当于大小为 1 的 fixedthreadpool。\n\npublic static void main(string[] args) {\n    executorservice executorservice = executors.newcachedthreadpool();\n    for (int i = 0; i < 5; i++) {\n        executorservice.execute(new myrunnable());\n    }\n    executorservice.shutdown();\n}\n\n\n\n# daemon\n\n守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。\n\n当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。\n\nmain() 属于非守护线程。\n\n使用 setdaemon() 方法将一个线程设置为守护线程。\n\npublic static void main(string[] args) {\n    thread thread = new thread(new myrunnable());\n    thread.setdaemon(true);\n}\n\n\n\n# sleep()\n\nthread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。\n\nsleep() 可能会抛出 interruptedexception，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。\n\npublic void run() {\n    try {\n        thread.sleep(3000);\n    } catch (interruptedexception e) {\n        e.printstacktrace();\n    }\n}\n\n\n\n# yield()\n\n对静态方法 thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。\n\npublic void run() {\n    thread.yield();\n}\n\n\n\n# 线程中断\n\n一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。\n\n\n# interruptedexception\n\n通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 interruptedexception，从而提前结束该线程。但是不能中断 i/o 阻塞和 synchronized 锁阻塞。\n\n对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 thread.sleep() 方法，因此会抛出一个 interruptedexception，从而提前结束线程，不执行之后的语句。\n\npublic class interruptexample {\n\n    private static class mythread1 extends thread {\n        @override\n        public void run() {\n            try {\n                thread.sleep(2000);\n                system.out.println("thread run");\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }\n    }\n}\n\n\npublic static void main(string[] args) throws interruptedexception {\n    thread thread1 = new mythread1();\n    thread1.start();\n    thread1.interrupt();\n    system.out.println("main run");\n}\n\n\nmain run\njava.lang.interruptedexception: sleep interrupted\n    at java.lang.thread.sleep(native method)\n    at interruptexample.lambda$main$0(interruptexample.java:5)\n    at interruptexample$$lambda$1/713338599.run(unknown source)\n    at java.lang.thread.run(thread.java:745)\n\n\n\n# interrupted()\n\n如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 interruptedexception 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。\n\n但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。\n\npublic class interruptexample {\n\n    private static class mythread2 extends thread {\n        @override\n        public void run() {\n            while (!interrupted()) {\n                // ..\n            }\n            system.out.println("thread end");\n        }\n    }\n}\n\n\npublic static void main(string[] args) throws interruptedexception {\n    thread thread2 = new mythread2();\n    thread2.start();\n    thread2.interrupt();\n}\n\n\n\n# executor 的中断操作\n\n调用 executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownnow() 方法，则相当于调用每个线程的 interrupt() 方法。\n\n以下使用 lambda 创建线程，相当于创建了一个匿名内部线程。\n\npublic static void main(string[] args) {\n    executorservice executorservice = executors.newcachedthreadpool();\n    executorservice.execute(() -> {\n        try {\n            thread.sleep(2000);\n            system.out.println("thread run");\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n    });\n    executorservice.shutdownnow();\n    system.out.println("main run");\n}\n\n\nmain run\njava.lang.interruptedexception: sleep interrupted\n    at java.lang.thread.sleep(native method)\n    at executorinterruptexample.lambda$main$0(executorinterruptexample.java:9)\n    at executorinterruptexample$$lambda$1/1160460865.run(unknown source)\n    at java.util.concurrent.threadpoolexecutor.runworker(threadpoolexecutor.java:1142)\n    at java.util.concurrent.threadpoolexecutor$worker.run(threadpoolexecutor.java:617)\n    at java.lang.thread.run(thread.java:745)\n\n\n如果只想中断 executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 future<?> 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。\n\nfuture<?> future = executorservice.submit(() -> {\n    // ..\n});\nfuture.cancel(true);\n\n\n\n# 线程互斥同步\n\njava 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 jvm 实现的 synchronized，而另一个是 jdk 实现的 reentrantlock。\n\n\n# synchronized\n\n1. 同步一个代码块\n\npublic void func() {\n    synchronized (this) {\n        // ...\n    }\n}\n\n\n它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。\n\n对于以下代码，使用 executorservice 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。\n\npublic class synchronizedexample {\n\n    public void func1() {\n        synchronized (this) {\n            for (int i = 0; i < 10; i++) {\n                system.out.print(i + " ");\n            }\n        }\n    }\n}\n\n\npublic static void main(string[] args) {\n    synchronizedexample e1 = new synchronizedexample();\n    executorservice executorservice = executors.newcachedthreadpool();\n    executorservice.execute(() -> e1.func1());\n    executorservice.execute(() -> e1.func1());\n}\n\n\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\n\n\n对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。\n\npublic static void main(string[] args) {\n    synchronizedexample e1 = new synchronizedexample();\n    synchronizedexample e2 = new synchronizedexample();\n    executorservice executorservice = executors.newcachedthreadpool();\n    executorservice.execute(() -> e1.func1());\n    executorservice.execute(() -> e2.func1());\n}\n\n\n0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9\n\n\n2. 同步一个方法\n\npublic synchronized void func () {\n    // ...\n}\n\n\n它和同步代码块一样，作用于同一个对象。\n\n3. 同步一个类\n\npublic void func() {\n    synchronized (synchronizedexample.class) {\n        // ...\n    }\n}\n\n\n作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。\n\npublic class synchronizedexample {\n\n    public void func2() {\n        synchronized (synchronizedexample.class) {\n            for (int i = 0; i < 10; i++) {\n                system.out.print(i + " ");\n            }\n        }\n    }\n}\n\n\npublic static void main(string[] args) {\n    synchronizedexample e1 = new synchronizedexample();\n    synchronizedexample e2 = new synchronizedexample();\n    executorservice executorservice = executors.newcachedthreadpool();\n    executorservice.execute(() -> e1.func2());\n    executorservice.execute(() -> e2.func2());\n}\n\n\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\n\n\n4. 同步一个静态方法\n\npublic synchronized static void fun() {\n    // ...\n}\n\n\n作用于整个类。\n\n\n# reentrantlock\n\nreentrantlock 是 java.util.concurrent(j.u.c)包中的锁。\n\npublic class lockexample {\n\n    private lock lock = new reentrantlock();\n\n    public void func() {\n        lock.lock();\n        try {\n            for (int i = 0; i < 10; i++) {\n                system.out.print(i + " ");\n            }\n        } finally {\n            lock.unlock(); // 确保释放锁，从而避免发生死锁。\n        }\n    }\n}\n\n\npublic static void main(string[] args) {\n    lockexample lockexample = new lockexample();\n    executorservice executorservice = executors.newcachedthreadpool();\n    executorservice.execute(() -> lockexample.func());\n    executorservice.execute(() -> lockexample.func());\n}\n\n\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\n\n\n\n# 比较\n\n1. 锁的实现\n\nsynchronized 是 jvm 实现的，而 reentrantlock 是 jdk 实现的。\n\n2. 性能\n\n新版本 java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 reentrantlock 大致相同。\n\n3. 等待可中断\n\n当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。\n\nreentrantlock 可中断，而 synchronized 不行。\n\n4. 公平锁\n\n公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。\n\nsynchronized 中的锁是非公平的，reentrantlock 默认情况下也是非公平的，但是也可以是公平的。\n\n5. 锁绑定多个条件\n\n一个 reentrantlock 可以同时绑定多个 condition 对象。\n\n\n# 使用选择\n\n除非需要使用 reentrantlock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 jvm 实现的一种锁机制，jvm 原生地支持它，而 reentrantlock 不是所有的 jdk 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 jvm 会确保锁的释放。\n\n\n# 线程之间的协作\n\n当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。\n\n\n# join()\n\n在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。\n\n对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。\n\npublic class joinexample {\n\n    private class a extends thread {\n        @override\n        public void run() {\n            system.out.println("a");\n        }\n    }\n\n    private class b extends thread {\n\n        private a a;\n\n        b(a a) {\n            this.a = a;\n        }\n\n        @override\n        public void run() {\n            try {\n                a.join();\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n            system.out.println("b");\n        }\n    }\n\n    public void test() {\n        a a = new a();\n        b b = new b(a);\n        b.start();\n        a.start();\n    }\n}\n\n\npublic static void main(string[] args) {\n    joinexample example = new joinexample();\n    example.test();\n}\n\n\n\n# wait() notify() notifyall()\n\n调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyall() 来唤醒挂起的线程。\n\n它们都属于 object 的一部分，而不属于 thread。\n\n只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 illegalmonitorstateexeception。\n\n使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyall() 来唤醒挂起的线程，造成死锁。\n\npublic class waitnotifyexample {\n    public synchronized void before() {\n        system.out.println("before");\n        notifyall();\n    }\n\n    public synchronized void after() {\n        try {\n            wait();\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n        system.out.println("after");\n    }\n}\n\n\npublic static void main(string[] args) {\n    executorservice executorservice = executors.newcachedthreadpool();\n    waitnotifyexample example = new waitnotifyexample();\n    executorservice.execute(() -> example.after());\n    executorservice.execute(() -> example.before());\n}\n\n\nwait() 和 sleep() 的区别\n\n * wait() 是 object 的方法，而 sleep() 是 thread 的静态方法；\n * wait() 会释放锁，sleep() 不会。\n\n\n# await() signal() signalall()\n\njava.util.concurrent 类库中提供了 condition 类来实现线程之间的协调，可以在 condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalall() 方法唤醒等待的线程。相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。\n\n使用 lock 来获取一个 condition 对象。\n\npublic class awaitsignalexample {\n    private lock lock = new reentrantlock();\n    private condition condition = lock.newcondition();\n\n    public void before() {\n        lock.lock();\n        try {\n            system.out.println("before");\n            condition.signalall();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void after() {\n        lock.lock();\n        try {\n            condition.await();\n            system.out.println("after");\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\n\npublic static void main(string[] args) {\n    executorservice executorservice = executors.newcachedthreadpool();\n    awaitsignalexample example = new awaitsignalexample();\n    executorservice.execute(() -> example.after());\n    executorservice.execute(() -> example.before());\n}\n\n\n\n# 参考文章\n\n转载 https://www.pdai.tech/md/java/thread/java-thread-x-thread-basic.html',charsets:{cjk:!0}},{title:"Java 并发 - ThreadLocal详解",frontmatter:{},regularPath:"/java/thread/java-thread-x-threadlocal.html",relativePath:"java/thread/java-thread-x-threadlocal.md",key:"v-064549ee",path:"/java/thread/java-thread-x-threadlocal.html",headers:[{level:2,title:"Java 并发 - ThreadLocal详解",slug:"java-并发-threadlocal详解",normalizedTitle:"java 并发 - threadlocal详解",charIndex:2},{level:2,title:"带着BAT大厂的面试问题去理解",slug:"带着bat大厂的面试问题去理解",normalizedTitle:"带着bat大厂的面试问题去理解",charIndex:140},{level:2,title:"ThreadLocal简介",slug:"threadlocal简介",normalizedTitle:"threadlocal简介",charIndex:161},{level:2,title:"ThreadLocal理解",slug:"threadlocal理解",normalizedTitle:"threadlocal理解",charIndex:180},{level:2,title:"ThreadLocal原理",slug:"threadlocal原理",normalizedTitle:"threadlocal原理",charIndex:199},{level:3,title:"如何实现线程隔离",slug:"如何实现线程隔离",normalizedTitle:"如何实现线程隔离",charIndex:220},{level:3,title:"ThreadLocalMap对象是什么",slug:"threadlocalmap对象是什么",normalizedTitle:"threadlocalmap对象是什么",charIndex:236},{level:2,title:"ThreadLocal造成内存泄露的问题",slug:"threadlocal造成内存泄露的问题",normalizedTitle:"threadlocal造成内存泄露的问题",charIndex:261},{level:2,title:"再看ThreadLocal应用场景",slug:"再看threadlocal应用场景",normalizedTitle:"再看threadlocal应用场景",charIndex:287},{level:3,title:"每个线程维护了一个“序列号”",slug:"每个线程维护了一个-序列号",normalizedTitle:"每个线程维护了一个“序列号”",charIndex:312},{level:3,title:"Session的管理",slug:"session的管理",normalizedTitle:"session的管理",charIndex:334},{level:3,title:"在线程内部创建ThreadLocal",slug:"在线程内部创建threadlocal",normalizedTitle:"在线程内部创建threadlocal",charIndex:352},{level:3,title:"java 开发手册中推荐的 ThreadLocal",slug:"java-开发手册中推荐的-threadlocal",normalizedTitle:"java 开发手册中推荐的 threadlocal",charIndex:378},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:409}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"Java 并发 - ThreadLocal详解 带着BAT大厂的面试问题去理解 ThreadLocal简介 ThreadLocal理解 ThreadLocal原理 如何实现线程隔离 ThreadLocalMap对象是什么 ThreadLocal造成内存泄露的问题 再看ThreadLocal应用场景 每个线程维护了一个“序列号” Session的管理 在线程内部创建ThreadLocal java 开发手册中推荐的 ThreadLocal 参考文章",content:'# Java 并发 - ThreadLocal详解\n\n> ThreadLocal是通过线程隔离的方式防止任务在共享资源上产生冲突, 线程本地存储是一种自动化机制，可以为使用相同变量的每个不同线程都创建不同的存储。\n\n * Java 并发 - ThreadLocal详解\n   * 带着BAT大厂的面试问题去理解\n   * ThreadLocal简介\n   * ThreadLocal理解\n   * ThreadLocal原理\n     * 如何实现线程隔离\n     * ThreadLocalMap对象是什么\n   * ThreadLocal造成内存泄露的问题\n   * 再看ThreadLocal应用场景\n     * 每个线程维护了一个“序列号”\n     * Session的管理\n     * 在线程内部创建ThreadLocal\n     * java 开发手册中推荐的 ThreadLocal\n   * 参考文章\n\n\n# 带着BAT大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 什么是ThreadLocal? 用来解决什么问题的?\n * 说说你对ThreadLocal的理解\n * ThreadLocal是如何实现线程隔离的?\n * 为什么ThreadLocal会造成内存泄露? 如何解决\n * 还有哪些使用ThreadLocal的应用场景?\n\n\n# ThreadLocal简介\n\n我们在Java 并发 - 并发理论基础总结过线程安全(是指广义上的共享资源访问安全性，因为线程隔离是通过副本保证本线程访问资源安全性，它不保证线程之间还存在共享关系的狭义上的安全性)的解决思路：\n\n * 互斥同步: synchronized 和 ReentrantLock\n * 非阻塞同步: CAS, AtomicXXXX\n * 无同步方案: 栈封闭，本地存储(Thread Local)，可重入代码\n\n这个章节将详细的讲讲 本地存储(Thread Local)。官网的解释是这样的：\n\n> This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable. {@code ThreadLocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID) 该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量(通过其 get 或 set 方法)的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程(例如，用户 ID 或事务 ID)相关联。\n\n总结而言：ThreadLocal是一个将在多线程中为每一个线程创建单独的变量副本的类; 当使用ThreadLocal来维护变量时, ThreadLocal会为每个线程创建单独的变量副本, 避免因多线程操作共享变量而导致的数据不一致的情况。\n\n\n# ThreadLocal理解\n\n> 提到ThreadLocal被提到应用最多的是session管理和数据库链接管理，这里以数据访问为例帮助你理解ThreadLocal：\n\n * 如下数据库管理类在单线程使用是没有任何问题的\n\nclass ConnectionManager {\n    private static Connection connect = null;\n\n    public static Connection openConnection() {\n        if (connect == null) {\n            connect = DriverManager.getConnection();\n        }\n        return connect;\n    }\n\n    public static void closeConnection() {\n        if (connect != null)\n            connect.close();\n    }\n}\n\n\n很显然，在多线程中使用会存在线程安全问题：第一，这里面的2个方法都没有进行同步，很可能在openConnection方法中会多次创建connect；第二，由于connect是共享变量，那么必然在调用connect的地方需要使用到同步来保障线程安全，因为很可能一个线程在使用connect进行数据库操作，而另外一个线程调用closeConnection关闭链接。\n\n * 为了解决上述线程安全的问题，第一考虑：互斥同步\n\n你可能会说，将这段代码的两个方法进行同步处理，并且在调用connect的地方需要进行同步处理，比如用Synchronized或者ReentrantLock互斥锁。\n\n * 这里再抛出一个问题：这地方到底需不需要将connect变量进行共享?\n\n事实上，是不需要的。假如每个线程中都有一个connect变量，各个线程之间对connect变量的访问实际上是没有依赖关系的，即一个线程不需要关心其他线程是否对这个connect进行了修改的。即改后的代码可以这样：\n\nclass ConnectionManager {\n    private Connection connect = null;\n\n    public Connection openConnection() {\n        if (connect == null) {\n            connect = DriverManager.getConnection();\n        }\n        return connect;\n    }\n\n    public void closeConnection() {\n        if (connect != null)\n            connect.close();\n    }\n}\n\nclass Dao {\n    public void insert() {\n        ConnectionManager connectionManager = new ConnectionManager();\n        Connection connection = connectionManager.openConnection();\n\n        // 使用connection进行操作\n\n        connectionManager.closeConnection();\n    }\n}\n\n\n这样处理确实也没有任何问题，由于每次都是在方法内部创建的连接，那么线程之间自然不存在线程安全问题。但是这样会有一个致命的影响：导致服务器压力非常大，并且严重影响程序执行性能。由于在方法中需要频繁地开启和关闭数据库连接，这样不仅严重影响程序执行效率，还可能导致服务器压力巨大。\n\n * 这时候ThreadLocal登场了\n\n那么这种情况下使用ThreadLocal是再适合不过的了，因为ThreadLocal在每个线程中对该变量会创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。下面就是网上出现最多的例子：\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\npublic class ConnectionManager {\n\n    private static final ThreadLocal<Connection> dbConnectionLocal = new ThreadLocal<Connection>() {\n        @Override\n        protected Connection initialValue() {\n            try {\n                return DriverManager.getConnection("", "", "");\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n    };\n\n    public Connection getConnection() {\n        return dbConnectionLocal.get();\n    }\n}\n\n\n * 再注意下ThreadLocal的修饰符\n\nThreaLocal的JDK文档中说明：ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread。如果我们希望通过某个类将状态(例如用户ID、事务ID)与线程关联起来，那么通常在这个类中定义private static类型的ThreadLocal 实例。\n\n> 但是要注意，虽然ThreadLocal能够解决上面说的问题，但是由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用ThreadLocal要大。\n\n\n# ThreadLocal原理\n\n\n# 如何实现线程隔离\n\n主要是用到了Thread对象中的一个ThreadLocalMap类型的变量threadLocals, 负责存储当前线程的关于Connection的对象, dbConnectionLocal(以上述例子中为例) 这个变量为Key, 以新建的Connection对象为Value; 这样的话, 线程第一次读取的时候如果不存在就会调用ThreadLocal的initialValue方法创建一个Connection对象并且返回;\n\n具体关于为线程分配变量副本的代码如下:\n\npublic T get() {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap threadLocals = getMap(t);\n    if (threadLocals != null) {\n        ThreadLocalMap.Entry e = threadLocals.getEntry(this);\n        if (e != null) {\n            @SuppressWarnings("unchecked")\n            T result = (T)e.value;\n            return result;\n        }\n    }\n    return setInitialValue();\n}\n\n\n * 首先获取当前线程对象t, 然后从线程t中获取到ThreadLocalMap的成员属性threadLocals\n * 如果当前线程的threadLocals已经初始化(即不为null) 并且存在以当前ThreadLocal对象为Key的值, 则直接返回当前线程要获取的对象(本例中为Connection);\n * 如果当前线程的threadLocals已经初始化(即不为null)但是不存在以当前ThreadLocal对象为Key的的对象, 那么重新创建一个Connection对象, 并且添加到当前线程的threadLocals Map中,并返回\n * 如果当前线程的threadLocals属性还没有被初始化, 则重新创建一个ThreadLocalMap对象, 并且创建一个Connection对象并添加到ThreadLocalMap对象中并返回。\n\n如果存在则直接返回很好理解, 那么对于如何初始化的代码又是怎样的呢?\n\nprivate T setInitialValue() {\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n    return value;\n}\n\n\n * 首先调用我们上面写的重载过后的initialValue方法, 产生一个Connection对象\n\n * 继续查看当前线程的threadLocals是不是空的, 如果ThreadLocalMap已被初始化, 那么直接将产生的对象添加到ThreadLocalMap中, 如果没有初始化, 则创建并添加对象到其中;\n\n同时, ThreadLocal还提供了直接操作Thread对象中的threadLocals的方法\n\npublic void set(T value) {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n}\n\n\n这样我们也可以不实现initialValue, 将初始化工作放到DBConnectionFactory的getConnection方法中:\n\npublic Connection getConnection() {\n    Connection connection = dbConnectionLocal.get();\n    if (connection == null) {\n        try {\n            connection = DriverManager.getConnection("", "", "");\n            dbConnectionLocal.set(connection);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n    return connection;\n}\n\n\n那么我们看过代码之后就很清晰的知道了为什么ThreadLocal能够实现变量的多线程隔离了; 其实就是用了Map的数据结构给当前线程缓存了, 要使用的时候就从本线程的threadLocals对象中获取就可以了, key就是当前线程;\n\n当然了在当前线程下获取当前线程里面的Map里面的对象并操作肯定没有线程并发问题了, 当然能做到变量的线程间隔离了;\n\n现在我们知道了ThreadLocal到底是什么了, 又知道了如何使用ThreadLocal以及其基本实现原理了是不是就可以结束了呢? 其实还有一个问题就是ThreadLocalMap是个什么对象, 为什么要用这个对象呢?\n\n\n# ThreadLocalMap对象是什么\n\n本质上来讲, 它就是一个Map, 但是这个ThreadLocalMap与我们平时见到的Map有点不一样\n\n * 它没有实现Map接口;\n * 它没有public的方法, 最多有一个default的构造方法, 因为这个ThreadLocalMap的方法仅仅在ThreadLocal类中调用, 属于静态内部类\n * ThreadLocalMap的Entry实现继承了WeakReference<ThreadLocal<?>>\n * 该方法仅仅用了一个Entry数组来存储Key, Value; Entry并不是链表形式, 而是每个bucket里面仅仅放一个Entry;\n\n要了解ThreadLocalMap的实现, 我们先从入口开始, 就是往该Map中添加一个值:\n\nprivate void set(ThreadLocal<?> key, Object value) {\n\n    // We don\'t use a fast path as with get() because it is at\n    // least as common to use set() to create new entries as\n    // it is to replace existing ones, in which case, a fast\n    // path would fail more often than not.\n\n    Entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadLocalHashCode & (len-1);\n\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        ThreadLocal<?> k = e.get();\n\n        if (k == key) {\n            e.value = value;\n            return;\n        }\n\n        if (k == null) {\n            replaceStaleEntry(key, value, i);\n            return;\n        }\n    }\n\n    tab[i] = new Entry(key, value);\n    int sz = ++size;\n    if (!cleanSomeSlots(i, sz) && sz >= threshold)\n        rehash();\n}\n\n\n先进行简单的分析, 对该代码表层意思进行解读:\n\n * 看下当前threadLocal的在数组中的索引位置 比如: i = 2, 看 i = 2 位置上面的元素(Entry)的Key是否等于threadLocal 这个 Key, 如果等于就很好说了, 直接将该位置上面的Entry的Value替换成最新的就可以了;\n * 如果当前位置上面的 Entry 的 Key为空, 说明ThreadLocal对象已经被回收了, 那么就调用replaceStaleEntry\n * 如果清理完无用条目(ThreadLocal被回收的条目)、并且数组中的数据大小 > 阈值的时候对当前的Table进行重新哈希 所以, 该HashMap是处理冲突检测的机制是向后移位, 清除过期条目 最终找到合适的位置;\n\n了解完Set方法, 后面就是Get方法了:\n\nprivate Entry getEntry(ThreadLocal<?> key) {\n    int i = key.threadLocalHashCode & (table.length - 1);\n    Entry e = table[i];\n    if (e != null && e.get() == key)\n        return e;\n    else\n        return getEntryAfterMiss(key, i, e);\n}\n\n\n先找到ThreadLocal的索引位置, 如果索引位置处的entry不为空并且键与threadLocal是同一个对象, 则直接返回; 否则去后面的索引位置继续查找。\n\n\n# ThreadLocal造成内存泄露的问题\n\n网上有这样一个例子：\n\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class ThreadLocalDemo {\n    static class LocalVariable {\n        private Long[] a = new Long[1024 * 1024];\n    }\n\n    // (1)\n    final static ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(5, 5, 1, TimeUnit.MINUTES,\n            new LinkedBlockingQueue<>());\n    // (2)\n    final static ThreadLocal<LocalVariable> localVariable = new ThreadLocal<LocalVariable>();\n\n    public static void main(String[] args) throws InterruptedException {\n        // (3)\n        Thread.sleep(5000 * 4);\n        for (int i = 0; i < 50; ++i) {\n            poolExecutor.execute(new Runnable() {\n                public void run() {\n                    // (4)\n                    localVariable.set(new LocalVariable());\n                    // (5)\n                    System.out.println("use local varaible" + localVariable.get());\n                    localVariable.remove();\n                }\n            });\n        }\n        // (6)\n        System.out.println("pool execute over");\n    }\n}\n\n\n如果用线程池来操作ThreadLocal 对象确实会造成内存泄露, 因为对于线程池里面不会销毁的线程, 里面总会存在着<ThreadLocal, LocalVariable>的强引用, 因为final static 修饰的 ThreadLocal 并不会释放, 而ThreadLocalMap 对于 Key 虽然是弱引用, 但是强引用不会释放, 弱引用当然也会一直有值, 同时创建的LocalVariable对象也不会释放, 就造成了内存泄露; 如果LocalVariable对象不是一个大对象的话, 其实泄露的并不严重, 泄露的内存 = 核心线程数 * LocalVariable对象的大小;\n\n所以, 为了避免出现内存泄露的情况, ThreadLocal提供了一个清除线程中对象的方法, 即 remove, 其实内部实现就是调用 ThreadLocalMap 的remove方法:\n\nprivate void remove(ThreadLocal<?> key) {\n    Entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadLocalHashCode & (len-1);\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        if (e.get() == key) {\n            e.clear();\n            expungeStaleEntry(i);\n            return;\n        }\n    }\n}\n\n\n找到Key对应的Entry, 并且清除Entry的Key(ThreadLocal)置空, 随后清除过期的Entry即可避免内存泄露。\n\n\n# 再看ThreadLocal应用场景\n\n除了上述的数据库管理类的例子，我们再看看其它一些应用：\n\n\n# 每个线程维护了一个“序列号”\n\n> 再回想上文说的，如果我们希望通过某个类将状态(例如用户ID、事务ID)与线程关联起来，那么通常在这个类中定义private static类型的ThreadLocal 实例。\n\n每个线程维护了一个“序列号”\n\npublic class SerialNum {\n    // The next serial number to be assigned\n    private static int nextSerialNum = 0;\n\n    private static ThreadLocal serialNum = new ThreadLocal() {\n        protected synchronized Object initialValue() {\n            return new Integer(nextSerialNum++);\n        }\n    };\n\n    public static int get() {\n        return ((Integer) (serialNum.get())).intValue();\n    }\n}\n\n\n\n# Session的管理\n\n经典的另外一个例子：\n\nprivate static final ThreadLocal threadSession = new ThreadLocal();  \n  \npublic static Session getSession() throws InfrastructureException {  \n    Session s = (Session) threadSession.get();  \n    try {  \n        if (s == null) {  \n            s = getSessionFactory().openSession();  \n            threadSession.set(s);  \n        }  \n    } catch (HibernateException ex) {  \n        throw new InfrastructureException(ex);  \n    }  \n    return s;  \n}  \n\n\n\n# 在线程内部创建ThreadLocal\n\n还有一种用法是在线程类内部创建ThreadLocal，基本步骤如下：\n\n * 在多线程的类(如ThreadDemo类)中，创建一个ThreadLocal对象threadXxx，用来保存线程间需要隔离处理的对象xxx。\n * 在ThreadDemo类中，创建一个获取要隔离访问的数据的方法getXxx()，在方法中判断，若ThreadLocal对象为null时候，应该new()一个隔离访问类型的对象，并强制转换为要应用的类型。\n * 在ThreadDemo类的run()方法中，通过调用getXxx()方法获取要操作的数据，这样可以保证每个线程对应一个数据对象，在任何时刻都操作的是这个对象。\n\npublic class ThreadLocalTest implements Runnable{\n    \n    ThreadLocal<Student> StudentThreadLocal = new ThreadLocal<Student>();\n\n    @Override\n    public void run() {\n        String currentThreadName = Thread.currentThread().getName();\n        System.out.println(currentThreadName + " is running...");\n        Random random = new Random();\n        int age = random.nextInt(100);\n        System.out.println(currentThreadName + " is set age: "  + age);\n        Student Student = getStudentt(); //通过这个方法，为每个线程都独立的new一个Studentt对象，每个线程的的Studentt对象都可以设置不同的值\n        Student.setAge(age);\n        System.out.println(currentThreadName + " is first get age: " + Student.getAge());\n        try {\n            Thread.sleep(500);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println( currentThreadName + " is second get age: " + Student.getAge());\n        \n    }\n    \n    private Student getStudentt() {\n        Student Student = StudentThreadLocal.get();\n        if (null == Student) {\n            Student = new Student();\n            StudentThreadLocal.set(Student);\n        }\n        return Student;\n    }\n\n    public static void main(String[] args) {\n        ThreadLocalTest t = new ThreadLocalTest();\n        Thread t1 = new Thread(t,"Thread A");\n        Thread t2 = new Thread(t,"Thread B");\n        t1.start();\n        t2.start();\n    }\n    \n}\n\nclass Student{\n    int age;\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n    \n}\n\n\n\n# java 开发手册中推荐的 ThreadLocal\n\n看看阿里巴巴 java 开发手册中推荐的 ThreadLocal 的用法:\n\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\n \npublic class DateUtils {\n    public static final ThreadLocal<DateFormat> df = new ThreadLocal<DateFormat>(){\n        @Override\n        protected DateFormat initialValue() {\n            return new SimpleDateFormat("yyyy-MM-dd");\n        }\n    };\n}\n\n\n然后我们再要用到 DateFormat 对象的地方，这样调用：\n\nDateUtils.df.get().format(new Date());\n\n\n\n# 参考文章\n\n * https://blog.csdn.net/vking_wang/article/details/14225379\n * https://mp.weixin.qq.com/s/mo3-y-45_ao54b5T7ez7iA\n * https://www.xttblog.com/?p=3087\n * https://blog.csdn.net/whut2010hj/article/details/81413887\n * https://segmentfault.com/a/1190000018399795\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-threadlocal.html',normalizedContent:'# java 并发 - threadlocal详解\n\n> threadlocal是通过线程隔离的方式防止任务在共享资源上产生冲突, 线程本地存储是一种自动化机制，可以为使用相同变量的每个不同线程都创建不同的存储。\n\n * java 并发 - threadlocal详解\n   * 带着bat大厂的面试问题去理解\n   * threadlocal简介\n   * threadlocal理解\n   * threadlocal原理\n     * 如何实现线程隔离\n     * threadlocalmap对象是什么\n   * threadlocal造成内存泄露的问题\n   * 再看threadlocal应用场景\n     * 每个线程维护了一个“序列号”\n     * session的管理\n     * 在线程内部创建threadlocal\n     * java 开发手册中推荐的 threadlocal\n   * 参考文章\n\n\n# 带着bat大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。\n\n * 什么是threadlocal? 用来解决什么问题的?\n * 说说你对threadlocal的理解\n * threadlocal是如何实现线程隔离的?\n * 为什么threadlocal会造成内存泄露? 如何解决\n * 还有哪些使用threadlocal的应用场景?\n\n\n# threadlocal简介\n\n我们在java 并发 - 并发理论基础总结过线程安全(是指广义上的共享资源访问安全性，因为线程隔离是通过副本保证本线程访问资源安全性，它不保证线程之间还存在共享关系的狭义上的安全性)的解决思路：\n\n * 互斥同步: synchronized 和 reentrantlock\n * 非阻塞同步: cas, atomicxxxx\n * 无同步方案: 栈封闭，本地存储(thread local)，可重入代码\n\n这个章节将详细的讲讲 本地存储(thread local)。官网的解释是这样的：\n\n> this class provides thread-local variables. these variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable. {@code threadlocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user id or transaction id) 该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量(通过其 get 或 set 方法)的每个线程都有自己的局部变量，它独立于变量的初始化副本。threadlocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程(例如，用户 id 或事务 id)相关联。\n\n总结而言：threadlocal是一个将在多线程中为每一个线程创建单独的变量副本的类; 当使用threadlocal来维护变量时, threadlocal会为每个线程创建单独的变量副本, 避免因多线程操作共享变量而导致的数据不一致的情况。\n\n\n# threadlocal理解\n\n> 提到threadlocal被提到应用最多的是session管理和数据库链接管理，这里以数据访问为例帮助你理解threadlocal：\n\n * 如下数据库管理类在单线程使用是没有任何问题的\n\nclass connectionmanager {\n    private static connection connect = null;\n\n    public static connection openconnection() {\n        if (connect == null) {\n            connect = drivermanager.getconnection();\n        }\n        return connect;\n    }\n\n    public static void closeconnection() {\n        if (connect != null)\n            connect.close();\n    }\n}\n\n\n很显然，在多线程中使用会存在线程安全问题：第一，这里面的2个方法都没有进行同步，很可能在openconnection方法中会多次创建connect；第二，由于connect是共享变量，那么必然在调用connect的地方需要使用到同步来保障线程安全，因为很可能一个线程在使用connect进行数据库操作，而另外一个线程调用closeconnection关闭链接。\n\n * 为了解决上述线程安全的问题，第一考虑：互斥同步\n\n你可能会说，将这段代码的两个方法进行同步处理，并且在调用connect的地方需要进行同步处理，比如用synchronized或者reentrantlock互斥锁。\n\n * 这里再抛出一个问题：这地方到底需不需要将connect变量进行共享?\n\n事实上，是不需要的。假如每个线程中都有一个connect变量，各个线程之间对connect变量的访问实际上是没有依赖关系的，即一个线程不需要关心其他线程是否对这个connect进行了修改的。即改后的代码可以这样：\n\nclass connectionmanager {\n    private connection connect = null;\n\n    public connection openconnection() {\n        if (connect == null) {\n            connect = drivermanager.getconnection();\n        }\n        return connect;\n    }\n\n    public void closeconnection() {\n        if (connect != null)\n            connect.close();\n    }\n}\n\nclass dao {\n    public void insert() {\n        connectionmanager connectionmanager = new connectionmanager();\n        connection connection = connectionmanager.openconnection();\n\n        // 使用connection进行操作\n\n        connectionmanager.closeconnection();\n    }\n}\n\n\n这样处理确实也没有任何问题，由于每次都是在方法内部创建的连接，那么线程之间自然不存在线程安全问题。但是这样会有一个致命的影响：导致服务器压力非常大，并且严重影响程序执行性能。由于在方法中需要频繁地开启和关闭数据库连接，这样不仅严重影响程序执行效率，还可能导致服务器压力巨大。\n\n * 这时候threadlocal登场了\n\n那么这种情况下使用threadlocal是再适合不过的了，因为threadlocal在每个线程中对该变量会创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。下面就是网上出现最多的例子：\n\nimport java.sql.connection;\nimport java.sql.drivermanager;\nimport java.sql.sqlexception;\n\npublic class connectionmanager {\n\n    private static final threadlocal<connection> dbconnectionlocal = new threadlocal<connection>() {\n        @override\n        protected connection initialvalue() {\n            try {\n                return drivermanager.getconnection("", "", "");\n            } catch (sqlexception e) {\n                e.printstacktrace();\n            }\n            return null;\n        }\n    };\n\n    public connection getconnection() {\n        return dbconnectionlocal.get();\n    }\n}\n\n\n * 再注意下threadlocal的修饰符\n\nthrealocal的jdk文档中说明：threadlocal instances are typically private static fields in classes that wish to associate state with a thread。如果我们希望通过某个类将状态(例如用户id、事务id)与线程关联起来，那么通常在这个类中定义private static类型的threadlocal 实例。\n\n> 但是要注意，虽然threadlocal能够解决上面说的问题，但是由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用threadlocal要大。\n\n\n# threadlocal原理\n\n\n# 如何实现线程隔离\n\n主要是用到了thread对象中的一个threadlocalmap类型的变量threadlocals, 负责存储当前线程的关于connection的对象, dbconnectionlocal(以上述例子中为例) 这个变量为key, 以新建的connection对象为value; 这样的话, 线程第一次读取的时候如果不存在就会调用threadlocal的initialvalue方法创建一个connection对象并且返回;\n\n具体关于为线程分配变量副本的代码如下:\n\npublic t get() {\n    thread t = thread.currentthread();\n    threadlocalmap threadlocals = getmap(t);\n    if (threadlocals != null) {\n        threadlocalmap.entry e = threadlocals.getentry(this);\n        if (e != null) {\n            @suppresswarnings("unchecked")\n            t result = (t)e.value;\n            return result;\n        }\n    }\n    return setinitialvalue();\n}\n\n\n * 首先获取当前线程对象t, 然后从线程t中获取到threadlocalmap的成员属性threadlocals\n * 如果当前线程的threadlocals已经初始化(即不为null) 并且存在以当前threadlocal对象为key的值, 则直接返回当前线程要获取的对象(本例中为connection);\n * 如果当前线程的threadlocals已经初始化(即不为null)但是不存在以当前threadlocal对象为key的的对象, 那么重新创建一个connection对象, 并且添加到当前线程的threadlocals map中,并返回\n * 如果当前线程的threadlocals属性还没有被初始化, 则重新创建一个threadlocalmap对象, 并且创建一个connection对象并添加到threadlocalmap对象中并返回。\n\n如果存在则直接返回很好理解, 那么对于如何初始化的代码又是怎样的呢?\n\nprivate t setinitialvalue() {\n    t value = initialvalue();\n    thread t = thread.currentthread();\n    threadlocalmap map = getmap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createmap(t, value);\n    return value;\n}\n\n\n * 首先调用我们上面写的重载过后的initialvalue方法, 产生一个connection对象\n\n * 继续查看当前线程的threadlocals是不是空的, 如果threadlocalmap已被初始化, 那么直接将产生的对象添加到threadlocalmap中, 如果没有初始化, 则创建并添加对象到其中;\n\n同时, threadlocal还提供了直接操作thread对象中的threadlocals的方法\n\npublic void set(t value) {\n    thread t = thread.currentthread();\n    threadlocalmap map = getmap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createmap(t, value);\n}\n\n\n这样我们也可以不实现initialvalue, 将初始化工作放到dbconnectionfactory的getconnection方法中:\n\npublic connection getconnection() {\n    connection connection = dbconnectionlocal.get();\n    if (connection == null) {\n        try {\n            connection = drivermanager.getconnection("", "", "");\n            dbconnectionlocal.set(connection);\n        } catch (sqlexception e) {\n            e.printstacktrace();\n        }\n    }\n    return connection;\n}\n\n\n那么我们看过代码之后就很清晰的知道了为什么threadlocal能够实现变量的多线程隔离了; 其实就是用了map的数据结构给当前线程缓存了, 要使用的时候就从本线程的threadlocals对象中获取就可以了, key就是当前线程;\n\n当然了在当前线程下获取当前线程里面的map里面的对象并操作肯定没有线程并发问题了, 当然能做到变量的线程间隔离了;\n\n现在我们知道了threadlocal到底是什么了, 又知道了如何使用threadlocal以及其基本实现原理了是不是就可以结束了呢? 其实还有一个问题就是threadlocalmap是个什么对象, 为什么要用这个对象呢?\n\n\n# threadlocalmap对象是什么\n\n本质上来讲, 它就是一个map, 但是这个threadlocalmap与我们平时见到的map有点不一样\n\n * 它没有实现map接口;\n * 它没有public的方法, 最多有一个default的构造方法, 因为这个threadlocalmap的方法仅仅在threadlocal类中调用, 属于静态内部类\n * threadlocalmap的entry实现继承了weakreference<threadlocal<?>>\n * 该方法仅仅用了一个entry数组来存储key, value; entry并不是链表形式, 而是每个bucket里面仅仅放一个entry;\n\n要了解threadlocalmap的实现, 我们先从入口开始, 就是往该map中添加一个值:\n\nprivate void set(threadlocal<?> key, object value) {\n\n    // we don\'t use a fast path as with get() because it is at\n    // least as common to use set() to create new entries as\n    // it is to replace existing ones, in which case, a fast\n    // path would fail more often than not.\n\n    entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadlocalhashcode & (len-1);\n\n    for (entry e = tab[i];\n         e != null;\n         e = tab[i = nextindex(i, len)]) {\n        threadlocal<?> k = e.get();\n\n        if (k == key) {\n            e.value = value;\n            return;\n        }\n\n        if (k == null) {\n            replacestaleentry(key, value, i);\n            return;\n        }\n    }\n\n    tab[i] = new entry(key, value);\n    int sz = ++size;\n    if (!cleansomeslots(i, sz) && sz >= threshold)\n        rehash();\n}\n\n\n先进行简单的分析, 对该代码表层意思进行解读:\n\n * 看下当前threadlocal的在数组中的索引位置 比如: i = 2, 看 i = 2 位置上面的元素(entry)的key是否等于threadlocal 这个 key, 如果等于就很好说了, 直接将该位置上面的entry的value替换成最新的就可以了;\n * 如果当前位置上面的 entry 的 key为空, 说明threadlocal对象已经被回收了, 那么就调用replacestaleentry\n * 如果清理完无用条目(threadlocal被回收的条目)、并且数组中的数据大小 > 阈值的时候对当前的table进行重新哈希 所以, 该hashmap是处理冲突检测的机制是向后移位, 清除过期条目 最终找到合适的位置;\n\n了解完set方法, 后面就是get方法了:\n\nprivate entry getentry(threadlocal<?> key) {\n    int i = key.threadlocalhashcode & (table.length - 1);\n    entry e = table[i];\n    if (e != null && e.get() == key)\n        return e;\n    else\n        return getentryaftermiss(key, i, e);\n}\n\n\n先找到threadlocal的索引位置, 如果索引位置处的entry不为空并且键与threadlocal是同一个对象, 则直接返回; 否则去后面的索引位置继续查找。\n\n\n# threadlocal造成内存泄露的问题\n\n网上有这样一个例子：\n\nimport java.util.concurrent.linkedblockingqueue;\nimport java.util.concurrent.threadpoolexecutor;\nimport java.util.concurrent.timeunit;\n\npublic class threadlocaldemo {\n    static class localvariable {\n        private long[] a = new long[1024 * 1024];\n    }\n\n    // (1)\n    final static threadpoolexecutor poolexecutor = new threadpoolexecutor(5, 5, 1, timeunit.minutes,\n            new linkedblockingqueue<>());\n    // (2)\n    final static threadlocal<localvariable> localvariable = new threadlocal<localvariable>();\n\n    public static void main(string[] args) throws interruptedexception {\n        // (3)\n        thread.sleep(5000 * 4);\n        for (int i = 0; i < 50; ++i) {\n            poolexecutor.execute(new runnable() {\n                public void run() {\n                    // (4)\n                    localvariable.set(new localvariable());\n                    // (5)\n                    system.out.println("use local varaible" + localvariable.get());\n                    localvariable.remove();\n                }\n            });\n        }\n        // (6)\n        system.out.println("pool execute over");\n    }\n}\n\n\n如果用线程池来操作threadlocal 对象确实会造成内存泄露, 因为对于线程池里面不会销毁的线程, 里面总会存在着<threadlocal, localvariable>的强引用, 因为final static 修饰的 threadlocal 并不会释放, 而threadlocalmap 对于 key 虽然是弱引用, 但是强引用不会释放, 弱引用当然也会一直有值, 同时创建的localvariable对象也不会释放, 就造成了内存泄露; 如果localvariable对象不是一个大对象的话, 其实泄露的并不严重, 泄露的内存 = 核心线程数 * localvariable对象的大小;\n\n所以, 为了避免出现内存泄露的情况, threadlocal提供了一个清除线程中对象的方法, 即 remove, 其实内部实现就是调用 threadlocalmap 的remove方法:\n\nprivate void remove(threadlocal<?> key) {\n    entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadlocalhashcode & (len-1);\n    for (entry e = tab[i];\n         e != null;\n         e = tab[i = nextindex(i, len)]) {\n        if (e.get() == key) {\n            e.clear();\n            expungestaleentry(i);\n            return;\n        }\n    }\n}\n\n\n找到key对应的entry, 并且清除entry的key(threadlocal)置空, 随后清除过期的entry即可避免内存泄露。\n\n\n# 再看threadlocal应用场景\n\n除了上述的数据库管理类的例子，我们再看看其它一些应用：\n\n\n# 每个线程维护了一个“序列号”\n\n> 再回想上文说的，如果我们希望通过某个类将状态(例如用户id、事务id)与线程关联起来，那么通常在这个类中定义private static类型的threadlocal 实例。\n\n每个线程维护了一个“序列号”\n\npublic class serialnum {\n    // the next serial number to be assigned\n    private static int nextserialnum = 0;\n\n    private static threadlocal serialnum = new threadlocal() {\n        protected synchronized object initialvalue() {\n            return new integer(nextserialnum++);\n        }\n    };\n\n    public static int get() {\n        return ((integer) (serialnum.get())).intvalue();\n    }\n}\n\n\n\n# session的管理\n\n经典的另外一个例子：\n\nprivate static final threadlocal threadsession = new threadlocal();  \n  \npublic static session getsession() throws infrastructureexception {  \n    session s = (session) threadsession.get();  \n    try {  \n        if (s == null) {  \n            s = getsessionfactory().opensession();  \n            threadsession.set(s);  \n        }  \n    } catch (hibernateexception ex) {  \n        throw new infrastructureexception(ex);  \n    }  \n    return s;  \n}  \n\n\n\n# 在线程内部创建threadlocal\n\n还有一种用法是在线程类内部创建threadlocal，基本步骤如下：\n\n * 在多线程的类(如threaddemo类)中，创建一个threadlocal对象threadxxx，用来保存线程间需要隔离处理的对象xxx。\n * 在threaddemo类中，创建一个获取要隔离访问的数据的方法getxxx()，在方法中判断，若threadlocal对象为null时候，应该new()一个隔离访问类型的对象，并强制转换为要应用的类型。\n * 在threaddemo类的run()方法中，通过调用getxxx()方法获取要操作的数据，这样可以保证每个线程对应一个数据对象，在任何时刻都操作的是这个对象。\n\npublic class threadlocaltest implements runnable{\n    \n    threadlocal<student> studentthreadlocal = new threadlocal<student>();\n\n    @override\n    public void run() {\n        string currentthreadname = thread.currentthread().getname();\n        system.out.println(currentthreadname + " is running...");\n        random random = new random();\n        int age = random.nextint(100);\n        system.out.println(currentthreadname + " is set age: "  + age);\n        student student = getstudentt(); //通过这个方法，为每个线程都独立的new一个studentt对象，每个线程的的studentt对象都可以设置不同的值\n        student.setage(age);\n        system.out.println(currentthreadname + " is first get age: " + student.getage());\n        try {\n            thread.sleep(500);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n        system.out.println( currentthreadname + " is second get age: " + student.getage());\n        \n    }\n    \n    private student getstudentt() {\n        student student = studentthreadlocal.get();\n        if (null == student) {\n            student = new student();\n            studentthreadlocal.set(student);\n        }\n        return student;\n    }\n\n    public static void main(string[] args) {\n        threadlocaltest t = new threadlocaltest();\n        thread t1 = new thread(t,"thread a");\n        thread t2 = new thread(t,"thread b");\n        t1.start();\n        t2.start();\n    }\n    \n}\n\nclass student{\n    int age;\n    public int getage() {\n        return age;\n    }\n    public void setage(int age) {\n        this.age = age;\n    }\n    \n}\n\n\n\n# java 开发手册中推荐的 threadlocal\n\n看看阿里巴巴 java 开发手册中推荐的 threadlocal 的用法:\n\nimport java.text.dateformat;\nimport java.text.simpledateformat;\n \npublic class dateutils {\n    public static final threadlocal<dateformat> df = new threadlocal<dateformat>(){\n        @override\n        protected dateformat initialvalue() {\n            return new simpledateformat("yyyy-mm-dd");\n        }\n    };\n}\n\n\n然后我们再要用到 dateformat 对象的地方，这样调用：\n\ndateutils.df.get().format(new date());\n\n\n\n# 参考文章\n\n * https://blog.csdn.net/vking_wang/article/details/14225379\n * https://mp.weixin.qq.com/s/mo3-y-45_ao54b5t7ez7ia\n * https://www.xttblog.com/?p=3087\n * https://blog.csdn.net/whut2010hj/article/details/81413887\n * https://segmentfault.com/a/1190000018399795\n * 转载 https://www.pdai.tech/md/java/thread/java-thread-x-threadlocal.html',charsets:{cjk:!0}},{title:"♥数据库基础和SQL知识体系详解♥",frontmatter:{},regularPath:"/sql/basic/sql-db.html",relativePath:"sql/basic/sql-db.md",key:"v-c2b654bc",path:"/sql/basic/sql-db.html",headers:[{level:2,title:"♥数据库基础和SQL知识体系详解♥",slug:"♥数据库基础和sql知识体系详解♥",normalizedTitle:"♥数据库基础和sql知识体系详解♥",charIndex:2},{level:2,title:"知识体系结构",slug:"知识体系结构",normalizedTitle:"知识体系结构",charIndex:46},{level:3,title:"数据库基础与理论",slug:"数据库基础与理论",normalizedTitle:"数据库基础与理论",charIndex:59},{level:3,title:"SQL语言基础和进阶",slug:"sql语言基础和进阶",normalizedTitle:"sql语言基础和进阶",charIndex:780}],lastUpdated:"2023/4/9 16:04:35",lastUpdatedTimestamp:1681027475e3,headersStr:"♥数据库基础和SQL知识体系详解♥ 知识体系结构 数据库基础与理论 SQL语言基础和进阶",content:"# ♥数据库基础和SQL知识体系详解♥\n\n> 本系列主要介绍数据库相关的知识体系。\n\n\n# 知识体系结构\n\n\n\n\n# 数据库基础与理论\n\n相关文章\n\n> A. 了解数据库基础和理论知识：在学习数据库之前，不要一上来就是SQL语句；这里建议从数据结构开始切入到数据库，然后再理解数据库是如何工作的，紧接着理解数据库系统的原理知识点和相关知识体系。\n\n * SQL DB - 资料汇总\n * SQL DB - 关系型数据库是如何工作的\n   * 很多人在学习数据库时都是孤立的学习知识点，这样是很难将所有知识点串起来深入理解；强烈推荐你学习两篇文章：Architecture of a Database System在新窗口打开以及How does a relational database work在新窗口打开；本文主要在第二篇基础上翻译并梳理，如果你英文不好的话，你可以通过本文帮助你构筑数据库体系的基础\n * SQL DB - 关系型数据库设计理论\n   * 在上文了解数据库如何工作后，本节介绍如何将一个关系模型（基于表的数据模型）合理的转化为数据表和关系表，以及确定主外键的。这便是数据库设计理论基础，包括术语，函数依赖，范式等理论基础\n * SQL DB - 关系型数据库设计流程\n   * 在上文知道如何设计表和健后，让我们再看看整个的数据库设计的标准流程吧，主要包括需求分析, 概念结构设计, 逻辑结构设计 , 物理设计, 实施阶段和运行和维护阶段这6个阶段\n * SQL DB - 数据库系统核心知识点\n   * 基于上篇数据库如何工作的基础之上，我们再来梳理下数据库系统中有哪些重要的知识点，包括：事务，并发一致性，封锁，隔离级别，多版本并发控制等\n\n----------------------------------------\n\n\n# SQL语言基础和进阶\n\n相关文章\n\n> B. 完全掌握SQL语言：在了解数据库基础之后，如下章节将重点阐述SQL语言相关的知识；主要顺序是：SQL语法->SQL语句练习->SQL题目进阶->SQL语句优化建议等。\n\n * SQL语言 - SQL语法基础\n   * 本文包含了所有SQL语言的基础语法，并用例子的方式向你展示\n * SQL语言 - SQL语句练习\n   * 在上文学习了SQL的基本语法以后，本文将通过最经典的“教师-学生-成绩”表来帮助你练习SQL。\n * SQL语言 - SQL题目进阶\n   * 接下来，通过Leetcode上的SQL题目进行进阶吧\n * SQL语言 - SQL语句优化\n   * 最后，再总结一些SQL语句的优化建议\n * 转载 https://www.pdai.tech/md/db/sql/sql-db.html\n\n----------------------------------------",normalizedContent:"# ♥数据库基础和sql知识体系详解♥\n\n> 本系列主要介绍数据库相关的知识体系。\n\n\n# 知识体系结构\n\n\n\n\n# 数据库基础与理论\n\n相关文章\n\n> a. 了解数据库基础和理论知识：在学习数据库之前，不要一上来就是sql语句；这里建议从数据结构开始切入到数据库，然后再理解数据库是如何工作的，紧接着理解数据库系统的原理知识点和相关知识体系。\n\n * sql db - 资料汇总\n * sql db - 关系型数据库是如何工作的\n   * 很多人在学习数据库时都是孤立的学习知识点，这样是很难将所有知识点串起来深入理解；强烈推荐你学习两篇文章：architecture of a database system在新窗口打开以及how does a relational database work在新窗口打开；本文主要在第二篇基础上翻译并梳理，如果你英文不好的话，你可以通过本文帮助你构筑数据库体系的基础\n * sql db - 关系型数据库设计理论\n   * 在上文了解数据库如何工作后，本节介绍如何将一个关系模型（基于表的数据模型）合理的转化为数据表和关系表，以及确定主外键的。这便是数据库设计理论基础，包括术语，函数依赖，范式等理论基础\n * sql db - 关系型数据库设计流程\n   * 在上文知道如何设计表和健后，让我们再看看整个的数据库设计的标准流程吧，主要包括需求分析, 概念结构设计, 逻辑结构设计 , 物理设计, 实施阶段和运行和维护阶段这6个阶段\n * sql db - 数据库系统核心知识点\n   * 基于上篇数据库如何工作的基础之上，我们再来梳理下数据库系统中有哪些重要的知识点，包括：事务，并发一致性，封锁，隔离级别，多版本并发控制等\n\n----------------------------------------\n\n\n# sql语言基础和进阶\n\n相关文章\n\n> b. 完全掌握sql语言：在了解数据库基础之后，如下章节将重点阐述sql语言相关的知识；主要顺序是：sql语法->sql语句练习->sql题目进阶->sql语句优化建议等。\n\n * sql语言 - sql语法基础\n   * 本文包含了所有sql语言的基础语法，并用例子的方式向你展示\n * sql语言 - sql语句练习\n   * 在上文学习了sql的基本语法以后，本文将通过最经典的“教师-学生-成绩”表来帮助你练习sql。\n * sql语言 - sql题目进阶\n   * 接下来，通过leetcode上的sql题目进行进阶吧\n * sql语言 - sql语句优化\n   * 最后，再总结一些sql语句的优化建议\n * 转载 https://www.pdai.tech/md/db/sql/sql-db.html\n\n----------------------------------------",charsets:{cjk:!0}},{title:"Java 并发 - 理论基础",frontmatter:{},regularPath:"/java/thread/java-thread-x-theorty.html",relativePath:"java/thread/java-thread-x-theorty.md",key:"v-07d81cee",path:"/java/thread/java-thread-x-theorty.html",headers:[{level:2,title:"Java 并发 - 理论基础",slug:"java-并发-理论基础",normalizedTitle:"java 并发 - 理论基础",charIndex:2},{level:2,title:"带着BAT大厂的面试问题去理解",slug:"带着bat大厂的面试问题去理解",normalizedTitle:"带着bat大厂的面试问题去理解",charIndex:76},{level:2,title:"为什么需要多线程",slug:"为什么需要多线程",normalizedTitle:"为什么需要多线程",charIndex:97},{level:2,title:"线程不安全示例",slug:"线程不安全示例",normalizedTitle:"线程不安全示例",charIndex:111},{level:2,title:"并发出现问题的根源: 并发三要素",slug:"并发出现问题的根源-并发三要素",normalizedTitle:"并发出现问题的根源: 并发三要素",charIndex:124},{level:3,title:"可见性: CPU缓存引起",slug:"可见性-cpu缓存引起",normalizedTitle:"可见性: cpu缓存引起",charIndex:148},{level:3,title:"原子性: 分时复用引起",slug:"原子性-分时复用引起",normalizedTitle:"原子性: 分时复用引起",charIndex:168},{level:3,title:"有序性: 重排序引起",slug:"有序性-重排序引起",normalizedTitle:"有序性: 重排序引起",charIndex:187},{level:2,title:"JAVA是怎么解决并发问题的: JMM(Java内存模型)",slug:"java是怎么解决并发问题的-jmm-java内存模型",normalizedTitle:"java是怎么解决并发问题的: jmm(java内存模型)",charIndex:203},{level:3,title:"关键字: volatile、synchronized 和 final",slug:"关键字-volatile、synchronized-和-final",normalizedTitle:"关键字: volatile、synchronized 和 final",charIndex:240},{level:3,title:"Happens-Before 规则",slug:"happens-before-规则",normalizedTitle:"happens-before 规则",charIndex:282},{level:2,title:"线程安全: 不是一个非真即假的命题",slug:"线程安全-不是一个非真即假的命题",normalizedTitle:"线程安全: 不是一个非真即假的命题",charIndex:461},{level:3,title:"1\\. 不可变",slug:"_1-不可变",normalizedTitle:"1. 不可变",charIndex:486},{level:3,title:"2\\. 绝对线程安全",slug:"_2-绝对线程安全",normalizedTitle:"2. 绝对线程安全",charIndex:500},{level:3,title:"3\\. 相对线程安全",slug:"_3-相对线程安全",normalizedTitle:"3. 相对线程安全",charIndex:517},{level:3,title:"4\\. 线程兼容",slug:"_4-线程兼容",normalizedTitle:"4. 线程兼容",charIndex:534},{level:3,title:"5\\. 线程对立",slug:"_5-线程对立",normalizedTitle:"5. 线程对立",charIndex:549},{level:2,title:"线程安全的实现方法",slug:"线程安全的实现方法",normalizedTitle:"线程安全的实现方法",charIndex:562},{level:3,title:"1\\. 互斥同步",slug:"_1-互斥同步",normalizedTitle:"1. 互斥同步",charIndex:579},{level:3,title:"2\\. 非阻塞同步",slug:"_2-非阻塞同步",normalizedTitle:"2. 非阻塞同步",charIndex:594},{level:3,title:"3\\. 无同步方案",slug:"_3-无同步方案",normalizedTitle:"3. 无同步方案",charIndex:610},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:624}],lastUpdated:"2023/4/10 22:14:07",lastUpdatedTimestamp:1681136047e3,headersStr:"Java 并发 - 理论基础 带着BAT大厂的面试问题去理解 为什么需要多线程 线程不安全示例 并发出现问题的根源: 并发三要素 可见性: CPU缓存引起 原子性: 分时复用引起 有序性: 重排序引起 JAVA是怎么解决并发问题的: JMM(Java内存模型) 关键字: volatile、synchronized 和 final Happens-Before 规则 线程安全: 不是一个非真即假的命题 1\\. 不可变 2\\. 绝对线程安全 3\\. 相对线程安全 4\\. 线程兼容 5\\. 线程对立 线程安全的实现方法 1\\. 互斥同步 2\\. 非阻塞同步 3\\. 无同步方案 参考文章",content:'# Java 并发 - 理论基础\n\n> 本文从理论的角度引入并发安全问题以及JMM应对并发问题的原理。\n\n * Java 并发 - 理论基础\n   * 带着BAT大厂的面试问题去理解\n   * 为什么需要多线程\n   * 线程不安全示例\n   * 并发出现问题的根源: 并发三要素\n     * 可见性: CPU缓存引起\n     * 原子性: 分时复用引起\n     * 有序性: 重排序引起\n   * JAVA是怎么解决并发问题的: JMM(Java内存模型)\n     * 关键字: volatile、synchronized 和 final\n     * Happens-Before 规则\n       * 1. 单一线程原则\n       * 2. 管程锁定规则\n       * 3. volatile 变量规则\n       * 4. 线程启动规则\n       * 5. 线程加入规则\n       * 6. 线程中断规则\n       * 7. 对象终结规则\n       * 8. 传递性\n   * 线程安全: 不是一个非真即假的命题\n     * 1. 不可变\n     * 2. 绝对线程安全\n     * 3. 相对线程安全\n     * 4. 线程兼容\n     * 5. 线程对立\n   * 线程安全的实现方法\n     * 1. 互斥同步\n     * 2. 非阻塞同步\n     * 3. 无同步方案\n   * 参考文章\n\n\n# 带着BAT大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解并发理论基础。@pdai\n\n * 多线程的出现是要解决什么问题的?\n * 线程不安全是指什么? 举例说明\n * 并发出现线程不安全的本质什么? 可见性，原子性和有序性。\n * Java是怎么解决并发问题的? 3个关键字，JMM和8个Happens-Before\n * 线程安全是不是非真即假? 不是\n * 线程安全有哪些实现思路?\n * 如何理解并发和并行的区别?\n\n\n# 为什么需要多线程\n\n众所周知，CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:\n\n * CPU 增加了缓存，以均衡与内存的速度差异；// 导致 可见性问题\n * 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；// 导致 原子性问题\n * 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。// 导致 有序性问题\n\n\n# 线程不安全示例\n\n如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。\n\n以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。\n\npublic class ThreadUnsafeExample {\n\n    private int cnt = 0;\n\n    public void add() {\n        cnt++;\n    }\n\n    public int get() {\n        return cnt;\n    }\n}\n\n\npublic static void main(String[] args) throws InterruptedException {\n    final int threadSize = 1000;\n    ThreadUnsafeExample example = new ThreadUnsafeExample();\n    final CountDownLatch countDownLatch = new CountDownLatch(threadSize);\n    ExecutorService executorService = Executors.newCachedThreadPool();\n    for (int i = 0; i < threadSize; i++) {\n        executorService.execute(() -> {\n            example.add();\n            countDownLatch.countDown();\n        });\n    }\n    countDownLatch.await();\n    executorService.shutdown();\n    System.out.println(example.get());\n}\n\n\n\n# 并发出现问题的根源: 并发三要素\n\n上述代码输出为什么不是1000? 并发出现问题的根源是什么?\n\n\n# 可见性: CPU缓存引起\n\n可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。\n\n举个简单的例子，看下面这段代码：\n\n//线程1执行的代码\nint i = 0;\ni = 10;\n \n//线程2执行的代码\nj = i;\n\n\n假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。\n\n此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.\n\n这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。\n\n\n# 原子性: 分时复用引起\n\n原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。\n\n举个简单的例子，看下面这段代码：\n\nint i = 1;\n\n// 线程1执行\ni += 1;\n\n// 线程2执行\ni += 1;\n\n\n这里需要注意的是：i += 1需要三条 CPU 指令\n\n 1. 将变量 i 从内存读取到 CPU寄存器；\n 2. 在CPU寄存器中执行 i + 1 操作；\n 3. 将最后的结果i写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。\n\n由于CPU分时复用（线程切换）的存在，线程1执行了第一条指令后，就切换到线程2执行，假如线程2执行了这三条指令后，再切换会线程1执行后续两条指令，将造成最后写到内存中的i值是2而不是3。\n\n\n# 有序性: 重排序引起\n\n有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：\n\nint i = 0;              \nboolean flag = false;\ni = 1;                //语句1  \nflag = true;          //语句2\n\n\n上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗? 不一定，为什么呢? 这里可能会发生指令重排序（Instruction Reorder）。\n\n在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：\n\n * 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。\n * 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。\n * 内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。\n\n从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：\n\n\n\n上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。\n\n具体可以参看：Java 内存模型详解的重排序章节。\n\n\n# JAVA是怎么解决并发问题的: JMM(Java内存模型)\n\nJava 内存模型是个很复杂的规范，强烈推荐你看后续（应该是网上能找到最好的材料之一了）：Java 内存模型详解。\n\n理解的第一个维度：核心知识点\n\nJMM本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括：\n\n * volatile、synchronized 和 final 三个关键字\n * Happens-Before 规则\n\n理解的第二个维度：可见性，有序性，原子性\n\n * 原子性\n\n在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 请分析以下哪些操作是原子性操作：\n\nx = 10;        //语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中\ny = x;         //语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。\nx++;           //语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。\nx = x + 1;     //语句4： 同语句3\n\n\n上面4个语句只有语句1的操作具备原子性。\n\n也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。\n\n> 从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。\n\n * 可见性\n\nJava提供了volatile关键字来保证可见性。\n\n当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。\n\n而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。\n\n> 另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。\n\n * 有序性\n\n在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然JMM是通过Happens-Before 规则来保证有序性的。\n\n\n# 关键字: volatile、synchronized 和 final\n\n以下三篇文章详细分析了这三个关键字：\n\n * 关键字: synchronized详解\n * 关键字: volatile详解\n * 关键字: final详解\n\n\n# Happens-Before 规则\n\n上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。\n\n# 1. 单一线程原则\n\n> Single Thread rule\n\n在一个线程内，在程序前面的操作先行发生于后面的操作。\n\n\n\n# 2. 管程锁定规则\n\n> Monitor Lock Rule\n\n一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。\n\n\n\n# 3. volatile 变量规则\n\n> Volatile Variable Rule\n\n对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。\n\n\n\n# 4. 线程启动规则\n\n> Thread Start Rule\n\nThread 对象的 start() 方法调用先行发生于此线程的每一个动作。\n\n\n\n# 5. 线程加入规则\n\n> Thread Join Rule\n\nThread 对象的结束先行发生于 join() 方法返回。\n\n\n\n# 6. 线程中断规则\n\n> Thread Interruption Rule\n\n对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。\n\n# 7. 对象终结规则\n\n> Finalizer Rule\n\n一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始。\n\n# 8. 传递性\n\n> Transitivity\n\n如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。\n\n\n# 线程安全: 不是一个非真即假的命题\n\n一个类在可以被多个线程安全调用时就是线程安全的。\n\n线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分成以下五类: 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。\n\n\n# 1. 不可变\n\n不可变(Immutable)的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。\n\n多线程环境下，应当尽量使对象成为不可变，来满足线程安全。\n\n不可变的类型:\n\n * final 关键字修饰的基本数据类型\n * String\n * 枚举类型\n * Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。\n\n对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。\n\npublic class ImmutableExample {\n    public static void main(String[] args) {\n        Map<String, Integer> map = new HashMap<>();\n        Map<String, Integer> unmodifiableMap = Collections.unmodifiableMap(map);\n        unmodifiableMap.put("a", 1);\n    }\n}\n\n\nException in thread "main" java.lang.UnsupportedOperationException\n    at java.util.Collections$UnmodifiableMap.put(Collections.java:1457)\n    at ImmutableExample.main(ImmutableExample.java:9)\n\n\nCollections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。\n\npublic V put(K key, V value) {\n    throw new UnsupportedOperationException();\n}\n\n\n\n# 2. 绝对线程安全\n\n不管运行时环境如何，调用者都不需要任何额外的同步措施。\n\n\n# 3. 相对线程安全\n\n相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。\n\n在 Java 语言中，大部分的线程安全类都属于这种类型，例如 Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。\n\n对于下面的代码，如果删除元素的线程删除了 Vector 的一个元素，而获取元素的线程试图访问一个已经被删除的元素，那么就会抛出 ArrayIndexOutOfBoundsException。\n\npublic class VectorUnsafeExample {\n    private static Vector<Integer> vector = new Vector<>();\n\n    public static void main(String[] args) {\n        while (true) {\n            for (int i = 0; i < 100; i++) {\n                vector.add(i);\n            }\n            ExecutorService executorService = Executors.newCachedThreadPool();\n            executorService.execute(() -> {\n                for (int i = 0; i < vector.size(); i++) {\n                    vector.remove(i);\n                }\n            });\n            executorService.execute(() -> {\n                for (int i = 0; i < vector.size(); i++) {\n                    vector.get(i);\n                }\n            });\n            executorService.shutdown();\n        }\n    }\n}\n\n\nException in thread "Thread-159738" java.lang.ArrayIndexOutOfBoundsException: Array index out of range: 3\n    at java.util.Vector.remove(Vector.java:831)\n    at VectorUnsafeExample.lambda$main$0(VectorUnsafeExample.java:14)\n    at VectorUnsafeExample$$Lambda$1/713338599.run(Unknown Source)\n    at java.lang.Thread.run(Thread.java:745)\n\n\n如果要保证上面的代码能正确执行下去，就需要对删除元素和获取元素的代码进行同步。\n\nexecutorService.execute(() -> {\n    synchronized (vector) {\n        for (int i = 0; i < vector.size(); i++) {\n            vector.remove(i);\n        }\n    }\n});\nexecutorService.execute(() -> {\n    synchronized (vector) {\n        for (int i = 0; i < vector.size(); i++) {\n            vector.get(i);\n        }\n    }\n});\n\n\n\n# 4. 线程兼容\n\n线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。Java API 中大部分的类都是属于线程兼容的，如与前面的 Vector 和 HashTable 相对应的集合类 ArrayList 和 HashMap 等。\n\n\n# 5. 线程对立\n\n线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于 Java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。\n\n\n# 线程安全的实现方法\n\n\n# 1. 互斥同步\n\nsynchronized 和 ReentrantLock。\n\n初步了解你可以看：\n\n * Java 并发 - 线程基础：线程互斥同步\n\n详细分析请看：\n\n * 关键字: Synchronized详解\n * JUC锁: ReentrantLock详解\n\n\n# 2. 非阻塞同步\n\n互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。\n\n互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。\n\n(一)CAS\n\n随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略: 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施(不断地重试，直到成功为止)。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。\n\n乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是: 比较并交换(Compare-and-Swap，CAS)。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。\n\n(二)AtomicInteger\n\nJ.U.C 包里面的整数原子类 AtomicInteger，其中的 compareAndSet() 和 getAndIncrement() 等方法都使用了 Unsafe 类的 CAS 操作。\n\n以下代码使用了 AtomicInteger 执行了自增的操作。\n\nprivate AtomicInteger cnt = new AtomicInteger();\n\npublic void add() {\n    cnt.incrementAndGet();\n}\n\n\n以下代码是 incrementAndGet() 的源码，它调用了 unsafe 的 getAndAddInt() 。\n\npublic final int incrementAndGet() {\n    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;\n}\n\n\n以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。\n\n可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。\n\npublic final int getAndAddInt(Object var1, long var2, int var4) {\n    int var5;\n    do {\n        var5 = this.getIntVolatile(var1, var2);\n    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n\n    return var5;\n}\n\n\n(三)ABA\n\n如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。\n\nJ.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。\n\nCAS, Unsafe和原子类详细分析请看：\n\n * JUC原子类: CAS, Unsafe和原子类详解\n\n\n# 3. 无同步方案\n\n要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。\n\n(一)栈封闭\n\n多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class StackClosedExample {\n    public void add100() {\n        int cnt = 0;\n        for (int i = 0; i < 100; i++) {\n            cnt++;\n        }\n        System.out.println(cnt);\n    }\n}\n\n\npublic static void main(String[] args) {\n    StackClosedExample example = new StackClosedExample();\n    ExecutorService executorService = Executors.newCachedThreadPool();\n    executorService.execute(() -> example.add100());\n    executorService.execute(() -> example.add100());\n    executorService.shutdown();\n}\n\n\n更详细的分析请看J.U.C中线程池相关内容详解：\n\n * JUC线程池: FutureTask详解\n * JUC线程池: ThreadPoolExecutor详解\n * JUC线程池: ScheduledThreadPool详解\n * JUC线程池: Fork/Join框架详解\n\n(二)线程本地存储(Thread Local Storage)\n\n如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。\n\n符合这种特点的应用并不少见，大部分使用消费队列的架构模式(如“生产者-消费者”模式)都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”(Thread-per-Request)的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。\n\n可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。\n\n对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。\n\npublic class ThreadLocalExample {\n    public static void main(String[] args) {\n        ThreadLocal threadLocal = new ThreadLocal();\n        Thread thread1 = new Thread(() -> {\n            threadLocal.set(1);\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(threadLocal.get());\n            threadLocal.remove();\n        });\n        Thread thread2 = new Thread(() -> {\n            threadLocal.set(2);\n            threadLocal.remove();\n        });\n        thread1.start();\n        thread2.start();\n    }\n}\n\n\n输出结果\n\n为了理解 ThreadLocal，先看以下代码:\n\npublic class ThreadLocalExample1 {\n    public static void main(String[] args) {\n        ThreadLocal threadLocal1 = new ThreadLocal();\n        ThreadLocal threadLocal2 = new ThreadLocal();\n        Thread thread1 = new Thread(() -> {\n            threadLocal1.set(1);\n            threadLocal2.set(1);\n        });\n        Thread thread2 = new Thread(() -> {\n            threadLocal1.set(2);\n            threadLocal2.set(2);\n        });\n        thread1.start();\n        thread2.start();\n    }\n}\n\n\n它所对应的底层结构图为:\n\n\n\n每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象，Thread 类中就定义了 ThreadLocal.ThreadLocalMap 成员。\n\n/* ThreadLocal values pertaining to this thread. This map is maintained\n * by the ThreadLocal class. */\nThreadLocal.ThreadLocalMap threadLocals = null;\n\n\n当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal->value 键值对插入到该 Map 中。\n\npublic void set(T value) {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n}\n\n\nget() 方法类似。\n\npublic T get() {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null) {\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {\n            @SuppressWarnings("unchecked")\n            T result = (T)e.value;\n            return result;\n        }\n    }\n    return setInitialValue();\n}\n\n\nThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。\n\n在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。\n\n更详细的分析看：Java 并发 - ThreadLocal详解\n\n(三)可重入代码(Reentrant Code)\n\n这种代码也叫做纯代码(Pure Code)，可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。\n\n可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。\n\n\n# 参考文章\n\n转载 https://www.pdai.tech/md/java/thread/java-thread-x-theorty.html',normalizedContent:'# java 并发 - 理论基础\n\n> 本文从理论的角度引入并发安全问题以及jmm应对并发问题的原理。\n\n * java 并发 - 理论基础\n   * 带着bat大厂的面试问题去理解\n   * 为什么需要多线程\n   * 线程不安全示例\n   * 并发出现问题的根源: 并发三要素\n     * 可见性: cpu缓存引起\n     * 原子性: 分时复用引起\n     * 有序性: 重排序引起\n   * java是怎么解决并发问题的: jmm(java内存模型)\n     * 关键字: volatile、synchronized 和 final\n     * happens-before 规则\n       * 1. 单一线程原则\n       * 2. 管程锁定规则\n       * 3. volatile 变量规则\n       * 4. 线程启动规则\n       * 5. 线程加入规则\n       * 6. 线程中断规则\n       * 7. 对象终结规则\n       * 8. 传递性\n   * 线程安全: 不是一个非真即假的命题\n     * 1. 不可变\n     * 2. 绝对线程安全\n     * 3. 相对线程安全\n     * 4. 线程兼容\n     * 5. 线程对立\n   * 线程安全的实现方法\n     * 1. 互斥同步\n     * 2. 非阻塞同步\n     * 3. 无同步方案\n   * 参考文章\n\n\n# 带着bat大厂的面试问题去理解\n\n提示\n\n请带着这些问题继续后文，会很大程度上帮助你更好的理解并发理论基础。@pdai\n\n * 多线程的出现是要解决什么问题的?\n * 线程不安全是指什么? 举例说明\n * 并发出现线程不安全的本质什么? 可见性，原子性和有序性。\n * java是怎么解决并发问题的? 3个关键字，jmm和8个happens-before\n * 线程安全是不是非真即假? 不是\n * 线程安全有哪些实现思路?\n * 如何理解并发和并行的区别?\n\n\n# 为什么需要多线程\n\n众所周知，cpu、内存、i/o 设备的速度是有极大差异的，为了合理利用 cpu 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:\n\n * cpu 增加了缓存，以均衡与内存的速度差异；// 导致 可见性问题\n * 操作系统增加了进程、线程，以分时复用 cpu，进而均衡 cpu 与 i/o 设备的速度差异；// 导致 原子性问题\n * 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。// 导致 有序性问题\n\n\n# 线程不安全示例\n\n如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。\n\n以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。\n\npublic class threadunsafeexample {\n\n    private int cnt = 0;\n\n    public void add() {\n        cnt++;\n    }\n\n    public int get() {\n        return cnt;\n    }\n}\n\n\npublic static void main(string[] args) throws interruptedexception {\n    final int threadsize = 1000;\n    threadunsafeexample example = new threadunsafeexample();\n    final countdownlatch countdownlatch = new countdownlatch(threadsize);\n    executorservice executorservice = executors.newcachedthreadpool();\n    for (int i = 0; i < threadsize; i++) {\n        executorservice.execute(() -> {\n            example.add();\n            countdownlatch.countdown();\n        });\n    }\n    countdownlatch.await();\n    executorservice.shutdown();\n    system.out.println(example.get());\n}\n\n\n\n# 并发出现问题的根源: 并发三要素\n\n上述代码输出为什么不是1000? 并发出现问题的根源是什么?\n\n\n# 可见性: cpu缓存引起\n\n可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。\n\n举个简单的例子，看下面这段代码：\n\n//线程1执行的代码\nint i = 0;\ni = 10;\n \n//线程2执行的代码\nj = i;\n\n\n假若执行线程1的是cpu1，执行线程2的是cpu2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到cpu1的高速缓存中，然后赋值为10，那么在cpu1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。\n\n此时线程2执行 j = i，它会先去主存读取i的值并加载到cpu2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.\n\n这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。\n\n\n# 原子性: 分时复用引起\n\n原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。\n\n举个简单的例子，看下面这段代码：\n\nint i = 1;\n\n// 线程1执行\ni += 1;\n\n// 线程2执行\ni += 1;\n\n\n这里需要注意的是：i += 1需要三条 cpu 指令\n\n 1. 将变量 i 从内存读取到 cpu寄存器；\n 2. 在cpu寄存器中执行 i + 1 操作；\n 3. 将最后的结果i写入内存（缓存机制导致可能写入的是 cpu 缓存而不是内存）。\n\n由于cpu分时复用（线程切换）的存在，线程1执行了第一条指令后，就切换到线程2执行，假如线程2执行了这三条指令后，再切换会线程1执行后续两条指令，将造成最后写到内存中的i值是2而不是3。\n\n\n# 有序性: 重排序引起\n\n有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：\n\nint i = 0;              \nboolean flag = false;\ni = 1;                //语句1  \nflag = true;          //语句2\n\n\n上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么jvm在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗? 不一定，为什么呢? 这里可能会发生指令重排序（instruction reorder）。\n\n在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：\n\n * 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。\n * 指令级并行的重排序。现代处理器采用了指令级并行技术（instruction-level parallelism， ilp）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。\n * 内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。\n\n从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：\n\n\n\n上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，jmm 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，jmm 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。\n\n具体可以参看：java 内存模型详解的重排序章节。\n\n\n# java是怎么解决并发问题的: jmm(java内存模型)\n\njava 内存模型是个很复杂的规范，强烈推荐你看后续（应该是网上能找到最好的材料之一了）：java 内存模型详解。\n\n理解的第一个维度：核心知识点\n\njmm本质上可以理解为，java 内存模型规范了 jvm 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括：\n\n * volatile、synchronized 和 final 三个关键字\n * happens-before 规则\n\n理解的第二个维度：可见性，有序性，原子性\n\n * 原子性\n\n在java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 请分析以下哪些操作是原子性操作：\n\nx = 10;        //语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中\ny = x;         //语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。\nx++;           //语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。\nx = x + 1;     //语句4： 同语句3\n\n\n上面4个语句只有语句1的操作具备原子性。\n\n也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。\n\n> 从上面可以看出，java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和lock来实现。由于synchronized和lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。\n\n * 可见性\n\njava提供了volatile关键字来保证可见性。\n\n当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。\n\n而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。\n\n> 另外，通过synchronized和lock也能够保证可见性，synchronized和lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。\n\n * 有序性\n\n在java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和lock来保证有序性，很显然，synchronized和lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然jmm是通过happens-before 规则来保证有序性的。\n\n\n# 关键字: volatile、synchronized 和 final\n\n以下三篇文章详细分析了这三个关键字：\n\n * 关键字: synchronized详解\n * 关键字: volatile详解\n * 关键字: final详解\n\n\n# happens-before 规则\n\n上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，jvm 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。\n\n# 1. 单一线程原则\n\n> single thread rule\n\n在一个线程内，在程序前面的操作先行发生于后面的操作。\n\n\n\n# 2. 管程锁定规则\n\n> monitor lock rule\n\n一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。\n\n\n\n# 3. volatile 变量规则\n\n> volatile variable rule\n\n对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。\n\n\n\n# 4. 线程启动规则\n\n> thread start rule\n\nthread 对象的 start() 方法调用先行发生于此线程的每一个动作。\n\n\n\n# 5. 线程加入规则\n\n> thread join rule\n\nthread 对象的结束先行发生于 join() 方法返回。\n\n\n\n# 6. 线程中断规则\n\n> thread interruption rule\n\n对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。\n\n# 7. 对象终结规则\n\n> finalizer rule\n\n一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始。\n\n# 8. 传递性\n\n> transitivity\n\n如果操作 a 先行发生于操作 b，操作 b 先行发生于操作 c，那么操作 a 先行发生于操作 c。\n\n\n# 线程安全: 不是一个非真即假的命题\n\n一个类在可以被多个线程安全调用时就是线程安全的。\n\n线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分成以下五类: 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。\n\n\n# 1. 不可变\n\n不可变(immutable)的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。\n\n多线程环境下，应当尽量使对象成为不可变，来满足线程安全。\n\n不可变的类型:\n\n * final 关键字修饰的基本数据类型\n * string\n * 枚举类型\n * number 部分子类，如 long 和 double 等数值包装类型，biginteger 和 bigdecimal 等大数据类型。但同为 number 的原子类 atomicinteger 和 atomiclong 则是可变的。\n\n对于集合类型，可以使用 collections.unmodifiablexxx() 方法来获取一个不可变的集合。\n\npublic class immutableexample {\n    public static void main(string[] args) {\n        map<string, integer> map = new hashmap<>();\n        map<string, integer> unmodifiablemap = collections.unmodifiablemap(map);\n        unmodifiablemap.put("a", 1);\n    }\n}\n\n\nexception in thread "main" java.lang.unsupportedoperationexception\n    at java.util.collections$unmodifiablemap.put(collections.java:1457)\n    at immutableexample.main(immutableexample.java:9)\n\n\ncollections.unmodifiablexxx() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。\n\npublic v put(k key, v value) {\n    throw new unsupportedoperationexception();\n}\n\n\n\n# 2. 绝对线程安全\n\n不管运行时环境如何，调用者都不需要任何额外的同步措施。\n\n\n# 3. 相对线程安全\n\n相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。\n\n在 java 语言中，大部分的线程安全类都属于这种类型，例如 vector、hashtable、collections 的 synchronizedcollection() 方法包装的集合等。\n\n对于下面的代码，如果删除元素的线程删除了 vector 的一个元素，而获取元素的线程试图访问一个已经被删除的元素，那么就会抛出 arrayindexoutofboundsexception。\n\npublic class vectorunsafeexample {\n    private static vector<integer> vector = new vector<>();\n\n    public static void main(string[] args) {\n        while (true) {\n            for (int i = 0; i < 100; i++) {\n                vector.add(i);\n            }\n            executorservice executorservice = executors.newcachedthreadpool();\n            executorservice.execute(() -> {\n                for (int i = 0; i < vector.size(); i++) {\n                    vector.remove(i);\n                }\n            });\n            executorservice.execute(() -> {\n                for (int i = 0; i < vector.size(); i++) {\n                    vector.get(i);\n                }\n            });\n            executorservice.shutdown();\n        }\n    }\n}\n\n\nexception in thread "thread-159738" java.lang.arrayindexoutofboundsexception: array index out of range: 3\n    at java.util.vector.remove(vector.java:831)\n    at vectorunsafeexample.lambda$main$0(vectorunsafeexample.java:14)\n    at vectorunsafeexample$$lambda$1/713338599.run(unknown source)\n    at java.lang.thread.run(thread.java:745)\n\n\n如果要保证上面的代码能正确执行下去，就需要对删除元素和获取元素的代码进行同步。\n\nexecutorservice.execute(() -> {\n    synchronized (vector) {\n        for (int i = 0; i < vector.size(); i++) {\n            vector.remove(i);\n        }\n    }\n});\nexecutorservice.execute(() -> {\n    synchronized (vector) {\n        for (int i = 0; i < vector.size(); i++) {\n            vector.get(i);\n        }\n    }\n});\n\n\n\n# 4. 线程兼容\n\n线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。java api 中大部分的类都是属于线程兼容的，如与前面的 vector 和 hashtable 相对应的集合类 arraylist 和 hashmap 等。\n\n\n# 5. 线程对立\n\n线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于 java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。\n\n\n# 线程安全的实现方法\n\n\n# 1. 互斥同步\n\nsynchronized 和 reentrantlock。\n\n初步了解你可以看：\n\n * java 并发 - 线程基础：线程互斥同步\n\n详细分析请看：\n\n * 关键字: synchronized详解\n * juc锁: reentrantlock详解\n\n\n# 2. 非阻塞同步\n\n互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。\n\n互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。\n\n(一)cas\n\n随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略: 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施(不断地重试，直到成功为止)。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。\n\n乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是: 比较并交换(compare-and-swap，cas)。cas 指令需要有 3 个操作数，分别是内存地址 v、旧的预期值 a 和新值 b。当执行操作时，只有当 v 的值等于 a，才将 v 的值更新为 b。\n\n(二)atomicinteger\n\nj.u.c 包里面的整数原子类 atomicinteger，其中的 compareandset() 和 getandincrement() 等方法都使用了 unsafe 类的 cas 操作。\n\n以下代码使用了 atomicinteger 执行了自增的操作。\n\nprivate atomicinteger cnt = new atomicinteger();\n\npublic void add() {\n    cnt.incrementandget();\n}\n\n\n以下代码是 incrementandget() 的源码，它调用了 unsafe 的 getandaddint() 。\n\npublic final int incrementandget() {\n    return unsafe.getandaddint(this, valueoffset, 1) + 1;\n}\n\n\n以下代码是 getandaddint() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getintvolatile(var1, var2) 得到旧的预期值，通过调用 compareandswapint() 来进行 cas 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。\n\n可以看到 getandaddint() 在一个循环中进行，发生冲突的做法是不断的进行重试。\n\npublic final int getandaddint(object var1, long var2, int var4) {\n    int var5;\n    do {\n        var5 = this.getintvolatile(var1, var2);\n    } while(!this.compareandswapint(var1, var2, var5, var5 + var4));\n\n    return var5;\n}\n\n\n(三)aba\n\n如果一个变量初次读取的时候是 a 值，它的值被改成了 b，后来又被改回为 a，那 cas 操作就会误认为它从来没有被改变过。\n\nj.u.c 包提供了一个带有标记的原子引用类 atomicstampedreference 来解决这个问题，它可以通过控制变量值的版本来保证 cas 的正确性。大部分情况下 aba 问题不会影响程序并发的正确性，如果需要解决 aba 问题，改用传统的互斥同步可能会比原子类更高效。\n\ncas, unsafe和原子类详细分析请看：\n\n * juc原子类: cas, unsafe和原子类详解\n\n\n# 3. 无同步方案\n\n要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。\n\n(一)栈封闭\n\n多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。\n\nimport java.util.concurrent.executorservice;\nimport java.util.concurrent.executors;\n\npublic class stackclosedexample {\n    public void add100() {\n        int cnt = 0;\n        for (int i = 0; i < 100; i++) {\n            cnt++;\n        }\n        system.out.println(cnt);\n    }\n}\n\n\npublic static void main(string[] args) {\n    stackclosedexample example = new stackclosedexample();\n    executorservice executorservice = executors.newcachedthreadpool();\n    executorservice.execute(() -> example.add100());\n    executorservice.execute(() -> example.add100());\n    executorservice.shutdown();\n}\n\n\n更详细的分析请看j.u.c中线程池相关内容详解：\n\n * juc线程池: futuretask详解\n * juc线程池: threadpoolexecutor详解\n * juc线程池: scheduledthreadpool详解\n * juc线程池: fork/join框架详解\n\n(二)线程本地存储(thread local storage)\n\n如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。\n\n符合这种特点的应用并不少见，大部分使用消费队列的架构模式(如“生产者-消费者”模式)都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 web 交互模型中的“一个请求对应一个服务器线程”(thread-per-request)的处理方式，这种处理方式的广泛应用使得很多 web 服务端应用都可以使用线程本地存储来解决线程安全问题。\n\n可以使用 java.lang.threadlocal 类来实现线程本地存储功能。\n\n对于以下代码，thread1 中设置 threadlocal 为 1，而 thread2 设置 threadlocal 为 2。过了一段时间之后，thread1 读取 threadlocal 依然是 1，不受 thread2 的影响。\n\npublic class threadlocalexample {\n    public static void main(string[] args) {\n        threadlocal threadlocal = new threadlocal();\n        thread thread1 = new thread(() -> {\n            threadlocal.set(1);\n            try {\n                thread.sleep(1000);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n            system.out.println(threadlocal.get());\n            threadlocal.remove();\n        });\n        thread thread2 = new thread(() -> {\n            threadlocal.set(2);\n            threadlocal.remove();\n        });\n        thread1.start();\n        thread2.start();\n    }\n}\n\n\n输出结果\n\n为了理解 threadlocal，先看以下代码:\n\npublic class threadlocalexample1 {\n    public static void main(string[] args) {\n        threadlocal threadlocal1 = new threadlocal();\n        threadlocal threadlocal2 = new threadlocal();\n        thread thread1 = new thread(() -> {\n            threadlocal1.set(1);\n            threadlocal2.set(1);\n        });\n        thread thread2 = new thread(() -> {\n            threadlocal1.set(2);\n            threadlocal2.set(2);\n        });\n        thread1.start();\n        thread2.start();\n    }\n}\n\n\n它所对应的底层结构图为:\n\n\n\n每个 thread 都有一个 threadlocal.threadlocalmap 对象，thread 类中就定义了 threadlocal.threadlocalmap 成员。\n\n/* threadlocal values pertaining to this thread. this map is maintained\n * by the threadlocal class. */\nthreadlocal.threadlocalmap threadlocals = null;\n\n\n当调用一个 threadlocal 的 set(t value) 方法时，先得到当前线程的 threadlocalmap 对象，然后将 threadlocal->value 键值对插入到该 map 中。\n\npublic void set(t value) {\n    thread t = thread.currentthread();\n    threadlocalmap map = getmap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createmap(t, value);\n}\n\n\nget() 方法类似。\n\npublic t get() {\n    thread t = thread.currentthread();\n    threadlocalmap map = getmap(t);\n    if (map != null) {\n        threadlocalmap.entry e = map.getentry(this);\n        if (e != null) {\n            @suppresswarnings("unchecked")\n            t result = (t)e.value;\n            return result;\n        }\n    }\n    return setinitialvalue();\n}\n\n\nthreadlocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。\n\n在一些场景 (尤其是使用线程池) 下，由于 threadlocal.threadlocalmap 的底层数据结构导致 threadlocal 有内存泄漏的情况，应该尽可能在每次使用 threadlocal 后手动调用 remove()，以避免出现 threadlocal 经典的内存泄漏甚至是造成自身业务混乱的风险。\n\n更详细的分析看：java 并发 - threadlocal详解\n\n(三)可重入代码(reentrant code)\n\n这种代码也叫做纯代码(pure code)，可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。\n\n可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。\n\n\n# 参考文章\n\n转载 https://www.pdai.tech/md/java/thread/java-thread-x-theorty.html',charsets:{cjk:!0}},{frontmatter:{layout:"Tags",title:"Tags"},regularPath:"/tag/",key:"v-b1564aac",path:"/tag/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"FrontmatterKey",title:"Categories"},regularPath:"/categories/",key:"v-ef9325c4",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"TimeLines",title:"Timeline"},regularPath:"/timeline/",key:"v-6319eb4e",path:"/timeline/",headersStr:null,content:"",normalizedContent:"",charsets:{}}],themeConfig:{subSidebar:"auto",searchMaxSuggestions:15,smoothScroll:!0,logo:"/Eminem.svg",lastUpdated:"Last Updated",repo:"https://github.com/lowskylee/vblog",repoLabel:"GitHub",docsRepo:"https://github.com/lowskylee/vblog",docsDir:"docs",docsBranch:"master",editLinks:!0,editLinkText:"Edit this page",nav:[{text:"首页",link:"/"},{text:"Java",items:[{text:"Java 基础",link:"/java/basic/java-basic-oop"},{text:"Java 集合框架",link:"/java/collection/java-collection-all"},{text:"Java 多线程与并发",link:"/java/thread/java-thread-x-overview"}]},{text:"算法",items:[{text:"算法基础思想",link:"/algorithm/basic/alg-basic-overview"}]},{text:"数据库",items:[{text:"数据库基础和原理",link:"/sql/basic/sql-db"}]},{text:"Spring",items:[{text:"Spring Framework 5基础",link:"/spring/basic/spring"}]},{text:"开发必备",items:[{text:"在线ASCII码表",link:"https://www.fly63.com/tool/ascii/"},{text:"正则表达式调试工具",link:"https://regexr.com/"}]},{text:"技术文档",items:[{text:"Git中文教程",link:"https://git-scm.com/book/zh/v2"},{text:"Nginx中文文档",link:"https://www.nginx.cn/doc/index.html"},{text:"Kafka中文文档",link:"https://kafka.apachecn.org/"}]}],sidebar:{"/java/":[{title:"Java 基础",children:[{title:"Java 基础 - 面向对象",path:"/java/basic/java-basic-oop"},{title:"Java 基础 - 知识点",path:"/java/basic/java-basic-lan-basic"},{title:"Java 基础 - 图谱 & Q/A",path:"/java/basic/java-basic-lan-sum"},{title:"JJava 基础 - 泛型机制详解",path:"/java/basic/java-basic-x-generic"},{title:"Java 基础 - 注解机制详解",path:"/java/basic/java-basic-x-annotation"},{title:"Java 基础 - 异常机制详解",path:"/java/basic/java-basic-x-exception"},{title:"Java 基础 - 反射机制详解",path:"/java/basic/java-basic-x-reflection"},{title:"Java常用机制 - SPI机制详解",path:"/java/basic/java-advanced-spi"}]},{title:"Java 集合框架",children:[{title:"Collection 类关系图",path:"/java/collection/java-collection-all"},{title:"Collection - ArrayList 源码解析",path:"/java/collection/java-collection-ArrayList"},{title:"Collection - LinkedList源码解析",path:"/java/collection/java-collection-LinkedList"},{title:"Collection - Stack & Queue 源码解析",path:"/java/collection/java-collection-Queue&Stack"},{title:"Collection - PriorityQueue源码解析",path:"/java/collection/java-collection-PriorityQueue"},{title:"Map - HashSet & HashMap 源码解析",path:"/java/collection/java-map-HashMap&HashSet"},{title:"Map - LinkedHashSet&Map源码解析",path:"/java/collection/java-map-LinkedHashMap&LinkedHashSet"},{title:"Map - TreeSet & TreeMap 源码解析",path:"/java/collection/java-map-TreeMap&TreeSet"},{title:"Map - WeakHashMap源码解析",path:"/java/collection/java-map-WeakHashMap"}]},{title:"Java 多线程与并发",children:[{title:"Java并发知识体系详解",path:"/java/thread/java-thread-x-overview"},{title:"Java 并发 - 理论基础",path:"/java/thread/java-thread-x-theorty"},{title:"Java 并发 - 线程基础",path:"/java/thread/java-thread-x-thread-basic"},{title:"Java并发 - Java中所有的锁",path:"/java/thread/java-thread-x-lock-all"},{title:"关键字: synchronized详解",path:"/java/thread/java-thread-x-key-synchronized"},{title:"关键字: volatile详解",path:"/java/thread/java-thread-x-key-volatile"},{title:"关键字: final详解",path:"/java/thread/java-thread-x-key-final"},{title:"JUC - 类汇总和学习指南",path:"/java/thread/java-thread-x-juc-overview"},{title:"JUC原子类: CAS, Unsafe和原子类详解",path:"/java/thread/java-thread-x-juc-AtomicInteger"},{title:"JUC锁: LockSupport详解",path:"/java/thread/java-thread-x-lock-LockSupport"},{title:"JUC锁: 锁核心类AQS详解",path:"/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer"},{title:"JUC锁: ReentrantLock详解",path:"/java/thread/java-thread-x-lock-ReentrantLock"},{title:"JUC锁: ReentrantReadWriteLock详解",path:"/java/thread/java-thread-x-lock-ReentrantReadWriteLock"},{title:"JUC集合: ConcurrentHashMap详解",path:"/java/thread/java-thread-x-juc-collection-ConcurrentHashMap"},{title:"JUC集合: CopyOnWriteArrayList详解",path:"/java/thread/java-thread-x-juc-collection-CopyOnWriteArrayList"},{title:"JUC集合: ConcurrentLinkedQueue详解",path:"/java/thread/java-thread-x-juc-collection-ConcurrentLinkedQueue"},{title:"JUC集合: BlockingQueue详解",path:"/java/thread/java-thread-x-juc-collection-BlockingQueue"},{title:"JUC线程池: FutureTask详解",path:"/java/thread/java-thread-x-juc-executor-FutureTask"},{title:"JUC线程池: ThreadPoolExecutor详解",path:"/java/thread/java-thread-x-juc-executor-ThreadPoolExecutor"},{title:"JUC线程池: ScheduledThreadPoolExecutor详解",path:"/java/thread/java-thread-x-juc-executor-ScheduledThreadPoolExecutor"},{title:"JUC线程池: Fork/Join框架详解",path:"/java/thread/java-thread-x-juc-executor-ForkJoinPool"},{title:"JUC工具类: CountDownLatch详解",path:"/java/thread/java-thread-x-juc-tool-countdownlatch"},{title:"JUC工具类: CyclicBarrier详解",path:"/java/thread/java-thread-x-juc-tool-cyclicbarrier"},{title:"JUC工具类: Semaphore详解",path:"/java/thread/java-thread-x-juc-tool-semaphore"},{title:"JUC工具类: Phaser详解",path:"/java/thread/java-thread-x-juc-tool-phaser"},{title:"JUC工具类: Exchanger详解",path:"/java/thread/java-thread-x-juc-tool-exchanger"},{title:"Java 并发 - ThreadLocal详解",path:"/java/thread/java-thread-x-threadlocal"}]}],"/algorithm/":[{title:"算法基础和思想",children:[{title:"数据结构基础知识体系详解",path:"/algorithm/basic/alg-basic-overview"}]}],"/sql/":[{title:"数据库基础和原理",children:[{title:"数据库基础和SQL知识体系详解",path:"/sql/basic/sql-db"}]}],"/spring/":[{title:"Spring Framework 5基础",children:[{title:"Spring框架知识体系详解",path:"/spring/basic/spring"}]}],"/":[{title:"欢迎学习",collapsable:!1,children:[{title:"介绍",path:"/"},{title:"关于",path:"/about"}]}]}},locales:{"/":{lang:"zh-CN",path:"/"}}};var He=t(26),Qe={computed:{$recoPosts(){let n=this.$site.pages;return n=Object(He.a)(n,!1),Object(He.c)(n),n},$recoPostsForTimeline(){let n=this.$recoPosts;const e={},t=[];n=Object(He.a)(n,!0),this.pages=0==n.length?[]:n;for(let t=0,a=n.length;t<a;t++){const a=n[t],r=Ge(a.frontmatter.date,"year");e[r]?e[r].push(a):e[r]=[a]}for(const n in e){const a=e[n];Object(He.b)(a),t.unshift({year:n,data:a})}return t},$categoriesList(){return this.$categories.list.map(n=>(n.pages=n.pages.filter(n=>!1!==n.frontmatter.publish),n))},$tagesList(){return this.$tags.list.map(n=>(n.pages=n.pages.filter(n=>!1!==n.frontmatter.publish),n))},$showSubSideBar(){const{$themeConfig:{subSidebar:n,sidebar:e},$frontmatter:{subSidebar:t,sidebar:a}}=this,r=this.$page.headers||[];return!([t,a].indexOf(!1)>-1)&&([t,a].indexOf("auto")>-1&&r.length>0||[n,e].indexOf("auto")>-1&&r.length>0)}}};function Ge(n,e){n=function(n){var e=new Date(n).toJSON();return new Date(+new Date(e)+288e5).toISOString().replace(/T/g," ").replace(/\.[\d]{3}Z/,"").replace(/-/g,"/")}(n);const t=new Date(n),a=t.getFullYear(),r=t.getMonth()+1,i=t.getDate();return"year"==e?a:`${r}-${i}`}var Ke={all:"全部",article:"文章",tag:"标签",category:"分类",friendLink:"友情链接",timeLine:"时间轴",timeLineMsg:"昨日重现！"},Ye={all:"全部",article:"文章",tag:"標簽",category:"分類",friendLink:"友情鏈接",timeLine:"時間軸",timeLineMsg:"昨日重現！"},Xe={all:"All",article:"Articles",tag:"Tags",category:"Categories",friendLink:"Friend Links",timeLine:"TimeLine",timeLineMsg:"Yesterday Once More!"},Ze={all:"全部",article:"文章",tag:"ラベル",category:"分類",friendLink:"友情リンク",timeLine:"タイムライン",timeLineMsg:"昨日また！"},nt={all:"전체",article:"글",tag:"태그",category:"분류",friendLink:"링크 참조",timeLine:"타임 라인",timeLineMsg:"어제 또!"},et={all:"Todas",article:"Artículos",tag:"Etiquetas",category:"Categorías",friendLink:"Páginas amigas",timeLine:"Cronología",timeLineMsg:"¡Ayer otra vez!"},tt={computed:{$recoLocales(){const n=this.$themeLocaleConfig.recoLocales||{};return/^zh\-(CN|SG)$/.test(this.$lang)?{...Ke,...n}:/^zh\-(HK|MO|TW)$/.test(this.$lang)?{...Ye,...n}:/^ja\-JP$/.test(this.$lang)?{...Ze,...n}:/^ko\-KR$/.test(this.$lang)?{...nt,...n}:/^es(\-[A-Z]+)?$/.test(this.$lang)?{...et,...n}:{...Xe,...n}}}},at=t(40);t(271);a.b.component("Badge",()=>Promise.all([t.e(0),t.e(9)]).then(t.bind(null,512)));var rt={name:"BackToTop",data:()=>({visible:!1,customStyle:{right:"1rem",bottom:"6rem",width:"2.5rem",height:"2.5rem","border-radius":".25rem","line-height":"2.5rem"},visibilityHeight:400}),mounted(){window.addEventListener("scroll",this.throttle(this.handleScroll,500))},beforeDestroy(){window.removeEventListener("scroll",this.throttle(this.handleScroll,500))},methods:{handleScroll(){this.visible=window.pageYOffset>this.visibilityHeight},backToTop(){window.scrollTo(0,0)},throttle(n,e){let t=null,a=Date.now();return function(){const r=Date.now(),i=e-(r-a),o=this,s=arguments;clearTimeout(t),i<=0?(n.apply(o,s),a=Date.now()):t=setTimeout(n,i)}}}},it=(t(272),Object(Ue.a)(rt,(function(){var n=this._self._c;return n("transition",{attrs:{name:"fade"}},[n("div",{directives:[{name:"show",rawName:"v-show",value:this.visible,expression:"visible"}],staticClass:"back-to-ceiling",style:this.customStyle,on:{click:this.backToTop}},[n("svg",{staticClass:"icon",attrs:{t:"1574745035067",viewBox:"0 0 1024 1024",version:"1.1",xmlns:"http://www.w3.org/2000/svg","p-id":"5404"}},[n("path",{attrs:{d:"M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z","p-id":"5405"}}),n("path",{attrs:{d:"M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z","p-id":"5406"}})])])])}),[],!1,null,"c6073ba8",null).exports);t(273),t(278);const ot={prev:"上一页",next:"下一页",go:"前往",jump:"跳转至"},st={prev:"上壹頁",next:"下壹頁",go:"前往",jump:"跳轉至"},lt={prev:"Prev",next:"Next",go:"Go",jump:"Jump To"},ct={prev:"前のページ",next:"次のページ",go:"へ",jump:"ジャンプ"},ut={prev:"이전 페이지",next:"다음 페이지",go:"행",jump:"건너뛰기"};var dt={data:()=>({changePage:"",pageSize:10}),props:{total:{type:Number,default:10},perPage:{type:Number,default:10},currentPage:{type:Number,default:1}},computed:{pages(){return Math.ceil(this.total/this.pageSize)},efont:function(){return this.pages>7},indexes:function(){var n=1,e=this.pages,t=[];for(this.pages>=7&&(this.currentPage>5&&this.currentPage<this.pages-4?(n=Number(this.currentPage)-3,e=Number(this.currentPage)+3):this.currentPage<=5?(n=1,e=7):(e=this.pages,n=this.pages-6));n<=e;)t.push(n),n++;return t},pagationLocales(){return function(n){const{$lang:e,$recoLocales:{pagation:t}={}}=n;return t||(/^zh\-(CN|SG)$/.test(e)?ot:/^zh\-(HK|MO|TW)$/.test(e)?st:/^ja\-JP$/.test(e)?ct:/^ko\-KR$/.test(e)?ut:lt)}(this)},showStartFakePageNum:function(){return this.efont&&!this.indexes.includes(1)},showLastFakePageNum:function(){return this.efont&&!this.indexes.includes(this.pages)}},methods:{goPrev(){let n=this.currentPage;this.currentPage>1&&this.emit(--n)},goNext(){let n=this.currentPage;n<this.pages&&this.emit(++n)},jumpPage:function(n){const e=parseInt(n);e<=this.pages&&e>0?this.emit(e):alert(`请输入大于0，并且小于等于${this.pages}的页码！`)},emit(n){this.$emit("getCurrentPage",n)}}},pt=(t(279),Object(Ue.a)(dt,(function(){var n=this,e=n._self._c;return e("div",{directives:[{name:"show",rawName:"v-show",value:n.pages>1,expression:"pages > 1"}],staticClass:"pagation"},[e("div",{staticClass:"pagation-list"},[e("span",{directives:[{name:"show",rawName:"v-show",value:n.currentPage>1,expression:"currentPage > 1"}],staticClass:"jump",attrs:{unselectable:"on"},on:{click:n.goPrev}},[n._v(n._s(n.pagationLocales.prev))]),n._v(" "),n.showStartFakePageNum?e("span",{staticClass:"jump",on:{click:function(e){return n.jumpPage(1)}}},[n._v("1")]):n._e(),n._v(" "),n.showStartFakePageNum&&n.indexes[0]>2?e("span",{staticClass:"ellipsis"},[n._v("...")]):n._e(),n._v(" "),n._l(n.indexes,(function(t){return e("span",{key:t,staticClass:"jump",class:{bgprimary:n.currentPage==t},on:{click:function(e){return n.jumpPage(t)}}},[n._v(n._s(t))])})),n._v(" "),n.showLastFakePageNum&&n.pages-n.indexes.at(-1)>1?e("span",{staticClass:"ellipsis"},[n._v("...")]):n._e(),n._v(" "),n.showLastFakePageNum?e("span",{staticClass:"jump",on:{click:function(e){return n.jumpPage(n.pages)}}},[n._v(n._s(n.pages))]):n._e(),n._v(" "),n.currentPage<n.pages?e("span",{staticClass:"jump",on:{click:n.goNext}},[n._v(n._s(n.pagationLocales.next))]):n._e(),n._v(" "),e("span",{staticClass:"jumppoint"},[n._v(n._s(n.pagationLocales.jump))]),n._v(" "),e("span",{staticClass:"jumpinp"},[e("input",{directives:[{name:"model",rawName:"v-model",value:n.changePage,expression:"changePage"}],attrs:{type:"text"},domProps:{value:n.changePage},on:{input:function(e){e.target.composing||(n.changePage=e.target.value)}}})]),n._v(" "),e("span",{staticClass:"jump gobtn",on:{click:function(e){return n.jumpPage(n.changePage)}}},[n._v(n._s(n.pagationLocales.go))])],2)])}),[],!1,null,"22b6649c",null).exports),ht=(t(280),{tags:{},categories:{},timeline:{}});class ft{constructor(n,e){this._metaMap=Object.assign({},n),Object.keys(this._metaMap).forEach(n=>{const{pageKeys:t}=this._metaMap[n];this._metaMap[n].pages=t.map(n=>function(n,e){for(let t=0;t<n.length;t++){const a=n[t];if(a.key===e)return a}return{path:"",frontmatter:{}}}(e,n))})}get length(){return Object.keys(this._metaMap).length}get map(){return this._metaMap}get pages(){return this.list}get list(){return this.toArray()}toArray(){const n=[];return Object.keys(this._metaMap).forEach(e=>{const{pages:t,path:a}=this._metaMap[e];n.push({name:e,pages:t,path:a})}),n}getItemByName(n){return this._metaMap[n]}}var mt=t(130);const gt=t.n(mt)()("plugin-blog:pagination");class vt{constructor(n,e,t){gt("pagination",n);const{pages:a,prevText:r,nextText:i}=n,{path:o}=t;this._prevText=r,this._nextText=i;for(let n=0,e=a.length;n<e;n++){if(a[n].path===o){this.paginationIndex=n;break}}this.paginationIndex||(this.paginationIndex=0),this._paginationPages=a,this._currentPage=a[this.paginationIndex],this._matchedPages=e.filter(e=>n.filter(e,n.id,n.pid)).sort(n.sorter)}setIndexPage(n){this._indexPage=n}get length(){return this._paginationPages.length}get pages(){const[n,e]=this._currentPage.interval;return this._matchedPages.slice(n,e+1)}get hasPrev(){return 0!==this.paginationIndex}get prevLink(){return this.hasPrev?this.paginationIndex-1==0&&this._indexPage?this._indexPage:this._paginationPages[this.paginationIndex-1].path:null}get hasNext(){return this.paginationIndex!==this.length-1}get nextLink(){return this.hasNext?this._paginationPages[this.paginationIndex+1].path:null}get prevText(){return this._prevText}get nextText(){return this._nextText}getSpecificPageLink(n){return this._paginationPages[n].path}}const yt=new class{constructor(n){this.paginations=n}get pages(){return a.b.$vuepress.$get("siteData").pages}getPagination(n,e,t){gt("id",e),gt("pid",n);const a=this.paginations.filter(t=>t.id===e&&t.pid===n)[0];return new vt(a,this.pages,t)}}([]);var bt={comment:{enabled:!1,service:""},email:{enabled:!1},feed:{rss:!1,atom:!1,json:!1}};function kt(n){const e=document.documentElement.getBoundingClientRect(),t=n.getBoundingClientRect();return{x:t.left-e.left,y:t.top-e.top}}var wt=({Vue:n,router:e})=>{e.options.scrollBehavior=(e,t,a)=>{if(a)return window.scrollTo({top:a.y,behavior:"smooth"});if(!e.hash)return window.scrollTo({top:0,behavior:"smooth"});{if(n.$vuepress.$get("disableScrollBehavior"))return;const t=document.querySelector(e.hash);if(t)return window.scrollTo({top:kt(t).y,behavior:"smooth"})}}},xt={name:"KanBanNiang",data:()=>({isLoaded:!0,displayBanNiang:!1,isShowMessageBox:!1,isShowBtns:!0,messages:{message:"欢迎来到我的博客",welcome:"欢迎来到我的博客",home:"心里的花，我想要带你回家。",theme:"好吧，希望你能喜欢我的其他小伙伴。",close:"你不喜欢我了吗？痴痴地望着你。"},currentTheme:"blackCat",myTheme:["blackCat","whiteCat","haru1","haru2","haruto","koharu","izumi","shizuku","wanko","miku","z16"],themeName:["blackCat","whiteCat","haru1","haru2","haruto","koharu","izumi","shizuku","wanko","miku","z16"],model:{blackCat:"https://cdn.jsdelivr.net/gh/QiShaoXuan/live2DModel@1.0.0/live2d-widget-model-hijiki/assets/hijiki.model.json",whiteCat:"https://cdn.jsdelivr.net/gh/QiShaoXuan/live2DModel@1.0.0/live2d-widget-model-tororo/assets/tororo.model.json",haru1:"https://cdn.jsdelivr.net/gh/QiShaoXuan/live2DModel@1.0.0/live2d-widget-model-haru/01/assets/haru01.model.json",haru2:"https://cdn.jsdelivr.net/gh/QiShaoXuan/live2DModel@1.0.0/live2d-widget-model-haru/02/assets/haru02.model.json",haruto:"https://cdn.jsdelivr.net/gh/QiShaoXuan/live2DModel@1.0.0/live2d-widget-model-haruto/assets/haruto.model.json",koharu:"https://cdn.jsdelivr.net/gh/QiShaoXuan/live2DModel@1.0.0/live2d-widget-model-koharu/assets/koharu.model.json",izumi:"https://cdn.jsdelivr.net/gh/QiShaoXuan/live2DModel@1.0.0/live2d-widget-model-izumi/assets/izumi.model.json",shizuku:"https://cdn.jsdelivr.net/gh/QiShaoXuan/live2DModel@1.0.0/live2d-widget-model-shizuku/assets/shizuku.model.json",wanko:"https://cdn.jsdelivr.net/gh/QiShaoXuan/live2DModel@1.0.0/live2d-widget-model-wanko/assets/wanko.model.json",miku:"https://cdn.jsdelivr.net/gh/QiShaoXuan/live2DModel@1.0.0/live2d-widget-model-miku/assets/miku.model.json",z16:"https://cdn.jsdelivr.net/gh/QiShaoXuan/live2DModel@1.0.0/live2d-widget-model-z16/assets/z16.model.json"},style:{width:250,height:320},modelStyle:{right:"90px",bottom:"-20px",opacity:"0.9"},messageStyle:{right:"68px",bottom:"290px"},btnStyle:{right:"90px",bottom:"40px"}}),mounted(){this.btnStyle={...this.btnStyle,height:this.myTheme.length>1?"120px":"100px"},this.initBanNiang()},methods:{hoverGoHome(){this.messages.message=this.messages.home},hoverChangeTheme(){this.messages.message=this.messages.theme},hoverMoreInfo(){this.messages.message="想知道关于我的更多信息吗？"},hoverCloseBanNiang(){this.messages.message=this.messages.close},resetMessage(){this.messages.message=this.messages.welocme},goHome(){"/"!==this.$route.path&&this.$router.push("/")},changeTheme(){const n=[];for(var e=0;e<this.myTheme.length;e++)this.myTheme[e]!=this.currentTheme&&n.push(this.myTheme[e]);const t=Math.floor(Math.random()*(this.myTheme.length-1));this.currentTheme=n[t],this.initBanNiang()},closeBanNiang(){this.isLoaded=!1,this.displayBanNiang=!0},showBanNiang(){this.isLoaded=!0,this.displayBanNiang=!1,this.initBanNiang()},initBanNiang(){if(-1===this.themeName.indexOf(this.currentTheme))return console.log("@vuepress-reco/vuepress-plugin-kan-ban-niang不支持主题"+this.currentTheme+", 请检查主题名, 或前往https://vuepress-theme-reco.recoluan.com/views/plugins/kanbanniang.html 查看支持的主题"),void(document.querySelector(".kanbanniang").style.display="none");if(!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent))return this.isLoaded=!1,console.log("mobile do not load model");if(!window.loadlive2d){const n=document.createElement("script");n.innerHTML='!function(t){function i(r){if(e[r])return e[r].exports;var o=e[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,i),o.l=!0,o.exports}var e={};i.m=t,i.c=e,i.d=function(t,e,r){i.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:r})},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,"a",e),e},i.o=function(t,i){return Object.prototype.hasOwnProperty.call(t,i)},i.p="",i(i.s=4)}([function(t,i,e){"use strict";function r(){this.live2DModel=null,this.modelMatrix=null,this.eyeBlink=null,this.physics=null,this.pose=null,this.debugMode=!1,this.initialized=!1,this.updating=!1,this.alpha=1,this.accAlpha=0,this.lipSync=!1,this.lipSyncValue=0,this.accelX=0,this.accelY=0,this.accelZ=0,this.dragX=0,this.dragY=0,this.startTimeMSec=null,this.mainMotionManager=new h,this.expressionManager=new h,this.motions={},this.expressions={},this.isTexLoaded=!1}function o(){AMotion.prototype.constructor.call(this),this.paramList=new Array}function n(){this.id="",this.type=-1,this.value=null}function s(){this.nextBlinkTime=null,this.stateStartTime=null,this.blinkIntervalMsec=null,this.eyeState=g.STATE_FIRST,this.blinkIntervalMsec=4e3,this.closingMotionMsec=100,this.closedMotionMsec=50,this.openingMotionMsec=150,this.closeIfZero=!0,this.eyeID_L="PARAM_EYE_L_OPEN",this.eyeID_R="PARAM_EYE_R_OPEN"}function _(){this.tr=new Float32Array(16),this.identity()}function a(t,i){_.prototype.constructor.call(this),this.width=t,this.height=i}function h(){MotionQueueManager.prototype.constructor.call(this),this.currentPriority=null,this.reservePriority=null,this.super=MotionQueueManager.prototype}function l(){this.physicsList=new Array,this.startTimeMSec=UtSystem.getUserTimeMSec()}function $(){this.lastTime=0,this.lastModel=null,this.partsGroups=new Array}function u(t){this.paramIndex=-1,this.partsIndex=-1,this.link=null,this.id=t}function p(){this.EPSILON=.01,this.faceTargetX=0,this.faceTargetY=0,this.faceX=0,this.faceY=0,this.faceVX=0,this.faceVY=0,this.lastTimeSec=0}function f(){_.prototype.constructor.call(this),this.screenLeft=null,this.screenRight=null,this.screenTop=null,this.screenBottom=null,this.maxLeft=null,this.maxRight=null,this.maxTop=null,this.maxBottom=null,this.max=Number.MAX_VALUE,this.min=0}function c(){}var d=0;r.prototype.getModelMatrix=function(){return this.modelMatrix},r.prototype.setAlpha=function(t){t>.999&&(t=1),t<.001&&(t=0),this.alpha=t},r.prototype.getAlpha=function(){return this.alpha},r.prototype.isInitialized=function(){return this.initialized},r.prototype.setInitialized=function(t){this.initialized=t},r.prototype.isUpdating=function(){return this.updating},r.prototype.setUpdating=function(t){this.updating=t},r.prototype.getLive2DModel=function(){return this.live2DModel},r.prototype.setLipSync=function(t){this.lipSync=t},r.prototype.setLipSyncValue=function(t){this.lipSyncValue=t},r.prototype.setAccel=function(t,i,e){this.accelX=t,this.accelY=i,this.accelZ=e},r.prototype.setDrag=function(t,i){this.dragX=t,this.dragY=i},r.prototype.getMainMotionManager=function(){return this.mainMotionManager},r.prototype.getExpressionManager=function(){return this.expressionManager},r.prototype.loadModelData=function(t,i){var e=c.getPlatformManager();this.debugMode&&e.log("Load model : "+t);var r=this;e.loadLive2DModel(t,function(t){if(r.live2DModel=t,r.live2DModel.saveParam(),0!=Live2D.getError())return void console.error("Error : Failed to loadModelData().");r.modelMatrix=new a(r.live2DModel.getCanvasWidth(),r.live2DModel.getCanvasHeight()),r.modelMatrix.setWidth(2),r.modelMatrix.setCenterPosition(0,0),i(r.live2DModel)})},r.prototype.loadTexture=function(t,i,e){d++;var r=c.getPlatformManager();this.debugMode&&r.log("Load Texture : "+i);var o=this;r.loadTexture(this.live2DModel,t,i,function(){d--,0==d&&(o.isTexLoaded=!0),"function"==typeof e&&e()})},r.prototype.loadMotion=function(t,i,e){var r=c.getPlatformManager();this.debugMode&&r.log("Load Motion : "+i);var o=null,n=this;r.loadBytes(i,function(i){o=Live2DMotion.loadMotion(i),null!=t&&(n.motions[t]=o),e(o)})},r.prototype.loadExpression=function(t,i,e){var r=c.getPlatformManager();this.debugMode&&r.log("Load Expression : "+i);var n=this;r.loadBytes(i,function(i){null!=t&&(n.expressions[t]=o.loadJson(i)),"function"==typeof e&&e()})},r.prototype.loadPose=function(t,i){var e=c.getPlatformManager();this.debugMode&&e.log("Load Pose : "+t);var r=this;try{e.loadBytes(t,function(t){r.pose=$.load(t),"function"==typeof i&&i()})}catch(t){console.warn(t)}},r.prototype.loadPhysics=function(t){var i=c.getPlatformManager();this.debugMode&&i.log("Load Physics : "+t);var e=this;try{i.loadBytes(t,function(t){e.physics=l.load(t)})}catch(t){console.warn(t)}},r.prototype.hitTestSimple=function(t,i,e){if(null===this.live2DModel)return!1;var r=this.live2DModel.getDrawDataIndex(t);if(r<0)return!1;for(var o=this.live2DModel.getTransformedPoints(r),n=this.live2DModel.getCanvasWidth(),s=0,_=this.live2DModel.getCanvasHeight(),a=0,h=0;h<o.length;h+=2){var l=o[h],$=o[h+1];l<n&&(n=l),l>s&&(s=l),$<_&&(_=$),$>a&&(a=$)}var u=this.modelMatrix.invertTransformX(i),p=this.modelMatrix.invertTransformY(e);return n<=u&&u<=s&&_<=p&&p<=a},r.prototype.hitTestSimpleCustom=function(t,i,e,r){return null!==this.live2DModel&&t&&(e>=t[0]&&e<=i[0]&&r<=t[1]&&r>=i[1])},o.prototype=new AMotion,o.EXPRESSION_DEFAULT="DEFAULT",o.TYPE_SET=0,o.TYPE_ADD=1,o.TYPE_MULT=2,o.loadJson=function(t){var i=new o,e=c.getPlatformManager(),r=e.jsonParseFromBytes(t);if(i.setFadeIn(parseInt(r.fade_in)>0?parseInt(r.fade_in):1e3),i.setFadeOut(parseInt(r.fade_out)>0?parseInt(r.fade_out):1e3),null==r.params)return i;var s=r.params,_=s.length;i.paramList=[];for(var a=0;a<_;a++){var h=s[a],l=h.id.toString(),$=parseFloat(h.val),u=o.TYPE_ADD,p=null!=h.calc?h.calc.toString():"add";if((u="add"===p?o.TYPE_ADD:"mult"===p?o.TYPE_MULT:"set"===p?o.TYPE_SET:o.TYPE_ADD)==o.TYPE_ADD){var f=null==h.def?0:parseFloat(h.def);$-=f}else if(u==o.TYPE_MULT){var f=null==h.def?1:parseFloat(h.def);0==f&&(f=1),$/=f}var d=new n;d.id=l,d.type=u,d.value=$,i.paramList.push(d)}return i},o.prototype.updateParamExe=function(t,i,e,r){for(var n=this.paramList.length-1;n>=0;--n){var s=this.paramList[n];s.type==o.TYPE_ADD?t.addToParamFloat(s.id,s.value,e):s.type==o.TYPE_MULT?t.multParamFloat(s.id,s.value,e):s.type==o.TYPE_SET&&t.setParamFloat(s.id,s.value,e)}},s.prototype.calcNextBlink=function(){return UtSystem.getUserTimeMSec()+Math.random()*(2*this.blinkIntervalMsec-1)},s.prototype.setInterval=function(t){this.blinkIntervalMsec=t},s.prototype.setEyeMotion=function(t,i,e){this.closingMotionMsec=t,this.closedMotionMsec=i,this.openingMotionMsec=e},s.prototype.updateParam=function(t){var i,e=UtSystem.getUserTimeMSec(),r=0;switch(this.eyeState){case g.STATE_CLOSING:r=(e-this.stateStartTime)/this.closingMotionMsec,r>=1&&(r=1,this.eyeState=g.STATE_CLOSED,this.stateStartTime=e),i=1-r;break;case g.STATE_CLOSED:r=(e-this.stateStartTime)/this.closedMotionMsec,r>=1&&(this.eyeState=g.STATE_OPENING,this.stateStartTime=e),i=0;break;case g.STATE_OPENING:r=(e-this.stateStartTime)/this.openingMotionMsec,r>=1&&(r=1,this.eyeState=g.STATE_INTERVAL,this.nextBlinkTime=this.calcNextBlink()),i=r;break;case g.STATE_INTERVAL:this.nextBlinkTime<e&&(this.eyeState=g.STATE_CLOSING,this.stateStartTime=e),i=1;break;case g.STATE_FIRST:default:this.eyeState=g.STATE_INTERVAL,this.nextBlinkTime=this.calcNextBlink(),i=1}this.closeIfZero||(i=-i),t.setParamFloat(this.eyeID_L,i),t.setParamFloat(this.eyeID_R,i)};var g=function(){};g.STATE_FIRST="STATE_FIRST",g.STATE_INTERVAL="STATE_INTERVAL",g.STATE_CLOSING="STATE_CLOSING",g.STATE_CLOSED="STATE_CLOSED",g.STATE_OPENING="STATE_OPENING",_.mul=function(t,i,e){var r,o,n,s=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(r=0;r<4;r++)for(o=0;o<4;o++)for(n=0;n<4;n++)s[r+4*o]+=t[r+4*n]*i[n+4*o];for(r=0;r<16;r++)e[r]=s[r]},_.prototype.identity=function(){for(var t=0;t<16;t++)this.tr[t]=t%5==0?1:0},_.prototype.getArray=function(){return this.tr},_.prototype.getCopyMatrix=function(){return new Float32Array(this.tr)},_.prototype.setMatrix=function(t){if(null!=this.tr&&this.tr.length==this.tr.length)for(var i=0;i<16;i++)this.tr[i]=t[i]},_.prototype.getScaleX=function(){return this.tr[0]},_.prototype.getScaleY=function(){return this.tr[5]},_.prototype.transformX=function(t){return this.tr[0]*t+this.tr[12]},_.prototype.transformY=function(t){return this.tr[5]*t+this.tr[13]},_.prototype.invertTransformX=function(t){return(t-this.tr[12])/this.tr[0]},_.prototype.invertTransformY=function(t){return(t-this.tr[13])/this.tr[5]},_.prototype.multTranslate=function(t,i){var e=[1,0,0,0,0,1,0,0,0,0,1,0,t,i,0,1];_.mul(e,this.tr,this.tr)},_.prototype.translate=function(t,i){this.tr[12]=t,this.tr[13]=i},_.prototype.translateX=function(t){this.tr[12]=t},_.prototype.translateY=function(t){this.tr[13]=t},_.prototype.multScale=function(t,i){var e=[t,0,0,0,0,i,0,0,0,0,1,0,0,0,0,1];_.mul(e,this.tr,this.tr)},_.prototype.scale=function(t,i){this.tr[0]=t,this.tr[5]=i},a.prototype=new _,a.prototype.setPosition=function(t,i){this.translate(t,i)},a.prototype.setCenterPosition=function(t,i){var e=this.width*this.getScaleX(),r=this.height*this.getScaleY();this.translate(t-e/2,i-r/2)},a.prototype.top=function(t){this.setY(t)},a.prototype.bottom=function(t){var i=this.height*this.getScaleY();this.translateY(t-i)},a.prototype.left=function(t){this.setX(t)},a.prototype.right=function(t){var i=this.width*this.getScaleX();this.translateX(t-i)},a.prototype.centerX=function(t){var i=this.width*this.getScaleX();this.translateX(t-i/2)},a.prototype.centerY=function(t){var i=this.height*this.getScaleY();this.translateY(t-i/2)},a.prototype.setX=function(t){this.translateX(t)},a.prototype.setY=function(t){this.translateY(t)},a.prototype.setHeight=function(t){var i=t/this.height,e=-i;this.scale(i,e)},a.prototype.setWidth=function(t){var i=t/this.width,e=-i;this.scale(i,e)},h.prototype=new MotionQueueManager,h.prototype.getCurrentPriority=function(){return this.currentPriority},h.prototype.getReservePriority=function(){return this.reservePriority},h.prototype.reserveMotion=function(t){return!(this.reservePriority>=t)&&(!(this.currentPriority>=t)&&(this.reservePriority=t,!0))},h.prototype.setReservePriority=function(t){this.reservePriority=t},h.prototype.updateParam=function(t){var i=MotionQueueManager.prototype.updateParam.call(this,t);return this.isFinished()&&(this.currentPriority=0),i},h.prototype.startMotionPrio=function(t,i){return i==this.reservePriority&&(this.reservePriority=0),this.currentPriority=i,this.startMotion(t,!1)},l.load=function(t){for(var i=new l,e=c.getPlatformManager(),r=e.jsonParseFromBytes(t),o=r.physics_hair,n=o.length,s=0;s<n;s++){var _=o[s],a=new PhysicsHair,h=_.setup,$=parseFloat(h.length),u=parseFloat(h.regist),p=parseFloat(h.mass);a.setup($,u,p);for(var f=_.src,d=f.length,g=0;g<d;g++){var y=f[g],m=y.id,T=PhysicsHair.Src.SRC_TO_X,P=y.ptype;"x"===P?T=PhysicsHair.Src.SRC_TO_X:"y"===P?T=PhysicsHair.Src.SRC_TO_Y:"angle"===P?T=PhysicsHair.Src.SRC_TO_G_ANGLE:UtDebug.error("live2d","Invalid parameter:PhysicsHair.Src");var S=parseFloat(y.scale),v=parseFloat(y.weight);a.addSrcParam(T,m,S,v)}for(var L=_.targets,M=L.length,g=0;g<M;g++){var E=L[g],m=E.id,T=PhysicsHair.Target.TARGET_FROM_ANGLE,P=E.ptype;"angle"===P?T=PhysicsHair.Target.TARGET_FROM_ANGLE:"angle_v"===P?T=PhysicsHair.Target.TARGET_FROM_ANGLE_V:UtDebug.error("live2d","Invalid parameter:PhysicsHair.Target");var S=parseFloat(E.scale),v=parseFloat(E.weight);a.addTargetParam(T,m,S,v)}i.physicsList.push(a)}return i},l.prototype.updateParam=function(t){for(var i=UtSystem.getUserTimeMSec()-this.startTimeMSec,e=0;e<this.physicsList.length;e++)this.physicsList[e].update(t,i)},$.load=function(t){for(var i=new $,e=c.getPlatformManager(),r=e.jsonParseFromBytes(t),o=r.parts_visible,n=o.length,s=0;s<n;s++){for(var _=o[s],a=_.group,h=a.length,l=new Array,p=0;p<h;p++){var f=a[p],d=new u(f.id);if(l[p]=d,null!=f.link){var g=f.link,y=g.length;d.link=new Array;for(var m=0;m<y;m++){var T=new u(g[m]);d.link.push(T)}}}i.partsGroups.push(l)}return i},$.prototype.updateParam=function(t){if(null!=t){t!=this.lastModel&&this.initParam(t),this.lastModel=t;var i=UtSystem.getUserTimeMSec(),e=0==this.lastTime?0:(i-this.lastTime)/1e3;this.lastTime=i,e<0&&(e=0);for(var r=0;r<this.partsGroups.length;r++)this.normalizePartsOpacityGroup(t,this.partsGroups[r],e),this.copyOpacityOtherParts(t,this.partsGroups[r])}},$.prototype.initParam=function(t){if(null!=t)for(var i=0;i<this.partsGroups.length;i++)for(var e=this.partsGroups[i],r=0;r<e.length;r++){e[r].initIndex(t);var o=e[r].partsIndex,n=e[r].paramIndex;if(!(o<0)){var s=0!=t.getParamFloat(n);if(t.setPartsOpacity(o,s?1:0),t.setParamFloat(n,s?1:0),null!=e[r].link)for(var _=0;_<e[r].link.length;_++)e[r].link[_].initIndex(t)}}},$.prototype.normalizePartsOpacityGroup=function(t,i,e){for(var r=-1,o=1,n=0;n<i.length;n++){var s=i[n].partsIndex,_=i[n].paramIndex;if(!(s<0)&&0!=t.getParamFloat(_)){if(r>=0)break;r=n,o=t.getPartsOpacity(s),o+=e/.5,o>1&&(o=1)}}r<0&&(r=0,o=1);for(var n=0;n<i.length;n++){var s=i[n].partsIndex;if(!(s<0))if(r==n)t.setPartsOpacity(s,o);else{var a,h=t.getPartsOpacity(s);a=o<.5?-.5*o/.5+1:.5*(1-o)/.5;var l=(1-a)*(1-o);l>.15&&(a=1-.15/(1-o)),h>a&&(h=a),t.setPartsOpacity(s,h)}}},$.prototype.copyOpacityOtherParts=function(t,i){for(var e=0;e<i.length;e++){var r=i[e];if(null!=r.link&&!(r.partsIndex<0))for(var o=t.getPartsOpacity(r.partsIndex),n=0;n<r.link.length;n++){var s=r.link[n];s.partsIndex<0||t.setPartsOpacity(s.partsIndex,o)}}},u.prototype.initIndex=function(t){this.paramIndex=t.getParamIndex("VISIBLE:"+this.id),this.partsIndex=t.getPartsDataIndex(PartsDataID.getID(this.id)),t.setParamFloat(this.paramIndex,1)},p.FRAME_RATE=30,p.prototype.setPoint=function(t,i){this.faceTargetX=t,this.faceTargetY=i},p.prototype.getX=function(){return this.faceX},p.prototype.getY=function(){return this.faceY},p.prototype.update=function(){var t=40/7.5/p.FRAME_RATE;if(0==this.lastTimeSec)return void(this.lastTimeSec=UtSystem.getUserTimeMSec());var i=UtSystem.getUserTimeMSec(),e=(i-this.lastTimeSec)*p.FRAME_RATE/1e3;this.lastTimeSec=i;var r=.15*p.FRAME_RATE,o=e*t/r,n=this.faceTargetX-this.faceX,s=this.faceTargetY-this.faceY;if(!(Math.abs(n)<=this.EPSILON&&Math.abs(s)<=this.EPSILON)){var _=Math.sqrt(n*n+s*s),a=t*n/_,h=t*s/_,l=a-this.faceVX,$=h-this.faceVY,u=Math.sqrt(l*l+$*$);(u<-o||u>o)&&(l*=o/u,$*=o/u,u=o),this.faceVX+=l,this.faceVY+=$;var f=.5*(Math.sqrt(o*o+16*o*_-8*o*_)-o),c=Math.sqrt(this.faceVX*this.faceVX+this.faceVY*this.faceVY);c>f&&(this.faceVX*=f/c,this.faceVY*=f/c),this.faceX+=this.faceVX,this.faceY+=this.faceVY}},f.prototype=new _,f.prototype.getMaxScale=function(){return this.max},f.prototype.getMinScale=function(){return this.min},f.prototype.setMaxScale=function(t){this.max=t},f.prototype.setMinScale=function(t){this.min=t},f.prototype.isMaxScale=function(){return this.getScaleX()==this.max},f.prototype.isMinScale=function(){return this.getScaleX()==this.min},f.prototype.adjustTranslate=function(t,i){this.tr[0]*this.maxLeft+(this.tr[12]+t)>this.screenLeft&&(t=this.screenLeft-this.tr[0]*this.maxLeft-this.tr[12]),this.tr[0]*this.maxRight+(this.tr[12]+t)<this.screenRight&&(t=this.screenRight-this.tr[0]*this.maxRight-this.tr[12]),this.tr[5]*this.maxTop+(this.tr[13]+i)<this.screenTop&&(i=this.screenTop-this.tr[5]*this.maxTop-this.tr[13]),this.tr[5]*this.maxBottom+(this.tr[13]+i)>this.screenBottom&&(i=this.screenBottom-this.tr[5]*this.maxBottom-this.tr[13]);var e=[1,0,0,0,0,1,0,0,0,0,1,0,t,i,0,1];_.mul(e,this.tr,this.tr)},f.prototype.adjustScale=function(t,i,e){var r=e*this.tr[0];r<this.min?this.tr[0]>0&&(e=this.min/this.tr[0]):r>this.max&&this.tr[0]>0&&(e=this.max/this.tr[0]);var o=[1,0,0,0,0,1,0,0,0,0,1,0,t,i,0,1],n=[e,0,0,0,0,e,0,0,0,0,1,0,0,0,0,1],s=[1,0,0,0,0,1,0,0,0,0,1,0,-t,-i,0,1];_.mul(s,this.tr,this.tr),_.mul(n,this.tr,this.tr),_.mul(o,this.tr,this.tr)},f.prototype.setScreenRect=function(t,i,e,r){this.screenLeft=t,this.screenRight=i,this.screenTop=r,this.screenBottom=e},f.prototype.setMaxScreenRect=function(t,i,e,r){this.maxLeft=t,this.maxRight=i,this.maxTop=r,this.maxBottom=e},f.prototype.getScreenLeft=function(){return this.screenLeft},f.prototype.getScreenRight=function(){return this.screenRight},f.prototype.getScreenBottom=function(){return this.screenBottom},f.prototype.getScreenTop=function(){return this.screenTop},f.prototype.getMaxLeft=function(){return this.maxLeft},f.prototype.getMaxRight=function(){return this.maxRight},f.prototype.getMaxBottom=function(){return this.maxBottom},f.prototype.getMaxTop=function(){return this.maxTop},c.platformManager=null,c.getPlatformManager=function(){return c.platformManager},c.setPlatformManager=function(t){c.platformManager=t},t.exports={L2DTargetPoint:p,Live2DFramework:c,L2DViewMatrix:f,L2DPose:$,L2DPartsParam:u,L2DPhysics:l,L2DMotionManager:h,L2DModelMatrix:a,L2DMatrix44:_,EYE_STATE:g,L2DEyeBlink:s,L2DExpressionParam:n,L2DExpressionMotion:o,L2DBaseModel:r}},function(t,i,e){"use strict";var r={DEBUG_LOG:!1,DEBUG_MOUSE_LOG:!1,DEBUG_DRAW_HIT_AREA:!1,DEBUG_DRAW_ALPHA_MODEL:!1,VIEW_MAX_SCALE:2,VIEW_MIN_SCALE:.8,VIEW_LOGICAL_LEFT:-1,VIEW_LOGICAL_RIGHT:1,VIEW_LOGICAL_MAX_LEFT:-2,VIEW_LOGICAL_MAX_RIGHT:2,VIEW_LOGICAL_MAX_BOTTOM:-2,VIEW_LOGICAL_MAX_TOP:2,PRIORITY_NONE:0,PRIORITY_IDLE:1,PRIORITY_SLEEPY:2,PRIORITY_NORMAL:3,PRIORITY_FORCE:4,MOTION_GROUP_IDLE:"idle",MOTION_GROUP_SLEEPY:"sleepy",MOTION_GROUP_TAP_BODY:"tap_body",MOTION_GROUP_FLICK_HEAD:"flick_head",MOTION_GROUP_PINCH_IN:"pinch_in",MOTION_GROUP_PINCH_OUT:"pinch_out",MOTION_GROUP_SHAKE:"shake",HIT_AREA_HEAD:"head",HIT_AREA_BODY:"body"};t.exports=r},function(t,i,e){"use strict";function r(t){n=t}function o(){return n}Object.defineProperty(i,"__esModule",{value:!0}),i.setContext=r,i.getContext=o;var n=void 0},function(t,i,e){"use strict";function r(){}r.matrixStack=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],r.depth=0,r.currentMatrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],r.tmp=new Array(16),r.reset=function(){this.depth=0},r.loadIdentity=function(){for(var t=0;t<16;t++)this.currentMatrix[t]=t%5==0?1:0},r.push=function(){var t=(this.depth,16*(this.depth+1));this.matrixStack.length<t+16&&(this.matrixStack.length=t+16);for(var i=0;i<16;i++)this.matrixStack[t+i]=this.currentMatrix[i];this.depth++},r.pop=function(){--this.depth<0&&(myError("Invalid matrix stack."),this.depth=0);for(var t=16*this.depth,i=0;i<16;i++)this.currentMatrix[i]=this.matrixStack[t+i]},r.getMatrix=function(){return this.currentMatrix},r.multMatrix=function(t){var i,e,r;for(i=0;i<16;i++)this.tmp[i]=0;for(i=0;i<4;i++)for(e=0;e<4;e++)for(r=0;r<4;r++)this.tmp[i+4*e]+=this.currentMatrix[i+4*r]*t[r+4*e];for(i=0;i<16;i++)this.currentMatrix[i]=this.tmp[i]},t.exports=r},function(t,i,e){t.exports=e(5)},function(t,i,e){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t){C=document.getElementById(t),C.addEventListener&&(window.addEventListener("click",g),window.addEventListener("mousedown",g),window.addEventListener("mousemove",g),window.addEventListener("mouseup",g),document.addEventListener("mouseout",g),window.addEventListener("touchstart",y),window.addEventListener("touchend",y),window.addEventListener("touchmove",y))}function n(t){var i=C.width,e=C.height;N=new M.L2DTargetPoint;var r=e/i,o=w.default.VIEW_LOGICAL_LEFT,n=w.default.VIEW_LOGICAL_RIGHT,_=-r,h=r;if(window.Live2D.captureFrame=!1,B=new M.L2DViewMatrix,B.setScreenRect(o,n,_,h),B.setMaxScreenRect(w.default.VIEW_LOGICAL_MAX_LEFT,w.default.VIEW_LOGICAL_MAX_RIGHT,w.default.VIEW_LOGICAL_MAX_BOTTOM,w.default.VIEW_LOGICAL_MAX_TOP),B.setMaxScale(w.default.VIEW_MAX_SCALE),B.setMinScale(w.default.VIEW_MIN_SCALE),U=new M.L2DMatrix44,U.multScale(1,i/e),G=new M.L2DMatrix44,G.multTranslate(-i/2,-e/2),G.multScale(2/i,-2/i),F=v(),(0,D.setContext)(F),!F)return console.error("Failed to create WebGL context."),void(window.WebGLRenderingContext&&console.error("Your browser don\'t support WebGL, check https://get.webgl.org/ for futher information."));window.Live2D.setGL(F),F.clearColor(0,0,0,0),a(t),s()}function s(){b||(b=!0,function t(){_();var i=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;if(window.Live2D.captureFrame){window.Live2D.captureFrame=!1;var e=document.createElement("a");document.body.appendChild(e),e.setAttribute("type","hidden"),e.href=C.toDataURL(),e.download=window.Live2D.captureName||"live2d.png",e.click()}i(t,C)}())}function _(){O.default.reset(),O.default.loadIdentity(),N.update(),R.setDrag(N.getX(),N.getY()),F.clear(F.COLOR_BUFFER_BIT),O.default.multMatrix(U.getArray()),O.default.multMatrix(B.getArray()),O.default.push();for(var t=0;t<R.numModels();t++){var i=R.getModel(t);if(null==i)return;i.initialized&&!i.updating&&(i.update(),i.draw(F))}O.default.pop()}function a(t){R.reloadFlg=!0,R.count++,R.changeModel(F,t)}function h(t,i){return t.x*i.x+t.y*i.y}function l(t,i){var e=Math.sqrt(t*t+i*i);return{x:t/e,y:i/e}}function $(t,i,e){function r(t,i){return 180*Math.acos(h({x:0,y:1},l(t,i)))/Math.PI}if(i.x<e.left+e.width&&i.y<e.top+e.height&&i.x>e.left&&i.y>e.top)return i;var o=t.x-i.x,n=t.y-i.y,s=r(o,n);i.x<t.x&&(s=360-s);var _=360-r(e.left-t.x,-1*(e.top-t.y)),a=360-r(e.left-t.x,-1*(e.top+e.height-t.y)),$=r(e.left+e.width-t.x,-1*(e.top-t.y)),u=r(e.left+e.width-t.x,-1*(e.top+e.height-t.y)),p=n/o,f={};if(s<$){var c=e.top-t.y,d=c/p;f={y:t.y+c,x:t.x+d}}else if(s<u){var g=e.left+e.width-t.x,y=g*p;f={y:t.y+y,x:t.x+g}}else if(s<a){var m=e.top+e.height-t.y,T=m/p;f={y:t.y+m,x:t.x+T}}else if(s<_){var P=t.x-e.left,S=P*p;f={y:t.y-S,x:t.x-P}}else{var v=e.top-t.y,L=v/p;f={y:t.y+v,x:t.x+L}}return f}function u(t){Y=!0;var i=C.getBoundingClientRect(),e=P(t.clientX-i.left),r=S(t.clientY-i.top),o=$({x:i.left+i.width/2,y:i.top+i.height*X},{x:t.clientX,y:t.clientY},i),n=m(o.x-i.left),s=T(o.y-i.top);w.default.DEBUG_MOUSE_LOG&&console.log("onMouseMove device( x:"+t.clientX+" y:"+t.clientY+" ) view( x:"+n+" y:"+s+")"),k=e,V=r,N.setPoint(n,s)}function p(t){Y=!0;var i=C.getBoundingClientRect(),e=P(t.clientX-i.left),r=S(t.clientY-i.top),o=$({x:i.left+i.width/2,y:i.top+i.height*X},{x:t.clientX,y:t.clientY},i),n=m(o.x-i.left),s=T(o.y-i.top);w.default.DEBUG_MOUSE_LOG&&console.log("onMouseDown device( x:"+t.clientX+" y:"+t.clientY+" ) view( x:"+n+" y:"+s+")"),k=e,V=r,R.tapEvent(n,s)}function f(t){var i=C.getBoundingClientRect(),e=P(t.clientX-i.left),r=S(t.clientY-i.top),o=$({x:i.left+i.width/2,y:i.top+i.height*X},{x:t.clientX,y:t.clientY},i),n=m(o.x-i.left),s=T(o.y-i.top);w.default.DEBUG_MOUSE_LOG&&console.log("onMouseMove device( x:"+t.clientX+" y:"+t.clientY+" ) view( x:"+n+" y:"+s+")"),Y&&(k=e,V=r,N.setPoint(n,s))}function c(){Y&&(Y=!1),N.setPoint(0,0)}function d(){w.default.DEBUG_LOG&&console.log("Set Session Storage."),sessionStorage.setItem("Sleepy","1")}function g(t){if("mousewheel"==t.type);else if("mousedown"==t.type)p(t);else if("mousemove"==t.type){var i=sessionStorage.getItem("Sleepy");"1"===i&&sessionStorage.setItem("Sleepy","0"),u(t)}else if("mouseup"==t.type){if("button"in t&&0!=t.button)return}else if("mouseout"==t.type){w.default.DEBUG_LOG&&console.log("Mouse out Window."),c();var e=sessionStorage.getItem("SleepyTimer");window.clearTimeout(e),e=window.setTimeout(d,5e4),sessionStorage.setItem("SleepyTimer",e)}}function y(t){var i=t.touches[0];"touchstart"==t.type?1==t.touches.length&&u(i):"touchmove"==t.type?f(i):"touchend"==t.type&&c()}function m(t){var i=G.transformX(t);return B.invertTransformX(i)}function T(t){var i=G.transformY(t);return B.invertTransformY(i)}function P(t){return G.transformX(t)}function S(t){return G.transformY(t)}function v(){for(var t=["webgl","experimental-webgl","webkit-3d","moz-webgl"],i=0;i<t.length;i++)try{var e=C.getContext(t[i],{premultipliedAlpha:!0});if(e)return e}catch(t){}return null}function L(t,i,e){X=void 0===e?.5:e,o(t),n(i)}e(6);var M=e(0),E=e(8),A=r(E),I=e(1),w=r(I),x=e(3),O=r(x),D=e(2),R=(window.navigator.platform.toLowerCase(),new A.default),b=!1,F=null,C=null,N=null,B=null,U=null,G=null,Y=!1,k=0,V=0,X=.5;window.loadlive2d=L},function(t,i,e){"use strict";(function(t){!function(){function i(){At||(this._$MT=null,this._$5S=null,this._$NP=0,i._$42++,this._$5S=new Y(this))}function e(t){if(!At){this.clipContextList=new Array,this.glcontext=t.gl,this.dp_webgl=t,this.curFrameNo=0,this.firstError_clipInNotUpdate=!0,this.colorBuffer=0,this.isInitGLFBFunc=!1,this.tmpBoundsOnModel=new S,at.glContext.length>at.frameBuffers.length&&(this.curFrameNo=this.getMaskRenderTexture()),this.tmpModelToViewMatrix=new R,this.tmpMatrix2=new R,this.tmpMatrixForMask=new R,this.tmpMatrixForDraw=new R,this.CHANNEL_COLORS=new Array;var i=new A;i=new A,i.r=0,i.g=0,i.b=0,i.a=1,this.CHANNEL_COLORS.push(i),i=new A,i.r=1,i.g=0,i.b=0,i.a=0,this.CHANNEL_COLORS.push(i),i=new A,i.r=0,i.g=1,i.b=0,i.a=0,this.CHANNEL_COLORS.push(i),i=new A,i.r=0,i.g=0,i.b=1,i.a=0,this.CHANNEL_COLORS.push(i);for(var e=0;e<this.CHANNEL_COLORS.length;e++)this.dp_webgl.setChannelFlagAsColor(e,this.CHANNEL_COLORS[e])}}function r(t,i,e){this.clipIDList=new Array,this.clipIDList=e,this.clippingMaskDrawIndexList=new Array;for(var r=0;r<e.length;r++)this.clippingMaskDrawIndexList.push(i.getDrawDataIndex(e[r]));this.clippedDrawContextList=new Array,this.isUsing=!0,this.layoutChannelNo=0,this.layoutBounds=new S,this.allClippedDrawRect=new S,this.matrixForMask=new Float32Array(16),this.matrixForDraw=new Float32Array(16),this.owner=t}function o(t,i){this._$gP=t,this.drawDataIndex=i}function n(){At||(this.color=null)}function s(){At||(this._$dP=null,this._$eo=null,this._$V0=null,this._$dP=1e3,this._$eo=1e3,this._$V0=1,this._$a0())}function _(){}function a(){this._$r=null,this._$0S=null}function h(){At||(this.x=null,this.y=null,this.width=null,this.height=null)}function l(t){At||et.prototype.constructor.call(this,t)}function $(){}function u(t){At||et.prototype.constructor.call(this,t)}function p(){At||(this._$vo=null,this._$F2=null,this._$ao=400,this._$1S=400,p._$42++)}function f(){At||(this.p1=new c,this.p2=new c,this._$Fo=0,this._$Db=0,this._$L2=0,this._$M2=0,this._$ks=0,this._$9b=0,this._$iP=0,this._$iT=0,this._$lL=new Array,this._$qP=new Array,this.setup(.3,.5,.1))}function c(){this._$p=1,this.x=0,this.y=0,this.vx=0,this.vy=0,this.ax=0,this.ay=0,this.fx=0,this.fy=0,this._$s0=0,this._$70=0,this._$7L=0,this._$HL=0}function d(t,i,e){this._$wL=null,this.scale=null,this._$V0=null,this._$wL=t,this.scale=i,this._$V0=e}function g(t,i,e,r){d.prototype.constructor.call(this,i,e,r),this._$tL=null,this._$tL=t}function y(t,i,e){this._$wL=null,this.scale=null,this._$V0=null,this._$wL=t,this.scale=i,this._$V0=e}function T(t,i,e,r){y.prototype.constructor.call(this,i,e,r),this._$YP=null,this._$YP=t}function P(){At||(this._$fL=0,this._$gL=0,this._$B0=1,this._$z0=1,this._$qT=0,this.reflectX=!1,this.reflectY=!1)}function S(){At||(this.x=null,this.y=null,this.width=null,this.height=null)}function v(){}function L(){At||(this.x=null,this.y=null)}function M(){At||(this._$gP=null,this._$dr=null,this._$GS=null,this._$qb=null,this._$Lb=null,this._$mS=null,this.clipID=null,this.clipIDList=new Array)}function E(){At||(this._$Eb=E._$ps,this._$lT=1,this._$C0=1,this._$tT=1,this._$WL=1,this.culling=!1,this.matrix4x4=new Float32Array(16),this.premultipliedAlpha=!1,this.anisotropy=0,this.clippingProcess=E.CLIPPING_PROCESS_NONE,this.clipBufPre_clipContextMask=null,this.clipBufPre_clipContextDraw=null,this.CHANNEL_COLORS=new Array)}function A(){At||(this.a=1,this.r=1,this.g=1,this.b=1,this.scale=1,this._$ho=1,this.blendMode=at.L2D_COLOR_BLEND_MODE_MULT)}function I(){At||(this._$kP=null,this._$dr=null,this._$Ai=!0,this._$mS=null)}function w(){}function x(){At||(this._$VP=0,this._$wL=null,this._$GP=null,this._$8o=x._$ds,this._$2r=-1,this._$O2=0,this._$ri=0)}function O(){}function D(){At||(this._$Ob=null)}function R(){this.m=new Float32Array(16),this.identity()}function b(t){At||et.prototype.constructor.call(this,t)}function F(){At||(this._$7=1,this._$f=0,this._$H=0,this._$g=1,this._$k=0,this._$w=0,this._$hi=STATE_IDENTITY,this._$Z=_$pS)}function C(){At||(s.prototype.constructor.call(this),this.motions=new Array,this._$7r=null,this._$7r=C._$Co++,this._$D0=30,this._$yT=0,this._$E=!0,this.loopFadeIn=!0,this._$AS=-1,_$a0())}function N(){this._$P=new Float32Array(100),this.size=0}function B(){this._$4P=null,this._$I0=null,this._$RP=null}function U(){}function G(){}function Y(t){At||(this._$QT=!0,this._$co=-1,this._$qo=0,this._$pb=new Array(Y._$is),this._$_2=new Float32Array(Y._$is),this._$vr=new Float32Array(Y._$is),this._$Rr=new Float32Array(Y._$is),this._$Or=new Float32Array(Y._$is),this._$fs=new Float32Array(Y._$is),this._$Js=new Array(Y._$is),this._$3S=new Array,this._$aS=new Array,this._$Bo=null,this._$F2=new Array,this._$db=new Array,this._$8b=new Array,this._$Hr=new Array,this._$Ws=null,this._$Vs=null,this._$Er=null,this._$Es=new Int16Array(U._$Qb),this._$ZP=new Float32Array(2*U._$1r),this._$Ri=t,this._$b0=Y._$HP++,this.clipManager=null,this.dp_webgl=null)}function k(){}function V(){At||(this._$12=null,this._$bb=null,this._$_L=null,this._$jo=null,this._$iL=null,this._$0L=null,this._$Br=null,this._$Dr=null,this._$Cb=null,this._$mr=null,this._$_L=wt.STATE_FIRST,this._$Br=4e3,this._$Dr=100,this._$Cb=50,this._$mr=150,this._$jo=!0,this._$iL="PARAM_EYE_L_OPEN",this._$0L="PARAM_EYE_R_OPEN")}function X(){At||(E.prototype.constructor.call(this),this._$sb=new Int32Array(X._$As),this._$U2=new Array,this.transform=null,this.gl=null,null==X._$NT&&(X._$NT=X._$9r(256),X._$vS=X._$9r(256),X._$no=X._$vb(256)))}function z(){At||(I.prototype.constructor.call(this),this._$GS=null,this._$Y0=null)}function H(t){_t.prototype.constructor.call(this,t),this._$8r=I._$ur,this._$Yr=null,this._$Wr=null}function W(){At||(M.prototype.constructor.call(this),this._$gP=null,this._$dr=null,this._$GS=null,this._$qb=null,this._$Lb=null,this._$mS=null)}function j(){At||(this._$NL=null,this._$3S=null,this._$aS=null,j._$42++)}function q(){At||(i.prototype.constructor.call(this),this._$zo=new X)}function J(){At||(s.prototype.constructor.call(this),this.motions=new Array,this._$o2=null,this._$7r=J._$Co++,this._$D0=30,this._$yT=0,this._$E=!1,this.loopFadeIn=!0,this._$rr=-1,this._$eP=0)}function Q(t,i){return String.fromCharCode(t.getUint8(i))}function N(){this._$P=new Float32Array(100),this.size=0}function B(){this._$4P=null,this._$I0=null,this._$RP=null}function Z(){At||(I.prototype.constructor.call(this),this._$o=0,this._$A=0,this._$GS=null,this._$Eo=null)}function K(t){_t.prototype.constructor.call(this,t),this._$8r=I._$ur,this._$Cr=null,this._$hr=null}function tt(){At||(this.visible=!0,this._$g0=!1,this._$NL=null,this._$3S=null,this._$aS=null,tt._$42++)}function it(t){this._$VS=null,this._$e0=null,this._$e0=t}function et(t){At||(this.id=t)}function rt(){}function ot(){At||(this._$4S=null)}function nt(t,i){this.canvas=t,this.context=i,this.viewport=new Array(0,0,t.width,t.height),this._$6r=1,this._$xP=0,this._$3r=1,this._$uP=0,this._$Qo=-1,this.cacheImages={}}function st(){At||(this._$TT=null,this._$LT=null,this._$FS=null,this._$wL=null)}function _t(t){At||(this._$e0=null,this._$IP=null,this._$JS=!1,this._$AT=!0,this._$e0=t,this.totalScale=1,this._$7s=1,this.totalOpacity=1)}function at(){}function ht(){}function lt(t){At||(this._$ib=t)}function $t(){At||(W.prototype.constructor.call(this),this._$LP=-1,this._$d0=0,this._$Yo=0,this._$JP=null,this._$5P=null,this._$BP=null,this._$Eo=null,this._$Qi=null,this._$6s=$t._$ms,this.culling=!0,this.gl_cacheImage=null,this.instanceNo=$t._$42++)}function ut(t){Mt.prototype.constructor.call(this,t),this._$8r=W._$ur,this._$Cr=null,this._$hr=null}function pt(){At||(this.x=null,this.y=null)}function ft(t){At||(i.prototype.constructor.call(this),this.drawParamWebGL=new mt(t),this.drawParamWebGL.setGL(at.getGL(t)))}function ct(){At||(this.motions=null,this._$eb=!1,this.motions=new Array)}function dt(){this._$w0=null,this._$AT=!0,this._$9L=!1,this._$z2=-1,this._$bs=-1,this._$Do=-1,this._$sr=null,this._$sr=dt._$Gs++}function gt(){this.m=new Array(1,0,0,0,1,0,0,0,1)}function yt(t){At||et.prototype.constructor.call(this,t)}function mt(t){At||(E.prototype.constructor.call(this),this.textures=new Array,this.transform=null,this.gl=null,this.glno=t,this.firstDraw=!0,this.anisotropyExt=null,this.maxAnisotropy=0,this._$As=32,this._$Gr=!1,this._$NT=null,this._$vS=null,this._$no=null,this.vertShader=null,this.fragShader=null,this.vertShaderOff=null,this.fragShaderOff=null)}function Tt(t,i,e){return null==i&&(i=t.createBuffer()),t.bindBuffer(t.ARRAY_BUFFER,i),t.bufferData(t.ARRAY_BUFFER,e,t.DYNAMIC_DRAW),i}function Pt(t,i,e){return null==i&&(i=t.createBuffer()),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,i),t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.DYNAMIC_DRAW),i}function St(t){At||(this._$P=new Int8Array(8),this._$R0=new DataView(this._$P.buffer),this._$3i=new Int8Array(1e3),this._$hL=0,this._$v0=0,this._$S2=0,this._$Ko=new Array,this._$T=t,this._$F=0)}function vt(){}function Lt(){}function Mt(t){At||(this._$e0=null,this._$IP=null,this._$Us=null,this._$7s=null,this._$IS=[!1],this._$VS=null,this._$AT=!0,this.baseOpacity=1,this.clipBufPre_clipContext=null,this._$e0=t)}function Et(){}var At=!0;i._$0s=1,i._$4s=2,i._$42=0,i._$62=function(t,e){try{if(e instanceof ArrayBuffer&&(e=new DataView(e)),!(e instanceof DataView))throw new lt("_$SS#loadModel(b) / b _$x be DataView or ArrayBuffer");var r,o=new St(e),n=o._$ST(),s=o._$ST(),a=o._$ST();if(109!=n||111!=s||99!=a)throw new lt("_$gi _$C _$li , _$Q0 _$P0.");if(r=o._$ST(),o._$gr(r),r>G._$T7){t._$NP|=i._$4s;throw new lt("_$gi _$C _$li , _$n0 _$_ version _$li ( SDK : "+G._$T7+" < _$f0 : "+r+" )@_$SS#loadModel()\\n")}var h=o._$nP();if(r>=G._$s7){var l=o._$9T(),$=o._$9T();if(-30584!=l||-30584!=$)throw t._$NP|=i._$0s,new lt("_$gi _$C _$li , _$0 _$6 _$Ui.")}t._$KS(h);var u=t.getModelContext();u.setDrawParam(t.getDrawParam()),u.init()}catch(t){_._$Rb(t)}},i.prototype._$KS=function(t){this._$MT=t},i.prototype.getModelImpl=function(){return null==this._$MT&&(this._$MT=new p,this._$MT._$zP()),this._$MT},i.prototype.getCanvasWidth=function(){return null==this._$MT?0:this._$MT.getCanvasWidth()},i.prototype.getCanvasHeight=function(){return null==this._$MT?0:this._$MT.getCanvasHeight()},i.prototype.getParamFloat=function(t){return"number"!=typeof t&&(t=this._$5S.getParamIndex(u.getID(t))),this._$5S.getParamFloat(t)},i.prototype.setParamFloat=function(t,i,e){"number"!=typeof t&&(t=this._$5S.getParamIndex(u.getID(t))),arguments.length<3&&(e=1),this._$5S.setParamFloat(t,this._$5S.getParamFloat(t)*(1-e)+i*e)},i.prototype.addToParamFloat=function(t,i,e){"number"!=typeof t&&(t=this._$5S.getParamIndex(u.getID(t))),arguments.length<3&&(e=1),this._$5S.setParamFloat(t,this._$5S.getParamFloat(t)+i*e)},i.prototype.multParamFloat=function(t,i,e){"number"!=typeof t&&(t=this._$5S.getParamIndex(u.getID(t))),arguments.length<3&&(e=1),this._$5S.setParamFloat(t,this._$5S.getParamFloat(t)*(1+(i-1)*e))},i.prototype.getParamIndex=function(t){return this._$5S.getParamIndex(u.getID(t))},i.prototype.loadParam=function(){this._$5S.loadParam()},i.prototype.saveParam=function(){this._$5S.saveParam()},i.prototype.init=function(){this._$5S.init()},i.prototype.update=function(){this._$5S.update()},i.prototype._$Rs=function(){return _._$li("_$60 _$PT _$Rs()"),-1},i.prototype._$Ds=function(t){_._$li("_$60 _$PT _$SS#_$Ds() \\n")},i.prototype._$K2=function(){},i.prototype.draw=function(){},i.prototype.getModelContext=function(){return this._$5S},i.prototype._$s2=function(){return this._$NP},i.prototype._$P7=function(t,i,e,r){var o=-1,n=0,s=this;if(0!=e)if(1==t.length){var _=t[0],a=0!=s.getParamFloat(_),h=i[0],l=s.getPartsOpacity(h),$=e/r;a?(l+=$)>1&&(l=1):(l-=$)<0&&(l=0),s.setPartsOpacity(h,l)}else{for(var u=0;u<t.length;u++){var _=t[u],p=0!=s.getParamFloat(_);if(p){if(o>=0)break;o=u;var h=i[u];n=s.getPartsOpacity(h),n+=e/r,n>1&&(n=1)}}o<0&&(console.log("No _$wi _$q0/ _$U default[%s]",t[0]),o=0,n=1,s.loadParam(),s.setParamFloat(t[o],n),s.saveParam());for(var u=0;u<t.length;u++){var h=i[u];if(o==u)s.setPartsOpacity(h,n);else{var f,c=s.getPartsOpacity(h);f=n<.5?-.5*n/.5+1:.5*(1-n)/.5;var d=(1-f)*(1-n);d>.15&&(f=1-.15/(1-n)),c>f&&(c=f),s.setPartsOpacity(h,c)}}}else for(var u=0;u<t.length;u++){var _=t[u],h=i[u],p=0!=s.getParamFloat(_);s.setPartsOpacity(h,p?1:0)}},i.prototype.setPartsOpacity=function(t,i){"number"!=typeof t&&(t=this._$5S.getPartsDataIndex(l.getID(t))),this._$5S.setPartsOpacity(t,i)},i.prototype.getPartsDataIndex=function(t){return t instanceof l||(t=l.getID(t)),this._$5S.getPartsDataIndex(t)},i.prototype.getPartsOpacity=function(t){return"number"!=typeof t&&(t=this._$5S.getPartsDataIndex(l.getID(t))),t<0?0:this._$5S.getPartsOpacity(t)},i.prototype.getDrawParam=function(){},i.prototype.getDrawDataIndex=function(t){return this._$5S.getDrawDataIndex(b.getID(t))},i.prototype.getDrawData=function(t){return this._$5S.getDrawData(t)},i.prototype.getTransformedPoints=function(t){var i=this._$5S._$C2(t);return i instanceof ut?i.getTransformedPoints():null},i.prototype.getIndexArray=function(t){if(t<0||t>=this._$5S._$aS.length)return null;var i=this._$5S._$aS[t];return null!=i&&i.getType()==W._$wb&&i instanceof $t?i.getIndexArray():null},e.CHANNEL_COUNT=4,e.RENDER_TEXTURE_USE_MIPMAP=!1,e.NOT_USED_FRAME=-100,e.prototype._$L7=function(){if(this.tmpModelToViewMatrix&&(this.tmpModelToViewMatrix=null),this.tmpMatrix2&&(this.tmpMatrix2=null),this.tmpMatrixForMask&&(this.tmpMatrixForMask=null),this.tmpMatrixForDraw&&(this.tmpMatrixForDraw=null),this.tmpBoundsOnModel&&(this.tmpBoundsOnModel=null),this.CHANNEL_COLORS){for(var t=this.CHANNEL_COLORS.length-1;t>=0;--t)this.CHANNEL_COLORS.splice(t,1);this.CHANNEL_COLORS=[]}this.releaseShader()},e.prototype.releaseShader=function(){for(var t=at.frameBuffers.length,i=0;i<t;i++)this.gl.deleteFramebuffer(at.frameBuffers[i].framebuffer);at.frameBuffers=[],at.glContext=[]},e.prototype.init=function(t,i,e){for(var o=0;o<i.length;o++){var n=i[o].getClipIDList();if(null!=n){var s=this.findSameClip(n);null==s&&(s=new r(this,t,n),this.clipContextList.push(s));var _=i[o].getDrawDataID(),a=t.getDrawDataIndex(_);s.addClippedDrawData(_,a);e[o].clipBufPre_clipContext=s}}},e.prototype.getMaskRenderTexture=function(){var t=null;return t=this.dp_webgl.createFramebuffer(),at.frameBuffers[this.dp_webgl.glno]=t,this.dp_webgl.glno},e.prototype.setupClip=function(t,i){for(var e=0,r=0;r<this.clipContextList.length;r++){var o=this.clipContextList[r];this.calcClippedDrawTotalBounds(t,o),o.isUsing&&e++}if(e>0){var n=i.gl.getParameter(i.gl.FRAMEBUFFER_BINDING),s=new Array(4);s[0]=0,s[1]=0,s[2]=i.gl.canvas.width,s[3]=i.gl.canvas.height,i.gl.viewport(0,0,at.clippingMaskBufferSize,at.clippingMaskBufferSize),this.setupLayoutBounds(e),i.gl.bindFramebuffer(i.gl.FRAMEBUFFER,at.frameBuffers[this.curFrameNo].framebuffer),i.gl.clearColor(0,0,0,0),i.gl.clear(i.gl.COLOR_BUFFER_BIT);for(var r=0;r<this.clipContextList.length;r++){var o=this.clipContextList[r],_=o.allClippedDrawRect,a=(o.layoutChannelNo,o.layoutBounds);this.tmpBoundsOnModel._$jL(_),this.tmpBoundsOnModel.expand(.05*_.width,.05*_.height);var h=a.width/this.tmpBoundsOnModel.width,l=a.height/this.tmpBoundsOnModel.height;this.tmpMatrix2.identity(),this.tmpMatrix2.translate(-1,-1,0),this.tmpMatrix2.scale(2,2,1),this.tmpMatrix2.translate(a.x,a.y,0),this.tmpMatrix2.scale(h,l,1),this.tmpMatrix2.translate(-this.tmpBoundsOnModel.x,-this.tmpBoundsOnModel.y,0),this.tmpMatrixForMask.setMatrix(this.tmpMatrix2.m),this.tmpMatrix2.identity(),this.tmpMatrix2.translate(a.x,a.y,0),this.tmpMatrix2.scale(h,l,1),this.tmpMatrix2.translate(-this.tmpBoundsOnModel.x,-this.tmpBoundsOnModel.y,0),this.tmpMatrixForDraw.setMatrix(this.tmpMatrix2.m);for(var $=this.tmpMatrixForMask.getArray(),u=0;u<16;u++)o.matrixForMask[u]=$[u];for(var p=this.tmpMatrixForDraw.getArray(),u=0;u<16;u++)o.matrixForDraw[u]=p[u];for(var f=o.clippingMaskDrawIndexList.length,c=0;c<f;c++){var d=o.clippingMaskDrawIndexList[c],g=t.getDrawData(d),y=t._$C2(d);i.setClipBufPre_clipContextForMask(o),g.draw(i,t,y)}}i.gl.bindFramebuffer(i.gl.FRAMEBUFFER,n),i.setClipBufPre_clipContextForMask(null),i.gl.viewport(s[0],s[1],s[2],s[3])}},e.prototype.getColorBuffer=function(){return this.colorBuffer},e.prototype.findSameClip=function(t){for(var i=0;i<this.clipContextList.length;i++){var e=this.clipContextList[i],r=e.clipIDList.length;if(r==t.length){for(var o=0,n=0;n<r;n++)for(var s=e.clipIDList[n],_=0;_<r;_++)if(t[_]==s){o++;break}if(o==r)return e}}return null},e.prototype.calcClippedDrawTotalBounds=function(t,i){for(var e=t._$Ri.getModelImpl().getCanvasWidth(),r=t._$Ri.getModelImpl().getCanvasHeight(),o=e>r?e:r,n=o,s=o,_=0,a=0,h=i.clippedDrawContextList.length,l=0;l<h;l++){var $=i.clippedDrawContextList[l],u=$.drawDataIndex,p=t._$C2(u);if(p._$yo()){for(var f=p.getTransformedPoints(),c=f.length,d=[],g=[],y=0,m=U._$i2;m<c;m+=U._$No)d[y]=f[m],g[y]=f[m+1],y++;var T=Math.min.apply(null,d),P=Math.min.apply(null,g),S=Math.max.apply(null,d),v=Math.max.apply(null,g);T<n&&(n=T),P<s&&(s=P),S>_&&(_=S),v>a&&(a=v)}}if(n==o)i.allClippedDrawRect.x=0,i.allClippedDrawRect.y=0,i.allClippedDrawRect.width=0,i.allClippedDrawRect.height=0,i.isUsing=!1;else{var L=_-n,M=a-s;i.allClippedDrawRect.x=n,i.allClippedDrawRect.y=s,i.allClippedDrawRect.width=L,i.allClippedDrawRect.height=M,i.isUsing=!0}},e.prototype.setupLayoutBounds=function(t){var i=t/e.CHANNEL_COUNT,r=t%e.CHANNEL_COUNT;i=~~i,r=~~r;for(var o=0,n=0;n<e.CHANNEL_COUNT;n++){var s=i+(n<r?1:0);if(0==s);else if(1==s){var a=this.clipContextList[o++];a.layoutChannelNo=n,a.layoutBounds.x=0,a.layoutBounds.y=0,a.layoutBounds.width=1,a.layoutBounds.height=1}else if(2==s)for(var h=0;h<s;h++){var l=h%2,$=0;l=~~l;var a=this.clipContextList[o++];a.layoutChannelNo=n,a.layoutBounds.x=.5*l,a.layoutBounds.y=0,a.layoutBounds.width=.5,a.layoutBounds.height=1}else if(s<=4)for(var h=0;h<s;h++){var l=h%2,$=h/2;l=~~l,$=~~$;var a=this.clipContextList[o++];a.layoutChannelNo=n,a.layoutBounds.x=.5*l,a.layoutBounds.y=.5*$,a.layoutBounds.width=.5,a.layoutBounds.height=.5}else if(s<=9)for(var h=0;h<s;h++){var l=h%3,$=h/3;l=~~l,$=~~$;var a=this.clipContextList[o++];a.layoutChannelNo=n,a.layoutBounds.x=l/3,a.layoutBounds.y=$/3,a.layoutBounds.width=1/3,a.layoutBounds.height=1/3}else _._$li("_$6 _$0P mask count : %d",s)}},r.prototype.addClippedDrawData=function(t,i){var e=new o(t,i);this.clippedDrawContextList.push(e)},s._$JT=function(t,i,e){var r=t/i,o=e/i,n=o,s=1-(1-o)*(1-o),_=1-(1-n)*(1-n),a=1/3*(1-o)*s+(n*(2/3)+1/3*(1-n))*(1-s),h=(n+2/3*(1-n))*_+(o*(1/3)+2/3*(1-o))*(1-_),l=1-3*h+3*a-0,$=3*h-6*a+0,u=3*a-0;if(r<=0)return 0;if(r>=1)return 1;var p=r,f=p*p;return l*(p*f)+$*f+u*p+0},s.prototype._$a0=function(){},s.prototype.setFadeIn=function(t){this._$dP=t},s.prototype.setFadeOut=function(t){this._$eo=t},s.prototype._$pT=function(t){this._$V0=t},s.prototype.getFadeOut=function(){return this._$eo},s.prototype._$4T=function(){return this._$eo},s.prototype._$mT=function(){return this._$V0},s.prototype.getDurationMSec=function(){return-1},s.prototype.getLoopDurationMSec=function(){return-1},s.prototype.updateParam=function(t,i){if(i._$AT&&!i._$9L){var e=w.getUserTimeMSec();if(i._$z2<0){i._$z2=e,i._$bs=e;var r=this.getDurationMSec();i._$Do<0&&(i._$Do=r<=0?-1:i._$z2+r)}var o=this._$V0;o=o*(0==this._$dP?1:ht._$r2((e-i._$bs)/this._$dP))*(0==this._$eo||i._$Do<0?1:ht._$r2((i._$Do-e)/this._$eo)),0<=o&&o<=1||console.log("### assert!! ### "),this.updateParamExe(t,e,o,i),i._$Do>0&&i._$Do<e&&(i._$9L=!0)}},s.prototype.updateParamExe=function(t,i,e,r){},_._$8s=0,_._$fT=new Object,_.start=function(t){var i=_._$fT[t];null==i&&(i=new a,i._$r=t,_._$fT[t]=i),i._$0S=w.getSystemTimeMSec()},_.dump=function(t){var i=_._$fT[t];if(null!=i){var e=w.getSystemTimeMSec(),r=e-i._$0S;return console.log(t+" : "+r+"ms"),r}return-1},_.end=function(t){var i=_._$fT[t];if(null!=i){return w.getSystemTimeMSec()-i._$0S}return-1},_._$li=function(t,i){console.log("_$li : "+t+"\\n",i)},_._$Ji=function(t,i){console.log(t,i)},_._$dL=function(t,i){console.log(t,i),console.log("\\n")},_._$KL=function(t,i){for(var e=0;e<i;e++)e%16==0&&e>0?console.log("\\n"):e%8==0&&e>0&&console.log("  "),console.log("%02X ",255&t[e]);console.log("\\n")},_._$nr=function(t,i,e){console.log("%s\\n",t);for(var r=i.length,o=0;o<r;++o)console.log("%5d",i[o]),console.log("%s\\n",e),console.log(",");console.log("\\n")},_._$Rb=function(t){console.log("dump exception : "+t),console.log("stack :: "+t.stack)},h.prototype._$8P=function(){return.5*(this.x+this.x+this.width)},h.prototype._$6P=function(){return.5*(this.y+this.y+this.height)},h.prototype._$EL=function(){return this.x+this.width},h.prototype._$5T=function(){return this.y+this.height},h.prototype._$jL=function(t,i,e,r){this.x=t,this.y=i,this.width=e,this.height=r},h.prototype._$jL=function(t){this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height},l.prototype=new et,l._$tP=new Object,l._$27=function(){l._$tP.clear()},l.getID=function(t){var i=l._$tP[t];return null==i&&(i=new l(t),l._$tP[t]=i),i},l.prototype._$3s=function(){return new l},u.prototype=new et,u._$tP=new Object,u._$27=function(){u._$tP.clear()},u.getID=function(t){var i=u._$tP[t];return null==i&&(i=new u(t),u._$tP[t]=i),i},u.prototype._$3s=function(){return new u},p._$42=0,p.prototype._$zP=function(){null==this._$vo&&(this._$vo=new ot),null==this._$F2&&(this._$F2=new Array)},p.prototype.getCanvasWidth=function(){return this._$ao},p.prototype.getCanvasHeight=function(){return this._$1S},p.prototype._$F0=function(t){this._$vo=t._$nP(),this._$F2=t._$nP(),this._$ao=t._$6L(),this._$1S=t._$6L()},p.prototype._$6S=function(t){this._$F2.push(t)},p.prototype._$Xr=function(){return this._$F2},p.prototype._$E2=function(){return this._$vo},f.prototype.setup=function(t,i,e){this._$ks=this._$Yb(),this.p2._$xT(),3==arguments.length&&(this._$Fo=t,this._$L2=i,this.p1._$p=e,this.p2._$p=e,this.p2.y=t,this.setup())},f.prototype.getPhysicsPoint1=function(){return this.p1},f.prototype.getPhysicsPoint2=function(){return this.p2},f.prototype._$qr=function(){return this._$Db},f.prototype._$pr=function(t){this._$Db=t},f.prototype._$5r=function(){return this._$M2},f.prototype._$Cs=function(){return this._$9b},f.prototype._$Yb=function(){return-180*Math.atan2(this.p1.x-this.p2.x,-(this.p1.y-this.p2.y))/Math.PI},f.prototype.addSrcParam=function(t,i,e,r){var o=new g(t,i,e,r);this._$lL.push(o)},f.prototype.addTargetParam=function(t,i,e,r){var o=new T(t,i,e,r);this._$qP.push(o)},f.prototype.update=function(t,i){if(0==this._$iP)return this._$iP=this._$iT=i,void(this._$Fo=Math.sqrt((this.p1.x-this.p2.x)*(this.p1.x-this.p2.x)+(this.p1.y-this.p2.y)*(this.p1.y-this.p2.y)));var e=(i-this._$iT)/1e3;if(0!=e){for(var r=this._$lL.length-1;r>=0;--r){this._$lL[r]._$oP(t,this)}this._$oo(t,e),this._$M2=this._$Yb(),this._$9b=(this._$M2-this._$ks)/e,this._$ks=this._$M2}for(var r=this._$qP.length-1;r>=0;--r){this._$qP[r]._$YS(t,this)}this._$iT=i},f.prototype._$oo=function(t,i){i<.033&&(i=.033);var e=1/i;this.p1.vx=(this.p1.x-this.p1._$s0)*e,this.p1.vy=(this.p1.y-this.p1._$70)*e,this.p1.ax=(this.p1.vx-this.p1._$7L)*e,this.p1.ay=(this.p1.vy-this.p1._$HL)*e,this.p1.fx=this.p1.ax*this.p1._$p,this.p1.fy=this.p1.ay*this.p1._$p,this.p1._$xT();var r,o,n=-Math.atan2(this.p1.y-this.p2.y,this.p1.x-this.p2.x),s=Math.cos(n),_=Math.sin(n),a=9.8*this.p2._$p,h=this._$Db*Lt._$bS,l=a*Math.cos(n-h);r=l*_,o=l*s;var $=-this.p1.fx*_*_,u=-this.p1.fy*_*s,p=-this.p2.vx*this._$L2,f=-this.p2.vy*this._$L2;this.p2.fx=r+$+p,this.p2.fy=o+u+f,this.p2.ax=this.p2.fx/this.p2._$p,this.p2.ay=this.p2.fy/this.p2._$p,this.p2.vx+=this.p2.ax*i,this.p2.vy+=this.p2.ay*i,this.p2.x+=this.p2.vx*i,this.p2.y+=this.p2.vy*i;var c=Math.sqrt((this.p1.x-this.p2.x)*(this.p1.x-this.p2.x)+(this.p1.y-this.p2.y)*(this.p1.y-this.p2.y));this.p2.x=this.p1.x+this._$Fo*(this.p2.x-this.p1.x)/c,this.p2.y=this.p1.y+this._$Fo*(this.p2.y-this.p1.y)/c,this.p2.vx=(this.p2.x-this.p2._$s0)*e,this.p2.vy=(this.p2.y-this.p2._$70)*e,this.p2._$xT()},c.prototype._$xT=function(){this._$s0=this.x,this._$70=this.y,this._$7L=this.vx,this._$HL=this.vy},d.prototype._$oP=function(t,i){},g.prototype=new d,g.prototype._$oP=function(t,i){var e=this.scale*t.getParamFloat(this._$wL),r=i.getPhysicsPoint1();switch(this._$tL){default:case f.Src.SRC_TO_X:r.x=r.x+(e-r.x)*this._$V0;break;case f.Src.SRC_TO_Y:r.y=r.y+(e-r.y)*this._$V0;break;case f.Src.SRC_TO_G_ANGLE:var o=i._$qr();o+=(e-o)*this._$V0,i._$pr(o)}},y.prototype._$YS=function(t,i){},T.prototype=new y,T.prototype._$YS=function(t,i){switch(this._$YP){default:case f.Target.TARGET_FROM_ANGLE:t.setParamFloat(this._$wL,this.scale*i._$5r(),this._$V0);break;case f.Target.TARGET_FROM_ANGLE_V:t.setParamFloat(this._$wL,this.scale*i._$Cs(),this._$V0)}},f.Src=function(){},f.Src.SRC_TO_X="SRC_TO_X",f.Src.SRC_TO_Y="SRC_TO_Y",f.Src.SRC_TO_G_ANGLE="SRC_TO_G_ANGLE",f.Target=function(){},f.Target.TARGET_FROM_ANGLE="TARGET_FROM_ANGLE",f.Target.TARGET_FROM_ANGLE_V="TARGET_FROM_ANGLE_V",P.prototype.init=function(t){this._$fL=t._$fL,this._$gL=t._$gL,this._$B0=t._$B0,this._$z0=t._$z0,this._$qT=t._$qT,this.reflectX=t.reflectX,this.reflectY=t.reflectY},P.prototype._$F0=function(t){this._$fL=t._$_T(),this._$gL=t._$_T(),this._$B0=t._$_T(),this._$z0=t._$_T(),this._$qT=t._$_T(),t.getFormatVersion()>=G.LIVE2D_FORMAT_VERSION_V2_10_SDK2&&(this.reflectX=t._$po(),this.reflectY=t._$po())},P.prototype._$e=function(){};var It=function(){};It._$ni=function(t,i,e,r,o,n,s,_,a){var h=s*n-_*o;if(0==h)return null;var l,$=((t-e)*n-(i-r)*o)/h;return l=0!=o?(t-e-$*s)/o:(i-r-$*_)/n,isNaN(l)&&(l=(t-e-$*s)/o,isNaN(l)&&(l=(i-r-$*_)/n),isNaN(l)&&(console.log("a is NaN @UtVector#_$ni() "),console.log("v1x : "+o),console.log("v1x != 0 ? "+(0!=o)))),null==a?new Array(l,$):(a[0]=l,a[1]=$,a)},S.prototype._$8P=function(){return this.x+.5*this.width},S.prototype._$6P=function(){return this.y+.5*this.height},S.prototype._$EL=function(){return this.x+this.width},S.prototype._$5T=function(){return this.y+this.height},S.prototype._$jL=function(t,i,e,r){this.x=t,this.y=i,this.width=e,this.height=r},S.prototype._$jL=function(t){this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height},S.prototype.contains=function(t,i){return this.x<=this.x&&this.y<=this.y&&this.x<=this.x+this.width&&this.y<=this.y+this.height},S.prototype.expand=function(t,i){this.x-=t,this.y-=i,this.width+=2*t,this.height+=2*i},v._$Z2=function(t,i,e,r){var o=i._$Q2(t,e),n=t._$vs(),s=t._$Tr();if(i._$zr(n,s,o),o<=0)return r[n[0]];if(1==o){var _=r[n[0]],a=r[n[1]],h=s[0];return _+(a-_)*h|0}if(2==o){var _=r[n[0]],a=r[n[1]],l=r[n[2]],$=r[n[3]],h=s[0],u=s[1],p=_+(a-_)*h|0,f=l+($-l)*h|0;return p+(f-p)*u|0}if(3==o){var c=r[n[0]],d=r[n[1]],g=r[n[2]],y=r[n[3]],m=r[n[4]],T=r[n[5]],P=r[n[6]],S=r[n[7]],h=s[0],u=s[1],v=s[2],_=c+(d-c)*h|0,a=g+(y-g)*h|0,l=m+(T-m)*h|0,$=P+(S-P)*h|0,p=_+(a-_)*u|0,f=l+($-l)*u|0;return p+(f-p)*v|0}if(4==o){var L=r[n[0]],M=r[n[1]],E=r[n[2]],A=r[n[3]],I=r[n[4]],w=r[n[5]],x=r[n[6]],O=r[n[7]],D=r[n[8]],R=r[n[9]],b=r[n[10]],F=r[n[11]],C=r[n[12]],N=r[n[13]],B=r[n[14]],U=r[n[15]],h=s[0],u=s[1],v=s[2],G=s[3],c=L+(M-L)*h|0,d=E+(A-E)*h|0,g=I+(w-I)*h|0,y=x+(O-x)*h|0,m=D+(R-D)*h|0,T=b+(F-b)*h|0,P=C+(N-C)*h|0,S=B+(U-B)*h|0,_=c+(d-c)*u|0,a=g+(y-g)*u|0,l=m+(T-m)*u|0,$=P+(S-P)*u|0,p=_+(a-_)*v|0,f=l+($-l)*v|0;return p+(f-p)*G|0}for(var Y=1<<o,k=new Float32Array(Y),V=0;V<Y;V++){for(var X=V,z=1,H=0;H<o;H++)z*=X%2==0?1-s[H]:s[H],X/=2;k[V]=z}for(var W=new Float32Array(Y),j=0;j<Y;j++)W[j]=r[n[j]];for(var q=0,j=0;j<Y;j++)q+=k[j]*W[j];return q+.5|0},v._$br=function(t,i,e,r){var o=i._$Q2(t,e),n=t._$vs(),s=t._$Tr();if(i._$zr(n,s,o),o<=0)return r[n[0]];if(1==o){var _=r[n[0]],a=r[n[1]],h=s[0];return _+(a-_)*h}if(2==o){var _=r[n[0]],a=r[n[1]],l=r[n[2]],$=r[n[3]],h=s[0],u=s[1];return(1-u)*(_+(a-_)*h)+u*(l+($-l)*h)}if(3==o){var p=r[n[0]],f=r[n[1]],c=r[n[2]],d=r[n[3]],g=r[n[4]],y=r[n[5]],m=r[n[6]],T=r[n[7]],h=s[0],u=s[1],P=s[2];return(1-P)*((1-u)*(p+(f-p)*h)+u*(c+(d-c)*h))+P*((1-u)*(g+(y-g)*h)+u*(m+(T-m)*h))}if(4==o){var S=r[n[0]],v=r[n[1]],L=r[n[2]],M=r[n[3]],E=r[n[4]],A=r[n[5]],I=r[n[6]],w=r[n[7]],x=r[n[8]],O=r[n[9]],D=r[n[10]],R=r[n[11]],b=r[n[12]],F=r[n[13]],C=r[n[14]],N=r[n[15]],h=s[0],u=s[1],P=s[2],B=s[3];return(1-B)*((1-P)*((1-u)*(S+(v-S)*h)+u*(L+(M-L)*h))+P*((1-u)*(E+(A-E)*h)+u*(I+(w-I)*h)))+B*((1-P)*((1-u)*(x+(O-x)*h)+u*(D+(R-D)*h))+P*((1-u)*(b+(F-b)*h)+u*(C+(N-C)*h)))}for(var U=1<<o,G=new Float32Array(U),Y=0;Y<U;Y++){for(var k=Y,V=1,X=0;X<o;X++)V*=k%2==0?1-s[X]:s[X],k/=2;G[Y]=V}for(var z=new Float32Array(U),H=0;H<U;H++)z[H]=r[n[H]];for(var W=0,H=0;H<U;H++)W+=G[H]*z[H];return W},v._$Vr=function(t,i,e,r,o,n,s,_){var a=i._$Q2(t,e),h=t._$vs(),l=t._$Tr();i._$zr(h,l,a);var $=2*r,u=s;if(a<=0){var p=h[0],f=o[p];if(2==_&&0==s)w._$jT(f,0,n,0,$);else for(var c=0;c<$;)n[u]=f[c++],n[u+1]=f[c++],u+=_}else if(1==a)for(var f=o[h[0]],d=o[h[1]],g=l[0],y=1-g,c=0;c<$;)n[u]=f[c]*y+d[c]*g,++c,n[u+1]=f[c]*y+d[c]*g,++c,u+=_;else if(2==a)for(var f=o[h[0]],d=o[h[1]],m=o[h[2]],T=o[h[3]],g=l[0],P=l[1],y=1-g,S=1-P,v=S*y,L=S*g,M=P*y,E=P*g,c=0;c<$;)n[u]=v*f[c]+L*d[c]+M*m[c]+E*T[c],++c,n[u+1]=v*f[c]+L*d[c]+M*m[c]+E*T[c],++c,u+=_;else if(3==a)for(var A=o[h[0]],I=o[h[1]],x=o[h[2]],O=o[h[3]],D=o[h[4]],R=o[h[5]],b=o[h[6]],F=o[h[7]],g=l[0],P=l[1],C=l[2],y=1-g,S=1-P,N=1-C,B=N*S*y,U=N*S*g,G=N*P*y,Y=N*P*g,k=C*S*y,V=C*S*g,X=C*P*y,z=C*P*g,c=0;c<$;)n[u]=B*A[c]+U*I[c]+G*x[c]+Y*O[c]+k*D[c]+V*R[c]+X*b[c]+z*F[c],++c,n[u+1]=B*A[c]+U*I[c]+G*x[c]+Y*O[c]+k*D[c]+V*R[c]+X*b[c]+z*F[c],++c,u+=_;else if(4==a)for(var H=o[h[0]],W=o[h[1]],j=o[h[2]],q=o[h[3]],J=o[h[4]],Q=o[h[5]],Z=o[h[6]],K=o[h[7]],tt=o[h[8]],it=o[h[9]],et=o[h[10]],rt=o[h[11]],ot=o[h[12]],nt=o[h[13]],st=o[h[14]],_t=o[h[15]],g=l[0],P=l[1],C=l[2],at=l[3],y=1-g,S=1-P,N=1-C,ht=1-at,lt=ht*N*S*y,$t=ht*N*S*g,ut=ht*N*P*y,pt=ht*N*P*g,ft=ht*C*S*y,ct=ht*C*S*g,dt=ht*C*P*y,gt=ht*C*P*g,yt=at*N*S*y,mt=at*N*S*g,Tt=at*N*P*y,Pt=at*N*P*g,St=at*C*S*y,vt=at*C*S*g,Lt=at*C*P*y,Mt=at*C*P*g,c=0;c<$;)n[u]=lt*H[c]+$t*W[c]+ut*j[c]+pt*q[c]+ft*J[c]+ct*Q[c]+dt*Z[c]+gt*K[c]+yt*tt[c]+mt*it[c]+Tt*et[c]+Pt*rt[c]+St*ot[c]+vt*nt[c]+Lt*st[c]+Mt*_t[c],++c,n[u+1]=lt*H[c]+$t*W[c]+ut*j[c]+pt*q[c]+ft*J[c]+ct*Q[c]+dt*Z[c]+gt*K[c]+yt*tt[c]+mt*it[c]+Tt*et[c]+Pt*rt[c]+St*ot[c]+vt*nt[c]+Lt*st[c]+Mt*_t[c],++c,u+=_;else{for(var Et=1<<a,At=new Float32Array(Et),It=0;It<Et;It++){for(var wt=It,xt=1,Ot=0;Ot<a;Ot++)xt*=wt%2==0?1-l[Ot]:l[Ot],wt/=2;At[It]=xt}for(var Dt=new Float32Array(Et),Rt=0;Rt<Et;Rt++)Dt[Rt]=o[h[Rt]];for(var c=0;c<$;){for(var bt=0,Ft=0,Ct=c+1,Rt=0;Rt<Et;Rt++)bt+=At[Rt]*Dt[Rt][c],Ft+=At[Rt]*Dt[Rt][Ct];c+=2,n[u]=bt,n[u+1]=Ft,u+=_}}},L.prototype._$HT=function(t,i){this.x=t,this.y=i},L.prototype._$HT=function(t){this.x=t.x,this.y=t.y},M._$ur=-2,M._$ES=500,M._$wb=2,M._$8S=3,M._$52=M._$ES,M._$R2=M._$ES,M._$or=function(){return M._$52},M._$Pr=function(){return M._$R2},M.prototype.convertClipIDForV2_11=function(t){var i=[];return null==t?null:0==t.length?null:/,/.test(t)?i=t.id.split(","):(i.push(t.id),i)},M.prototype._$F0=function(t){this._$gP=t._$nP(),this._$dr=t._$nP(),this._$GS=t._$nP(),this._$qb=t._$6L(),this._$Lb=t._$cS(),this._$mS=t._$Tb(),t.getFormatVersion()>=G._$T7?(this.clipID=t._$nP(),this.clipIDList=this.convertClipIDForV2_11(this.clipID)):this.clipIDList=[],this._$MS(this._$Lb)},M.prototype.getClipIDList=function(){return this.clipIDList},M.prototype.init=function(t){},M.prototype._$Nr=function(t,i){if(i._$IS[0]=!1,i._$Us=v._$Z2(t,this._$GS,i._$IS,this._$Lb),at._$Zs);else if(i._$IS[0])return;i._$7s=v._$br(t,this._$GS,i._$IS,this._$mS)},M.prototype._$2b=function(t,i){},M.prototype.getDrawDataID=function(){return this._$gP},M.prototype._$j2=function(t){this._$gP=t},M.prototype.getOpacity=function(t,i){return i._$7s},M.prototype._$zS=function(t,i){return i._$Us},M.prototype._$MS=function(t){for(var i=t.length-1;i>=0;--i){var e=t[i];e<M._$52?M._$52=e:e>M._$R2&&(M._$R2=e)}},M.prototype.getTargetBaseDataID=function(){return this._$dr},M.prototype._$gs=function(t){this._$dr=t},M.prototype._$32=function(){return null!=this._$dr&&this._$dr!=yt._$2o()},M.prototype.preDraw=function(t,i,e){},M.prototype.draw=function(t,i,e){},M.prototype.getType=function(){},M.prototype._$B2=function(t,i,e){},E._$ps=32,E.CLIPPING_PROCESS_NONE=0,E.CLIPPING_PROCESS_OVERWRITE_ALPHA=1,E.CLIPPING_PROCESS_MULTIPLY_ALPHA=2,E.CLIPPING_PROCESS_DRAW=3,E.CLIPPING_PROCESS_CLEAR_ALPHA=4,E.prototype.setChannelFlagAsColor=function(t,i){this.CHANNEL_COLORS[t]=i},E.prototype.getChannelFlagAsColor=function(t){return this.CHANNEL_COLORS[t]},E.prototype._$ZT=function(){},E.prototype._$Uo=function(t,i,e,r,o,n,s){},E.prototype._$Rs=function(){return-1},E.prototype._$Ds=function(t){},E.prototype.setBaseColor=function(t,i,e,r){t<0?t=0:t>1&&(t=1),i<0?i=0:i>1&&(i=1),e<0?e=0:e>1&&(e=1),r<0?r=0:r>1&&(r=1),this._$lT=t,this._$C0=i,this._$tT=e,this._$WL=r},E.prototype._$WP=function(t){this.culling=t},E.prototype.setMatrix=function(t){for(var i=0;i<16;i++)this.matrix4x4[i]=t[i]},E.prototype._$IT=function(){return this.matrix4x4},E.prototype.setPremultipliedAlpha=function(t){this.premultipliedAlpha=t},E.prototype.isPremultipliedAlpha=function(){return this.premultipliedAlpha},E.prototype.setAnisotropy=function(t){this.anisotropy=t},E.prototype.getAnisotropy=function(){return this.anisotropy},E.prototype.getClippingProcess=function(){return this.clippingProcess},E.prototype.setClippingProcess=function(t){this.clippingProcess=t},E.prototype.setClipBufPre_clipContextForMask=function(t){this.clipBufPre_clipContextMask=t},E.prototype.getClipBufPre_clipContextMask=function(){return this.clipBufPre_clipContextMask},E.prototype.setClipBufPre_clipContextForDraw=function(t){this.clipBufPre_clipContextDraw=t},E.prototype.getClipBufPre_clipContextDraw=function(){return this.clipBufPre_clipContextDraw},I._$ur=-2,I._$c2=1,I._$_b=2,I.prototype._$F0=function(t){this._$kP=t._$nP(),this._$dr=t._$nP()},I.prototype.readV2_opacity=function(t){t.getFormatVersion()>=G.LIVE2D_FORMAT_VERSION_V2_10_SDK2&&(this._$mS=t._$Tb())},I.prototype.init=function(t){},I.prototype._$Nr=function(t,i){},I.prototype.interpolateOpacity=function(t,i,e,r){null==this._$mS?e.setInterpolatedOpacity(1):e.setInterpolatedOpacity(v._$br(t,i,r,this._$mS))},I.prototype._$2b=function(t,i){},I.prototype._$nb=function(t,i,e,r,o,n,s){},I.prototype.getType=function(){},I.prototype._$gs=function(t){this._$dr=t},I.prototype._$a2=function(t){this._$kP=t},I.prototype.getTargetBaseDataID=function(){return this._$dr},I.prototype.getBaseDataID=function(){return this._$kP},I.prototype._$32=function(){return null!=this._$dr&&this._$dr!=yt._$2o()},w._$W2=0,w._$CS=w._$W2,w._$Mo=function(){return!0},w._$XP=function(t){try{for(var i=getTimeMSec();getTimeMSec()-i<t;);}catch(t){t._$Rb()}},w.getUserTimeMSec=function(){return w._$CS==w._$W2?w.getSystemTimeMSec():w._$CS},w.setUserTimeMSec=function(t){w._$CS=t},w.updateUserTimeMSec=function(){return w._$CS=w.getSystemTimeMSec()},w.getTimeMSec=function(){return(new Date).getTime()},w.getSystemTimeMSec=function(){return(new Date).getTime()},w._$Q=function(t){},w._$jT=function(t,i,e,r,o){for(var n=0;n<o;n++)e[r+n]=t[i+n]},x._$ds=-2,x.prototype._$F0=function(t){this._$wL=t._$nP(),this._$VP=t._$6L(),this._$GP=t._$nP()},x.prototype.getParamIndex=function(t){return this._$2r!=t&&(this._$8o=x._$ds),this._$8o},x.prototype._$Pb=function(t,i){this._$8o=t,this._$2r=i},x.prototype.getParamID=function(){return this._$wL},x.prototype._$yP=function(t){this._$wL=t},x.prototype._$N2=function(){return this._$VP},x.prototype._$d2=function(){return this._$GP},x.prototype._$t2=function(t,i){this._$VP=t,this._$GP=i},x.prototype._$Lr=function(){return this._$O2},x.prototype._$wr=function(t){this._$O2=t},x.prototype._$SL=function(){return this._$ri},x.prototype._$AL=function(t){this._$ri=t},O.startsWith=function(t,i,e){var r=i+e.length;if(r>=t.length)return!1;for(var o=i;o<r;o++)if(O.getChar(t,o)!=e.charAt(o-i))return!1;return!0},O.getChar=function(t,i){return String.fromCharCode(t.getUint8(i))},O.createString=function(t,i,e){for(var r=new ArrayBuffer(2*e),o=new Uint16Array(r),n=0;n<e;n++)o[n]=t.getUint8(i+n);return String.fromCharCode.apply(null,o)},O._$LS=function(t,i,e,r){t instanceof ArrayBuffer&&(t=new DataView(t));var o=e,n=!1,s=!1,_=0,a=O.getChar(t,o);"-"==a&&(n=!0,o++);for(var h=!1;o<i;o++){switch(a=O.getChar(t,o)){case"0":_*=10;break;case"1":_=10*_+1;break;case"2":_=10*_+2;break;case"3":_=10*_+3;break;case"4":_=10*_+4;break;case"5":_=10*_+5;break;case"6":_=10*_+6;break;case"7":_=10*_+7;break;case"8":_=10*_+8;break;case"9":_=10*_+9;break;case".":s=!0,o++,h=!0;break;default:h=!0}if(h)break}if(s)for(var l=.1,$=!1;o<i;o++){switch(a=O.getChar(t,o)){case"0":break;case"1":_+=1*l;break;case"2":_+=2*l;break;case"3":_+=3*l;break;case"4":_+=4*l;break;case"5":_+=5*l;break;case"6":_+=6*l;break;case"7":_+=7*l;break;case"8":_+=8*l;break;case"9":_+=9*l;break;default:$=!0}if(l*=.1,$)break}return n&&(_=-_),r[0]=o,_},D.prototype._$zP=function(){this._$Ob=new Array},D.prototype._$F0=function(t){this._$Ob=t._$nP()},D.prototype._$Ur=function(t){if(t._$WS())return!0;for(var i=t._$v2(),e=this._$Ob.length-1;e>=0;--e){var r=this._$Ob[e].getParamIndex(i);if(r==x._$ds&&(r=t.getParamIndex(this._$Ob[e].getParamID())),t._$Xb(r))return!0}return!1},D.prototype._$Q2=function(t,i){for(var e,r,o=this._$Ob.length,n=t._$v2(),s=0,_=0;_<o;_++){var a=this._$Ob[_];if(e=a.getParamIndex(n),e==x._$ds&&(e=t.getParamIndex(a.getParamID()),a._$Pb(e,n)),e<0)throw new Exception("err 23242 : "+a.getParamID());var h=e<0?0:t.getParamFloat(e);r=a._$N2();var l,$,u=a._$d2(),p=-1,f=0;if(r<1);else if(1==r)l=u[0],l-U._$J<h&&h<l+U._$J?(p=0,f=0):(p=0,i[0]=!0);else if(l=u[0],h<l-U._$J)p=0,i[0]=!0;else if(h<l+U._$J)p=0;else{for(var c=!1,d=1;d<r;++d){if($=u[d],h<$+U._$J){$-U._$J<h?p=d:(p=d-1,f=(h-l)/($-l),s++),c=!0;break}l=$}c||(p=r-1,f=0,i[0]=!0)}a._$wr(p),a._$AL(f)}return s},D.prototype._$zr=function(t,i,e){var r=1<<e;r+1>U._$Qb&&console.log("err 23245\\n");for(var o=this._$Ob.length,n=1,s=1,_=0,a=0;a<r;++a)t[a]=0;for(var h=0;h<o;++h){var l=this._$Ob[h];if(0==l._$SL()){var $=l._$Lr()*n;if($<0&&at._$3T)throw new Exception("err 23246");for(var a=0;a<r;++a)t[a]+=$}else{for(var $=n*l._$Lr(),u=n*(l._$Lr()+1),a=0;a<r;++a)t[a]+=(a/s|0)%2==0?$:u;i[_++]=l._$SL(),s*=2}n*=l._$N2()}t[r]=65535,i[_]=-1},D.prototype._$h2=function(t,i,e){for(var r=new Float32Array(i),o=0;o<i;++o)r[o]=e[o];var n=new x;n._$yP(t),n._$t2(i,r),this._$Ob.push(n)},D.prototype._$J2=function(t){for(var i=t,e=this._$Ob.length,r=0;r<e;++r){var o=this._$Ob[r],n=o._$N2(),s=i%o._$N2(),_=o._$d2()[s];console.log("%s[%d]=%7.2f / ",o.getParamID(),s,_),i/=n}console.log("\\n")},D.prototype.getParamCount=function(){return this._$Ob.length},D.prototype._$zs=function(){return this._$Ob},R.prototype.identity=function(){for(var t=0;t<16;t++)this.m[t]=t%5==0?1:0},R.prototype.getArray=function(){return this.m},R.prototype.getCopyMatrix=function(){return new Float32Array(this.m)},R.prototype.setMatrix=function(t){if(null!=t&&16==t.length)for(var i=0;i<16;i++)this.m[i]=t[i]},R.prototype.mult=function(t,i,e){return null==i?null:(this==i?this.mult_safe(this.m,t.m,i.m,e):this.mult_fast(this.m,t.m,i.m,e),i)},R.prototype.mult_safe=function(t,i,e,r){if(t==e){var o=new Array(16);this.mult_fast(t,i,o,r);for(var n=15;n>=0;--n)e[n]=o[n]}else this.mult_fast(t,i,e,r)},R.prototype.mult_fast=function(t,i,e,r){r?(e[0]=t[0]*i[0]+t[4]*i[1]+t[8]*i[2],e[4]=t[0]*i[4]+t[4]*i[5]+t[8]*i[6],e[8]=t[0]*i[8]+t[4]*i[9]+t[8]*i[10],e[12]=t[0]*i[12]+t[4]*i[13]+t[8]*i[14]+t[12],e[1]=t[1]*i[0]+t[5]*i[1]+t[9]*i[2],e[5]=t[1]*i[4]+t[5]*i[5]+t[9]*i[6],e[9]=t[1]*i[8]+t[5]*i[9]+t[9]*i[10],e[13]=t[1]*i[12]+t[5]*i[13]+t[9]*i[14]+t[13],e[2]=t[2]*i[0]+t[6]*i[1]+t[10]*i[2],e[6]=t[2]*i[4]+t[6]*i[5]+t[10]*i[6],e[10]=t[2]*i[8]+t[6]*i[9]+t[10]*i[10],e[14]=t[2]*i[12]+t[6]*i[13]+t[10]*i[14]+t[14],e[3]=e[7]=e[11]=0,e[15]=1):(e[0]=t[0]*i[0]+t[4]*i[1]+t[8]*i[2]+t[12]*i[3],e[4]=t[0]*i[4]+t[4]*i[5]+t[8]*i[6]+t[12]*i[7],e[8]=t[0]*i[8]+t[4]*i[9]+t[8]*i[10]+t[12]*i[11],e[12]=t[0]*i[12]+t[4]*i[13]+t[8]*i[14]+t[12]*i[15],e[1]=t[1]*i[0]+t[5]*i[1]+t[9]*i[2]+t[13]*i[3],e[5]=t[1]*i[4]+t[5]*i[5]+t[9]*i[6]+t[13]*i[7],e[9]=t[1]*i[8]+t[5]*i[9]+t[9]*i[10]+t[13]*i[11],e[13]=t[1]*i[12]+t[5]*i[13]+t[9]*i[14]+t[13]*i[15],e[2]=t[2]*i[0]+t[6]*i[1]+t[10]*i[2]+t[14]*i[3],e[6]=t[2]*i[4]+t[6]*i[5]+t[10]*i[6]+t[14]*i[7],e[10]=t[2]*i[8]+t[6]*i[9]+t[10]*i[10]+t[14]*i[11],e[14]=t[2]*i[12]+t[6]*i[13]+t[10]*i[14]+t[14]*i[15],e[3]=t[3]*i[0]+t[7]*i[1]+t[11]*i[2]+t[15]*i[3],e[7]=t[3]*i[4]+t[7]*i[5]+t[11]*i[6]+t[15]*i[7],e[11]=t[3]*i[8]+t[7]*i[9]+t[11]*i[10]+t[15]*i[11],e[15]=t[3]*i[12]+t[7]*i[13]+t[11]*i[14]+t[15]*i[15])},R.prototype.translate=function(t,i,e){this.m[12]=this.m[0]*t+this.m[4]*i+this.m[8]*e+this.m[12],this.m[13]=this.m[1]*t+this.m[5]*i+this.m[9]*e+this.m[13],this.m[14]=this.m[2]*t+this.m[6]*i+this.m[10]*e+this.m[14],this.m[15]=this.m[3]*t+this.m[7]*i+this.m[11]*e+this.m[15]},R.prototype.scale=function(t,i,e){this.m[0]*=t,this.m[4]*=i,this.m[8]*=e,this.m[1]*=t,this.m[5]*=i,this.m[9]*=e,this.m[2]*=t,this.m[6]*=i,this.m[10]*=e,this.m[3]*=t,this.m[7]*=i,this.m[11]*=e},R.prototype.rotateX=function(t){var i=Lt.fcos(t),e=Lt._$9(t),r=this.m[4];this.m[4]=r*i+this.m[8]*e,this.m[8]=r*-e+this.m[8]*i,r=this.m[5],this.m[5]=r*i+this.m[9]*e,this.m[9]=r*-e+this.m[9]*i,r=this.m[6],this.m[6]=r*i+this.m[10]*e,this.m[10]=r*-e+this.m[10]*i,r=this.m[7],this.m[7]=r*i+this.m[11]*e,this.m[11]=r*-e+this.m[11]*i},R.prototype.rotateY=function(t){var i=Lt.fcos(t),e=Lt._$9(t),r=this.m[0];this.m[0]=r*i+this.m[8]*-e,this.m[8]=r*e+this.m[8]*i,r=this.m[1],this.m[1]=r*i+this.m[9]*-e,this.m[9]=r*e+this.m[9]*i,r=m[2],this.m[2]=r*i+this.m[10]*-e,this.m[10]=r*e+this.m[10]*i,r=m[3],this.m[3]=r*i+this.m[11]*-e,this.m[11]=r*e+this.m[11]*i},R.prototype.rotateZ=function(t){var i=Lt.fcos(t),e=Lt._$9(t),r=this.m[0];this.m[0]=r*i+this.m[4]*e,this.m[4]=r*-e+this.m[4]*i,r=this.m[1],this.m[1]=r*i+this.m[5]*e,this.m[5]=r*-e+this.m[5]*i,r=this.m[2],this.m[2]=r*i+this.m[6]*e,this.m[6]=r*-e+this.m[6]*i,r=this.m[3],this.m[3]=r*i+this.m[7]*e,this.m[7]=r*-e+this.m[7]*i},b.prototype=new et,b._$tP=new Object,b._$27=function(){b._$tP.clear()},b.getID=function(t){var i=b._$tP[t];return null==i&&(i=new b(t),b._$tP[t]=i),i},b.prototype._$3s=function(){return new b},F._$kS=-1,F._$pS=0,F._$hb=1,F.STATE_IDENTITY=0,F._$gb=1,F._$fo=2,F._$go=4,F.prototype.transform=function(t,i,e){var r,o,n,s,_,a,h=0,l=0;switch(this._$hi){default:return;case F._$go|F._$fo|F._$gb:for(r=this._$7,o=this._$H,n=this._$k,s=this._$f,_=this._$g,a=this._$w;--e>=0;){var $=t[h++],u=t[h++];i[l++]=r*$+o*u+n,i[l++]=s*$+_*u+a}return;case F._$go|F._$fo:for(r=this._$7,o=this._$H,s=this._$f,_=this._$g;--e>=0;){var $=t[h++],u=t[h++];i[l++]=r*$+o*u,i[l++]=s*$+_*u}return;case F._$go|F._$gb:for(o=this._$H,n=this._$k,s=this._$f,a=this._$w;--e>=0;){var $=t[h++];i[l++]=o*t[h++]+n,i[l++]=s*$+a}return;case F._$go:for(o=this._$H,s=this._$f;--e>=0;){var $=t[h++];i[l++]=o*t[h++],i[l++]=s*$}return;case F._$fo|F._$gb:for(r=this._$7,n=this._$k,_=this._$g,a=this._$w;--e>=0;)i[l++]=r*t[h++]+n,i[l++]=_*t[h++]+a;return;case F._$fo:for(r=this._$7,_=this._$g;--e>=0;)i[l++]=r*t[h++],i[l++]=_*t[h++];return;case F._$gb:for(n=this._$k,a=this._$w;--e>=0;)i[l++]=t[h++]+n,i[l++]=t[h++]+a;return;case F.STATE_IDENTITY:return void(t==i&&h==l||w._$jT(t,h,i,l,2*e))}},F.prototype.update=function(){0==this._$H&&0==this._$f?1==this._$7&&1==this._$g?0==this._$k&&0==this._$w?(this._$hi=F.STATE_IDENTITY,this._$Z=F._$pS):(this._$hi=F._$gb,this._$Z=F._$hb):0==this._$k&&0==this._$w?(this._$hi=F._$fo,this._$Z=F._$kS):(this._$hi=F._$fo|F._$gb,this._$Z=F._$kS):0==this._$7&&0==this._$g?0==this._$k&&0==this._$w?(this._$hi=F._$go,this._$Z=F._$kS):(this._$hi=F._$go|F._$gb,this._$Z=F._$kS):0==this._$k&&0==this._$w?(this._$hi=F._$go|F._$fo,this._$Z=F._$kS):(this._$hi=F._$go|F._$fo|F._$gb,this._$Z=F._$kS)},F.prototype._$RT=function(t){this._$IT(t);var i=t[0],e=t[2],r=t[1],o=t[3],n=Math.sqrt(i*i+r*r),s=i*o-e*r;0==n?at._$so&&console.log("affine._$RT() / rt==0"):(t[0]=n,t[1]=s/n,t[2]=(r*o+i*e)/s,t[3]=Math.atan2(r,i))},F.prototype._$ho=function(t,i,e,r){var o=new Float32Array(6),n=new Float32Array(6);t._$RT(o),i._$RT(n);var s=new Float32Array(6);s[0]=o[0]+(n[0]-o[0])*e,s[1]=o[1]+(n[1]-o[1])*e,s[2]=o[2]+(n[2]-o[2])*e,s[3]=o[3]+(n[3]-o[3])*e,s[4]=o[4]+(n[4]-o[4])*e,s[5]=o[5]+(n[5]-o[5])*e,r._$CT(s)},F.prototype._$CT=function(t){var i=Math.cos(t[3]),e=Math.sin(t[3]);this._$7=t[0]*i,this._$f=t[0]*e,this._$H=t[1]*(t[2]*i-e),this._$g=t[1]*(t[2]*e+i),this._$k=t[4],this._$w=t[5],this.update()},F.prototype._$IT=function(t){t[0]=this._$7,t[1]=this._$f,t[2]=this._$H,t[3]=this._$g,t[4]=this._$k,t[5]=this._$w},C.prototype=new s,C._$cs="VISIBLE:",C._$ar="LAYOUT:",C._$Co=0,C._$D2=[],C._$1T=1,C.loadMotion=function(t){var i=new C,e=[0],r=t.length;i._$yT=0;for(var o=0;o<r;++o){var n=255&t[o];if("\\n"!=n&&"\\r"!=n)if("#"!=n)if("$"!=n){if("a"<=n&&n<="z"||"A"<=n&&n<="Z"||"_"==n){for(var s=o,_=-1;o<r&&("\\r"!=(n=255&t[o])&&"\\n"!=n);++o)if("="==n){_=o;break}if(_>=0){var a=new B;O.startsWith(t,s,C._$cs)?(a._$RP=B._$hs,a._$4P=new String(t,s,_-s)):O.startsWith(t,s,C._$ar)?(a._$4P=new String(t,s+7,_-s-7),O.startsWith(t,s+7,"ANCHOR_X")?a._$RP=B._$xs:O.startsWith(t,s+7,"ANCHOR_Y")?a._$RP=B._$us:O.startsWith(t,s+7,"SCALE_X")?a._$RP=B._$qs:O.startsWith(t,s+7,"SCALE_Y")?a._$RP=B._$Ys:O.startsWith(t,s+7,"X")?a._$RP=B._$ws:O.startsWith(t,s+7,"Y")&&(a._$RP=B._$Ns)):(a._$RP=B._$Fr,a._$4P=new String(t,s,_-s)),i.motions.push(a);var h=0;for(C._$D2.clear(),o=_+1;o<r&&("\\r"!=(n=255&t[o])&&"\\n"!=n);++o)if(","!=n&&" "!=n&&"\\t"!=n){var l=O._$LS(t,r,o,e);if(e[0]>0){C._$D2.push(l),h++;var $=e[0];if($<o){console.log("_$n0 _$hi . @Live2DMotion loadMotion()\\n");break}o=$}}a._$I0=C._$D2._$BL(),h>i._$yT&&(i._$yT=h)}}}else{for(var s=o,_=-1;o<r&&("\\r"!=(n=255&t[o])&&"\\n"!=n);++o)if("="==n){_=o;break}var u=!1;if(_>=0)for(_==s+4&&"f"==t[s+1]&&"p"==t[s+2]&&"s"==t[s+3]&&(u=!0),o=_+1;o<r&&("\\r"!=(n=255&t[o])&&"\\n"!=n);++o)if(","!=n&&" "!=n&&"\\t"!=n){var l=O._$LS(t,r,o,e);e[0]>0&&u&&5<l&&l<121&&(i._$D0=l),o=e[0]}for(;o<r&&("\\n"!=t[o]&&"\\r"!=t[o]);++o);}else for(;o<r&&("\\n"!=t[o]&&"\\r"!=t[o]);++o);}return i._$AS=1e3*i._$yT/i._$D0|0,i},C.prototype.getDurationMSec=function(){return this._$AS},C.prototype.dump=function(){for(var t=0;t<this.motions.length;t++){var i=this.motions[t];console.log("_$wL[%s] [%d]. ",i._$4P,i._$I0.length);for(var e=0;e<i._$I0.length&&e<10;e++)console.log("%5.2f ,",i._$I0[e]);console.log("\\n")}},C.prototype.updateParamExe=function(t,i,e,r){for(var o=i-r._$z2,n=o*this._$D0/1e3,s=0|n,_=n-s,a=0;a<this.motions.length;a++){var h=this.motions[a],l=h._$I0.length,$=h._$4P;if(h._$RP==B._$hs){var u=h._$I0[s>=l?l-1:s];t.setParamFloat($,u)}else if(B._$ws<=h._$RP&&h._$RP<=B._$Ys);else{var p=t.getParamFloat($),f=h._$I0[s>=l?l-1:s],c=h._$I0[s+1>=l?l-1:s+1],d=f+(c-f)*_,g=p+(d-p)*e;t.setParamFloat($,g)}}s>=this._$yT&&(this._$E?(r._$z2=i,this.loopFadeIn&&(r._$bs=i)):r._$9L=!0)},C.prototype._$r0=function(){return this._$E},C.prototype._$aL=function(t){this._$E=t},C.prototype.isLoopFadeIn=function(){return this.loopFadeIn},C.prototype.setLoopFadeIn=function(t){this.loopFadeIn=t},N.prototype.clear=function(){this.size=0},N.prototype.add=function(t){if(this._$P.length<=this.size){var i=new Float32Array(2*this.size);w._$jT(this._$P,0,i,0,this.size),this._$P=i}this._$P[this.size++]=t},N.prototype._$BL=function(){var t=new Float32Array(this.size);return w._$jT(this._$P,0,t,0,this.size),t},B._$Fr=0,B._$hs=1,B._$ws=100,B._$Ns=101,B._$xs=102,B._$us=103,B._$qs=104,B._$Ys=105,U._$Ms=1,U._$Qs=2,U._$i2=0,U._$No=2,U._$do=U._$Ms,U._$Ls=!0,U._$1r=5,U._$Qb=65,U._$J=1e-4,U._$FT=.001,U._$Ss=3,G._$o7=6,G._$S7=7,G._$s7=8,G._$77=9,G.LIVE2D_FORMAT_VERSION_V2_10_SDK2=10,G.LIVE2D_FORMAT_VERSION_V2_11_SDK2_1=11,G._$T7=G.LIVE2D_FORMAT_VERSION_V2_11_SDK2_1,G._$Is=-2004318072,G._$h0=0,G._$4L=23,G._$7P=33,G._$uT=function(t){console.log("_$bo :: _$6 _$mo _$E0 : %d\\n",t)},G._$9o=function(t){if(t<40)return G._$uT(t),null;if(t<50)return G._$uT(t),null;if(t<60)return G._$uT(t),null;if(t<100)switch(t){case 65:return new Z;case 66:return new D;case 67:return new x;case 68:return new z;case 69:return new P;case 70:return new $t;default:return G._$uT(t),null}else if(t<150)switch(t){case 131:return new st;case 133:return new tt;case 136:return new p;case 137:return new ot;case 142:return new j}return G._$uT(t),null},Y._$HP=0,Y._$_0=!0;Y._$V2=-1,Y._$W0=-1,Y._$jr=!1,Y._$ZS=!0,Y._$tr=-1e6,Y._$lr=1e6,Y._$is=32,Y._$e=!1,Y.prototype.getDrawDataIndex=function(t){for(var i=this._$aS.length-1;i>=0;--i)if(null!=this._$aS[i]&&this._$aS[i].getDrawDataID()==t)return i;return-1},Y.prototype.getDrawData=function(t){if(t instanceof b){if(null==this._$Bo){this._$Bo=new Object;for(var i=this._$aS.length,e=0;e<i;e++){var r=this._$aS[e],o=r.getDrawDataID();null!=o&&(this._$Bo[o]=r)}}return this._$Bo[id]}return t<this._$aS.length?this._$aS[t]:null},Y.prototype.release=function(){this._$3S.clear(),this._$aS.clear(),this._$F2.clear(),null!=this._$Bo&&this._$Bo.clear(),this._$db.clear(),this._$8b.clear(),this._$Hr.clear()},Y.prototype.init=function(){this._$co++,this._$F2.length>0&&this.release();for(var t=this._$Ri.getModelImpl(),i=t._$Xr(),r=i.length,o=new Array,n=new Array,s=0;s<r;++s){var _=i[s];this._$F2.push(_),this._$Hr.push(_.init(this));for(var a=_.getBaseData(),h=a.length,l=0;l<h;++l)o.push(a[l]);for(var l=0;l<h;++l){var $=a[l].init(this);$._$l2(s),n.push($)}for(var u=_.getDrawData(),p=u.length,l=0;l<p;++l){var f=u[l],c=f.init(this);c._$IP=s,this._$aS.push(f),this._$8b.push(c)}}for(var d=o.length,g=yt._$2o();;){for(var y=!1,s=0;s<d;++s){var m=o[s];if(null!=m){var T=m.getTargetBaseDataID();(null==T||T==g||this.getBaseDataIndex(T)>=0)&&(this._$3S.push(m),this._$db.push(n[s]),o[s]=null,y=!0)}}if(!y)break}var P=t._$E2();if(null!=P){var S=P._$1s();if(null!=S)for(var v=S.length,s=0;s<v;++s){var L=S[s];null!=L&&this._$02(L.getParamID(),L.getDefaultValue(),L.getMinValue(),L.getMaxValue())}}this.clipManager=new e(this.dp_webgl),this.clipManager.init(this,this._$aS,this._$8b),this._$QT=!0},Y.prototype.update=function(){Y._$e&&_.start("_$zL");for(var t=this._$_2.length,i=0;i<t;i++)this._$_2[i]!=this._$vr[i]&&(this._$Js[i]=Y._$ZS,this._$vr[i]=this._$_2[i]);var e=this._$3S.length,r=this._$aS.length,o=W._$or(),n=W._$Pr(),s=n-o+1;(null==this._$Ws||this._$Ws.length<s)&&(this._$Ws=new Int16Array(s),this._$Vs=new Int16Array(s));for(var i=0;i<s;i++)this._$Ws[i]=Y._$V2,this._$Vs[i]=Y._$V2;(null==this._$Er||this._$Er.length<r)&&(this._$Er=new Int16Array(r));for(var i=0;i<r;i++)this._$Er[i]=Y._$W0;Y._$e&&_.dump("_$zL"),Y._$e&&_.start("_$UL");for(var a=null,h=0;h<e;++h){var l=this._$3S[h],$=this._$db[h];try{l._$Nr(this,$),l._$2b(this,$)}catch(t){null==a&&(a=t)}}null!=a&&Y._$_0&&_._$Rb(a),Y._$e&&_.dump("_$UL"),Y._$e&&_.start("_$DL");for(var u=null,p=0;p<r;++p){var f=this._$aS[p],c=this._$8b[p];try{if(f._$Nr(this,c),c._$u2())continue;f._$2b(this,c);var d,g=Math.floor(f._$zS(this,c)-o);try{d=this._$Vs[g]}catch(t){console.log("_$li :: %s / %s \\t\\t\\t\\t@@_$fS\\n",t.toString(),f.getDrawDataID().toString()),g=Math.floor(f._$zS(this,c)-o);continue}d==Y._$V2?this._$Ws[g]=p:this._$Er[d]=p,this._$Vs[g]=p}catch(t){null==u&&(u=t,at._$sT(at._$H7))}}null!=u&&Y._$_0&&_._$Rb(u),Y._$e&&_.dump("_$DL"),Y._$e&&_.start("_$eL");for(var i=this._$Js.length-1;i>=0;i--)this._$Js[i]=Y._$jr;return this._$QT=!1,Y._$e&&_.dump("_$eL"),!1},Y.prototype.preDraw=function(t){null!=this.clipManager&&(t._$ZT(),this.clipManager.setupClip(this,t))},Y.prototype.draw=function(t){if(null==this._$Ws)return void _._$li("call _$Ri.update() before _$Ri.draw() ");var i=this._$Ws.length;t._$ZT();for(var e=0;e<i;++e){var r=this._$Ws[e];if(r!=Y._$V2)for(;;){var o=this._$aS[r],n=this._$8b[r];if(n._$yo()){var s=n._$IP,a=this._$Hr[s];n._$VS=a.getPartsOpacity(),o.draw(t,this,n)}var h=this._$Er[r];if(h<=r||h==Y._$W0)break;r=h}}},Y.prototype.getParamIndex=function(t){for(var i=this._$pb.length-1;i>=0;--i)if(this._$pb[i]==t)return i;return this._$02(t,0,Y._$tr,Y._$lr)},Y.prototype._$BS=function(t){return this.getBaseDataIndex(t)},Y.prototype.getBaseDataIndex=function(t){for(var i=this._$3S.length-1;i>=0;--i)if(null!=this._$3S[i]&&this._$3S[i].getBaseDataID()==t)return i;return-1},Y.prototype._$UT=function(t,i){var e=new Float32Array(i);return w._$jT(t,0,e,0,t.length),e},Y.prototype._$02=function(t,i,e,r){if(this._$qo>=this._$pb.length){var o=this._$pb.length,n=new Array(2*o);w._$jT(this._$pb,0,n,0,o),this._$pb=n,this._$_2=this._$UT(this._$_2,2*o),this._$vr=this._$UT(this._$vr,2*o),this._$Rr=this._$UT(this._$Rr,2*o),this._$Or=this._$UT(this._$Or,2*o);var s=new Array;w._$jT(this._$Js,0,s,0,o),this._$Js=s}return this._$pb[this._$qo]=t,this._$_2[this._$qo]=i,this._$vr[this._$qo]=i,this._$Rr[this._$qo]=e,this._$Or[this._$qo]=r,this._$Js[this._$qo]=Y._$ZS,this._$qo++},Y.prototype._$Zo=function(t,i){this._$3S[t]=i},Y.prototype.setParamFloat=function(t,i){i<this._$Rr[t]&&(i=this._$Rr[t]),i>this._$Or[t]&&(i=this._$Or[t]),this._$_2[t]=i},Y.prototype.loadParam=function(){var t=this._$_2.length;t>this._$fs.length&&(t=this._$fs.length),w._$jT(this._$fs,0,this._$_2,0,t)},Y.prototype.saveParam=function(){var t=this._$_2.length;t>this._$fs.length&&(this._$fs=new Float32Array(t)),w._$jT(this._$_2,0,this._$fs,0,t)},Y.prototype._$v2=function(){return this._$co},Y.prototype._$WS=function(){return this._$QT},Y.prototype._$Xb=function(t){return this._$Js[t]==Y._$ZS},Y.prototype._$vs=function(){return this._$Es},Y.prototype._$Tr=function(){return this._$ZP},Y.prototype.getBaseData=function(t){return this._$3S[t]},Y.prototype.getParamFloat=function(t){return this._$_2[t]},Y.prototype.getParamMax=function(t){return this._$Or[t]},Y.prototype.getParamMin=function(t){return this._$Rr[t]},Y.prototype.setPartsOpacity=function(t,i){this._$Hr[t].setPartsOpacity(i)},Y.prototype.getPartsOpacity=function(t){return this._$Hr[t].getPartsOpacity()},Y.prototype.getPartsDataIndex=function(t){for(var i=this._$F2.length-1;i>=0;--i)if(null!=this._$F2[i]&&this._$F2[i]._$p2()==t)return i;return-1},Y.prototype._$q2=function(t){return this._$db[t]},Y.prototype._$C2=function(t){return this._$8b[t]},Y.prototype._$Bb=function(t){return this._$Hr[t]},Y.prototype._$5s=function(t,i){for(var e=this._$Ws.length,r=t,o=0;o<e;++o){var n=this._$Ws[o];if(n!=Y._$V2)for(;;){var s=this._$8b[n];s._$yo()&&(s._$GT()._$B2(this,s,r),r+=i);var _=this._$Er[n];if(_<=n||_==Y._$W0)break;n=_}}},Y.prototype.setDrawParam=function(t){this.dp_webgl=t},Y.prototype.getDrawParam=function(){return this.dp_webgl},k._$0T=function(t){return k._$0T(new _$5(t))},k._$0T=function(t){if(!t.exists())throw new _$ls(t._$3b());for(var i,e=t.length(),r=new Int8Array(e),o=new _$Xs(new _$kb(t),8192),n=0;(i=o.read(r,n,e-n))>0;)n+=i;return r},k._$C=function(t){var i=null,e=null;try{i=t instanceof Array?t:new _$Xs(t,8192),e=new _$js;for(var r,o=new Int8Array(1e3);(r=i.read(o))>0;)e.write(o,0,r);return e._$TS()}finally{null!=t&&t.close(),null!=e&&(e.flush(),e.close())}},V.prototype._$T2=function(){return w.getUserTimeMSec()+Math._$10()*(2*this._$Br-1)},V.prototype._$uo=function(t){this._$Br=t},V.prototype._$QS=function(t,i,e){this._$Dr=t,this._$Cb=i,this._$mr=e},V.prototype._$7T=function(t){var i,e=w.getUserTimeMSec(),r=0;switch(this._$_L){case STATE_CLOSING:r=(e-this._$bb)/this._$Dr,r>=1&&(r=1,this._$_L=wt.STATE_CLOSED,this._$bb=e),i=1-r;break;case STATE_CLOSED:r=(e-this._$bb)/this._$Cb,r>=1&&(this._$_L=wt.STATE_OPENING,this._$bb=e),i=0;break;case STATE_OPENING:r=(e-this._$bb)/this._$mr,r>=1&&(r=1,this._$_L=wt.STATE_INTERVAL,this._$12=this._$T2()),i=r;break;case STATE_INTERVAL:this._$12<e&&(this._$_L=wt.STATE_CLOSING,this._$bb=e),i=1;break;case STATE_FIRST:default:this._$_L=wt.STATE_INTERVAL,this._$12=this._$T2(),i=1}this._$jo||(i=-i),t.setParamFloat(this._$iL,i),t.setParamFloat(this._$0L,i)};var wt=function(){};wt.STATE_FIRST="STATE_FIRST",wt.STATE_INTERVAL="STATE_INTERVAL",wt.STATE_CLOSING="STATE_CLOSING",wt.STATE_CLOSED="STATE_CLOSED",wt.STATE_OPENING="STATE_OPENING",X.prototype=new E,X._$As=32,X._$Gr=!1,X._$NT=null,X._$vS=null,X._$no=null,X._$9r=function(t){return new Float32Array(t)},X._$vb=function(t){return new Int16Array(t)},X._$cr=function(t,i){return null==t||t._$yL()<i.length?(t=X._$9r(2*i.length),t.put(i),t._$oT(0)):(t.clear(),t.put(i),t._$oT(0)),t},X._$mb=function(t,i){return null==t||t._$yL()<i.length?(t=X._$vb(2*i.length),t.put(i),t._$oT(0)):(t.clear(),t.put(i),t._$oT(0)),t},X._$Hs=function(){return X._$Gr},X._$as=function(t){X._$Gr=t},X.prototype.setGL=function(t){this.gl=t},X.prototype.setTransform=function(t){this.transform=t},X.prototype._$ZT=function(){},X.prototype._$Uo=function(t,i,e,r,o,n,s,_){if(!(n<.01)){var a=this._$U2[t],h=n>.9?at.EXPAND_W:0;this.gl.drawElements(a,e,r,o,n,h,this.transform,_)}},X.prototype._$Rs=function(){throw new Error("_$Rs")},X.prototype._$Ds=function(t){throw new Error("_$Ds")},X.prototype._$K2=function(){for(var t=0;t<this._$sb.length;t++){0!=this._$sb[t]&&(this.gl._$Sr(1,this._$sb,t),this._$sb[t]=0)}},X.prototype.setTexture=function(t,i){this._$sb.length<t+1&&this._$nS(t),this._$sb[t]=i},X.prototype.setTexture=function(t,i){this._$sb.length<t+1&&this._$nS(t),this._$U2[t]=i},X.prototype._$nS=function(t){var i=Math.max(2*this._$sb.length,t+1+10),e=new Int32Array(i);w._$jT(this._$sb,0,e,0,this._$sb.length),this._$sb=e;var r=new Array;w._$jT(this._$U2,0,r,0,this._$U2.length),this._$U2=r},z.prototype=new I,z._$Xo=new Float32Array(2),z._$io=new Float32Array(2),z._$0o=new Float32Array(2),z._$Lo=new Float32Array(2),z._$To=new Float32Array(2),z._$Po=new Float32Array(2),z._$gT=new Array,z.prototype._$zP=function(){this._$GS=new D,this._$GS._$zP(),this._$Y0=new Array},z.prototype.getType=function(){return I._$c2},z.prototype._$F0=function(t){I.prototype._$F0.call(this,t),this._$GS=t._$nP(),this._$Y0=t._$nP(),I.prototype.readV2_opacity.call(this,t)},z.prototype.init=function(t){var i=new H(this);return i._$Yr=new P,this._$32()&&(i._$Wr=new P),i},z.prototype._$Nr=function(t,i){this!=i._$GT()&&console.log("### assert!! ### ");var e=i;if(this._$GS._$Ur(t)){var r=z._$gT;r[0]=!1;var o=this._$GS._$Q2(t,r);i._$Ib(r[0]),this.interpolateOpacity(t,this._$GS,i,r);var n=t._$vs(),s=t._$Tr();if(this._$GS._$zr(n,s,o),o<=0){var _=this._$Y0[n[0]];e._$Yr.init(_)}else if(1==o){var _=this._$Y0[n[0]],a=this._$Y0[n[1]],h=s[0];e._$Yr._$fL=_._$fL+(a._$fL-_._$fL)*h,e._$Yr._$gL=_._$gL+(a._$gL-_._$gL)*h,e._$Yr._$B0=_._$B0+(a._$B0-_._$B0)*h,e._$Yr._$z0=_._$z0+(a._$z0-_._$z0)*h,e._$Yr._$qT=_._$qT+(a._$qT-_._$qT)*h}else if(2==o){var _=this._$Y0[n[0]],a=this._$Y0[n[1]],l=this._$Y0[n[2]],$=this._$Y0[n[3]],h=s[0],u=s[1],p=_._$fL+(a._$fL-_._$fL)*h,f=l._$fL+($._$fL-l._$fL)*h;e._$Yr._$fL=p+(f-p)*u,p=_._$gL+(a._$gL-_._$gL)*h,f=l._$gL+($._$gL-l._$gL)*h,e._$Yr._$gL=p+(f-p)*u,p=_._$B0+(a._$B0-_._$B0)*h,f=l._$B0+($._$B0-l._$B0)*h,e._$Yr._$B0=p+(f-p)*u,p=_._$z0+(a._$z0-_._$z0)*h,f=l._$z0+($._$z0-l._$z0)*h,e._$Yr._$z0=p+(f-p)*u,p=_._$qT+(a._$qT-_._$qT)*h,f=l._$qT+($._$qT-l._$qT)*h,e._$Yr._$qT=p+(f-p)*u}else if(3==o){var c=this._$Y0[n[0]],d=this._$Y0[n[1]],g=this._$Y0[n[2]],y=this._$Y0[n[3]],m=this._$Y0[n[4]],T=this._$Y0[n[5]],P=this._$Y0[n[6]],S=this._$Y0[n[7]],h=s[0],u=s[1],v=s[2],p=c._$fL+(d._$fL-c._$fL)*h,f=g._$fL+(y._$fL-g._$fL)*h,L=m._$fL+(T._$fL-m._$fL)*h,M=P._$fL+(S._$fL-P._$fL)*h;e._$Yr._$fL=(1-v)*(p+(f-p)*u)+v*(L+(M-L)*u),p=c._$gL+(d._$gL-c._$gL)*h,f=g._$gL+(y._$gL-g._$gL)*h,L=m._$gL+(T._$gL-m._$gL)*h,M=P._$gL+(S._$gL-P._$gL)*h,e._$Yr._$gL=(1-v)*(p+(f-p)*u)+v*(L+(M-L)*u),p=c._$B0+(d._$B0-c._$B0)*h,f=g._$B0+(y._$B0-g._$B0)*h,L=m._$B0+(T._$B0-m._$B0)*h,M=P._$B0+(S._$B0-P._$B0)*h,e._$Yr._$B0=(1-v)*(p+(f-p)*u)+v*(L+(M-L)*u),p=c._$z0+(d._$z0-c._$z0)*h,f=g._$z0+(y._$z0-g._$z0)*h,L=m._$z0+(T._$z0-m._$z0)*h,M=P._$z0+(S._$z0-P._$z0)*h,e._$Yr._$z0=(1-v)*(p+(f-p)*u)+v*(L+(M-L)*u),p=c._$qT+(d._$qT-c._$qT)*h,f=g._$qT+(y._$qT-g._$qT)*h,L=m._$qT+(T._$qT-m._$qT)*h,M=P._$qT+(S._$qT-P._$qT)*h,e._$Yr._$qT=(1-v)*(p+(f-p)*u)+v*(L+(M-L)*u)}else if(4==o){var E=this._$Y0[n[0]],A=this._$Y0[n[1]],I=this._$Y0[n[2]],w=this._$Y0[n[3]],x=this._$Y0[n[4]],O=this._$Y0[n[5]],D=this._$Y0[n[6]],R=this._$Y0[n[7]],b=this._$Y0[n[8]],F=this._$Y0[n[9]],C=this._$Y0[n[10]],N=this._$Y0[n[11]],B=this._$Y0[n[12]],U=this._$Y0[n[13]],G=this._$Y0[n[14]],Y=this._$Y0[n[15]],h=s[0],u=s[1],v=s[2],k=s[3],p=E._$fL+(A._$fL-E._$fL)*h,f=I._$fL+(w._$fL-I._$fL)*h,L=x._$fL+(O._$fL-x._$fL)*h,M=D._$fL+(R._$fL-D._$fL)*h,V=b._$fL+(F._$fL-b._$fL)*h,X=C._$fL+(N._$fL-C._$fL)*h,H=B._$fL+(U._$fL-B._$fL)*h,W=G._$fL+(Y._$fL-G._$fL)*h;e._$Yr._$fL=(1-k)*((1-v)*(p+(f-p)*u)+v*(L+(M-L)*u))+k*((1-v)*(V+(X-V)*u)+v*(H+(W-H)*u)),p=E._$gL+(A._$gL-E._$gL)*h,f=I._$gL+(w._$gL-I._$gL)*h,L=x._$gL+(O._$gL-x._$gL)*h,M=D._$gL+(R._$gL-D._$gL)*h,V=b._$gL+(F._$gL-b._$gL)*h,X=C._$gL+(N._$gL-C._$gL)*h,H=B._$gL+(U._$gL-B._$gL)*h,W=G._$gL+(Y._$gL-G._$gL)*h,e._$Yr._$gL=(1-k)*((1-v)*(p+(f-p)*u)+v*(L+(M-L)*u))+k*((1-v)*(V+(X-V)*u)+v*(H+(W-H)*u)),p=E._$B0+(A._$B0-E._$B0)*h,f=I._$B0+(w._$B0-I._$B0)*h,L=x._$B0+(O._$B0-x._$B0)*h,M=D._$B0+(R._$B0-D._$B0)*h,V=b._$B0+(F._$B0-b._$B0)*h,X=C._$B0+(N._$B0-C._$B0)*h,H=B._$B0+(U._$B0-B._$B0)*h,W=G._$B0+(Y._$B0-G._$B0)*h,e._$Yr._$B0=(1-k)*((1-v)*(p+(f-p)*u)+v*(L+(M-L)*u))+k*((1-v)*(V+(X-V)*u)+v*(H+(W-H)*u)),p=E._$z0+(A._$z0-E._$z0)*h,f=I._$z0+(w._$z0-I._$z0)*h,L=x._$z0+(O._$z0-x._$z0)*h,M=D._$z0+(R._$z0-D._$z0)*h,V=b._$z0+(F._$z0-b._$z0)*h,X=C._$z0+(N._$z0-C._$z0)*h,H=B._$z0+(U._$z0-B._$z0)*h,W=G._$z0+(Y._$z0-G._$z0)*h,e._$Yr._$z0=(1-k)*((1-v)*(p+(f-p)*u)+v*(L+(M-L)*u))+k*((1-v)*(V+(X-V)*u)+v*(H+(W-H)*u)),p=E._$qT+(A._$qT-E._$qT)*h,f=I._$qT+(w._$qT-I._$qT)*h,L=x._$qT+(O._$qT-x._$qT)*h,M=D._$qT+(R._$qT-D._$qT)*h,V=b._$qT+(F._$qT-b._$qT)*h,X=C._$qT+(N._$qT-C._$qT)*h,H=B._$qT+(U._$qT-B._$qT)*h,W=G._$qT+(Y._$qT-G._$qT)*h,e._$Yr._$qT=(1-k)*((1-v)*(p+(f-p)*u)+v*(L+(M-L)*u))+k*((1-v)*(V+(X-V)*u)+v*(H+(W-H)*u))}else{for(var j=0|Math.pow(2,o),q=new Float32Array(j),J=0;J<j;J++){for(var Q=J,Z=1,K=0;K<o;K++)Z*=Q%2==0?1-s[K]:s[K],Q/=2;q[J]=Z}for(var tt=new Array,it=0;it<j;it++)tt[it]=this._$Y0[n[it]];for(var et=0,rt=0,ot=0,nt=0,st=0,it=0;it<j;it++)et+=q[it]*tt[it]._$fL,rt+=q[it]*tt[it]._$gL,ot+=q[it]*tt[it]._$B0,nt+=q[it]*tt[it]._$z0,st+=q[it]*tt[it]._$qT;e._$Yr._$fL=et,e._$Yr._$gL=rt,e._$Yr._$B0=ot,e._$Yr._$z0=nt,e._$Yr._$qT=st}var _=this._$Y0[n[0]];e._$Yr.reflectX=_.reflectX,e._$Yr.reflectY=_.reflectY}},z.prototype._$2b=function(t,i){this!=i._$GT()&&console.log("### assert!! ### ");var e=i;if(e._$hS(!0),this._$32()){var r=this.getTargetBaseDataID();if(e._$8r==I._$ur&&(e._$8r=t.getBaseDataIndex(r)),e._$8r<0)at._$so&&_._$li("_$L _$0P _$G :: %s",r),e._$hS(!1);else{var o=t.getBaseData(e._$8r);if(null!=o){var n=t._$q2(e._$8r),s=z._$Xo;s[0]=e._$Yr._$fL,s[1]=e._$Yr._$gL;var a=z._$io;a[0]=0,a[1]=-.1;n._$GT().getType()==I._$c2?a[1]=-10:a[1]=-.1;var h=z._$0o;this._$Jr(t,o,n,s,a,h);var l=Lt._$92(a,h);o._$nb(t,n,s,s,1,0,2),e._$Wr._$fL=s[0],e._$Wr._$gL=s[1],e._$Wr._$B0=e._$Yr._$B0,e._$Wr._$z0=e._$Yr._$z0,e._$Wr._$qT=e._$Yr._$qT-l*Lt._$NS;var $=n.getTotalScale();e.setTotalScale_notForClient($*e._$Wr._$B0);var u=n.getTotalOpacity();e.setTotalOpacity(u*e.getInterpolatedOpacity()),e._$Wr.reflectX=e._$Yr.reflectX,e._$Wr.reflectY=e._$Yr.reflectY,e._$hS(n._$yo())}else e._$hS(!1)}}else e.setTotalScale_notForClient(e._$Yr._$B0),e.setTotalOpacity(e.getInterpolatedOpacity())},z.prototype._$nb=function(t,i,e,r,o,n,s){this!=i._$GT()&&console.log("### assert!! ### ");for(var _,a,h=i,l=null!=h._$Wr?h._$Wr:h._$Yr,$=Math.sin(Lt._$bS*l._$qT),u=Math.cos(Lt._$bS*l._$qT),p=h.getTotalScale(),f=l.reflectX?-1:1,c=l.reflectY?-1:1,d=u*p*f,g=-$*p*c,y=$*p*f,m=u*p*c,T=l._$fL,P=l._$gL,S=o*s,v=n;v<S;v+=s)_=e[v],a=e[v+1],r[v]=d*_+g*a+T,r[v+1]=y*_+m*a+P},z.prototype._$Jr=function(t,i,e,r,o,n){i!=e._$GT()&&console.log("### assert!! ### ");var s=z._$Lo;z._$Lo[0]=r[0],z._$Lo[1]=r[1],i._$nb(t,e,s,s,1,0,2);for(var _=z._$To,a=z._$Po,h=1,l=0;l<10;l++){if(a[0]=r[0]+h*o[0],a[1]=r[1]+h*o[1],i._$nb(t,e,a,_,1,0,2),_[0]-=s[0],_[1]-=s[1],0!=_[0]||0!=_[1])return n[0]=_[0],void(n[1]=_[1]);if(a[0]=r[0]-h*o[0],a[1]=r[1]-h*o[1],i._$nb(t,e,a,_,1,0,2),_[0]-=s[0],_[1]-=s[1],0!=_[0]||0!=_[1])return _[0]=-_[0],_[0]=-_[0],n[0]=_[0],void(n[1]=_[1]);h*=.1}at._$so&&console.log("_$L0 to transform _$SP\\n")},H.prototype=new _t,W.prototype=new M,W._$ur=-2,W._$ES=500,W._$wb=2,W._$8S=3,W._$os=4,W._$52=W._$ES,W._$R2=W._$ES,W._$Sb=function(t){for(var i=t.length-1;i>=0;--i){var e=t[i];e<W._$52?W._$52=e:e>W._$R2&&(W._$R2=e)}},W._$or=function(){return W._$52},W._$Pr=function(){return W._$R2},W.prototype._$F0=function(t){this._$gP=t._$nP(),this._$dr=t._$nP(),this._$GS=t._$nP(),this._$qb=t._$6L(),this._$Lb=t._$cS(),this._$mS=t._$Tb(),t.getFormatVersion()>=G._$T7?(this.clipID=t._$nP(),this.clipIDList=this.convertClipIDForV2_11(this.clipID)):this.clipIDList=null,W._$Sb(this._$Lb)},W.prototype.getClipIDList=function(){return this.clipIDList},W.prototype._$Nr=function(t,i){if(i._$IS[0]=!1,i._$Us=v._$Z2(t,this._$GS,i._$IS,this._$Lb),at._$Zs);else if(i._$IS[0])return;i._$7s=v._$br(t,this._$GS,i._$IS,this._$mS)},W.prototype._$2b=function(t){},W.prototype.getDrawDataID=function(){return this._$gP},W.prototype._$j2=function(t){this._$gP=t},W.prototype.getOpacity=function(t,i){return i._$7s},W.prototype._$zS=function(t,i){return i._$Us},W.prototype.getTargetBaseDataID=function(){return this._$dr},W.prototype._$gs=function(t){this._$dr=t},W.prototype._$32=function(){return null!=this._$dr&&this._$dr!=yt._$2o()},W.prototype.getType=function(){},j._$42=0,j.prototype._$1b=function(){return this._$3S},j.prototype.getDrawDataList=function(){return this._$aS},j.prototype._$F0=function(t){this._$NL=t._$nP(),this._$aS=t._$nP(),this._$3S=t._$nP()},j.prototype._$kr=function(t){t._$Zo(this._$3S),t._$xo(this._$aS),this._$3S=null,this._$aS=null},q.prototype=new i,q.loadModel=function(t){var e=new q;return i._$62(e,t),e},q.loadModel=function(t){var e=new q;return i._$62(e,t),e},q._$to=function(){return new q},q._$er=function(t){var i=new _$5("../_$_r/_$t0/_$Ri/_$_P._$d");if(0==i.exists())throw new _$ls("_$t0 _$_ _$6 _$Ui :: "+i._$PL());for(var e=["../_$_r/_$t0/_$Ri/_$_P.512/_$CP._$1","../_$_r/_$t0/_$Ri/_$_P.512/_$vP._$1","../_$_r/_$t0/_$Ri/_$_P.512/_$EP._$1","../_$_r/_$t0/_$Ri/_$_P.512/_$pP._$1"],r=q.loadModel(i._$3b()),o=0;o<e.length;o++){var n=new _$5(e[o]);if(0==n.exists())throw new _$ls("_$t0 _$_ _$6 _$Ui :: "+n._$PL());r.setTexture(o,_$nL._$_o(t,n._$3b()))}return r},q.prototype.setGL=function(t){this._$zo.setGL(t)},q.prototype.setTransform=function(t){this._$zo.setTransform(t)},q.prototype.draw=function(){this._$5S.draw(this._$zo)},q.prototype._$K2=function(){this._$zo._$K2()},q.prototype.setTexture=function(t,i){null==this._$zo&&_._$li("_$Yi for QT _$ki / _$XS() is _$6 _$ui!!"),this._$zo.setTexture(t,i)},q.prototype.setTexture=function(t,i){null==this._$zo&&_._$li("_$Yi for QT _$ki / _$XS() is _$6 _$ui!!"),this._$zo.setTexture(t,i)},q.prototype._$Rs=function(){return this._$zo._$Rs()},q.prototype._$Ds=function(t){this._$zo._$Ds(t)},q.prototype.getDrawParam=function(){return this._$zo},J.prototype=new s,J._$cs="VISIBLE:",J._$ar="LAYOUT:",J.MTN_PREFIX_FADEIN="FADEIN:",J.MTN_PREFIX_FADEOUT="FADEOUT:",J._$Co=0,J._$1T=1,J.loadMotion=function(t){var i=k._$C(t);return J.loadMotion(i)},J.loadMotion=function(t){t instanceof ArrayBuffer&&(t=new DataView(t));var i=new J,e=[0],r=t.byteLength;i._$yT=0;for(var o=0;o<r;++o){var n=Q(t,o),s=n.charCodeAt(0);if("\\n"!=n&&"\\r"!=n)if("#"!=n)if("$"!=n){if(97<=s&&s<=122||65<=s&&s<=90||"_"==n){for(var _=o,a=-1;o<r&&("\\r"!=(n=Q(t,o))&&"\\n"!=n);++o)if("="==n){a=o;break}if(a>=0){var h=new B;O.startsWith(t,_,J._$cs)?(h._$RP=B._$hs,h._$4P=O.createString(t,_,a-_)):O.startsWith(t,_,J._$ar)?(h._$4P=O.createString(t,_+7,a-_-7),O.startsWith(t,_+7,"ANCHOR_X")?h._$RP=B._$xs:O.startsWith(t,_+7,"ANCHOR_Y")?h._$RP=B._$us:O.startsWith(t,_+7,"SCALE_X")?h._$RP=B._$qs:O.startsWith(t,_+7,"SCALE_Y")?h._$RP=B._$Ys:O.startsWith(t,_+7,"X")?h._$RP=B._$ws:O.startsWith(t,_+7,"Y")&&(h._$RP=B._$Ns)):(h._$RP=B._$Fr,h._$4P=O.createString(t,_,a-_)),i.motions.push(h);var l=0,$=[];for(o=a+1;o<r&&("\\r"!=(n=Q(t,o))&&"\\n"!=n);++o)if(","!=n&&" "!=n&&"\\t"!=n){var u=O._$LS(t,r,o,e);if(e[0]>0){$.push(u),l++;var p=e[0];if(p<o){console.log("_$n0 _$hi . @Live2DMotion loadMotion()\\n");break}o=p-1}}h._$I0=new Float32Array($),l>i._$yT&&(i._$yT=l)}}}else{for(var _=o,a=-1;o<r&&("\\r"!=(n=Q(t,o))&&"\\n"!=n);++o)if("="==n){a=o;break}var f=!1;if(a>=0)for(a==_+4&&"f"==Q(t,_+1)&&"p"==Q(t,_+2)&&"s"==Q(t,_+3)&&(f=!0),o=a+1;o<r&&("\\r"!=(n=Q(t,o))&&"\\n"!=n);++o)if(","!=n&&" "!=n&&"\\t"!=n){var u=O._$LS(t,r,o,e);e[0]>0&&f&&5<u&&u<121&&(i._$D0=u),o=e[0]}for(;o<r&&("\\n"!=Q(t,o)&&"\\r"!=Q(t,o));++o);}else for(;o<r&&("\\n"!=Q(t,o)&&"\\r"!=Q(t,o));++o);}return i._$rr=1e3*i._$yT/i._$D0|0,i},J.prototype.getDurationMSec=function(){return this._$E?-1:this._$rr},J.prototype.getLoopDurationMSec=function(){return this._$rr},J.prototype.dump=function(){for(var t=0;t<this.motions.length;t++){var i=this.motions[t];console.log("_$wL[%s] [%d]. ",i._$4P,i._$I0.length);for(var e=0;e<i._$I0.length&&e<10;e++)console.log("%5.2f ,",i._$I0[e]);console.log("\\n")}},J.prototype.updateParamExe=function(t,i,e,r){for(var o=i-r._$z2,n=o*this._$D0/1e3,s=0|n,_=n-s,a=0;a<this.motions.length;a++){var h=this.motions[a],l=h._$I0.length,$=h._$4P;if(h._$RP==B._$hs){var u=h._$I0[s>=l?l-1:s];t.setParamFloat($,u)}else if(B._$ws<=h._$RP&&h._$RP<=B._$Ys);else{var p,f=t.getParamIndex($),c=t.getModelContext(),d=c.getParamMax(f),g=c.getParamMin(f),y=.4*(d-g),m=c.getParamFloat(f),T=h._$I0[s>=l?l-1:s],P=h._$I0[s+1>=l?l-1:s+1];p=T<P&&P-T>y||T>P&&T-P>y?T:T+(P-T)*_;var S=m+(p-m)*e;t.setParamFloat($,S)}}s>=this._$yT&&(this._$E?(r._$z2=i,this.loopFadeIn&&(r._$bs=i)):r._$9L=!0),this._$eP=e},J.prototype._$r0=function(){return this._$E},J.prototype._$aL=function(t){this._$E=t},J.prototype._$S0=function(){return this._$D0},J.prototype._$U0=function(t){this._$D0=t},J.prototype.isLoopFadeIn=function(){return this.loopFadeIn},J.prototype.setLoopFadeIn=function(t){this.loopFadeIn=t},N.prototype.clear=function(){this.size=0},N.prototype.add=function(t){if(this._$P.length<=this.size){var i=new Float32Array(2*this.size);w._$jT(this._$P,0,i,0,this.size),this._$P=i}this._$P[this.size++]=t},N.prototype._$BL=function(){var t=new Float32Array(this.size);return w._$jT(this._$P,0,t,0,this.size),t},B._$Fr=0,B._$hs=1,B._$ws=100,B._$Ns=101,B._$xs=102,B._$us=103,B._$qs=104,B._$Ys=105,Z.prototype=new I,Z._$gT=new Array,Z.prototype._$zP=function(){this._$GS=new D,this._$GS._$zP()},Z.prototype._$F0=function(t){I.prototype._$F0.call(this,t),this._$A=t._$6L(),this._$o=t._$6L(),this._$GS=t._$nP(),this._$Eo=t._$nP(),I.prototype.readV2_opacity.call(this,t)},Z.prototype.init=function(t){var i=new K(this),e=(this._$o+1)*(this._$A+1);return null!=i._$Cr&&(i._$Cr=null),i._$Cr=new Float32Array(2*e),null!=i._$hr&&(i._$hr=null),this._$32()?i._$hr=new Float32Array(2*e):i._$hr=null,i},Z.prototype._$Nr=function(t,i){var e=i;if(this._$GS._$Ur(t)){var r=this._$VT(),o=Z._$gT;o[0]=!1,v._$Vr(t,this._$GS,o,r,this._$Eo,e._$Cr,0,2),i._$Ib(o[0]),this.interpolateOpacity(t,this._$GS,i,o)}},Z.prototype._$2b=function(t,i){var e=i;if(e._$hS(!0),this._$32()){var r=this.getTargetBaseDataID();if(e._$8r==I._$ur&&(e._$8r=t.getBaseDataIndex(r)),e._$8r<0)at._$so&&_._$li("_$L _$0P _$G :: %s",r),e._$hS(!1);else{var o=t.getBaseData(e._$8r),n=t._$q2(e._$8r);if(null!=o&&n._$yo()){var s=n.getTotalScale();e.setTotalScale_notForClient(s);var a=n.getTotalOpacity();e.setTotalOpacity(a*e.getInterpolatedOpacity()),o._$nb(t,n,e._$Cr,e._$hr,this._$VT(),0,2),e._$hS(!0)}else e._$hS(!1)}}else e.setTotalOpacity(e.getInterpolatedOpacity())},Z.prototype._$nb=function(t,i,e,r,o,n,s){var _=i,a=null!=_._$hr?_._$hr:_._$Cr;Z.transformPoints_sdk2(e,r,o,n,s,a,this._$o,this._$A)},Z.transformPoints_sdk2=function(i,e,r,o,n,s,_,a){for(var h,l,$,u=r*n,p=0,f=0,c=0,d=0,g=0,y=0,m=!1,T=o;T<u;T+=n){var P,S,v,L;if(v=i[T],L=i[T+1],P=v*_,S=L*a,P<0||S<0||_<=P||a<=S){var M=_+1;if(!m){m=!0,p=.25*(s[2*(0+0*M)]+s[2*(_+0*M)]+s[2*(0+a*M)]+s[2*(_+a*M)]),f=.25*(s[2*(0+0*M)+1]+s[2*(_+0*M)+1]+s[2*(0+a*M)+1]+s[2*(_+a*M)+1]);var E=s[2*(_+a*M)]-s[2*(0+0*M)],A=s[2*(_+a*M)+1]-s[2*(0+0*M)+1],I=s[2*(_+0*M)]-s[2*(0+a*M)],w=s[2*(_+0*M)+1]-s[2*(0+a*M)+1];c=.5*(E+I),d=.5*(A+w),g=.5*(E-I),y=.5*(A-w),p-=.5*(c+g),f-=.5*(d+y)}if(-2<v&&v<3&&-2<L&&L<3)if(v<=0)if(L<=0){var x=s[2*(0+0*M)],O=s[2*(0+0*M)+1],D=p-2*c,R=f-2*d,b=p-2*g,F=f-2*y,C=p-2*c-2*g,N=f-2*d-2*y,B=.5*(v- -2),U=.5*(L- -2);B+U<=1?(e[T]=C+(b-C)*B+(D-C)*U,e[T+1]=N+(F-N)*B+(R-N)*U):(e[T]=x+(D-x)*(1-B)+(b-x)*(1-U),e[T+1]=O+(R-O)*(1-B)+(F-O)*(1-U))}else if(L>=1){var b=s[2*(0+a*M)],F=s[2*(0+a*M)+1],C=p-2*c+1*g,N=f-2*d+1*y,x=p+3*g,O=f+3*y,D=p-2*c+3*g,R=f-2*d+3*y,B=.5*(v- -2),U=.5*(L-1);B+U<=1?(e[T]=C+(b-C)*B+(D-C)*U,e[T+1]=N+(F-N)*B+(R-N)*U):(e[T]=x+(D-x)*(1-B)+(b-x)*(1-U),e[T+1]=O+(R-O)*(1-B)+(F-O)*(1-U))}else{var G=0|S;G==a&&(G=a-1);var B=.5*(v- -2),U=S-G,Y=G/a,k=(G+1)/a,b=s[2*(0+G*M)],F=s[2*(0+G*M)+1],x=s[2*(0+(G+1)*M)],O=s[2*(0+(G+1)*M)+1],C=p-2*c+Y*g,N=f-2*d+Y*y,D=p-2*c+k*g,R=f-2*d+k*y;B+U<=1?(e[T]=C+(b-C)*B+(D-C)*U,e[T+1]=N+(F-N)*B+(R-N)*U):(e[T]=x+(D-x)*(1-B)+(b-x)*(1-U),e[T+1]=O+(R-O)*(1-B)+(F-O)*(1-U))}else if(1<=v)if(L<=0){var D=s[2*(_+0*M)],R=s[2*(_+0*M)+1],x=p+3*c,O=f+3*d,C=p+1*c-2*g,N=f+1*d-2*y,b=p+3*c-2*g,F=f+3*d-2*y,B=.5*(v-1),U=.5*(L- -2);B+U<=1?(e[T]=C+(b-C)*B+(D-C)*U,e[T+1]=N+(F-N)*B+(R-N)*U):(e[T]=x+(D-x)*(1-B)+(b-x)*(1-U),e[T+1]=O+(R-O)*(1-B)+(F-O)*(1-U))}else if(L>=1){var C=s[2*(_+a*M)],N=s[2*(_+a*M)+1],b=p+3*c+1*g,F=f+3*d+1*y,D=p+1*c+3*g,R=f+1*d+3*y,x=p+3*c+3*g,O=f+3*d+3*y,B=.5*(v-1),U=.5*(L-1);B+U<=1?(e[T]=C+(b-C)*B+(D-C)*U,e[T+1]=N+(F-N)*B+(R-N)*U):(e[T]=x+(D-x)*(1-B)+(b-x)*(1-U),e[T+1]=O+(R-O)*(1-B)+(F-O)*(1-U))}else{var G=0|S;G==a&&(G=a-1);var B=.5*(v-1),U=S-G,Y=G/a,k=(G+1)/a,C=s[2*(_+G*M)],N=s[2*(_+G*M)+1],D=s[2*(_+(G+1)*M)],R=s[2*(_+(G+1)*M)+1],b=p+3*c+Y*g,F=f+3*d+Y*y,x=p+3*c+k*g,O=f+3*d+k*y;B+U<=1?(e[T]=C+(b-C)*B+(D-C)*U,e[T+1]=N+(F-N)*B+(R-N)*U):(e[T]=x+(D-x)*(1-B)+(b-x)*(1-U),e[T+1]=O+(R-O)*(1-B)+(F-O)*(1-U))}else if(L<=0){var V=0|P;V==_&&(V=_-1);var B=P-V,U=.5*(L- -2),X=V/_,z=(V+1)/_,D=s[2*(V+0*M)],R=s[2*(V+0*M)+1],x=s[2*(V+1+0*M)],O=s[2*(V+1+0*M)+1],C=p+X*c-2*g,N=f+X*d-2*y,b=p+z*c-2*g,F=f+z*d-2*y;B+U<=1?(e[T]=C+(b-C)*B+(D-C)*U,e[T+1]=N+(F-N)*B+(R-N)*U):(e[T]=x+(D-x)*(1-B)+(b-x)*(1-U),e[T+1]=O+(R-O)*(1-B)+(F-O)*(1-U))}else if(L>=1){var V=0|P;V==_&&(V=_-1);var B=P-V,U=.5*(L-1),X=V/_,z=(V+1)/_,C=s[2*(V+a*M)],N=s[2*(V+a*M)+1],b=s[2*(V+1+a*M)],F=s[2*(V+1+a*M)+1],D=p+X*c+3*g,R=f+X*d+3*y,x=p+z*c+3*g,O=f+z*d+3*y;B+U<=1?(e[T]=C+(b-C)*B+(D-C)*U,e[T+1]=N+(F-N)*B+(R-N)*U):(e[T]=x+(D-x)*(1-B)+(b-x)*(1-U),e[T+1]=O+(R-O)*(1-B)+(F-O)*(1-U))}else t.err.printf("_$li calc : %.4f , %.4f\\t\\t\\t\\t\\t@@BDBoxGrid\\n",v,L);else e[T]=p+v*c+L*g,e[T+1]=f+v*d+L*y}else l=P-(0|P),$=S-(0|S),h=2*((0|P)+(0|S)*(_+1)),l+$<1?(e[T]=s[h]*(1-l-$)+s[h+2]*l+s[h+2*(_+1)]*$,e[T+1]=s[h+1]*(1-l-$)+s[h+3]*l+s[h+2*(_+1)+1]*$):(e[T]=s[h+2*(_+1)+2]*(l-1+$)+s[h+2*(_+1)]*(1-l)+s[h+2]*(1-$),e[T+1]=s[h+2*(_+1)+3]*(l-1+$)+s[h+2*(_+1)+1]*(1-l)+s[h+3]*(1-$))}},Z.prototype.transformPoints_sdk1=function(t,i,e,r,o,n,s){for(var _,a,h,l,$,u,p,f=i,c=this._$o,d=this._$A,g=o*s,y=null!=f._$hr?f._$hr:f._$Cr,m=n;m<g;m+=s)at._$ts?(_=e[m],a=e[m+1],_<0?_=0:_>1&&(_=1),a<0?a=0:a>1&&(a=1),_*=c,a*=d,h=0|_,l=0|a,h>c-1&&(h=c-1),l>d-1&&(l=d-1),u=_-h,p=a-l,$=2*(h+l*(c+1))):(_=e[m]*c,a=e[m+1]*d,u=_-(0|_),p=a-(0|a),$=2*((0|_)+(0|a)*(c+1))),u+p<1?(r[m]=y[$]*(1-u-p)+y[$+2]*u+y[$+2*(c+1)]*p,r[m+1]=y[$+1]*(1-u-p)+y[$+3]*u+y[$+2*(c+1)+1]*p):(r[m]=y[$+2*(c+1)+2]*(u-1+p)+y[$+2*(c+1)]*(1-u)+y[$+2]*(1-p),r[m+1]=y[$+2*(c+1)+3]*(u-1+p)+y[$+2*(c+1)+1]*(1-u)+y[$+3]*(1-p))},Z.prototype._$VT=function(){return(this._$o+1)*(this._$A+1)},Z.prototype.getType=function(){return I._$_b},K.prototype=new _t,tt._$42=0,tt.prototype._$zP=function(){this._$3S=new Array,this._$aS=new Array},tt.prototype._$F0=function(t){this._$g0=t._$8L(),this.visible=t._$8L(),this._$NL=t._$nP(),this._$3S=t._$nP(),this._$aS=t._$nP()},tt.prototype.init=function(t){var i=new it(this);return i.setPartsOpacity(this.isVisible()?1:0),i},tt.prototype._$6o=function(t){if(null==this._$3S)throw new Error("_$3S _$6 _$Wo@_$6o");this._$3S.push(t)},tt.prototype._$3o=function(t){if(null==this._$aS)throw new Error("_$aS _$6 _$Wo@_$3o");this._$aS.push(t)},tt.prototype._$Zo=function(t){this._$3S=t},tt.prototype._$xo=function(t){this._$aS=t},tt.prototype.isVisible=function(){return this.visible},tt.prototype._$uL=function(){return this._$g0},tt.prototype._$KP=function(t){this.visible=t},tt.prototype._$ET=function(t){this._$g0=t},tt.prototype.getBaseData=function(){return this._$3S},tt.prototype.getDrawData=function(){return this._$aS},tt.prototype._$p2=function(){return this._$NL},tt.prototype._$ob=function(t){this._$NL=t},tt.prototype.getPartsID=function(){return this._$NL},tt.prototype._$MP=function(t){this._$NL=t},it.prototype=new $,it.prototype.getPartsOpacity=function(){return this._$VS},it.prototype.setPartsOpacity=function(t){this._$VS=t},et._$L7=function(){u._$27(),yt._$27(),b._$27(),l._$27()},et.prototype.toString=function(){return this.id},rt.prototype._$F0=function(t){},ot.prototype._$1s=function(){return this._$4S},ot.prototype._$zP=function(){this._$4S=new Array},ot.prototype._$F0=function(t){this._$4S=t._$nP()},ot.prototype._$Ks=function(t){this._$4S.push(t)},nt.tr=new gt,nt._$50=new gt,nt._$Ti=new Array(0,0),nt._$Pi=new Array(0,0),nt._$B=new Array(0,0),nt.prototype._$lP=function(t,i,e,r){this.viewport=new Array(t,i,e,r)},nt.prototype._$bL=function(){this.context.save();var t=this.viewport;null!=t&&(this.context.beginPath(),this.context._$Li(t[0],t[1],t[2],t[3]),this.context.clip())},nt.prototype._$ei=function(){this.context.restore()},nt.prototype.drawElements=function(t,i,e,r,o,n,s,a){try{o!=this._$Qo&&(this._$Qo=o,this.context.globalAlpha=o);for(var h=i.length,l=t.width,$=t.height,u=this.context,p=this._$xP,f=this._$uP,c=this._$6r,d=this._$3r,g=nt.tr,y=nt._$Ti,m=nt._$Pi,T=nt._$B,P=0;P<h;P+=3){u.save();var S=i[P],v=i[P+1],L=i[P+2],M=p+c*e[2*S],E=f+d*e[2*S+1],A=p+c*e[2*v],I=f+d*e[2*v+1],w=p+c*e[2*L],x=f+d*e[2*L+1];s&&(s._$PS(M,E,T),M=T[0],E=T[1],s._$PS(A,I,T),A=T[0],I=T[1],s._$PS(w,x,T),w=T[0],x=T[1]);var O=l*r[2*S],D=$-$*r[2*S+1],R=l*r[2*v],b=$-$*r[2*v+1],F=l*r[2*L],C=$-$*r[2*L+1],N=Math.atan2(b-D,R-O),B=Math.atan2(I-E,A-M),U=A-M,G=I-E,Y=Math.sqrt(U*U+G*G),k=R-O,V=b-D,X=Math.sqrt(k*k+V*V),z=Y/X;It._$ni(F,C,O,D,R-O,b-D,-(b-D),R-O,y),It._$ni(w,x,M,E,A-M,I-E,-(I-E),A-M,m);var H=(m[0]-y[0])/y[1],W=Math.min(O,R,F),j=Math.max(O,R,F),q=Math.min(D,b,C),J=Math.max(D,b,C),Q=Math.floor(W),Z=Math.floor(q),K=Math.ceil(j),tt=Math.ceil(J);g.identity(),g.translate(M,E),g.rotate(B),g.scale(1,m[1]/y[1]),g.shear(H,0),g.scale(z,z),g.rotate(-N),g.translate(-O,-D),g.setContext(u);if(n||(n=1.2),at.IGNORE_EXPAND&&(n=0),at.USE_CACHED_POLYGON_IMAGE){var it=a._$e0;if(it.gl_cacheImage=it.gl_cacheImage||{},!it.gl_cacheImage[P]){var et=nt.createCanvas(K-Q,tt-Z);at.DEBUG_DATA.LDGL_CANVAS_MB=at.DEBUG_DATA.LDGL_CANVAS_MB||0,at.DEBUG_DATA.LDGL_CANVAS_MB+=(K-Q)*(tt-Z)*4;var rt=et.getContext("2d");rt.translate(-Q,-Z),nt.clip(rt,g,n,Y,O,D,R,b,F,C,M,E,A,I,w,x),rt.drawImage(t,0,0),it.gl_cacheImage[P]={cacheCanvas:et,cacheContext:rt}}u.drawImage(it.gl_cacheImage[P].cacheCanvas,Q,Z)}else at.IGNORE_CLIP||nt.clip(u,g,n,Y,O,D,R,b,F,C,M,E,A,I,w,x),at.USE_ADJUST_TRANSLATION&&(W=0,j=l,q=0,J=$),u.drawImage(t,W,q,j-W,J-q,W,q,j-W,J-q);u.restore()}}catch(t){_._$Rb(t)}},nt.clip=function(t,i,e,r,o,n,s,_,a,h,l,$,u,p,f,c){e>.02?nt.expandClip(t,i,e,r,l,$,u,p,f,c):nt.clipWithTransform(t,null,o,n,s,_,a,h)},nt.expandClip=function(t,i,e,r,o,n,s,_,a,h){var l=s-o,$=_-n,u=a-o,p=h-n,f=l*p-$*u>0?e:-e,c=-$,d=l,g=a-s,y=h-_,m=-y,T=g,P=Math.sqrt(g*g+y*y),S=-p,v=u,L=Math.sqrt(u*u+p*p),M=o-f*c/r,E=n-f*d/r,A=s-f*c/r,I=_-f*d/r,w=s-f*m/P,x=_-f*T/P,O=a-f*m/P,D=h-f*T/P,R=o+f*S/L,b=n+f*v/L,F=a+f*S/L,C=h+f*v/L,N=nt._$50;return null!=i._$P2(N)&&(nt.clipWithTransform(t,N,M,E,A,I,w,x,O,D,F,C,R,b),!0)},nt.clipWithTransform=function(t,i,e,r,o,n,s,a){if(arguments.length<7)return void _._$li("err : @LDGL.clip()");if(!(arguments[1]instanceof gt))return void _._$li("err : a[0] is _$6 LDTransform @LDGL.clip()");var h=nt._$B,l=i,$=arguments;if(t.beginPath(),l){l._$PS($[2],$[3],h),t.moveTo(h[0],h[1]);for(var u=4;u<$.length;u+=2)l._$PS($[u],$[u+1],h),t.lineTo(h[0],h[1])}else{t.moveTo($[2],$[3]);for(var u=4;u<$.length;u+=2)t.lineTo($[u],$[u+1])}t.clip()},nt.createCanvas=function(t,i){var e=document.createElement("canvas");return e.setAttribute("width",t),e.setAttribute("height",i),e||_._$li("err : "+e),e},nt.dumpValues=function(){for(var t="",i=0;i<arguments.length;i++)t+="["+i+"]= "+arguments[i].toFixed(3)+" , ";console.log(t)},st.prototype._$F0=function(t){this._$TT=t._$_T(),this._$LT=t._$_T(),this._$FS=t._$_T(),this._$wL=t._$nP()},st.prototype.getMinValue=function(){return this._$TT},st.prototype.getMaxValue=function(){return this._$LT},st.prototype.getDefaultValue=function(){return this._$FS},st.prototype.getParamID=function(){return this._$wL},_t.prototype._$yo=function(){return this._$AT&&!this._$JS},_t.prototype._$hS=function(t){this._$AT=t},_t.prototype._$GT=function(){return this._$e0},_t.prototype._$l2=function(t){this._$IP=t},_t.prototype.getPartsIndex=function(){return this._$IP},_t.prototype._$x2=function(){return this._$JS},_t.prototype._$Ib=function(t){this._$JS=t},_t.prototype.getTotalScale=function(){return this.totalScale},_t.prototype.setTotalScale_notForClient=function(t){this.totalScale=t},_t.prototype.getInterpolatedOpacity=function(){return this._$7s},_t.prototype.setInterpolatedOpacity=function(t){this._$7s=t},_t.prototype.getTotalOpacity=function(t){return this.totalOpacity},_t.prototype.setTotalOpacity=function(t){this.totalOpacity=t},at._$2s="2.1.00_1",at._$Kr=201001e3,at._$sP=!0,at._$so=!0,at._$cb=!1,at._$3T=!0,at._$Ts=!0,at._$fb=!0,at._$ts=!0,at.L2D_DEFORMER_EXTEND=!0,at._$Wb=!1;at._$yr=!1,at._$Zs=!1,at.L2D_NO_ERROR=0,at._$i7=1e3,at._$9s=1001,at._$es=1100,at._$r7=2e3,at._$07=2001,at._$b7=2002,at._$H7=4e3,at.L2D_COLOR_BLEND_MODE_MULT=0,at.L2D_COLOR_BLEND_MODE_ADD=1,at.L2D_COLOR_BLEND_MODE_INTERPOLATE=2,at._$6b=!0,at._$cT=0,at.clippingMaskBufferSize=256,at.glContext=new Array,at.frameBuffers=new Array,at.fTexture=new Array,at.IGNORE_CLIP=!1,at.IGNORE_EXPAND=!1,at.EXPAND_W=2,at.USE_ADJUST_TRANSLATION=!0,at.USE_CANVAS_TRANSFORM=!0,at.USE_CACHED_POLYGON_IMAGE=!1,at.DEBUG_DATA={},at.PROFILE_IOS_SPEED={PROFILE_NAME:"iOS Speed",USE_ADJUST_TRANSLATION:!0,USE_CACHED_POLYGON_IMAGE:!0,EXPAND_W:4},at.PROFILE_IOS_QUALITY={PROFILE_NAME:"iOS HiQ",USE_ADJUST_TRANSLATION:!0,USE_CACHED_POLYGON_IMAGE:!1,EXPAND_W:2},at.PROFILE_IOS_DEFAULT=at.PROFILE_IOS_QUALITY,at.PROFILE_ANDROID={PROFILE_NAME:"Android",USE_ADJUST_TRANSLATION:!1,USE_CACHED_POLYGON_IMAGE:!1,EXPAND_W:2},at.PROFILE_DESKTOP={PROFILE_NAME:"Desktop",USE_ADJUST_TRANSLATION:!1,USE_CACHED_POLYGON_IMAGE:!1,EXPAND_W:2},at.initProfile=function(){Et.isIOS()?at.setupProfile(at.PROFILE_IOS_DEFAULT):Et.isAndroid()?at.setupProfile(at.PROFILE_ANDROID):at.setupProfile(at.PROFILE_DESKTOP)},at.setupProfile=function(t,i){if("number"==typeof t)switch(t){case 9901:t=at.PROFILE_IOS_SPEED;break;case 9902:t=at.PROFILE_IOS_QUALITY;break;case 9903:t=at.PROFILE_IOS_DEFAULT;break;case 9904:t=at.PROFILE_ANDROID;break;case 9905:t=at.PROFILE_DESKTOP;break;default:alert("profile _$6 _$Ui : "+t)}arguments.length<2&&(i=!0),i&&console.log("profile : "+t.PROFILE_NAME);for(var e in t)at[e]=t[e],i&&console.log("  ["+e+"] = "+t[e])},at.init=function(){if(at._$6b){console.log("Live2D %s",at._$2s),at._$6b=!1;!0,at.initProfile()}},at.getVersionStr=function(){return at._$2s},at.getVersionNo=function(){return at._$Kr},at._$sT=function(t){at._$cT=t},at.getError=function(){var t=at._$cT;return at._$cT=0,t},at.dispose=function(){at.glContext=[],at.frameBuffers=[],at.fTexture=[]},at.setGL=function(t,i){var e=i||0;at.glContext[e]=t},at.getGL=function(t){return at.glContext[t]},at.setClippingMaskBufferSize=function(t){at.clippingMaskBufferSize=t},at.getClippingMaskBufferSize=function(){return at.clippingMaskBufferSize},at.deleteBuffer=function(t){at.getGL(t).deleteFramebuffer(at.frameBuffers[t].framebuffer),delete at.frameBuffers[t],delete at.glContext[t]},ht._$r2=function(t){return t<0?0:t>1?1:.5-.5*Math.cos(t*Lt.PI_F)},lt._$fr=-1,lt.prototype.toString=function(){return this._$ib},$t.prototype=new W,$t._$42=0,$t._$Os=30,$t._$ms=0,$t._$ns=1,$t._$_s=2,$t._$gT=new Array,$t.prototype._$_S=function(t){this._$LP=t},$t.prototype.getTextureNo=function(){return this._$LP},$t.prototype._$ZL=function(){return this._$Qi},$t.prototype._$H2=function(){return this._$JP},$t.prototype.getNumPoints=function(){return this._$d0},$t.prototype.getType=function(){return W._$wb},$t.prototype._$B2=function(t,i,e){var r=i,o=null!=r._$hr?r._$hr:r._$Cr;switch(U._$do){default:case U._$Ms:throw new Error("_$L _$ro ");case U._$Qs:for(var n=this._$d0-1;n>=0;--n)o[n*U._$No+4]=e}},$t.prototype._$zP=function(){this._$GS=new D,this._$GS._$zP()},$t.prototype._$F0=function(t){W.prototype._$F0.call(this,t),this._$LP=t._$6L(),this._$d0=t._$6L(),this._$Yo=t._$6L();var i=t._$nP();this._$BP=new Int16Array(3*this._$Yo);for(var e=3*this._$Yo-1;e>=0;--e)this._$BP[e]=i[e];if(this._$Eo=t._$nP(),this._$Qi=t._$nP(),t.getFormatVersion()>=G._$s7){if(this._$JP=t._$6L(),0!=this._$JP){if(0!=(1&this._$JP)){var r=t._$6L();null==this._$5P&&(this._$5P=new Object),this._$5P._$Hb=parseInt(r)}0!=(this._$JP&$t._$Os)?this._$6s=(this._$JP&$t._$Os)>>1:this._$6s=$t._$ms,0!=(32&this._$JP)&&(this.culling=!1)}}else this._$JP=0},$t.prototype.init=function(t){var i=new ut(this),e=this._$d0*U._$No,r=this._$32();switch(null!=i._$Cr&&(i._$Cr=null),i._$Cr=new Float32Array(e),null!=i._$hr&&(i._$hr=null),i._$hr=r?new Float32Array(e):null,U._$do){default:case U._$Ms:if(U._$Ls)for(var o=this._$d0-1;o>=0;--o){var n=o<<1;this._$Qi[n+1]=1-this._$Qi[n+1]}break;case U._$Qs:for(var o=this._$d0-1;o>=0;--o){var n=o<<1,s=o*U._$No,_=this._$Qi[n],a=this._$Qi[n+1];i._$Cr[s]=_,i._$Cr[s+1]=a,i._$Cr[s+4]=0,r&&(i._$hr[s]=_,i._$hr[s+1]=a,i._$hr[s+4]=0)}}return i},$t.prototype._$Nr=function(t,i){var e=i;if(this!=e._$GT()&&console.log("### assert!! ### "),this._$GS._$Ur(t)&&(W.prototype._$Nr.call(this,t,e),!e._$IS[0])){var r=$t._$gT;r[0]=!1,v._$Vr(t,this._$GS,r,this._$d0,this._$Eo,e._$Cr,U._$i2,U._$No)}},$t.prototype._$2b=function(t,i){try{this!=i._$GT()&&console.log("### assert!! ### ");var e=!1;i._$IS[0]&&(e=!0);var r=i;if(!e&&(W.prototype._$2b.call(this,t),this._$32())){var o=this.getTargetBaseDataID();if(r._$8r==W._$ur&&(r._$8r=t.getBaseDataIndex(o)),r._$8r<0)at._$so&&_._$li("_$L _$0P _$G :: %s",o);else{var n=t.getBaseData(r._$8r),s=t._$q2(r._$8r);null==n||s._$x2()?r._$AT=!1:(n._$nb(t,s,r._$Cr,r._$hr,this._$d0,U._$i2,U._$No),r._$AT=!0),r.baseOpacity=s.getTotalOpacity()}}}catch(t){throw t}},$t.prototype.draw=function(t,i,e){if(this!=e._$GT()&&console.log("### assert!! ### "),!e._$IS[0]){var r=e,o=this._$LP;o<0&&(o=1);var n=this.getOpacity(i,r)*e._$VS*e.baseOpacity,s=null!=r._$hr?r._$hr:r._$Cr;t.setClipBufPre_clipContextForDraw(e.clipBufPre_clipContext),t._$WP(this.culling),t._$Uo(o,3*this._$Yo,this._$BP,s,this._$Qi,n,this._$6s,r)}},$t.prototype.dump=function(){console.log("  _$yi( %d ) , _$d0( %d ) , _$Yo( %d ) \\n",this._$LP,this._$d0,this._$Yo),console.log("  _$Oi _$di = { ");for(var t=0;t<this._$BP.length;t++)console.log("%5d ,",this._$BP[t]);console.log("\\n  _$5i _$30");for(var t=0;t<this._$Eo.length;t++){console.log("\\n    _$30[%d] = ",t);for(var i=this._$Eo[t],e=0;e<i.length;e++)console.log("%6.2f, ",i[e])}console.log("\\n")},$t.prototype._$72=function(t){return null==this._$5P?null:this._$5P[t]},$t.prototype.getIndexArray=function(){return this._$BP},ut.prototype=new Mt,ut.prototype.getTransformedPoints=function(){return null!=this._$hr?this._$hr:this._$Cr},pt.prototype._$HT=function(t){this.x=t.x,this.y=t.y},pt.prototype._$HT=function(t,i){this.x=t,this.y=i},ft.prototype=new i,ft.loadModel=function(t){var e=new ft;return i._$62(e,t),e},ft.loadModel=function(t,e){var r=e||0,o=new ft(r);return i._$62(o,t),o},ft._$to=function(){return new ft},ft._$er=function(t){var i=new _$5("../_$_r/_$t0/_$Ri/_$_P._$d");if(0==i.exists())throw new _$ls("_$t0 _$_ _$6 _$Ui :: "+i._$PL());for(var e=["../_$_r/_$t0/_$Ri/_$_P.512/_$CP._$1","../_$_r/_$t0/_$Ri/_$_P.512/_$vP._$1","../_$_r/_$t0/_$Ri/_$_P.512/_$EP._$1","../_$_r/_$t0/_$Ri/_$_P.512/_$pP._$1"],r=ft.loadModel(i._$3b()),o=0;o<e.length;o++){var n=new _$5(e[o]);if(0==n.exists())throw new _$ls("_$t0 _$_ _$6 _$Ui :: "+n._$PL());r.setTexture(o,_$nL._$_o(t,n._$3b()))}return r},ft.prototype.setGL=function(t){at.setGL(t)},ft.prototype.setTransform=function(t){this.drawParamWebGL.setTransform(t)},ft.prototype.update=function(){this._$5S.update(),this._$5S.preDraw(this.drawParamWebGL)},ft.prototype.draw=function(){this._$5S.draw(this.drawParamWebGL)},ft.prototype._$K2=function(){this.drawParamWebGL._$K2()},ft.prototype.setTexture=function(t,i){null==this.drawParamWebGL&&_._$li("_$Yi for QT _$ki / _$XS() is _$6 _$ui!!"),this.drawParamWebGL.setTexture(t,i)},ft.prototype.setTexture=function(t,i){null==this.drawParamWebGL&&_._$li("_$Yi for QT _$ki / _$XS() is _$6 _$ui!!"),this.drawParamWebGL.setTexture(t,i)},ft.prototype._$Rs=function(){return this.drawParamWebGL._$Rs()},ft.prototype._$Ds=function(t){this.drawParamWebGL._$Ds(t)},ft.prototype.getDrawParam=function(){return this.drawParamWebGL},ft.prototype.setMatrix=function(t){this.drawParamWebGL.setMatrix(t)},ft.prototype.setPremultipliedAlpha=function(t){this.drawParamWebGL.setPremultipliedAlpha(t)},ft.prototype.isPremultipliedAlpha=function(){return this.drawParamWebGL.isPremultipliedAlpha()},ft.prototype.setAnisotropy=function(t){this.drawParamWebGL.setAnisotropy(t)},ft.prototype.getAnisotropy=function(){return this.drawParamWebGL.getAnisotropy()},ct.prototype._$tb=function(){return this.motions},ct.prototype.startMotion=function(t,i){for(var e=null,r=this.motions.length,o=0;o<r;++o)null!=(e=this.motions[o])&&(e._$qS(e._$w0.getFadeOut()),this._$eb&&_._$Ji("MotionQueueManager[size:%2d]->startMotion() / start _$K _$3 (m%d)\\n",r,e._$sr));if(null==t)return-1;e=new dt,e._$w0=t,this.motions.push(e);var n=e._$sr;return this._$eb&&_._$Ji("MotionQueueManager[size:%2d]->startMotion() / new _$w0 (m%d)\\n",r,n),n},ct.prototype.updateParam=function(t){try{for(var i=!1,e=0;e<this.motions.length;e++){var r=this.motions[e];if(null!=r){var o=r._$w0;null!=o?(o.updateParam(t,r),i=!0,r.isFinished()&&(this._$eb&&_._$Ji("MotionQueueManager[size:%2d]->updateParam() / _$T0 _$w0 (m%d)\\n",this.motions.length-1,r._$sr),this.motions.splice(e,1),e--)):(this.motions=this.motions.splice(e,1),e--)}else this.motions.splice(e,1),e--}return i}catch(t){return _._$li(t),!0}},ct.prototype.isFinished=function(t){if(arguments.length>=1){for(var i=0;i<this.motions.length;i++){var e=this.motions[i];if(null!=e&&(e._$sr==t&&!e.isFinished()))return!1}return!0}for(var i=0;i<this.motions.length;i++){var e=this.motions[i];if(null!=e){if(null!=e._$w0){if(!e.isFinished())return!1}else this.motions.splice(i,1),i--}else this.motions.splice(i,1),i--}return!0},ct.prototype.stopAllMotions=function(){for(var t=0;t<this.motions.length;t++){var i=this.motions[t];if(null!=i){i._$w0;this.motions.splice(t,1),t--}else this.motions.splice(t,1),t--}},ct.prototype._$Zr=function(t){this._$eb=t},ct.prototype._$e=function(){console.log("-- _$R --\\n");for(var t=0;t<this.motions.length;t++){var i=this.motions[t],e=i._$w0;console.log("MotionQueueEnt[%d] :: %s\\n",this.motions.length,e.toString())}},dt._$Gs=0,dt.prototype.isFinished=function(){return this._$9L},dt.prototype._$qS=function(t){var i=w.getUserTimeMSec(),e=i+t;(this._$Do<0||e<this._$Do)&&(this._$Do=e)},dt.prototype._$Bs=function(){return this._$sr},gt.prototype.setContext=function(t){var i=this.m;t.transform(i[0],i[1],i[3],i[4],i[6],i[7])},gt.prototype.toString=function(){for(var t="LDTransform { ",i=0;i<9;i++)t+=this.m[i].toFixed(2)+" ,";return t+=" }"},gt.prototype.identity=function(){var t=this.m;t[0]=t[4]=t[8]=1,t[1]=t[2]=t[3]=t[5]=t[6]=t[7]=0},gt.prototype._$PS=function(t,i,e){null==e&&(e=new Array(0,0));var r=this.m;return e[0]=r[0]*t+r[3]*i+r[6],e[1]=r[1]*t+r[4]*i+r[7],e},gt.prototype._$P2=function(t){t||(t=new gt);var i=this.m,e=i[0],r=i[1],o=i[2],n=i[3],s=i[4],_=i[5],a=i[6],h=i[7],l=i[8],$=e*s*l+r*_*a+o*n*h-e*_*h-o*s*a-r*n*l;if(0==$)return null;var u=1/$;return t.m[0]=u*(s*l-h*_),t.m[1]=u*(h*o-r*l),t.m[2]=u*(r*_-s*o),t.m[3]=u*(a*_-n*l),t.m[4]=u*(e*l-a*o),t.m[5]=u*(n*o-e*_),t.m[6]=u*(n*h-a*s),t.m[7]=u*(a*r-e*h),t.m[8]=u*(e*s-n*r),t},gt.prototype.transform=function(t,i,e){null==e&&(e=new Array(0,0));var r=this.m;return e[0]=r[0]*t+r[3]*i+r[6],e[1]=r[1]*t+r[4]*i+r[7],e},gt.prototype.translate=function(t,i){var e=this.m;e[6]=e[0]*t+e[3]*i+e[6],e[7]=e[1]*t+e[4]*i+e[7],e[8]=e[2]*t+e[5]*i+e[8]},gt.prototype.scale=function(t,i){var e=this.m;e[0]*=t,e[1]*=t,e[2]*=t,e[3]*=i,e[4]*=i,e[5]*=i},gt.prototype.shear=function(t,i){var e=this.m,r=e[0]+e[3]*i,o=e[1]+e[4]*i,n=e[2]+e[5]*i;e[3]=e[0]*t+e[3],e[4]=e[1]*t+e[4],e[5]=e[2]*t+e[5],e[0]=r,e[1]=o,e[2]=n},gt.prototype.rotate=function(t){var i=this.m,e=Math.cos(t),r=Math.sin(t),o=i[0]*e+i[3]*r,n=i[1]*e+i[4]*r,s=i[2]*e+i[5]*r;i[3]=-i[0]*r+i[3]*e,i[4]=-i[1]*r+i[4]*e,i[5]=-i[2]*r+i[5]*e,i[0]=o,i[1]=n,i[2]=s},gt.prototype.concatenate=function(t){var i=this.m,e=t.m,r=i[0]*e[0]+i[3]*e[1]+i[6]*e[2],o=i[1]*e[0]+i[4]*e[1]+i[7]*e[2],n=i[2]*e[0]+i[5]*e[1]+i[8]*e[2],s=i[0]*e[3]+i[3]*e[4]+i[6]*e[5],_=i[1]*e[3]+i[4]*e[4]+i[7]*e[5],a=i[2]*e[3]+i[5]*e[4]+i[8]*e[5],h=i[0]*e[6]+i[3]*e[7]+i[6]*e[8],l=i[1]*e[6]+i[4]*e[7]+i[7]*e[8],$=i[2]*e[6]+i[5]*e[7]+i[8]*e[8];m[0]=r,m[1]=o,m[2]=n,m[3]=s,m[4]=_,m[5]=a,m[6]=h,m[7]=l,m[8]=$},yt.prototype=new et,yt._$eT=null,yt._$tP=new Object,yt._$2o=function(){return null==yt._$eT&&(yt._$eT=yt.getID("DST_BASE")),yt._$eT},yt._$27=function(){yt._$tP.clear(),yt._$eT=null},yt.getID=function(t){var i=yt._$tP[t];return null==i&&(i=new yt(t),yt._$tP[t]=i),i},yt.prototype._$3s=function(){return new yt},mt.prototype=new E,mt._$9r=function(t){return new Float32Array(t)},mt._$vb=function(t){return new Int16Array(t)},mt._$cr=function(t,i){return null==t||t._$yL()<i.length?(t=mt._$9r(2*i.length),t.put(i),t._$oT(0)):(t.clear(),t.put(i),t._$oT(0)),t},mt._$mb=function(t,i){return null==t||t._$yL()<i.length?(t=mt._$vb(2*i.length),t.put(i),t._$oT(0)):(t.clear(),t.put(i),t._$oT(0)),t},mt._$Hs=function(){return this._$Gr},mt._$as=function(t){this._$Gr=t},mt.prototype.getGL=function(){return this.gl},mt.prototype.setGL=function(t){this.gl=t},mt.prototype.setTransform=function(t){this.transform=t},mt.prototype._$ZT=function(){var t=this.gl;this.firstDraw&&(this.initShader(),this.firstDraw=!1,this.anisotropyExt=t.getExtension("EXT_texture_filter_anisotropic")||t.getExtension("WEBKIT_EXT_texture_filter_anisotropic")||t.getExtension("MOZ_EXT_texture_filter_anisotropic"),this.anisotropyExt&&(this.maxAnisotropy=t.getParameter(this.anisotropyExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT))),t.disable(t.SCISSOR_TEST),t.disable(t.STENCIL_TEST),t.disable(t.DEPTH_TEST),t.frontFace(t.CW),t.enable(t.BLEND),t.colorMask(1,1,1,1),t.bindBuffer(t.ARRAY_BUFFER,null),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)},mt.prototype._$Uo=function(t,i,e,r,o,n,s,_){if(!(n<.01&&null==this.clipBufPre_clipContextMask)){var a=(n>.9&&at.EXPAND_W,this.gl);if(null==this.gl)throw new Error("gl is null");var h=1*this._$C0*n,l=1*this._$tT*n,$=1*this._$WL*n,u=this._$lT*n;if(null!=this.clipBufPre_clipContextMask){a.frontFace(a.CCW),a.useProgram(this.shaderProgram),this._$vS=Tt(a,this._$vS,r),this._$no=Pt(a,this._$no,e),a.enableVertexAttribArray(this.a_position_Loc),a.vertexAttribPointer(this.a_position_Loc,2,a.FLOAT,!1,0,0),this._$NT=Tt(a,this._$NT,o),a.activeTexture(a.TEXTURE1),a.bindTexture(a.TEXTURE_2D,this.textures[t]),a.uniform1i(this.s_texture0_Loc,1),a.enableVertexAttribArray(this.a_texCoord_Loc),a.vertexAttribPointer(this.a_texCoord_Loc,2,a.FLOAT,!1,0,0),a.uniformMatrix4fv(this.u_matrix_Loc,!1,this.getClipBufPre_clipContextMask().matrixForMask);var p=this.getClipBufPre_clipContextMask().layoutChannelNo,f=this.getChannelFlagAsColor(p);a.uniform4f(this.u_channelFlag,f.r,f.g,f.b,f.a);var c=this.getClipBufPre_clipContextMask().layoutBounds;a.uniform4f(this.u_baseColor_Loc,2*c.x-1,2*c.y-1,2*c._$EL()-1,2*c._$5T()-1),a.uniform1i(this.u_maskFlag_Loc,!0)}else if(null!=this.getClipBufPre_clipContextDraw()){a.useProgram(this.shaderProgramOff),this._$vS=Tt(a,this._$vS,r),this._$no=Pt(a,this._$no,e),a.enableVertexAttribArray(this.a_position_Loc_Off),a.vertexAttribPointer(this.a_position_Loc_Off,2,a.FLOAT,!1,0,0),this._$NT=Tt(a,this._$NT,o),a.activeTexture(a.TEXTURE1),a.bindTexture(a.TEXTURE_2D,this.textures[t]),a.uniform1i(this.s_texture0_Loc_Off,1),a.enableVertexAttribArray(this.a_texCoord_Loc_Off),a.vertexAttribPointer(this.a_texCoord_Loc_Off,2,a.FLOAT,!1,0,0),a.uniformMatrix4fv(this.u_clipMatrix_Loc_Off,!1,this.getClipBufPre_clipContextDraw().matrixForDraw),a.uniformMatrix4fv(this.u_matrix_Loc_Off,!1,this.matrix4x4),a.activeTexture(a.TEXTURE2),a.bindTexture(a.TEXTURE_2D,at.fTexture[this.glno]),a.uniform1i(this.s_texture1_Loc_Off,2);var p=this.getClipBufPre_clipContextDraw().layoutChannelNo,f=this.getChannelFlagAsColor(p);a.uniform4f(this.u_channelFlag_Loc_Off,f.r,f.g,f.b,f.a),a.uniform4f(this.u_baseColor_Loc_Off,h,l,$,u)}else a.useProgram(this.shaderProgram),this._$vS=Tt(a,this._$vS,r),this._$no=Pt(a,this._$no,e),a.enableVertexAttribArray(this.a_position_Loc),a.vertexAttribPointer(this.a_position_Loc,2,a.FLOAT,!1,0,0),this._$NT=Tt(a,this._$NT,o),a.activeTexture(a.TEXTURE1),a.bindTexture(a.TEXTURE_2D,this.textures[t]),a.uniform1i(this.s_texture0_Loc,1),a.enableVertexAttribArray(this.a_texCoord_Loc),a.vertexAttribPointer(this.a_texCoord_Loc,2,a.FLOAT,!1,0,0),a.uniformMatrix4fv(this.u_matrix_Loc,!1,this.matrix4x4),a.uniform4f(this.u_baseColor_Loc,h,l,$,u),a.uniform1i(this.u_maskFlag_Loc,!1);this.culling?this.gl.enable(a.CULL_FACE):this.gl.disable(a.CULL_FACE),this.gl.enable(a.BLEND);var d,g,y,m;if(null!=this.clipBufPre_clipContextMask)d=a.ONE,g=a.ONE_MINUS_SRC_ALPHA,y=a.ONE,m=a.ONE_MINUS_SRC_ALPHA;else switch(s){case $t._$ms:d=a.ONE,g=a.ONE_MINUS_SRC_ALPHA,y=a.ONE,m=a.ONE_MINUS_SRC_ALPHA;break;case $t._$ns:d=a.ONE,g=a.ONE,y=a.ZERO,m=a.ONE;break;case $t._$_s:d=a.DST_COLOR,g=a.ONE_MINUS_SRC_ALPHA,y=a.ZERO,m=a.ONE}a.blendEquationSeparate(a.FUNC_ADD,a.FUNC_ADD),a.blendFuncSeparate(d,g,y,m),this.anisotropyExt&&a.texParameteri(a.TEXTURE_2D,this.anisotropyExt.TEXTURE_MAX_ANISOTROPY_EXT,this.maxAnisotropy);var T=e.length;a.drawElements(a.TRIANGLES,T,a.UNSIGNED_SHORT,0),a.bindTexture(a.TEXTURE_2D,null)}},mt.prototype._$Rs=function(){throw new Error("_$Rs")},mt.prototype._$Ds=function(t){throw new Error("_$Ds")},mt.prototype._$K2=function(){for(var t=0;t<this.textures.length;t++){0!=this.textures[t]&&(this.gl._$K2(1,this.textures,t),this.textures[t]=null)}},mt.prototype.setTexture=function(t,i){this.textures[t]=i},mt.prototype.initShader=function(){var t=this.gl;this.loadShaders2(),this.a_position_Loc=t.getAttribLocation(this.shaderProgram,"a_position"),this.a_texCoord_Loc=t.getAttribLocation(this.shaderProgram,"a_texCoord"),this.u_matrix_Loc=t.getUniformLocation(this.shaderProgram,"u_mvpMatrix"),this.s_texture0_Loc=t.getUniformLocation(this.shaderProgram,"s_texture0"),this.u_channelFlag=t.getUniformLocation(this.shaderProgram,"u_channelFlag"),this.u_baseColor_Loc=t.getUniformLocation(this.shaderProgram,"u_baseColor"),this.u_maskFlag_Loc=t.getUniformLocation(this.shaderProgram,"u_maskFlag"),this.a_position_Loc_Off=t.getAttribLocation(this.shaderProgramOff,"a_position"),this.a_texCoord_Loc_Off=t.getAttribLocation(this.shaderProgramOff,"a_texCoord"),this.u_matrix_Loc_Off=t.getUniformLocation(this.shaderProgramOff,"u_mvpMatrix"),this.u_clipMatrix_Loc_Off=t.getUniformLocation(this.shaderProgramOff,"u_ClipMatrix"),this.s_texture0_Loc_Off=t.getUniformLocation(this.shaderProgramOff,"s_texture0"),this.s_texture1_Loc_Off=t.getUniformLocation(this.shaderProgramOff,"s_texture1"),this.u_channelFlag_Loc_Off=t.getUniformLocation(this.shaderProgramOff,"u_channelFlag"),this.u_baseColor_Loc_Off=t.getUniformLocation(this.shaderProgramOff,"u_baseColor")},mt.prototype.disposeShader=function(){var t=this.gl;this.shaderProgram&&(t.deleteProgram(this.shaderProgram),this.shaderProgram=null),this.shaderProgramOff&&(t.deleteProgram(this.shaderProgramOff),this.shaderProgramOff=null)},mt.prototype.compileShader=function(t,i){var e=this.gl,r=i,o=e.createShader(t);if(null==o)return _._$Ji("_$L0 to create shader"),null;if(e.shaderSource(o,r),e.compileShader(o),!e.getShaderParameter(o,e.COMPILE_STATUS)){var n=e.getShaderInfoLog(o);return _._$Ji("_$L0 to compile shader : "+n),e.deleteShader(o),null}return o},mt.prototype.loadShaders2=function(){var t=this.gl;if(this.shaderProgram=t.createProgram(),!this.shaderProgram)return!1;if(this.shaderProgramOff=t.createProgram(),!this.shaderProgramOff)return!1;if(this.vertShader=this.compileShader(t.VERTEX_SHADER,"attribute vec4     a_position;attribute vec2     a_texCoord;varying vec2       v_texCoord;varying vec4       v_ClipPos;uniform mat4       u_mvpMatrix;void main(){    gl_Position = u_mvpMatrix * a_position;    v_ClipPos = u_mvpMatrix * a_position;    v_texCoord = a_texCoord;}"),!this.vertShader)return _._$Ji("Vertex shader compile _$li!"),!1;if(this.vertShaderOff=this.compileShader(t.VERTEX_SHADER,"attribute vec4     a_position;attribute vec2     a_texCoord;varying vec2       v_texCoord;varying vec4       v_ClipPos;uniform mat4       u_mvpMatrix;uniform mat4       u_ClipMatrix;void main(){    gl_Position = u_mvpMatrix * a_position;    v_ClipPos = u_ClipMatrix * a_position;    v_texCoord = a_texCoord ;}"),!this.vertShaderOff)return _._$Ji("OffVertex shader compile _$li!"),!1;if(this.fragShader=this.compileShader(t.FRAGMENT_SHADER,"precision mediump float;varying vec2       v_texCoord;varying vec4       v_ClipPos;uniform sampler2D  s_texture0;uniform vec4       u_channelFlag;uniform vec4       u_baseColor;uniform bool       u_maskFlag;void main(){    vec4 smpColor;     if(u_maskFlag){        float isInside =             step(u_baseColor.x, v_ClipPos.x/v_ClipPos.w)          * step(u_baseColor.y, v_ClipPos.y/v_ClipPos.w)          * step(v_ClipPos.x/v_ClipPos.w, u_baseColor.z)          * step(v_ClipPos.y/v_ClipPos.w, u_baseColor.w);        smpColor = u_channelFlag * texture2D(s_texture0 , v_texCoord).a * isInside;    }else{        smpColor = texture2D(s_texture0 , v_texCoord) * u_baseColor;    }    gl_FragColor = smpColor;}"),!this.fragShader)return _._$Ji("Fragment shader compile _$li!"),!1;if(this.fragShaderOff=this.compileShader(t.FRAGMENT_SHADER,"precision mediump float ;varying vec2       v_texCoord;varying vec4       v_ClipPos;uniform sampler2D  s_texture0;uniform sampler2D  s_texture1;uniform vec4       u_channelFlag;uniform vec4       u_baseColor ;void main(){    vec4 col_formask = texture2D(s_texture0, v_texCoord) * u_baseColor;    vec4 clipMask = texture2D(s_texture1, v_ClipPos.xy / v_ClipPos.w) * u_channelFlag;    float maskVal = clipMask.r + clipMask.g + clipMask.b + clipMask.a;    col_formask = col_formask * maskVal;    gl_FragColor = col_formask;}"),!this.fragShaderOff)return _._$Ji("OffFragment shader compile _$li!"),!1;if(t.attachShader(this.shaderProgram,this.vertShader),t.attachShader(this.shaderProgram,this.fragShader),t.attachShader(this.shaderProgramOff,this.vertShaderOff),t.attachShader(this.shaderProgramOff,this.fragShaderOff),t.linkProgram(this.shaderProgram),t.linkProgram(this.shaderProgramOff),!t.getProgramParameter(this.shaderProgram,t.LINK_STATUS)){var i=t.getProgramInfoLog(this.shaderProgram);return _._$Ji("_$L0 to link program: "+i),this.vertShader&&(t.deleteShader(this.vertShader),this.vertShader=0),this.fragShader&&(t.deleteShader(this.fragShader),this.fragShader=0),this.shaderProgram&&(t.deleteProgram(this.shaderProgram),this.shaderProgram=0),this.vertShaderOff&&(t.deleteShader(this.vertShaderOff),this.vertShaderOff=0),this.fragShaderOff&&(t.deleteShader(this.fragShaderOff),this.fragShaderOff=0),this.shaderProgramOff&&(t.deleteProgram(this.shaderProgramOff),this.shaderProgramOff=0),!1}return!0},mt.prototype.createFramebuffer=function(){var t=this.gl,i=at.clippingMaskBufferSize,e=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,e);var r=t.createRenderbuffer();t.bindRenderbuffer(t.RENDERBUFFER,r),t.renderbufferStorage(t.RENDERBUFFER,t.RGBA4,i,i),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.RENDERBUFFER,r);var o=t.createTexture();return t.bindTexture(t.TEXTURE_2D,o),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,i,i,0,t.RGBA,t.UNSIGNED_BYTE,null),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,o,0),t.bindTexture(t.TEXTURE_2D,null),t.bindRenderbuffer(t.RENDERBUFFER,null),t.bindFramebuffer(t.FRAMEBUFFER,null),at.fTexture[this.glno]=o,{framebuffer:e,renderbuffer:r,texture:at.fTexture[this.glno]}},St.prototype._$fP=function(){var t,i,e,r=this._$ST();if(0==(128&r))return 255&r;if(0==(128&(t=this._$ST())))return(127&r)<<7|127&t;if(0==(128&(i=this._$ST())))return(127&r)<<14|(127&t)<<7|255&i;if(0==(128&(e=this._$ST())))return(127&r)<<21|(127&t)<<14|(127&i)<<7|255&e;throw new lt("_$L _$0P  _")},St.prototype.getFormatVersion=function(){return this._$S2},St.prototype._$gr=function(t){this._$S2=t},St.prototype._$3L=function(){return this._$fP()},St.prototype._$mP=function(){return this._$zT(),this._$F+=8,this._$T.getFloat64(this._$F-8)},St.prototype._$_T=function(){return this._$zT(),this._$F+=4,this._$T.getFloat32(this._$F-4)},St.prototype._$6L=function(){return this._$zT(),this._$F+=4,this._$T.getInt32(this._$F-4)},St.prototype._$ST=function(){return this._$zT(),this._$T.getInt8(this._$F++)},St.prototype._$9T=function(){return this._$zT(),this._$F+=2,this._$T.getInt16(this._$F-2)},St.prototype._$2T=function(){throw this._$zT(),this._$F+=8,new lt("_$L _$q read long")},St.prototype._$po=function(){return this._$zT(),0!=this._$T.getInt8(this._$F++)};var xt=!0;St.prototype._$bT=function(){this._$zT();var t=this._$3L(),i=null;if(xt)try{var e=new ArrayBuffer(2*t);i=new Uint16Array(e);for(var r=0;r<t;++r)i[r]=this._$T.getUint8(this._$F++);return String.fromCharCode.apply(null,i)}catch(t){xt=!1}try{var o=new Array;if(null==i)for(var r=0;r<t;++r)o[r]=this._$T.getUint8(this._$F++);else for(var r=0;r<t;++r)o[r]=i[r];return String.fromCharCode.apply(null,o)}catch(t){console.log("read utf8 / _$rT _$L0 !! : "+t)}},St.prototype._$cS=function(){this._$zT();for(var t=this._$3L(),i=new Int32Array(t),e=0;e<t;e++)i[e]=this._$T.getInt32(this._$F),this._$F+=4;return i},St.prototype._$Tb=function(){this._$zT();for(var t=this._$3L(),i=new Float32Array(t),e=0;e<t;e++)i[e]=this._$T.getFloat32(this._$F),this._$F+=4;return i},St.prototype._$5b=function(){this._$zT();for(var t=this._$3L(),i=new Float64Array(t),e=0;e<t;e++)i[e]=this._$T.getFloat64(this._$F),this._$F+=8;return i},St.prototype._$nP=function(){return this._$Jb(-1)},St.prototype._$Jb=function(t){if(this._$zT(),t<0&&(t=this._$3L()),t==G._$7P){var i=this._$6L();if(0<=i&&i<this._$Ko.length)return this._$Ko[i];throw new lt("_$sL _$4i @_$m0")}var e=this._$4b(t);return this._$Ko.push(e),e},St.prototype._$4b=function(t){if(0==t)return null;if(50==t){var i=this._$bT(),e=b.getID(i);return e}if(51==t){var i=this._$bT(),e=yt.getID(i);return e}if(134==t){var i=this._$bT(),e=l.getID(i);return e}if(60==t){var i=this._$bT(),e=u.getID(i);return e}if(t>=48){var r=G._$9o(t);return null!=r?(r._$F0(this),r):null}switch(t){case 1:return this._$bT();case 10:return new n(this._$6L(),!0);case 11:return new S(this._$mP(),this._$mP(),this._$mP(),this._$mP());case 12:return new S(this._$_T(),this._$_T(),this._$_T(),this._$_T());case 13:return new L(this._$mP(),this._$mP());case 14:return new L(this._$_T(),this._$_T());case 15:for(var o=this._$3L(),e=new Array(o),s=0;s<o;s++)e[s]=this._$nP();return e;case 17:var e=new F(this._$mP(),this._$mP(),this._$mP(),this._$mP(),this._$mP(),this._$mP());return e;case 21:return new h(this._$6L(),this._$6L(),this._$6L(),this._$6L());case 22:return new pt(this._$6L(),this._$6L());case 23:throw new Error("_$L _$ro ");case 16:case 25:return this._$cS();case 26:return this._$5b();case 27:return this._$Tb();case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 18:case 19:case 20:case 24:case 28:throw new lt("_$6 _$q : _$nP() of 2-9 ,18,19,20,24,28 : "+t);default:throw new lt("_$6 _$q : _$nP() NO _$i : "+t)}},St.prototype._$8L=function(){return 0==this._$hL?this._$v0=this._$ST():8==this._$hL&&(this._$v0=this._$ST(),this._$hL=0),1==(this._$v0>>7-this._$hL++&1)},St.prototype._$zT=function(){0!=this._$hL&&(this._$hL=0)},vt.prototype._$wP=function(t,i,e){for(var r=0;r<e;r++){for(var o=0;o<i;o++){var n=2*(o+r*i);console.log("(% 7.3f , % 7.3f) , ",t[n],t[n+1])}console.log("\\n")}console.log("\\n")},Lt._$2S=Math.PI/180,Lt._$bS=Math.PI/180,Lt._$wS=180/Math.PI,Lt._$NS=180/Math.PI,Lt.PI_F=Math.PI,Lt._$kT=[0,.012368,.024734,.037097,.049454,.061803,.074143,.086471,.098786,.111087,.12337,.135634,.147877,.160098,.172295,.184465,.196606,.208718,.220798,.232844,.244854,.256827,.268761,.280654,.292503,.304308,.316066,.327776,.339436,.351044,.362598,.374097,.385538,.396921,.408243,.419502,.430697,.441826,.452888,.463881,.474802,.485651,.496425,.507124,.517745,.528287,.538748,.549126,.559421,.56963,.579752,.589785,.599728,.609579,.619337,.629,.638567,.648036,.657406,.666676,.675843,.684908,.693867,.70272,.711466,.720103,.72863,.737045,.745348,.753536,.76161,.769566,.777405,.785125,.792725,.800204,.807561,.814793,.821901,.828884,.835739,.842467,.849066,.855535,.861873,.868079,.874153,.880093,.885898,.891567,.897101,.902497,.907754,.912873,.917853,.922692,.92739,.931946,.936359,.940629,.944755,.948737,.952574,.956265,.959809,.963207,.966457,.96956,.972514,.97532,.977976,.980482,.982839,.985045,.987101,.989006,.990759,.992361,.993811,.995109,.996254,.997248,.998088,.998776,.999312,.999694,.999924,1],Lt._$92=function(t,i){var e=Math.atan2(t[1],t[0]),r=Math.atan2(i[1],i[0]);return Lt._$tS(e,r)},Lt._$tS=function(t,i){for(var e=t-i;e<-Math.PI;)e+=2*Math.PI;for(;e>Math.PI;)e-=2*Math.PI;return e},Lt._$9=function(t){return Math.sin(t)},Lt.fcos=function(t){return Math.cos(t)},Mt.prototype._$u2=function(){return this._$IS[0]},Mt.prototype._$yo=function(){return this._$AT&&!this._$IS[0]},Mt.prototype._$GT=function(){return this._$e0},Et._$W2=0,Et.SYSTEM_INFO=null,Et.USER_AGENT=navigator.userAgent,Et.isIPhone=function(){return Et.SYSTEM_INFO||Et.setup(),Et.SYSTEM_INFO._isIPhone},Et.isIOS=function(){return Et.SYSTEM_INFO||Et.setup(),Et.SYSTEM_INFO._isIPhone||Et.SYSTEM_INFO._isIPad},Et.isAndroid=function(){return Et.SYSTEM_INFO||Et.setup(),Et.SYSTEM_INFO._isAndroid},Et.getOSVersion=function(){return Et.SYSTEM_INFO||Et.setup(),Et.SYSTEM_INFO.version},Et.getOS=function(){return Et.SYSTEM_INFO||Et.setup(),Et.SYSTEM_INFO._isIPhone||Et.SYSTEM_INFO._isIPad?"iOS":Et.SYSTEM_INFO._isAndroid?"Android":"_$Q0 OS"},Et.setup=function(){function t(t,i){for(var e=t.substring(i).split(/[ _,;\\.]/),r=0,o=0;o<=2&&!isNaN(e[o]);o++){var n=parseInt(e[o]);if(n<0||n>999){_._$li("err : "+n+" @UtHtml5.setup()"),r=0;break}r+=n*Math.pow(1e3,2-o)}return r}var i,e=Et.USER_AGENT,r=Et.SYSTEM_INFO={userAgent:e};if((i=e.indexOf("iPhone OS "))>=0)r.os="iPhone",r._isIPhone=!0,r.version=t(e,i+"iPhone OS ".length);else if((i=e.indexOf("iPad"))>=0){if((i=e.indexOf("CPU OS"))<0)return void _._$li(" err : "+e+" @UtHtml5.setup()");r.os="iPad",r._isIPad=!0,r.version=t(e,i+"CPU OS ".length)}else(i=e.indexOf("Android"))>=0?(r.os="Android",r._isAndroid=!0,r.version=t(e,i+"Android ".length)):(r.os="-",r.version=-1)},window.UtSystem=w,window.UtDebug=_,window.LDTransform=gt,window.LDGL=nt,window.Live2D=at,window.Live2DModelWebGL=ft,window.Live2DModelJS=q,window.Live2DMotion=J,window.MotionQueueManager=ct,window.PhysicsHair=f,window.AMotion=s,window.PartsDataID=l,window.DrawDataID=b,window.BaseDataID=yt,window.ParamID=u,at.init();var At=!1}()}).call(i,e(7))},function(t,i){t.exports={import:function(){throw new Error("System.import cannot be used indirectly")}}},function(t,i,e){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(){this.models=[],this.count=-1,this.reloadFlg=!1,Live2D.init(),n.Live2DFramework.setPlatformManager(new _.default)}Object.defineProperty(i,"__esModule",{value:!0}),i.default=o;var n=e(0),s=e(9),_=r(s),a=e(10),h=r(a),l=e(1),$=r(l);o.prototype.createModel=function(){var t=new h.default;return this.models.push(t),t},o.prototype.changeModel=function(t,i){if(this.reloadFlg){this.reloadFlg=!1;this.releaseModel(0,t),this.createModel(),this.models[0].load(t,i)}},o.prototype.getModel=function(t){return t>=this.models.length?null:this.models[t]},o.prototype.releaseModel=function(t,i){this.models.length<=t||(this.models[t].release(i),delete this.models[t],this.models.splice(t,1))},o.prototype.numModels=function(){return this.models.length},o.prototype.setDrag=function(t,i){for(var e=0;e<this.models.length;e++)this.models[e].setDrag(t,i)},o.prototype.maxScaleEvent=function(){$.default.DEBUG_LOG&&console.log("Max scale event.");for(var t=0;t<this.models.length;t++)this.models[t].startRandomMotion($.default.MOTION_GROUP_PINCH_IN,$.default.PRIORITY_NORMAL)},o.prototype.minScaleEvent=function(){$.default.DEBUG_LOG&&console.log("Min scale event.");for(var t=0;t<this.models.length;t++)this.models[t].startRandomMotion($.default.MOTION_GROUP_PINCH_OUT,$.default.PRIORITY_NORMAL)},o.prototype.tapEvent=function(t,i){$.default.DEBUG_LOG&&console.log("tapEvent view x:"+t+" y:"+i);for(var e=0;e<this.models.length;e++)this.models[e].hitTest($.default.HIT_AREA_HEAD,t,i)?($.default.DEBUG_LOG&&console.log("Tap face."),this.models[e].setRandomExpression()):this.models[e].hitTest($.default.HIT_AREA_BODY,t,i)?($.default.DEBUG_LOG&&console.log("Tap body. models["+e+"]"),this.models[e].startRandomMotion($.default.MOTION_GROUP_TAP_BODY,$.default.PRIORITY_NORMAL)):this.models[e].hitTestCustom("head",t,i)?($.default.DEBUG_LOG&&console.log("Tap face."),this.models[e].startRandomMotion($.default.MOTION_GROUP_FLICK_HEAD,$.default.PRIORITY_NORMAL)):this.models[e].hitTestCustom("body",t,i)&&($.default.DEBUG_LOG&&console.log("Tap body. models["+e+"]"),this.models[e].startRandomMotion($.default.MOTION_GROUP_TAP_BODY,$.default.PRIORITY_NORMAL));return!0}},function(t,i,e){"use strict";function r(){}Object.defineProperty(i,"__esModule",{value:!0}),i.default=r;var o=e(2);r.prototype.loadBytes=function(t,i){var e=new XMLHttpRequest;e.open("GET",t,!0),e.responseType="arraybuffer",e.onload=function(){switch(e.status){case 200:i(e.response);break;default:console.error("Failed to load ("+e.status+") : "+t)}},e.send(null)},r.prototype.loadString=function(t){this.loadBytes(t,function(t){return t})},r.prototype.loadLive2DModel=function(t,i){var e=null;this.loadBytes(t,function(t){e=Live2DModelWebGL.loadModel(t),i(e)})},r.prototype.loadTexture=function(t,i,e,r){var n=new Image;n.crossOrigin="Anonymous",n.src=e;n.onload=function(){var e=(0,o.getContext)(),s=e.createTexture();if(!s)return console.error("Failed to generate gl texture name."),-1;0==t.isPremultipliedAlpha()&&e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,1),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,1),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,s),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR_MIPMAP_NEAREST),e.generateMipmap(e.TEXTURE_2D),t.setTexture(i,s),s=null,"function"==typeof r&&r()},n.onerror=function(){console.error("Failed to load image : "+e)}},r.prototype.jsonParseFromBytes=function(t){var i,e=new Uint8Array(t,0,3);return i=239==e[0]&&187==e[1]&&191==e[2]?String.fromCharCode.apply(null,new Uint8Array(t,3)):String.fromCharCode.apply(null,new Uint8Array(t)),JSON.parse(i)},r.prototype.log=function(t){}},function(t,i,e){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(){n.L2DBaseModel.prototype.constructor.call(this),this.modelHomeDir="",this.modelSetting=null,this.tmpMatrix=[]}Object.defineProperty(i,"__esModule",{value:!0}),i.default=o;var n=e(0),s=e(11),_=r(s),a=e(1),h=r(a),l=e(3),$=r(l);o.prototype=new n.L2DBaseModel,o.prototype.load=function(t,i,e){this.setUpdating(!0),this.setInitialized(!1),this.modelHomeDir=i.substring(0,i.lastIndexOf("/")+1),this.modelSetting=new _.default;var r=this;this.modelSetting.loadModelSetting(i,function(){var t=r.modelHomeDir+r.modelSetting.getModelFile();r.loadModelData(t,function(t){for(var i=0;i<r.modelSetting.getTextureNum();i++){if(/^https?:\\/\\/|^\\/\\//i.test(r.modelSetting.getTextureFile(i)))var o=r.modelSetting.getTextureFile(i);else var o=r.modelHomeDir+r.modelSetting.getTextureFile(i);r.loadTexture(i,o,function(){if(r.isTexLoaded){if(r.modelSetting.getExpressionNum()>0){r.expressions={};for(var t=0;t<r.modelSetting.getExpressionNum();t++){var i=r.modelSetting.getExpressionName(t),o=r.modelHomeDir+r.modelSetting.getExpressionFile(t);r.loadExpression(i,o)}}else r.expressionManager=null,r.expressions={};if(r.eyeBlink,null!=r.modelSetting.getPhysicsFile()?r.loadPhysics(r.modelHomeDir+r.modelSetting.getPhysicsFile()):r.physics=null,null!=r.modelSetting.getPoseFile()?r.loadPose(r.modelHomeDir+r.modelSetting.getPoseFile(),function(){r.pose.updateParam(r.live2DModel)}):r.pose=null,null!=r.modelSetting.getLayout()){var n=r.modelSetting.getLayout();null!=n.width&&r.modelMatrix.setWidth(n.width),null!=n.height&&r.modelMatrix.setHeight(n.height),null!=n.x&&r.modelMatrix.setX(n.x),null!=n.y&&r.modelMatrix.setY(n.y),null!=n.center_x&&r.modelMatrix.centerX(n.center_x),null!=n.center_y&&r.modelMatrix.centerY(n.center_y),null!=n.top&&r.modelMatrix.top(n.top),null!=n.bottom&&r.modelMatrix.bottom(n.bottom),null!=n.left&&r.modelMatrix.left(n.left),null!=n.right&&r.modelMatrix.right(n.right)}if(null!=r.modelSetting.getHitAreasCustom()){var s=r.modelSetting.getHitAreasCustom();null!=s.head_x&&(h.default.hit_areas_custom_head_x=s.head_x),null!=s.head_y&&(h.default.hit_areas_custom_head_y=s.head_y),null!=s.body_x&&(h.default.hit_areas_custom_body_x=s.body_x),null!=s.body_y&&(h.default.hit_areas_custom_body_y=s.body_y)}for(var t=0;t<r.modelSetting.getInitParamNum();t++)r.live2DModel.setParamFloat(r.modelSetting.getInitParamID(t),r.modelSetting.getInitParamValue(t));for(var t=0;t<r.modelSetting.getInitPartsVisibleNum();t++)r.live2DModel.setPartsOpacity(r.modelSetting.getInitPartsVisibleID(t),r.modelSetting.getInitPartsVisibleValue(t));r.live2DModel.saveParam(),r.preloadMotionGroup(h.default.MOTION_GROUP_IDLE),r.preloadMotionGroup(h.default.MOTION_GROUP_SLEEPY),r.mainMotionManager.stopAllMotions(),r.setUpdating(!1),r.setInitialized(!0),"function"==typeof e&&e()}})}})})},o.prototype.release=function(t){var i=n.Live2DFramework.getPlatformManager();t.deleteTexture(i.texture)},o.prototype.preloadMotionGroup=function(t){for(var i=this,e=0;e<this.modelSetting.getMotionNum(t);e++){var r=this.modelSetting.getMotionFile(t,e);this.loadMotion(r,this.modelHomeDir+r,function(r){r.setFadeIn(i.modelSetting.getMotionFadeIn(t,e)),r.setFadeOut(i.modelSetting.getMotionFadeOut(t,e))})}},o.prototype.update=function(){if(null==this.live2DModel)return void(h.default.DEBUG_LOG&&console.error("Failed to update."));var t=UtSystem.getUserTimeMSec()-this.startTimeMSec,i=t/1e3,e=2*i*Math.PI;if(this.mainMotionManager.isFinished()){"1"===sessionStorage.getItem("Sleepy")?this.startRandomMotion(h.default.MOTION_GROUP_SLEEPY,h.default.PRIORITY_SLEEPY):this.startRandomMotion(h.default.MOTION_GROUP_IDLE,h.default.PRIORITY_IDLE)}this.live2DModel.loadParam(),this.mainMotionManager.updateParam(this.live2DModel)||null!=this.eyeBlink&&this.eyeBlink.updateParam(this.live2DModel),this.live2DModel.saveParam(),null==this.expressionManager||null==this.expressions||this.expressionManager.isFinished()||this.expressionManager.updateParam(this.live2DModel),this.live2DModel.addToParamFloat("PARAM_ANGLE_X",30*this.dragX,1),this.live2DModel.addToParamFloat("PARAM_ANGLE_Y",30*this.dragY,1),this.live2DModel.addToParamFloat("PARAM_ANGLE_Z",this.dragX*this.dragY*-30,1),this.live2DModel.addToParamFloat("PARAM_BODY_ANGLE_X",10*this.dragX,1),this.live2DModel.addToParamFloat("PARAM_EYE_BALL_X",this.dragX,1),this.live2DModel.addToParamFloat("PARAM_EYE_BALL_Y",this.dragY,1),this.live2DModel.addToParamFloat("PARAM_ANGLE_X",Number(15*Math.sin(e/6.5345)),.5),this.live2DModel.addToParamFloat("PARAM_ANGLE_Y",Number(8*Math.sin(e/3.5345)),.5),this.live2DModel.addToParamFloat("PARAM_ANGLE_Z",Number(10*Math.sin(e/5.5345)),.5),this.live2DModel.addToParamFloat("PARAM_BODY_ANGLE_X",Number(4*Math.sin(e/15.5345)),.5),this.live2DModel.setParamFloat("PARAM_BREATH",Number(.5+.5*Math.sin(e/3.2345)),1),null!=this.physics&&this.physics.updateParam(this.live2DModel),null==this.lipSync&&this.live2DModel.setParamFloat("PARAM_MOUTH_OPEN_Y",this.lipSyncValue),null!=this.pose&&this.pose.updateParam(this.live2DModel),this.live2DModel.update()},o.prototype.setRandomExpression=function(){var t=[];for(var i in this.expressions)t.push(i);var e=parseInt(Math.random()*t.length);this.setExpression(t[e])},o.prototype.startRandomMotion=function(t,i){var e=this.modelSetting.getMotionNum(t),r=parseInt(Math.random()*e);this.startMotion(t,r,i)},o.prototype.startMotion=function(t,i,e){var r=this.modelSetting.getMotionFile(t,i);if(null==r||""==r)return void(h.default.DEBUG_LOG&&console.error("Failed to motion."));if(e==h.default.PRIORITY_FORCE)this.mainMotionManager.setReservePriority(e);else if(!this.mainMotionManager.reserveMotion(e))return void(h.default.DEBUG_LOG&&console.log("Motion is running."));var o,n=this;null==this.motions[t]?this.loadMotion(null,this.modelHomeDir+r,function(r){o=r,n.setFadeInFadeOut(t,i,e,o)}):(o=this.motions[t],n.setFadeInFadeOut(t,i,e,o))},o.prototype.setFadeInFadeOut=function(t,i,e,r){var o=this.modelSetting.getMotionFile(t,i);if(r.setFadeIn(this.modelSetting.getMotionFadeIn(t,i)),r.setFadeOut(this.modelSetting.getMotionFadeOut(t,i)),h.default.DEBUG_LOG&&console.log("Start motion : "+o),null==this.modelSetting.getMotionSound(t,i))this.mainMotionManager.startMotionPrio(r,e);else{var n=this.modelSetting.getMotionSound(t,i),s=document.createElement("audio");s.src=this.modelHomeDir+n,h.default.DEBUG_LOG&&console.log("Start sound : "+n),s.play(),this.mainMotionManager.startMotionPrio(r,e)}},o.prototype.setExpression=function(t){var i=this.expressions[t];h.default.DEBUG_LOG&&console.log("Expression : "+t),this.expressionManager.startMotion(i,!1)},o.prototype.draw=function(t){$.default.push(),$.default.multMatrix(this.modelMatrix.getArray()),this.tmpMatrix=$.default.getMatrix(),this.live2DModel.setMatrix(this.tmpMatrix),this.live2DModel.draw(),$.default.pop()},o.prototype.hitTest=function(t,i,e){for(var r=this.modelSetting.getHitAreaNum(),o=0;o<r;o++)if(t==this.modelSetting.getHitAreaName(o)){var n=this.modelSetting.getHitAreaID(o);return this.hitTestSimple(n,i,e)}return!1},o.prototype.hitTestCustom=function(t,i,e){return"head"==t?this.hitTestSimpleCustom(h.default.hit_areas_custom_head_x,h.default.hit_areas_custom_head_y,i,e):"body"==t&&this.hitTestSimpleCustom(h.default.hit_areas_custom_body_x,h.default.hit_areas_custom_body_y,i,e)}},function(t,i,e){"use strict";function r(){this.NAME="name",this.ID="id",this.MODEL="model",this.TEXTURES="textures",this.HIT_AREAS="hit_areas",this.PHYSICS="physics",this.POSE="pose",this.EXPRESSIONS="expressions",this.MOTION_GROUPS="motions",this.SOUND="sound",this.FADE_IN="fade_in",this.FADE_OUT="fade_out",this.LAYOUT="layout",this.HIT_AREAS_CUSTOM="hit_areas_custom",this.INIT_PARAM="init_param",this.INIT_PARTS_VISIBLE="init_parts_visible",this.VALUE="val",this.FILE="file",this.json={}}Object.defineProperty(i,"__esModule",{value:!0}),i.default=r;var o=e(0);r.prototype.loadModelSetting=function(t,i){var e=this;o.Live2DFramework.getPlatformManager().loadBytes(t,function(t){var r=String.fromCharCode.apply(null,new Uint8Array(t));e.json=JSON.parse(r),i()})},r.prototype.getTextureFile=function(t){return null==this.json[this.TEXTURES]||null==this.json[this.TEXTURES][t]?null:this.json[this.TEXTURES][t]},r.prototype.getModelFile=function(){return this.json[this.MODEL]},r.prototype.getTextureNum=function(){return null==this.json[this.TEXTURES]?0:this.json[this.TEXTURES].length},r.prototype.getHitAreaNum=function(){return null==this.json[this.HIT_AREAS]?0:this.json[this.HIT_AREAS].length},r.prototype.getHitAreaID=function(t){return null==this.json[this.HIT_AREAS]||null==this.json[this.HIT_AREAS][t]?null:this.json[this.HIT_AREAS][t][this.ID]},r.prototype.getHitAreaName=function(t){return null==this.json[this.HIT_AREAS]||null==this.json[this.HIT_AREAS][t]?null:this.json[this.HIT_AREAS][t][this.NAME]},r.prototype.getPhysicsFile=function(){return this.json[this.PHYSICS]},r.prototype.getPoseFile=function(){return this.json[this.POSE]},r.prototype.getExpressionNum=function(){return null==this.json[this.EXPRESSIONS]?0:this.json[this.EXPRESSIONS].length},r.prototype.getExpressionFile=function(t){return null==this.json[this.EXPRESSIONS]?null:this.json[this.EXPRESSIONS][t][this.FILE]},r.prototype.getExpressionName=function(t){return null==this.json[this.EXPRESSIONS]?null:this.json[this.EXPRESSIONS][t][this.NAME]},r.prototype.getLayout=function(){return this.json[this.LAYOUT]},r.prototype.getHitAreasCustom=function(){return this.json[this.HIT_AREAS_CUSTOM]},r.prototype.getInitParamNum=function(){return null==this.json[this.INIT_PARAM]?0:this.json[this.INIT_PARAM].length},r.prototype.getMotionNum=function(t){return null==this.json[this.MOTION_GROUPS]||null==this.json[this.MOTION_GROUPS][t]?0:this.json[this.MOTION_GROUPS][t].length},r.prototype.getMotionFile=function(t,i){return null==this.json[this.MOTION_GROUPS]||null==this.json[this.MOTION_GROUPS][t]||null==this.json[this.MOTION_GROUPS][t][i]?null:this.json[this.MOTION_GROUPS][t][i][this.FILE]},r.prototype.getMotionSound=function(t,i){return null==this.json[this.MOTION_GROUPS]||null==this.json[this.MOTION_GROUPS][t]||null==this.json[this.MOTION_GROUPS][t][i]||null==this.json[this.MOTION_GROUPS][t][i][this.SOUND]?null:this.json[this.MOTION_GROUPS][t][i][this.SOUND]},r.prototype.getMotionFadeIn=function(t,i){return null==this.json[this.MOTION_GROUPS]||null==this.json[this.MOTION_GROUPS][t]||null==this.json[this.MOTION_GROUPS][t][i]||null==this.json[this.MOTION_GROUPS][t][i][this.FADE_IN]?1e3:this.json[this.MOTION_GROUPS][t][i][this.FADE_IN]},r.prototype.getMotionFadeOut=function(t,i){return null==this.json[this.MOTION_GROUPS]||null==this.json[this.MOTION_GROUPS][t]||null==this.json[this.MOTION_GROUPS][t][i]||null==this.json[this.MOTION_GROUPS][t][i][this.FADE_OUT]?1e3:this.json[this.MOTION_GROUPS][t][i][this.FADE_OUT]},r.prototype.getInitParamID=function(t){return null==this.json[this.INIT_PARAM]||null==this.json[this.INIT_PARAM][t]?null:this.json[this.INIT_PARAM][t][this.ID]},r.prototype.getInitParamValue=function(t){return null==this.json[this.INIT_PARAM]||null==this.json[this.INIT_PARAM][t]?NaN:this.json[this.INIT_PARAM][t][this.VALUE]},r.prototype.getInitPartsVisibleNum=function(){return null==this.json[this.INIT_PARTS_VISIBLE]?0:this.json[this.INIT_PARTS_VISIBLE].length},r.prototype.getInitPartsVisibleID=function(t){return null==this.json[this.INIT_PARTS_VISIBLE]||null==this.json[this.INIT_PARTS_VISIBLE][t]?null:this.json[this.INIT_PARTS_VISIBLE][t][this.ID]},r.prototype.getInitPartsVisibleValue=function(t){return null==this.json[this.INIT_PARTS_VISIBLE]||null==this.json[this.INIT_PARTS_VISIBLE][t]?NaN:this.json[this.INIT_PARTS_VISIBLE][t][this.VALUE]}}]);\n',document.body.appendChild(n)}var n=new XMLHttpRequest;n.open("get",this.model[this.currentTheme]),n.send(),n.onreadystatechange=function(){200!==n.status&&(console.log("看板娘的CDN资源加载失败了，请稍后刷新页面重试！"),document.querySelector(".kanbanniang").style.display="none")},window.loadlive2d("banniang",this.model[this.currentTheme])}}},St=(t(283),Object(Ue.a)(xt,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"kanbanniang"},[e("div",{directives:[{name:"show",rawName:"v-show",value:n.isLoaded,expression:"isLoaded"}],staticClass:"banniang-container"},[e("div",{directives:[{name:"show",rawName:"v-show",value:n.isShowMessageBox,expression:"isShowMessageBox"}],staticClass:"messageBox",style:n.messageStyle},[n._v("\n      "+n._s(n.messages.message||"欢迎来到 "+n.$site.title)+"\n    ")]),n._v(" "),e("div",{directives:[{name:"show",rawName:"v-show",value:!n.isShowBtns,expression:"!isShowBtns"}],staticClass:"operation",style:n.btnStyle,on:{mouseenter:function(e){n.isShowMessageBox=!0},mouseleave:function(e){n.isShowMessageBox=!1}}},[e("i",{staticClass:"kbnfont kbn-ban-home ban-home",on:{click:n.goHome,mouseenter:n.hoverGoHome,mouseleave:n.resetMessage}}),n._v(" "),e("i",{staticClass:"kbnfont kbn-ban-message message"}),n._v(" "),e("i",{staticClass:"kbnfont kbn-ban-close close",on:{click:n.closeBanNiang,mouseenter:n.hoverCloseBanNiang,mouseleave:n.resetMessage}}),n._v(" "),e("a",{attrs:{target:"_blank",href:"https://vuepress-theme-reco.recoluan.com/views/plugins/kanbanniang.html"}},[e("i",{staticClass:"kbnfont kbn-ban-info info",on:{mouseenter:n.hoverMoreInfo,mouseleave:n.resetMessage}})]),n._v(" "),e("i",{directives:[{name:"show",rawName:"v-show",value:n.myTheme.length>1,expression:"myTheme.length > 1"}],staticClass:"kbnfont kbn-ban-theme skin",on:{click:n.changeTheme,mouseenter:n.hoverChangeTheme,mouseleave:n.resetMessage}})]),n._v(" "),e("canvas",{staticClass:"live2d",style:n.modelStyle,attrs:{id:"banniang",width:n.style.width,height:n.style.height}})]),n._v(" "),e("div",{directives:[{name:"show",rawName:"v-show",value:n.displayBanNiang,expression:"displayBanNiang"}],staticClass:"showBanNiang",on:{click:n.showBanNiang}},[n._v("\n    看板娘\n  ")])])}),[],!1,null,"5775ee02",null).exports),_t={name:"Valine",props:{options:{type:Object,default:()=>({})}},mounted:function(){this.initValine()},methods:{initValine(){new(t(284))({el:"#valine",placeholder:"just go go",notify:!1,verify:!1,avatar:"retro",visitor:!0,recordIP:!1,path:window.location.pathname,...this.options})}},watch:{$route(n,e){n.path!==e.path&&setTimeout(()=>{this.initValine()},300)}}},jt=(t(285),Object(Ue.a)(_t,(function(){this._self._c;return this._m(0)}),[function(){var n=this._self._c;return n("div",{staticClass:"valine-wrapper"},[n("div",{attrs:{id:"valine"}})])}],!1,null,null,null).exports),Tt=t(6);function Ct(n){return Object(Tt.a)((function(e,t){void 0===e.inject&&(e.inject={}),Array.isArray(e.inject)||(e.inject[t]=n||t)}))}function At(n){var e=function(){var t=this,a="function"==typeof n?n.call(this):n;for(var r in(a=Object.create(a||null)).__reactiveInject__=this.__reactiveInject__||{},e.managed)a[e.managed[r]]=this[r];var i=function(n){a[e.managedReactive[n]]=o[n],Object.defineProperty(a.__reactiveInject__,e.managedReactive[n],{enumerable:!0,get:function(){return t[n]}})},o=this;for(var r in e.managedReactive)i(r);return a};return e.managed={},e.managedReactive={},e}function It(n){return"function"!=typeof n||!n.managed&&!n.managedReactive}var Et="undefined"!=typeof Reflect&&void 0!==Reflect.getMetadata;function Ot(n,e,t){if(Et&&!Array.isArray(n)&&"function"!=typeof n&&void 0===n.type){var a=Reflect.getMetadata("design:type",e,t);a!==Object&&(n.type=a)}}function Lt(n){return void 0===n&&(n={}),function(e,t){Ot(n,e,t),Object(Tt.a)((function(e,t){(e.props||(e.props={}))[t]=n}))(e,t)}}function $t(n,e){void 0===e&&(e={});var t=e.deep,a=void 0!==t&&t,r=e.immediate,i=void 0!==r&&r;return Object(Tt.a)((function(e,t){"object"!=typeof e.watch&&(e.watch=Object.create(null));var r=e.watch;"object"!=typeof r[n]||Array.isArray(r[n])?void 0===r[n]&&(r[n]=[]):r[n]=[r[n]],r[n].push({handler:t,deep:a,immediate:i})}))}var Pt=t(20);const zt=n=>Object(Pt.stringify)(n),Dt=(n,e)=>`${n}${Object(Pt.stringify)(e,{addQueryPrefix:!0})}`,Mt=(n,e)=>`${n.replace(/\/$/,"")}/${e.replace(/^\//,"")}`;var Ft=t(131),Rt=t.n(Ft);const qt=n=>Rt()(n,"YYYY-MM-DD HH:mm:ss"),Nt=n=>(n.split("#")[0]||"").split("?")[0]||"",Bt=n=>Object(Pt.parse)(n,{ignoreQueryPrefix:!0})
/*!
 * vue-i18n v8.28.2 
 * (c) 2022 kazuya kawaguchi
 * Released under the MIT License.
 */;var Ut=["compactDisplay","currency","currencyDisplay","currencySign","localeMatcher","notation","numberingSystem","signDisplay","style","unit","unitDisplay","useGrouping","minimumIntegerDigits","minimumFractionDigits","maximumFractionDigits","minimumSignificantDigits","maximumSignificantDigits"],Jt=["dateStyle","timeStyle","calendar","localeMatcher","hour12","hourCycle","timeZone","formatMatcher","weekday","era","year","month","day","hour","minute","second","timeZoneName"];function Vt(n,e){"undefined"!=typeof console&&(console.warn("[vue-i18n] "+n),e&&console.warn(e.stack))}var Wt=Array.isArray;function Ht(n){return null!==n&&"object"==typeof n}function Qt(n){return"string"==typeof n}var Gt=Object.prototype.toString;function Kt(n){return"[object Object]"===Gt.call(n)}function Yt(n){return null==n}function Xt(n){return"function"==typeof n}function Zt(){for(var n=[],e=arguments.length;e--;)n[e]=arguments[e];var t=null,a=null;return 1===n.length?Ht(n[0])||Wt(n[0])?a=n[0]:"string"==typeof n[0]&&(t=n[0]):2===n.length&&("string"==typeof n[0]&&(t=n[0]),(Ht(n[1])||Wt(n[1]))&&(a=n[1])),{locale:t,params:a}}function na(n){return JSON.parse(JSON.stringify(n))}function ea(n,e){return!!~n.indexOf(e)}var ta=Object.prototype.hasOwnProperty;function aa(n,e){return ta.call(n,e)}function ra(n){for(var e=arguments,t=Object(n),a=1;a<arguments.length;a++){var r=e[a];if(null!=r){var i=void 0;for(i in r)aa(r,i)&&(Ht(r[i])?t[i]=ra(t[i],r[i]):t[i]=r[i])}}return t}function ia(n,e){if(n===e)return!0;var t=Ht(n),a=Ht(e);if(!t||!a)return!t&&!a&&String(n)===String(e);try{var r=Wt(n),i=Wt(e);if(r&&i)return n.length===e.length&&n.every((function(n,t){return ia(n,e[t])}));if(r||i)return!1;var o=Object.keys(n),s=Object.keys(e);return o.length===s.length&&o.every((function(t){return ia(n[t],e[t])}))}catch(n){return!1}}function oa(n){return null!=n&&Object.keys(n).forEach((function(e){"string"==typeof n[e]&&(n[e]=n[e].replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&apos;"))})),n}var sa={name:"i18n",functional:!0,props:{tag:{type:[String,Boolean,Object],default:"span"},path:{type:String,required:!0},locale:{type:String},places:{type:[Array,Object]}},render:function(n,e){var t=e.data,a=e.parent,r=e.props,i=e.slots,o=a.$i18n;if(o){var s=r.path,l=r.locale,c=r.places,u=i(),d=o.i(s,l,function(n){var e;for(e in n)if("default"!==e)return!1;return Boolean(e)}(u)||c?function(n,e){var t=e?function(n){0;return Array.isArray(n)?n.reduce(ca,{}):Object.assign({},n)}(e):{};if(!n)return t;var a=(n=n.filter((function(n){return n.tag||""!==n.text.trim()}))).every(ua);0;return n.reduce(a?la:ca,t)}(u.default,c):u),p=r.tag&&!0!==r.tag||!1===r.tag?r.tag:"span";return p?n(p,t,d):d}}};function la(n,e){return e.data&&e.data.attrs&&e.data.attrs.place&&(n[e.data.attrs.place]=e),n}function ca(n,e,t){return n[t]=e,n}function ua(n){return Boolean(n.data&&n.data.attrs&&n.data.attrs.place)}var da,pa={name:"i18n-n",functional:!0,props:{tag:{type:[String,Boolean,Object],default:"span"},value:{type:Number,required:!0},format:{type:[String,Object]},locale:{type:String}},render:function(n,e){var t=e.props,a=e.parent,r=e.data,i=a.$i18n;if(!i)return null;var o=null,s=null;Qt(t.format)?o=t.format:Ht(t.format)&&(t.format.key&&(o=t.format.key),s=Object.keys(t.format).reduce((function(n,e){var a;return ea(Ut,e)?Object.assign({},n,((a={})[e]=t.format[e],a)):n}),null));var l=t.locale||i.locale,c=i._ntp(t.value,l,o,s),u=c.map((function(n,e){var t,a=r.scopedSlots&&r.scopedSlots[n.type];return a?a(((t={})[n.type]=n.value,t.index=e,t.parts=c,t)):n.value})),d=t.tag&&!0!==t.tag||!1===t.tag?t.tag:"span";return d?n(d,{attrs:r.attrs,class:r.class,staticClass:r.staticClass},u):u}};function ha(n,e,t){ga(n,t)&&va(n,e,t)}function fa(n,e,t,a){if(ga(n,t)){var r=t.context.$i18n;(function(n,e){var t=e.context;return n._locale===t.$i18n.locale})(n,t)&&ia(e.value,e.oldValue)&&ia(n._localeMessage,r.getLocaleMessage(r.locale))||va(n,e,t)}}function ma(n,e,t,a){if(t.context){var r=t.context.$i18n||{};e.modifiers.preserve||r.preserveDirectiveContent||(n.textContent=""),n._vt=void 0,delete n._vt,n._locale=void 0,delete n._locale,n._localeMessage=void 0,delete n._localeMessage}else Vt("Vue instance does not exists in VNode context")}function ga(n,e){var t=e.context;return t?!!t.$i18n||(Vt("VueI18n instance does not exists in Vue instance"),!1):(Vt("Vue instance does not exists in VNode context"),!1)}function va(n,e,t){var a,r,i=function(n){var e,t,a,r;Qt(n)?e=n:Kt(n)&&(e=n.path,t=n.locale,a=n.args,r=n.choice);return{path:e,locale:t,args:a,choice:r}}(e.value),o=i.path,s=i.locale,l=i.args,c=i.choice;if(o||s||l)if(o){var u=t.context;n._vt=n.textContent=null!=c?(a=u.$i18n).tc.apply(a,[o,c].concat(ya(s,l))):(r=u.$i18n).t.apply(r,[o].concat(ya(s,l))),n._locale=u.$i18n.locale,n._localeMessage=u.$i18n.getLocaleMessage(u.$i18n.locale)}else Vt("`path` is required in v-t directive");else Vt("value type not supported")}function ya(n,e){var t=[];return n&&t.push(n),e&&(Array.isArray(e)||Kt(e))&&t.push(e),t}function ba(n,e){void 0===e&&(e={bridge:!1}),ba.installed=!0;var t;(da=n).version&&Number(da.version.split(".")[0]);(t=da).prototype.hasOwnProperty("$i18n")||Object.defineProperty(t.prototype,"$i18n",{get:function(){return this._i18n}}),t.prototype.$t=function(n){for(var e=[],t=arguments.length-1;t-- >0;)e[t]=arguments[t+1];var a=this.$i18n;return a._t.apply(a,[n,a.locale,a._getMessages(),this].concat(e))},t.prototype.$tc=function(n,e){for(var t=[],a=arguments.length-2;a-- >0;)t[a]=arguments[a+2];var r=this.$i18n;return r._tc.apply(r,[n,r.locale,r._getMessages(),this,e].concat(t))},t.prototype.$te=function(n,e){var t=this.$i18n;return t._te(n,t.locale,t._getMessages(),e)},t.prototype.$d=function(n){for(var e,t=[],a=arguments.length-1;a-- >0;)t[a]=arguments[a+1];return(e=this.$i18n).d.apply(e,[n].concat(t))},t.prototype.$n=function(n){for(var e,t=[],a=arguments.length-1;a-- >0;)t[a]=arguments[a+1];return(e=this.$i18n).n.apply(e,[n].concat(t))},da.mixin(function(n){function e(){this!==this.$root&&this.$options.__INTLIFY_META__&&this.$el&&this.$el.setAttribute("data-intlify",this.$options.__INTLIFY_META__)}return void 0===n&&(n=!1),n?{mounted:e}:{beforeCreate:function(){var n=this.$options;if(n.i18n=n.i18n||(n.__i18nBridge||n.__i18n?{}:null),n.i18n)if(n.i18n instanceof za){if(n.__i18nBridge||n.__i18n)try{var e=n.i18n&&n.i18n.messages?n.i18n.messages:{};(n.__i18nBridge||n.__i18n).forEach((function(n){e=ra(e,JSON.parse(n))})),Object.keys(e).forEach((function(t){n.i18n.mergeLocaleMessage(t,e[t])}))}catch(n){0}this._i18n=n.i18n,this._i18nWatcher=this._i18n.watchI18nData()}else if(Kt(n.i18n)){var t=this.$root&&this.$root.$i18n&&this.$root.$i18n instanceof za?this.$root.$i18n:null;if(t&&(n.i18n.root=this.$root,n.i18n.formatter=t.formatter,n.i18n.fallbackLocale=t.fallbackLocale,n.i18n.formatFallbackMessages=t.formatFallbackMessages,n.i18n.silentTranslationWarn=t.silentTranslationWarn,n.i18n.silentFallbackWarn=t.silentFallbackWarn,n.i18n.pluralizationRules=t.pluralizationRules,n.i18n.preserveDirectiveContent=t.preserveDirectiveContent),n.__i18nBridge||n.__i18n)try{var a=n.i18n&&n.i18n.messages?n.i18n.messages:{};(n.__i18nBridge||n.__i18n).forEach((function(n){a=ra(a,JSON.parse(n))})),n.i18n.messages=a}catch(n){0}var r=n.i18n.sharedMessages;r&&Kt(r)&&(n.i18n.messages=ra(n.i18n.messages,r)),this._i18n=new za(n.i18n),this._i18nWatcher=this._i18n.watchI18nData(),(void 0===n.i18n.sync||n.i18n.sync)&&(this._localeWatcher=this.$i18n.watchLocale()),t&&t.onComponentInstanceCreated(this._i18n)}else 0;else this.$root&&this.$root.$i18n&&this.$root.$i18n instanceof za?this._i18n=this.$root.$i18n:n.parent&&n.parent.$i18n&&n.parent.$i18n instanceof za&&(this._i18n=n.parent.$i18n)},beforeMount:function(){var n=this.$options;n.i18n=n.i18n||(n.__i18nBridge||n.__i18n?{}:null),n.i18n?(n.i18n instanceof za||Kt(n.i18n))&&(this._i18n.subscribeDataChanging(this),this._subscribing=!0):(this.$root&&this.$root.$i18n&&this.$root.$i18n instanceof za||n.parent&&n.parent.$i18n&&n.parent.$i18n instanceof za)&&(this._i18n.subscribeDataChanging(this),this._subscribing=!0)},mounted:e,beforeDestroy:function(){if(this._i18n){var n=this;this.$nextTick((function(){n._subscribing&&(n._i18n.unsubscribeDataChanging(n),delete n._subscribing),n._i18nWatcher&&(n._i18nWatcher(),n._i18n.destroyVM(),delete n._i18nWatcher),n._localeWatcher&&(n._localeWatcher(),delete n._localeWatcher)}))}}}}(e.bridge)),da.directive("t",{bind:ha,update:fa,unbind:ma}),da.component(sa.name,sa),da.component(pa.name,pa),da.config.optionMergeStrategies.i18n=function(n,e){return void 0===e?n:e}}var ka=function(){this._caches=Object.create(null)};ka.prototype.interpolate=function(n,e){if(!e)return[n];var t=this._caches[n];return t||(t=function(n){var e=[],t=0,a="";for(;t<n.length;){var r=n[t++];if("{"===r){a&&e.push({type:"text",value:a}),a="";var i="";for(r=n[t++];void 0!==r&&"}"!==r;)i+=r,r=n[t++];var o="}"===r,s=wa.test(i)?"list":o&&xa.test(i)?"named":"unknown";e.push({value:i,type:s})}else"%"===r?"{"!==n[t]&&(a+=r):a+=r}return a&&e.push({type:"text",value:a}),e}(n),this._caches[n]=t),function(n,e){var t=[],a=0,r=Array.isArray(e)?"list":Ht(e)?"named":"unknown";if("unknown"===r)return t;for(;a<n.length;){var i=n[a];switch(i.type){case"text":t.push(i.value);break;case"list":t.push(e[parseInt(i.value,10)]);break;case"named":"named"===r&&t.push(e[i.value]);break;case"unknown":0}a++}return t}(t,e)};var wa=/^(?:\d)+/,xa=/^(?:\w)+/;var Sa=[];Sa[0]={ws:[0],ident:[3,0],"[":[4],eof:[7]},Sa[1]={ws:[1],".":[2],"[":[4],eof:[7]},Sa[2]={ws:[2],ident:[3,0],0:[3,0],number:[3,0]},Sa[3]={ident:[3,0],0:[3,0],number:[3,0],ws:[1,1],".":[2,1],"[":[4,1],eof:[7,1]},Sa[4]={"'":[5,0],'"':[6,0],"[":[4,2],"]":[1,3],eof:8,else:[4,0]},Sa[5]={"'":[4,0],eof:8,else:[5,0]},Sa[6]={'"':[4,0],eof:8,else:[6,0]};var _a=/^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;function ja(n){if(null==n)return"eof";switch(n.charCodeAt(0)){case 91:case 93:case 46:case 34:case 39:return n;case 95:case 36:case 45:return"ident";case 9:case 10:case 13:case 160:case 65279:case 8232:case 8233:return"ws"}return"ident"}function Ta(n){var e,t,a,r=n.trim();return("0"!==n.charAt(0)||!isNaN(n))&&(a=r,_a.test(a)?(t=(e=r).charCodeAt(0))!==e.charCodeAt(e.length-1)||34!==t&&39!==t?e:e.slice(1,-1):"*"+r)}var Ca=function(){this._cache=Object.create(null)};Ca.prototype.parsePath=function(n){var e=this._cache[n];return e||(e=function(n){var e,t,a,r,i,o,s,l=[],c=-1,u=0,d=0,p=[];function h(){var e=n[c+1];if(5===u&&"'"===e||6===u&&'"'===e)return c++,a="\\"+e,p[0](),!0}for(p[1]=function(){void 0!==t&&(l.push(t),t=void 0)},p[0]=function(){void 0===t?t=a:t+=a},p[2]=function(){p[0](),d++},p[3]=function(){if(d>0)d--,u=4,p[0]();else{if(d=0,void 0===t)return!1;if(!1===(t=Ta(t)))return!1;p[1]()}};null!==u;)if(c++,"\\"!==(e=n[c])||!h()){if(r=ja(e),8===(i=(s=Sa[u])[r]||s.else||8))return;if(u=i[0],(o=p[i[1]])&&(a=void 0===(a=i[2])?e:a,!1===o()))return;if(7===u)return l}}(n))&&(this._cache[n]=e),e||[]},Ca.prototype.getPathValue=function(n,e){if(!Ht(n))return null;var t=this.parsePath(e);if(0===t.length)return null;for(var a=t.length,r=n,i=0;i<a;){var o=r[t[i]];if(null==o)return null;r=o,i++}return r};var Aa,Ia=/<\/?[\w\s="/.':;#-\/]+>/,Ea=/(?:@(?:\.[a-zA-Z]+)?:(?:[\w\-_|./]+|\([\w\-_:|./]+\)))/g,Oa=/^@(?:\.([a-zA-Z]+))?:/,La=/[()]/g,$a={upper:function(n){return n.toLocaleUpperCase()},lower:function(n){return n.toLocaleLowerCase()},capitalize:function(n){return""+n.charAt(0).toLocaleUpperCase()+n.substr(1)}},Pa=new ka,za=function(n){var e=this;void 0===n&&(n={}),!da&&"undefined"!=typeof window&&window.Vue&&ba(window.Vue);var t=n.locale||"en-US",a=!1!==n.fallbackLocale&&(n.fallbackLocale||"en-US"),r=n.messages||{},i=n.dateTimeFormats||n.datetimeFormats||{},o=n.numberFormats||{};this._vm=null,this._formatter=n.formatter||Pa,this._modifiers=n.modifiers||{},this._missing=n.missing||null,this._root=n.root||null,this._sync=void 0===n.sync||!!n.sync,this._fallbackRoot=void 0===n.fallbackRoot||!!n.fallbackRoot,this._fallbackRootWithEmptyString=void 0===n.fallbackRootWithEmptyString||!!n.fallbackRootWithEmptyString,this._formatFallbackMessages=void 0!==n.formatFallbackMessages&&!!n.formatFallbackMessages,this._silentTranslationWarn=void 0!==n.silentTranslationWarn&&n.silentTranslationWarn,this._silentFallbackWarn=void 0!==n.silentFallbackWarn&&!!n.silentFallbackWarn,this._dateTimeFormatters={},this._numberFormatters={},this._path=new Ca,this._dataListeners=new Set,this._componentInstanceCreatedListener=n.componentInstanceCreatedListener||null,this._preserveDirectiveContent=void 0!==n.preserveDirectiveContent&&!!n.preserveDirectiveContent,this.pluralizationRules=n.pluralizationRules||{},this._warnHtmlInMessage=n.warnHtmlInMessage||"off",this._postTranslation=n.postTranslation||null,this._escapeParameterHtml=n.escapeParameterHtml||!1,"__VUE_I18N_BRIDGE__"in n&&(this.__VUE_I18N_BRIDGE__=n.__VUE_I18N_BRIDGE__),this.getChoiceIndex=function(n,t){var a=Object.getPrototypeOf(e);if(a&&a.getChoiceIndex)return a.getChoiceIndex.call(e,n,t);var r,i;return e.locale in e.pluralizationRules?e.pluralizationRules[e.locale].apply(e,[n,t]):(r=n,i=t,r=Math.abs(r),2===i?r?r>1?1:0:1:r?Math.min(r,2):0)},this._exist=function(n,t){return!(!n||!t)&&(!Yt(e._path.getPathValue(n,t))||!!n[t])},"warn"!==this._warnHtmlInMessage&&"error"!==this._warnHtmlInMessage||Object.keys(r).forEach((function(n){e._checkLocaleMessage(n,e._warnHtmlInMessage,r[n])})),this._initVM({locale:t,fallbackLocale:a,messages:r,dateTimeFormats:i,numberFormats:o})},Da={vm:{configurable:!0},messages:{configurable:!0},dateTimeFormats:{configurable:!0},numberFormats:{configurable:!0},availableLocales:{configurable:!0},locale:{configurable:!0},fallbackLocale:{configurable:!0},formatFallbackMessages:{configurable:!0},missing:{configurable:!0},formatter:{configurable:!0},silentTranslationWarn:{configurable:!0},silentFallbackWarn:{configurable:!0},preserveDirectiveContent:{configurable:!0},warnHtmlInMessage:{configurable:!0},postTranslation:{configurable:!0},sync:{configurable:!0}};za.prototype._checkLocaleMessage=function(n,e,t){var a=function(n,e,t,r){if(Kt(t))Object.keys(t).forEach((function(i){var o=t[i];Kt(o)?(r.push(i),r.push("."),a(n,e,o,r),r.pop(),r.pop()):(r.push(i),a(n,e,o,r),r.pop())}));else if(Wt(t))t.forEach((function(t,i){Kt(t)?(r.push("["+i+"]"),r.push("."),a(n,e,t,r),r.pop(),r.pop()):(r.push("["+i+"]"),a(n,e,t,r),r.pop())}));else if(Qt(t)){if(Ia.test(t)){var i="Detected HTML in message '"+t+"' of keypath '"+r.join("")+"' at '"+e+"'. Consider component interpolation with '<i18n>' to avoid XSS. See https://bit.ly/2ZqJzkp";"warn"===n?Vt(i):"error"===n&&function(n,e){"undefined"!=typeof console&&(console.error("[vue-i18n] "+n),e&&console.error(e.stack))}(i)}}};a(e,n,t,[])},za.prototype._initVM=function(n){var e=da.config.silent;da.config.silent=!0,this._vm=new da({data:n,__VUE18N__INSTANCE__:!0}),da.config.silent=e},za.prototype.destroyVM=function(){this._vm.$destroy()},za.prototype.subscribeDataChanging=function(n){this._dataListeners.add(n)},za.prototype.unsubscribeDataChanging=function(n){!function(n,e){if(n.delete(e));}(this._dataListeners,n)},za.prototype.watchI18nData=function(){var n=this;return this._vm.$watch("$data",(function(){for(var e,t,a=(e=n._dataListeners,t=[],e.forEach((function(n){return t.push(n)})),t),r=a.length;r--;)da.nextTick((function(){a[r]&&a[r].$forceUpdate()}))}),{deep:!0})},za.prototype.watchLocale=function(n){if(n){if(!this.__VUE_I18N_BRIDGE__)return null;var e=this,t=this._vm;return this.vm.$watch("locale",(function(a){t.$set(t,"locale",a),e.__VUE_I18N_BRIDGE__&&n&&(n.locale.value=a),t.$forceUpdate()}),{immediate:!0})}if(!this._sync||!this._root)return null;var a=this._vm;return this._root.$i18n.vm.$watch("locale",(function(n){a.$set(a,"locale",n),a.$forceUpdate()}),{immediate:!0})},za.prototype.onComponentInstanceCreated=function(n){this._componentInstanceCreatedListener&&this._componentInstanceCreatedListener(n,this)},Da.vm.get=function(){return this._vm},Da.messages.get=function(){return na(this._getMessages())},Da.dateTimeFormats.get=function(){return na(this._getDateTimeFormats())},Da.numberFormats.get=function(){return na(this._getNumberFormats())},Da.availableLocales.get=function(){return Object.keys(this.messages).sort()},Da.locale.get=function(){return this._vm.locale},Da.locale.set=function(n){this._vm.$set(this._vm,"locale",n)},Da.fallbackLocale.get=function(){return this._vm.fallbackLocale},Da.fallbackLocale.set=function(n){this._localeChainCache={},this._vm.$set(this._vm,"fallbackLocale",n)},Da.formatFallbackMessages.get=function(){return this._formatFallbackMessages},Da.formatFallbackMessages.set=function(n){this._formatFallbackMessages=n},Da.missing.get=function(){return this._missing},Da.missing.set=function(n){this._missing=n},Da.formatter.get=function(){return this._formatter},Da.formatter.set=function(n){this._formatter=n},Da.silentTranslationWarn.get=function(){return this._silentTranslationWarn},Da.silentTranslationWarn.set=function(n){this._silentTranslationWarn=n},Da.silentFallbackWarn.get=function(){return this._silentFallbackWarn},Da.silentFallbackWarn.set=function(n){this._silentFallbackWarn=n},Da.preserveDirectiveContent.get=function(){return this._preserveDirectiveContent},Da.preserveDirectiveContent.set=function(n){this._preserveDirectiveContent=n},Da.warnHtmlInMessage.get=function(){return this._warnHtmlInMessage},Da.warnHtmlInMessage.set=function(n){var e=this,t=this._warnHtmlInMessage;if(this._warnHtmlInMessage=n,t!==n&&("warn"===n||"error"===n)){var a=this._getMessages();Object.keys(a).forEach((function(n){e._checkLocaleMessage(n,e._warnHtmlInMessage,a[n])}))}},Da.postTranslation.get=function(){return this._postTranslation},Da.postTranslation.set=function(n){this._postTranslation=n},Da.sync.get=function(){return this._sync},Da.sync.set=function(n){this._sync=n},za.prototype._getMessages=function(){return this._vm.messages},za.prototype._getDateTimeFormats=function(){return this._vm.dateTimeFormats},za.prototype._getNumberFormats=function(){return this._vm.numberFormats},za.prototype._warnDefault=function(n,e,t,a,r,i){if(!Yt(t))return t;if(this._missing){var o=this._missing.apply(null,[n,e,a,r]);if(Qt(o))return o}else 0;if(this._formatFallbackMessages){var s=Zt.apply(void 0,r);return this._render(e,i,s.params,e)}return e},za.prototype._isFallbackRoot=function(n){return(this._fallbackRootWithEmptyString?!n:Yt(n))&&!Yt(this._root)&&this._fallbackRoot},za.prototype._isSilentFallbackWarn=function(n){return this._silentFallbackWarn instanceof RegExp?this._silentFallbackWarn.test(n):this._silentFallbackWarn},za.prototype._isSilentFallback=function(n,e){return this._isSilentFallbackWarn(e)&&(this._isFallbackRoot()||n!==this.fallbackLocale)},za.prototype._isSilentTranslationWarn=function(n){return this._silentTranslationWarn instanceof RegExp?this._silentTranslationWarn.test(n):this._silentTranslationWarn},za.prototype._interpolate=function(n,e,t,a,r,i,o){if(!e)return null;var s,l=this._path.getPathValue(e,t);if(Wt(l)||Kt(l))return l;if(Yt(l)){if(!Kt(e))return null;if(!Qt(s=e[t])&&!Xt(s))return null}else{if(!Qt(l)&&!Xt(l))return null;s=l}return Qt(s)&&(s.indexOf("@:")>=0||s.indexOf("@.")>=0)&&(s=this._link(n,e,s,a,"raw",i,o)),this._render(s,r,i,t)},za.prototype._link=function(n,e,t,a,r,i,o){var s=t,l=s.match(Ea);for(var c in l)if(l.hasOwnProperty(c)){var u=l[c],d=u.match(Oa),p=d[0],h=d[1],f=u.replace(p,"").replace(La,"");if(ea(o,f))return s;o.push(f);var m=this._interpolate(n,e,f,a,"raw"===r?"string":r,"raw"===r?void 0:i,o);if(this._isFallbackRoot(m)){if(!this._root)throw Error("unexpected error");var g=this._root.$i18n;m=g._translate(g._getMessages(),g.locale,g.fallbackLocale,f,a,r,i)}m=this._warnDefault(n,f,m,a,Wt(i)?i:[i],r),this._modifiers.hasOwnProperty(h)?m=this._modifiers[h](m):$a.hasOwnProperty(h)&&(m=$a[h](m)),o.pop(),s=m?s.replace(u,m):s}return s},za.prototype._createMessageContext=function(n,e,t,a){var r=this,i=Wt(n)?n:[],o=Ht(n)?n:{},s=this._getMessages(),l=this.locale;return{list:function(n){return i[n]},named:function(n){return o[n]},values:n,formatter:e,path:t,messages:s,locale:l,linked:function(n){return r._interpolate(l,s[l]||{},n,null,a,void 0,[n])}}},za.prototype._render=function(n,e,t,a){if(Xt(n))return n(this._createMessageContext(t,this._formatter||Pa,a,e));var r=this._formatter.interpolate(n,t,a);return r||(r=Pa.interpolate(n,t,a)),"string"!==e||Qt(r)?r:r.join("")},za.prototype._appendItemToChain=function(n,e,t){var a=!1;return ea(n,e)||(a=!0,e&&(a="!"!==e[e.length-1],e=e.replace(/!/g,""),n.push(e),t&&t[e]&&(a=t[e]))),a},za.prototype._appendLocaleToChain=function(n,e,t){var a,r=e.split("-");do{var i=r.join("-");a=this._appendItemToChain(n,i,t),r.splice(-1,1)}while(r.length&&!0===a);return a},za.prototype._appendBlockToChain=function(n,e,t){for(var a=!0,r=0;r<e.length&&"boolean"==typeof a;r++){var i=e[r];Qt(i)&&(a=this._appendLocaleToChain(n,i,t))}return a},za.prototype._getLocaleChain=function(n,e){if(""===n)return[];this._localeChainCache||(this._localeChainCache={});var t=this._localeChainCache[n];if(!t){e||(e=this.fallbackLocale),t=[];for(var a,r=[n];Wt(r);)r=this._appendBlockToChain(t,r,e);(r=Qt(a=Wt(e)?e:Ht(e)?e.default?e.default:null:e)?[a]:a)&&this._appendBlockToChain(t,r,null),this._localeChainCache[n]=t}return t},za.prototype._translate=function(n,e,t,a,r,i,o){for(var s,l=this._getLocaleChain(e,t),c=0;c<l.length;c++){var u=l[c];if(!Yt(s=this._interpolate(u,n[u],a,r,i,o,[a])))return s}return null},za.prototype._t=function(n,e,t,a){for(var r,i=[],o=arguments.length-4;o-- >0;)i[o]=arguments[o+4];if(!n)return"";var s=Zt.apply(void 0,i);this._escapeParameterHtml&&(s.params=oa(s.params));var l=s.locale||e,c=this._translate(t,l,this.fallbackLocale,n,a,"string",s.params);if(this._isFallbackRoot(c)){if(!this._root)throw Error("unexpected error");return(r=this._root).$t.apply(r,[n].concat(i))}return c=this._warnDefault(l,n,c,a,i,"string"),this._postTranslation&&null!=c&&(c=this._postTranslation(c,n)),c},za.prototype.t=function(n){for(var e,t=[],a=arguments.length-1;a-- >0;)t[a]=arguments[a+1];return(e=this)._t.apply(e,[n,this.locale,this._getMessages(),null].concat(t))},za.prototype._i=function(n,e,t,a,r){var i=this._translate(t,e,this.fallbackLocale,n,a,"raw",r);if(this._isFallbackRoot(i)){if(!this._root)throw Error("unexpected error");return this._root.$i18n.i(n,e,r)}return this._warnDefault(e,n,i,a,[r],"raw")},za.prototype.i=function(n,e,t){return n?(Qt(e)||(e=this.locale),this._i(n,e,this._getMessages(),null,t)):""},za.prototype._tc=function(n,e,t,a,r){for(var i,o=[],s=arguments.length-5;s-- >0;)o[s]=arguments[s+5];if(!n)return"";void 0===r&&(r=1);var l={count:r,n:r},c=Zt.apply(void 0,o);return c.params=Object.assign(l,c.params),o=null===c.locale?[c.params]:[c.locale,c.params],this.fetchChoice((i=this)._t.apply(i,[n,e,t,a].concat(o)),r)},za.prototype.fetchChoice=function(n,e){if(!n||!Qt(n))return null;var t=n.split("|");return t[e=this.getChoiceIndex(e,t.length)]?t[e].trim():n},za.prototype.tc=function(n,e){for(var t,a=[],r=arguments.length-2;r-- >0;)a[r]=arguments[r+2];return(t=this)._tc.apply(t,[n,this.locale,this._getMessages(),null,e].concat(a))},za.prototype._te=function(n,e,t){for(var a=[],r=arguments.length-3;r-- >0;)a[r]=arguments[r+3];var i=Zt.apply(void 0,a).locale||e;return this._exist(t[i],n)},za.prototype.te=function(n,e){return this._te(n,this.locale,this._getMessages(),e)},za.prototype.getLocaleMessage=function(n){return na(this._vm.messages[n]||{})},za.prototype.setLocaleMessage=function(n,e){"warn"!==this._warnHtmlInMessage&&"error"!==this._warnHtmlInMessage||this._checkLocaleMessage(n,this._warnHtmlInMessage,e),this._vm.$set(this._vm.messages,n,e)},za.prototype.mergeLocaleMessage=function(n,e){"warn"!==this._warnHtmlInMessage&&"error"!==this._warnHtmlInMessage||this._checkLocaleMessage(n,this._warnHtmlInMessage,e),this._vm.$set(this._vm.messages,n,ra(void 0!==this._vm.messages[n]&&Object.keys(this._vm.messages[n]).length?Object.assign({},this._vm.messages[n]):{},e))},za.prototype.getDateTimeFormat=function(n){return na(this._vm.dateTimeFormats[n]||{})},za.prototype.setDateTimeFormat=function(n,e){this._vm.$set(this._vm.dateTimeFormats,n,e),this._clearDateTimeFormat(n,e)},za.prototype.mergeDateTimeFormat=function(n,e){this._vm.$set(this._vm.dateTimeFormats,n,ra(this._vm.dateTimeFormats[n]||{},e)),this._clearDateTimeFormat(n,e)},za.prototype._clearDateTimeFormat=function(n,e){for(var t in e){var a=n+"__"+t;this._dateTimeFormatters.hasOwnProperty(a)&&delete this._dateTimeFormatters[a]}},za.prototype._localizeDateTime=function(n,e,t,a,r,i){for(var o=e,s=a[o],l=this._getLocaleChain(e,t),c=0;c<l.length;c++){var u=l[c];if(o=u,!Yt(s=a[u])&&!Yt(s[r]))break}if(Yt(s)||Yt(s[r]))return null;var d,p=s[r];if(i)d=new Intl.DateTimeFormat(o,Object.assign({},p,i));else{var h=o+"__"+r;(d=this._dateTimeFormatters[h])||(d=this._dateTimeFormatters[h]=new Intl.DateTimeFormat(o,p))}return d.format(n)},za.prototype._d=function(n,e,t,a){if(!t)return(a?new Intl.DateTimeFormat(e,a):new Intl.DateTimeFormat(e)).format(n);var r=this._localizeDateTime(n,e,this.fallbackLocale,this._getDateTimeFormats(),t,a);if(this._isFallbackRoot(r)){if(!this._root)throw Error("unexpected error");return this._root.$i18n.d(n,t,e)}return r||""},za.prototype.d=function(n){for(var e=[],t=arguments.length-1;t-- >0;)e[t]=arguments[t+1];var a=this.locale,r=null,i=null;return 1===e.length?(Qt(e[0])?r=e[0]:Ht(e[0])&&(e[0].locale&&(a=e[0].locale),e[0].key&&(r=e[0].key)),i=Object.keys(e[0]).reduce((function(n,t){var a;return ea(Jt,t)?Object.assign({},n,((a={})[t]=e[0][t],a)):n}),null)):2===e.length&&(Qt(e[0])&&(r=e[0]),Qt(e[1])&&(a=e[1])),this._d(n,a,r,i)},za.prototype.getNumberFormat=function(n){return na(this._vm.numberFormats[n]||{})},za.prototype.setNumberFormat=function(n,e){this._vm.$set(this._vm.numberFormats,n,e),this._clearNumberFormat(n,e)},za.prototype.mergeNumberFormat=function(n,e){this._vm.$set(this._vm.numberFormats,n,ra(this._vm.numberFormats[n]||{},e)),this._clearNumberFormat(n,e)},za.prototype._clearNumberFormat=function(n,e){for(var t in e){var a=n+"__"+t;this._numberFormatters.hasOwnProperty(a)&&delete this._numberFormatters[a]}},za.prototype._getNumberFormatter=function(n,e,t,a,r,i){for(var o=e,s=a[o],l=this._getLocaleChain(e,t),c=0;c<l.length;c++){var u=l[c];if(o=u,!Yt(s=a[u])&&!Yt(s[r]))break}if(Yt(s)||Yt(s[r]))return null;var d,p=s[r];if(i)d=new Intl.NumberFormat(o,Object.assign({},p,i));else{var h=o+"__"+r;(d=this._numberFormatters[h])||(d=this._numberFormatters[h]=new Intl.NumberFormat(o,p))}return d},za.prototype._n=function(n,e,t,a){if(!za.availabilities.numberFormat)return"";if(!t)return(a?new Intl.NumberFormat(e,a):new Intl.NumberFormat(e)).format(n);var r=this._getNumberFormatter(n,e,this.fallbackLocale,this._getNumberFormats(),t,a),i=r&&r.format(n);if(this._isFallbackRoot(i)){if(!this._root)throw Error("unexpected error");return this._root.$i18n.n(n,Object.assign({},{key:t,locale:e},a))}return i||""},za.prototype.n=function(n){for(var e=[],t=arguments.length-1;t-- >0;)e[t]=arguments[t+1];var a=this.locale,r=null,i=null;return 1===e.length?Qt(e[0])?r=e[0]:Ht(e[0])&&(e[0].locale&&(a=e[0].locale),e[0].key&&(r=e[0].key),i=Object.keys(e[0]).reduce((function(n,t){var a;return ea(Ut,t)?Object.assign({},n,((a={})[t]=e[0][t],a)):n}),null)):2===e.length&&(Qt(e[0])&&(r=e[0]),Qt(e[1])&&(a=e[1])),this._n(n,a,r,i)},za.prototype._ntp=function(n,e,t,a){if(!za.availabilities.numberFormat)return[];if(!t)return(a?new Intl.NumberFormat(e,a):new Intl.NumberFormat(e)).formatToParts(n);var r=this._getNumberFormatter(n,e,this.fallbackLocale,this._getNumberFormats(),t,a),i=r&&r.formatToParts(n);if(this._isFallbackRoot(i)){if(!this._root)throw Error("unexpected error");return this._root.$i18n._ntp(n,e,t,a)}return i||[]},Object.defineProperties(za.prototype,Da),Object.defineProperty(za,"availabilities",{get:function(){if(!Aa){var n="undefined"!=typeof Intl;Aa={dateTimeFormat:n&&void 0!==Intl.DateTimeFormat,numberFormat:n&&void 0!==Intl.NumberFormat}}return Aa}}),za.install=ba,za.version="8.28.2";var Ma=za;
/*!
 * vssue - A vue-powered issue-based comment plugin
 *
 * @version v1.4.8
 * @link https://vssue.js.org
 * @license MIT
 * @copyright 2018-2021 meteorlxy
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */function Fa(n,e,t,a){var r,i=arguments.length,o=i<3?e:null===a?a=Object.getOwnPropertyDescriptor(e,t):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(n,e,t,a);else for(var s=n.length-1;s>=0;s--)(r=n[s])&&(o=(i<3?r(o):i>3?r(e,t,o):r(e,t))||o);return i>3&&o&&Object.defineProperty(e,t,o),o}var Ra=a.b.extend({name:"Iconfont"});function qa(n,e,t,a,r,i,o,s,l,c){"boolean"!=typeof o&&(l=s,s=o,o=!1);const u="function"==typeof t?t.options:t;let d;if(n&&n.render&&(u.render=n.render,u.staticRenderFns=n.staticRenderFns,u._compiled=!0,r&&(u.functional=!0)),a&&(u._scopeId=a),i?(d=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),e&&e.call(this,l(n)),n&&n._registeredComponents&&n._registeredComponents.add(i)},u._ssrRegister=d):e&&(d=o?function(n){e.call(this,c(n,this.$root.$options.shadowRoot))}:function(n){e.call(this,s(n))}),d)if(u.functional){const n=u.render;u.render=function(e,t){return d.call(t),n(e,t)}}else{const n=u.beforeCreate;u.beforeCreate=n?[].concat(n,d):[d]}return t}"undefined"!=typeof navigator&&/msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());const Na=qa({render:function(n,e){var t=e._c;return t("svg",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}]},[t("symbol",{attrs:{id:"vssue-icon-bitbucket",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M579.5522464 489.45249493q4.8371808 38.38537173-30.81752427 61.55702827t-67.95459093 3.66689493q-23.79580907-10.37653333-32.6119616-35.34262826t-0.31207573-50.01020907 31.67573333-35.34262827q21.92335253-11.00068587 44.1587808-7.33379093t39.00952427 21.61127573 16.77409493 41.1160384zM647.19476053 476.65737173q-8.50407573-65.22392427-68.8908192-99.9424t-120.07131413-7.9579424q-38.38537173 17.08617173-61.24495253 53.9111616t-21.0651424 78.95527574q2.41859093 55.4715424 47.20152426 94.48106666t100.87862827 34.1723424q55.4715424-4.8371808 92.60860907-51.18049493t30.50544746-102.43900907zM792.93434133 146.32472427q-12.17097173-16.4620192-34.1723424-27.15062827t-35.34262826-13.41927573-43.30057174-7.64586667q-177.33729493-28.63299093-345.00022826 1.24830507-26.2144 4.29104747-40.25782827 7.33379093t-33.54819093 13.41927573-30.50544747 26.2144q18.2564576 17.08617173 46.34331413 27.6967616t44.78293334 13.41927574 53.36502826 7.02171413q138.95192427 17.71032427 273.06666667 0.62415253 38.38537173-4.8371808 54.53531413-7.33379093t44.1587808-13.1072 45.7191616-28.32091413zM827.65281813 777.10872427q-4.8371808 15.83786667-9.44030506 46.65539093t-8.50407574 51.18049493-17.39824746 42.6764192-35.34262827 34.4064q-52.4288 29.2571424-115.46819093 43.61264747t-123.1140576 13.41927573-122.8019808-11.3127616q-28.0088384-4.8371808-49.69813334-11.00068586t-46.65539093-16.4620192-44.4708576-26.52647574-31.67573333-37.4491424q-15.21371413-58.51428587-34.71847574-177.96144746l3.66689494-9.7523808 11.00068586-5.46133334q135.9091808 90.1900192 308.72137174 90.1900192t309.34552426-90.1900192q12.79512427 3.66689493 14.5895616 14.04342827t-3.0427424 27.46270507-4.8371808 22.54750506zM937.97175147 191.41973333q-15.83786667 101.8148576-67.64251414 399.22346667-3.0427424 18.2564576-16.4620192 34.1723424t-26.52647573 24.3419424-33.23611413 18.88060907q-153.61950507 76.7707424-371.8387808 53.67710506-151.12289493-16.4620192-240.14262827-84.72868586-9.12822827-7.33379093-15.52579093-16.1499424t-10.37653334-21.2992-5.46133333-20.75306667-3.66689493-24.10788587-3.3548192-21.2992q-5.46133333-30.50544747-16.1499424-91.43832426t-17.08617174-98.4600384-14.35550506-89.8779424-13.41927574-96.27550507q1.7944384-15.83786667 10.68860907-29.5692192t19.19268587-22.8595808 27.46270506-18.2564576 28.0088384-13.73135253 29.2571424-11.3127616q76.22460907-28.0088384 190.75657174-39.00952427 231.0144-22.54750507 412.01859093 30.50544747 94.48106667 28.0088384 131.072 74.35215253 9.7523808 12.17097173 10.0644576 31.0515808t-3.3548192 32.9240384z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-gitea",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M184.31868985 236.10860742C106.94832667 235.94086648 3.32655508 285.13080468 9.02973665 408.46209936c8.93218827 192.65010787 206.32096845 210.5144844 285.20099725 212.06608453 8.63864186 36.14810496 101.48307766 160.77938883 170.21479898 167.32127321h301.09442177c180.57278288-11.99345499 315.77172611-546.07960359 215.54670217-548.09249109-165.7696721 7.79993906-264.02374305 11.74184405-348.27147151 12.41280591v166.69224585l-26.25140843-11.61603761-0.16773997-154.99233728c-96.70246985-0.04193548-181.83083757-4.52899687-343.4069947-12.49667687-20.21274496-0.12580547-48.39316992-3.5644886-78.67035236-3.64835859z m10.94507577 68.14462849h9.22573371c10.98701124 98.75729283 28.85138778 156.50200291 64.99949274 244.73357185-92.25734394-10.90314029-170.75995634-37.69970509-185.18564974-137.75698809-7.46445813-51.78991757 17.69663558-105.84433456 110.96042329-107.01851827z m358.83913087 97.07988723c6.29027343 0.08386999 12.70635233 1.25805468 18.74501482 4.02577499l31.40943263 13.54505513-22.51917887 41.05451824a28.18042496 25.03528825 0 0 0-10.10637297 1.59353561 28.18042496 25.03528825 0 0 0-16.98373825 32.038459 28.18042496 25.03528825 0 0 0 4.69673781 7.29671718l-38.83195528 70.70267333a28.18042496 25.03528825 0 0 0-9.30960467 1.59353659 28.18042496 25.03528825 0 0 0-16.98373825 32.038459 28.18042496 25.03528825 0 0 0 36.06423497 15.09665623 28.18042496 25.03528825 0 0 0 16.94180276-32.08039449 28.18042496 25.03528825 0 0 0-6.62575434-9.22573468l37.82551056-68.85752581a28.18042496 25.03528825 0 0 0 12.28700044-1.25805469 28.18042496 25.03528825 0 0 0 8.93218826-4.69673783c14.59343435 6.12253248 26.54495386 11.11281671 35.14166122 15.34826717 12.91602778 6.37414341 17.48696012 10.60959485 18.87082027 15.30633169 1.38386015 4.61286685-0.12580547 13.50312062-7.42252263 29.10299872-5.45157063 11.61603859-14.46762889 28.09655497-25.11915823 47.51253164a28.18042496 25.03528825 0 0 0-10.52572486 1.59353659 28.18042496 25.03528825 0 0 0-16.98373826 32.038459 28.18042496 25.03528825 0 0 0 36.06423498 15.09665623 28.18042496 25.03528825 0 0 0 16.94180278-32.03845901 28.18042496 25.03528825 0 0 0-5.74511608-8.47090188c10.52572388-19.20630122 19.58371762-35.72875308 25.41270465-48.14155897 7.88380904-16.85793279 11.99345499-29.39654416 8.38703091-41.51580463-3.60642311-12.11926046-14.67730434-20.0030695-29.35460966-27.25785217-9.6450856-4.73867233-21.68047607-9.77089106-36.06423399-15.80955357a28.18042496 25.03528825 0 0 0-1.59353562-10.022502 28.18042496 25.03528825 0 0 0-6.08059796-8.7644483l22.14176246-40.38355541 122.61839638 52.96410227c22.14176247 9.6031511 31.2836262 33.12877372 20.54822685 52.8382968l-84.28966393 154.32137544c-10.77733482 19.66758857-37.23841869 27.80300855-59.38018118 18.24179293l-173.48574115-74.98005927c-22.14176247-9.5612156-31.32556167-33.12877372-20.54822687-52.83829679l84.28966395-154.27943995c7.38058716-13.54505513 22.22563246-21.59660511 37.951317-22.22563246h2.68384935z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-gitee",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M978.404275 409.561604H455.061338c-25.117645 0-45.499734 20.382089-45.499734 45.499734l-0.031997 113.781333c0 25.117645 20.350092 45.499734 45.499734 45.531731h318.594132c25.117645 0 45.499734 20.382089 45.499734 45.499735v22.749867a136.5312 136.5312 0 0 1-136.5312 136.5312H250.248539a45.499734 45.499734 0 0 1-45.499734-45.499734V341.343999a136.5312 136.5312 0 0 1 136.5312-136.5312L978.308284 204.780802c25.117645 0 45.499734-20.350092 45.499734-45.467738L1023.904009 45.531731h0.031997A45.499734 45.499734 0 0 0 978.468269 0h-0.031997L341.343999 0.031997C152.84967 0.031997 0.031997 152.84967 0.031997 341.343999v637.092273c0 25.117645 20.382089 45.499734 45.499734 45.499734h671.233072a307.171203 307.171203 0 0 0 307.171203-307.171203v-261.671468c0-25.117645-20.382089-45.499734-45.499734-45.499734z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-github",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M512 20.4425c-278.334 0-504 225.6345-504 504 0 222.6735 144.4275 411.6105 344.673 478.233 25.2 4.662 34.461-10.9305 34.461-24.255 0-12.0015-0.4725-51.723-0.693-93.8385-140.238 30.492-169.8165-59.472-169.8165-59.472-22.932-58.2435-55.944-73.7415-55.944-73.7415-45.738-31.2795 3.465-30.6495 3.465-30.6495 50.589 3.5595 77.238 51.9435 77.238 51.9435 44.9505 77.049 117.9045 54.7785 146.664 41.895 4.5045-32.571 17.577-54.81 32.004-67.41-111.951-12.726-229.635-55.9755-229.635-249.0705 0-55.0305 19.6875-99.981 51.9435-135.2925-5.229-12.6945-22.491-63.945 4.8825-133.371 0 0 42.336-13.545 138.6315 51.66 40.194-11.1825 83.3175-16.758 126.1575-16.9785 42.8085 0.189 85.9635 5.796 126.252 16.9785 96.201-65.205 138.4425-51.66 138.4425-51.66 27.4365 69.426 10.1745 120.6765 4.9455 133.371 32.319 35.28 51.8805 80.262 51.8805 135.2925 0 193.5675-117.9045 236.187-230.139 248.6925 18.081 15.6555 34.1775 46.305 34.1775 93.3345 0 67.4415-0.5985 121.716-0.5985 138.3165 0 13.419 9.072 29.1375 34.6185 24.192 200.151-66.717 344.3895-255.5595 344.3895-478.17 0-278.3655-225.666-504-504-504z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-gitlab",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M66.61375986 405.11600042L512.11376028 976.03999972 23.84576 621.65599958a39.312 39.312 0 0 1-14.07600042-43.30799944l56.8080007-173.26800028z m259.88400014 0h371.26800014L512.14975986 976.03999972zM215.11376 60.88400042l111.384 344.232H66.61375986l111.384-344.232a19.72800014 19.72800014 0 0 1 37.11600014 0z m742.49999972 344.232l56.8080007 173.2679993a39.23999986 39.23999986 0 0 1-14.07600042 43.30800042l-488.26800028 354.38400014 445.50000042-570.92400028z m0 0h-259.88400014l111.384-344.232a19.72800014 19.72800014 0 0 1 37.11600014 0z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-loading",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M843.307 742.24c0 3.217 2.607 5.824 5.824 5.824s5.824-2.607 5.824-5.824a5.823 5.823 0 0 0-5.824-5.824 5.823 5.823 0 0 0-5.824 5.824zM714.731 874.912c0 6.398 5.186 11.584 11.584 11.584s11.584-5.186 11.584-11.584-5.186-11.584-11.584-11.584-11.584 5.186-11.584 11.584zM541.419 943.2c0 9.614 7.794 17.408 17.408 17.408s17.408-7.794 17.408-17.408-7.794-17.408-17.408-17.408-17.408 7.794-17.408 17.408z m-186.56-9.152c0 12.795 10.373 23.168 23.168 23.168s23.168-10.373 23.168-23.168-10.373-23.168-23.168-23.168-23.168 10.373-23.168 23.168zM189.355 849.12c0 16.012 12.98 28.992 28.992 28.992s28.992-12.98 28.992-28.992-12.98-28.992-28.992-28.992-28.992 12.98-28.992 28.992zM74.731 704.736c0 19.228 15.588 34.816 34.816 34.816s34.816-15.588 34.816-34.816-15.588-34.816-34.816-34.816-34.816 15.588-34.816 34.816z m-43.008-177.28c0 22.41 18.166 40.576 40.576 40.576s40.576-18.166 40.576-40.576-18.166-40.576-40.576-40.576-40.576 18.166-40.576 40.576z m35.392-176.128c0 25.626 20.774 46.4 46.4 46.4s46.4-20.774 46.4-46.4c0-25.626-20.774-46.4-46.4-46.4-25.626 0-46.4 20.774-46.4 46.4z m106.176-142.016c0 28.843 23.381 52.224 52.224 52.224s52.224-23.381 52.224-52.224c0-28.843-23.381-52.224-52.224-52.224-28.843 0-52.224 23.381-52.224 52.224z m155.904-81.344c0 32.024 25.96 57.984 57.984 57.984s57.984-25.96 57.984-57.984-25.96-57.984-57.984-57.984-57.984 25.96-57.984 57.984z m175.104-5.056c0 35.24 28.568 63.808 63.808 63.808s63.808-28.568 63.808-63.808c0-35.24-28.568-63.808-63.808-63.808-35.24 0-63.808 28.568-63.808 63.808z m160.32 72.128c0 38.421 31.147 69.568 69.568 69.568s69.568-31.147 69.568-69.568-31.147-69.568-69.568-69.568-69.568 31.147-69.568 69.568z m113.92 135.488c0 41.638 33.754 75.392 75.392 75.392s75.392-33.754 75.392-75.392-33.754-75.392-75.392-75.392-75.392 33.754-75.392 75.392z m45.312 175.488c0 44.854 36.362 81.216 81.216 81.216s81.216-36.362 81.216-81.216c0-44.854-36.362-81.216-81.216-81.216-44.854 0-81.216 36.362-81.216 81.216z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-like",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M885.9 533.7c16.8-22.2 26.1-49.4 26.1-77.7 0-44.9-25.1-87.4-65.5-111.1a67.67 67.67 0 0 0-34.3-9.3H572.4l6-122.9c1.4-29.7-9.1-57.9-29.5-79.4-20.5-21.5-48.1-33.4-77.9-33.4-52 0-98 35-111.8 85.1l-85.9 311H144c-17.7 0-32 14.3-32 32v364c0 17.7 14.3 32 32 32h601.3c9.2 0 18.2-1.8 26.5-5.4 47.6-20.3 78.3-66.8 78.3-118.4 0-12.6-1.8-25-5.4-37 16.8-22.2 26.1-49.4 26.1-77.7 0-12.6-1.8-25-5.4-37 16.8-22.2 26.1-49.4 26.1-77.7-0.2-12.6-2-25.1-5.6-37.1zM184 852V568h81v284h-81z m636.4-353l-21.9 19 13.9 25.4c4.6 8.4 6.9 17.6 6.9 27.3 0 16.5-7.2 32.2-19.6 43l-21.9 19 13.9 25.4c4.6 8.4 6.9 17.6 6.9 27.3 0 16.5-7.2 32.2-19.6 43l-21.9 19 13.9 25.4c4.6 8.4 6.9 17.6 6.9 27.3 0 22.4-13.2 42.6-33.6 51.8H329V564.8l99.5-360.5c5.2-18.9 22.5-32.2 42.2-32.3 7.6 0 15.1 2.2 21.1 6.7 9.9 7.4 15.2 18.6 14.6 30.5l-9.6 198.4h314.4C829 418.5 840 436.9 840 456c0 16.5-7.2 32.1-19.6 43z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-unlike",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M885.9 490.3c3.6-12 5.4-24.4 5.4-37 0-28.3-9.3-55.5-26.1-77.7 3.6-12 5.4-24.4 5.4-37 0-28.3-9.3-55.5-26.1-77.7 3.6-12 5.4-24.4 5.4-37 0-51.6-30.7-98.1-78.3-118.4-8.3-3.6-17.2-5.4-26.5-5.4H144c-17.7 0-32 14.3-32 32v364c0 17.7 14.3 32 32 32h129.3l85.8 310.8C372.9 889 418.9 924 470.9 924c29.7 0 57.4-11.8 77.9-33.4 20.5-21.5 31-49.7 29.5-79.4l-6-122.9h239.9c12.1 0 23.9-3.2 34.3-9.3 40.4-23.5 65.5-66.1 65.5-111 0-28.3-9.3-55.5-26.1-77.7zM184 456V172h81v284h-81z m627.2 160.4H496.8l9.6 198.4c0.6 11.9-4.7 23.1-14.6 30.5-6.1 4.5-13.6 6.8-21.1 6.7-19.6-0.1-36.9-13.4-42.2-32.3L329 459.2V172h415.4c20.4 9.2 33.6 29.4 33.6 51.8 0 9.7-2.3 18.9-6.9 27.3l-13.9 25.4 21.9 19c12.5 10.8 19.6 26.5 19.6 43 0 9.7-2.3 18.9-6.9 27.3l-13.9 25.4 21.9 19c12.5 10.8 19.6 26.5 19.6 43 0 9.7-2.3 18.9-6.9 27.3l-14 25.5 21.9 19c12.5 10.8 19.6 26.5 19.6 43 0 19.1-11 37.5-28.8 48.4z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-heart",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M923 283.6c-13.4-31.1-32.6-58.9-56.9-82.8-24.3-23.8-52.5-42.4-84-55.5-32.5-13.5-66.9-20.3-102.4-20.3-49.3 0-97.4 13.5-139.2 39-10 6.1-19.5 12.8-28.5 20.1-9-7.3-18.5-14-28.5-20.1-41.8-25.5-89.9-39-139.2-39-35.5 0-69.9 6.8-102.4 20.3-31.4 13-59.7 31.7-84 55.5-24.4 23.9-43.5 51.7-56.9 82.8-13.9 32.3-21 66.6-21 101.9 0 33.3 6.8 68 20.3 103.3 11.3 29.5 27.5 60.1 48.2 91 32.8 48.9 77.9 99.9 133.9 151.6 92.8 85.7 184.7 144.9 188.6 147.3l23.7 15.2c10.5 6.7 24 6.7 34.5 0l23.7-15.2c3.9-2.5 95.7-61.6 188.6-147.3 56-51.7 101.1-102.7 133.9-151.6 20.7-30.9 37-61.5 48.2-91 13.5-35.3 20.3-70 20.3-103.3 0.1-35.3-7-69.6-20.9-101.9zM512 814.8S156 586.7 156 385.5C156 283.6 240.3 201 344.3 201c73.1 0 136.5 40.8 167.7 100.4C543.2 241.8 606.6 201 679.7 201c104 0 188.3 82.6 188.3 184.5 0 201.2-356 429.3-356 429.3z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-edit",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M723.2 917.76H286.72c-65.28 0-118.4-51.2-118.4-113.92V261.76C168.32 198.4 221.44 147.2 286.72 147.2h375.04c17.92 0 32 14.08 32 32s-14.08 32-32 32H286.72c-30.08 0-54.4 22.4-54.4 49.92v542.08c0 27.52 24.32 49.92 54.4 49.92H723.2c30.08 0 54.4-22.4 54.4-49.92V440.32c0-17.92 14.08-32 32-32s32 14.08 32 32v363.52c0 62.72-53.12 113.92-118.4 113.92z"}}),e._v(" "),t("path",{attrs:{d:"M499.84 602.24c-7.68 0-14.72-2.56-21.12-7.68-13.44-11.52-14.72-32-3.2-45.44L780.16 198.4c11.52-13.44 32-14.72 45.44-3.2s14.72 32 3.2 45.44L524.16 591.36c-6.4 7.04-15.36 10.88-24.32 10.88z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-delete",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M677.647059 256l0-90.352941c0-37.436235-23.461647-60.235294-61.771294-60.235294L408.094118 105.411765c-38.249412 0-61.741176 22.799059-61.741176 60.235294l0 90.352941-180.705882 0 0 60.235294 60.235294 0 0 512c0 54.272 33.972706 90.352941 90.352941 90.352941l391.529412 0c55.085176 0 90.352941-33.490824 90.352941-90.352941l0-512 60.235294 0 0-60.235294L677.647059 256zM406.588235 165.647059l210.823529 0-1.264941 90.352941L406.588235 256 406.588235 165.647059zM737.882353 858.352941l-451.764706 0 0-542.117647 451.764706 0L737.882353 858.352941zM466.823529 376.470588l-58.729412 0-1.505882 391.529412 60.235294 0L466.823529 376.470588zM617.411765 376.470588l-60.235294 0 0 391.529412 60.235294 0L617.411765 376.470588z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-reply",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M426.666667 384 426.666667 213.333333 128 512 426.666667 810.666667 426.666667 635.733333C640 635.733333 789.333333 704 896 853.333333 853.333333 640 725.333333 426.666667 426.666667 384Z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-error",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M512 720m-48 0a48 48 0 1 0 96 0 48 48 0 1 0-96 0Z"}}),e._v(" "),t("path",{attrs:{d:"M480 416v184c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V416c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8z"}}),e._v(" "),t("path",{attrs:{d:"M955.7 856l-416-720c-6.2-10.7-16.9-16-27.7-16s-21.6 5.3-27.7 16l-416 720C56 877.4 71.4 904 96 904h832c24.6 0 40-26.6 27.7-48z m-783.5-27.9L512 239.9l339.8 588.2H172.2z"}})])])},staticRenderFns:[]},void 0,Ra,void 0,!0,void 0,!1,void 0,void 0,void 0);const Ba=qa({},void 0,a.b.extend({name:"TransitionFade",functional:!0,props:{group:{type:Boolean,required:!1,default:!1},tag:{type:String,required:!1,default:"div"}},render:(n,{props:e,children:t})=>n(e.group?"TransitionGroup":"Transition",{props:{name:"fade",mode:"out-in",appear:!0,tag:e.tag}},t)}),void 0,void 0,void 0,!1,void 0,void 0,void 0);const Ua=qa({},void 0,a.b.extend({name:"VssueIcon",functional:!0,props:{name:{type:String,required:!0},title:{type:String,required:!1,default:null}},render:(n,{props:e,data:t})=>n("svg",Object.assign(Object.assign({},t),{class:["vssue-icon","vssue-icon-"+e.name],attrs:{"aria-hidden":"true"}}),[n("title",e.title),n("use",{attrs:{"xlink:href":"#vssue-icon-"+e.name}})])}),void 0,void 0,void 0,!1,void 0,void 0,void 0);let Ja=class extends a.b{constructor(){super(...arguments),this.editMode=!1,this.editContent=this.comment.contentRaw,this.creatingReactions=[],this.isPutingComment=!1,this.isDeletingComment=!1}get currentUser(){return this.vssue.user?this.vssue.user.username:null}get content(){return this.comment.content}get author(){return this.comment.author}get createdAt(){return qt(this.comment.createdAt)}get updatedAt(){return qt(this.comment.updatedAt)}get showReactions(){return Boolean(this.vssue.API&&this.vssue.API.platform.meta.reactable&&this.comment.reactions&&!this.editMode)}get reactionKeys(){return["heart","like","unlike"]}get editContentRows(){return this.editContent.split("\n").length-1}get editInputRows(){return this.editContentRows<3?5:this.editContentRows+2}async postReaction({reaction:n}){try{if(this.creatingReactions.includes(n))return;this.creatingReactions.push(n);await this.vssue.postCommentReaction({commentId:this.comment.id,reaction:n})||this.vssue.$emit("error",new Error(this.vssue.$t("reactionGiven",{reaction:this.vssue.$t(n)})));const e=await this.vssue.getCommentReactions({commentId:this.comment.id});e&&(this.comment.reactions=e)}finally{this.creatingReactions.splice(this.creatingReactions.findIndex(e=>e===n),1)}}enterEdit(){this.editMode=!0,this.$nextTick(()=>{this.$refs.input.focus()})}resetEdit(){this.editMode=!1,this.editContent=this.comment.contentRaw}async putComment(){try{if(this.vssue.isPending)return;if(this.editContent!==this.comment.contentRaw){this.isPutingComment=!0,this.vssue.isUpdatingComment=!0;const n=await this.vssue.putComment({commentId:this.comment.id,content:this.editContent});n&&this.vssue.comments.data.splice(this.vssue.comments.data.findIndex(n=>n.id===this.comment.id),1,n)}this.editMode=!1}finally{this.isPutingComment=!1,this.vssue.isUpdatingComment=!1}}async deleteComment(){try{if(this.vssue.isPending)return;if(!window.confirm(this.vssue.$t("deleteConfirm")))return;this.isDeletingComment=!0,this.vssue.isUpdatingComment=!0;await this.vssue.deleteComment({commentId:this.comment.id})?(this.vssue.comments.count-=1,this.vssue.comments.data.length>1&&this.vssue.comments.data.splice(this.vssue.comments.data.findIndex(n=>n.id===this.comment.id),1),this.vssue.query.page>1&&this.vssue.query.page>Math.ceil(this.vssue.comments.count/this.vssue.query.perPage)?this.vssue.query.page-=1:await this.vssue.getComments()):this.vssue.$emit("error",new Error(this.vssue.$t("deleteFailed")))}finally{this.isDeletingComment=!1,this.vssue.isUpdatingComment=!1}}};Fa([Lt({type:Object,required:!0})],Ja.prototype,"comment",void 0),Fa([Ct()],Ja.prototype,"vssue",void 0),Ja=Fa([Object(Tt.b)({components:{VssueIcon:Ua}})],Ja);const Va=qa({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"vssue-comment",class:{"vssue-comment-edit-mode":n.editMode,"vssue-comment-disabled":n.isDeletingComment||n.isPutingComment}},[t("div",{staticClass:"vssue-comment-avatar"},[t("a",{attrs:{href:n.author.homepage,title:n.author.username,target:"_blank",rel:"noopener noreferrer"}},[t("img",{attrs:{src:n.author.avatar,alt:n.author.username}})])]),n._v(" "),t("div",{staticClass:"vssue-comment-body"},[n._t("body",[t("div",{staticClass:"vssue-comment-header"},[t("span",{staticClass:"vssue-comment-author"},[t("a",{attrs:{href:n.author.homepage,title:n.author.username,target:"_blank",rel:"noopener noreferrer"}},[n._v("\n            "+n._s(n.author.username)+"\n          ")])]),n._v(" "),t("span",{staticClass:"vssue-comment-created-at"},[n._v("\n          "+n._s(n.createdAt)+"\n        ")])]),n._v(" "),t("div",{staticClass:"vssue-comment-main"},[n.editMode?t("textarea",{directives:[{name:"model",rawName:"v-model",value:n.editContent,expression:"editContent"}],ref:"input",staticClass:"vssue-edit-comment-input",attrs:{rows:n.editInputRows},domProps:{value:n.editContent},on:{keyup:function(e){return!e.type.indexOf("key")&&n._k(e.keyCode,"enter",13,e.key,"Enter")?null:e.ctrlKey?n.putComment():null},input:function(e){e.target.composing||(n.editContent=e.target.value)}}}):t("article",{staticClass:"markdown-body",domProps:{innerHTML:n._s(n.content)}})]),n._v(" "),t("div",{staticClass:"vssue-comment-footer"},[n.editMode?t("span",{staticClass:"vssue-comment-hint"},[n._v("\n          "+n._s(n.vssue.$t("editMode"))+"\n        ")]):n._e(),n._v(" "),n.showReactions?t("span",{staticClass:"vssue-comment-reactions"},n._l(n.reactionKeys,(function(e){return t("span",{key:e,staticClass:"vssue-comment-reaction",attrs:{title:n.vssue.$t(n.creatingReactions.includes(e)?"loading":e)},on:{click:function(t){return n.postReaction({reaction:e})}}},[t("VssueIcon",{attrs:{name:n.creatingReactions.includes(e)?"loading":e,title:n.vssue.$t(n.creatingReactions.includes(e)?"loading":e)}}),n._v(" "),t("span",{staticClass:"vssue-comment-reaction-number"},[n._v("\n              "+n._s(n.comment.reactions[e])+"\n            ")])],1)})),0):n._e(),n._v(" "),t("span",{staticClass:"vssue-comment-operations"},[n.comment.author.username===n.currentUser&&n.editMode?t("span",{staticClass:"vssue-comment-operation",class:{"vssue-comment-operation-muted":n.isPutingComment},attrs:{title:n.vssue.$t(n.isPutingComment?"loading":"submit")},on:{click:function(e){return n.putComment()}}},[t("VssueIcon",{directives:[{name:"show",rawName:"v-show",value:n.isPutingComment,expression:"isPutingComment"}],attrs:{name:"loading",title:n.vssue.$t("loading")}}),n._v("\n\n            "+n._s(n.vssue.$t("submit"))+"\n          ")],1):n._e(),n._v(" "),n.comment.author.username===n.currentUser&&n.editMode?t("span",{staticClass:"vssue-comment-operation vssue-comment-operation-muted",attrs:{title:n.vssue.$t("cancel")},on:{click:function(e){return n.resetEdit()}}},[n._v("\n            "+n._s(n.vssue.$t("cancel"))+"\n          ")]):n._e(),n._v(" "),n.comment.author.username===n.currentUser?t("span",{directives:[{name:"show",rawName:"v-show",value:!n.editMode,expression:"!editMode"}],staticClass:"vssue-comment-operation",on:{click:function(e){return n.enterEdit()}}},[t("VssueIcon",{attrs:{name:"edit",title:n.vssue.$t("edit")}})],1):n._e(),n._v(" "),n.comment.author.username===n.currentUser||n.vssue.isAdmin?t("span",{directives:[{name:"show",rawName:"v-show",value:!n.editMode,expression:"!editMode"}],staticClass:"vssue-comment-operation",on:{click:function(e){return n.deleteComment()}}},[t("VssueIcon",{attrs:{name:n.isDeletingComment?"loading":"delete",title:n.vssue.$t(n.isDeletingComment?"loading":"delete")}})],1):n._e(),n._v(" "),t("span",{directives:[{name:"show",rawName:"v-show",value:!n.editMode,expression:"!editMode"}],staticClass:"vssue-comment-operation",on:{click:function(e){return n.vssue.$emit("reply-comment",n.comment)}}},[t("VssueIcon",{attrs:{name:"reply",title:n.vssue.$t("reply")}})],1)])])])],2)])},staticRenderFns:[]},void 0,Ja,void 0,!1,void 0,!1,void 0,void 0,void 0);let Wa=class extends a.b{get disabled(){return this.vssue.isPending}get pageCount(){const n=Math.ceil(this.vssue.comments.count/this.vssue.comments.perPage);return n>1?n:1}get perPageOptions(){const n=[5,10,20,50];return!n.includes(this.vssue.options.perPage)&&this.vssue.options.perPage<100&&n.push(this.vssue.options.perPage),n.sort((n,e)=>n-e)}get page(){return this.vssue.query.page>this.pageCount?this.pageCount:this.vssue.query.page}set page(n){n>0&&n<=this.pageCount&&(this.vssue.query.page=n)}get perPage(){return this.vssue.query.perPage}set perPage(n){this.perPageOptions.includes(n)&&(this.vssue.query.perPage=n)}};Fa([Ct()],Wa.prototype,"vssue",void 0),Wa=Fa([Object(Tt.b)({components:{VssueIcon:Ua}})],Wa);const Ha=qa({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"vssue-pagination"},[t("div",{staticClass:"vssue-pagination-per-page"},[t("label",[t("select",{directives:[{name:"model",rawName:"v-model",value:n.perPage,expression:"perPage"}],staticClass:"vssue-pagination-select",attrs:{disabled:n.disabled},on:{change:function(e){var t=Array.prototype.filter.call(e.target.options,(function(n){return n.selected})).map((function(n){return"_value"in n?n._value:n.value}));n.perPage=e.target.multiple?t:t[0]}}},n._l(n.perPageOptions,(function(e){return t("option",{key:e,domProps:{value:e}},[n._v("\n          "+n._s(e)+"\n        ")])})),0),n._v(" "),t("span",[n._v("\n        "+n._s(n.vssue.$t("perPage"))+"\n      ")])]),n._v(" "),n.vssue.API.platform.meta.sortable?t("span",{class:{"vssue-pagination-link":!0,disabled:n.disabled},attrs:{title:n.vssue.$t("sort")},on:{click:function(e){n.vssue.query.sort="asc"===n.vssue.query.sort?"desc":"asc"}}},[n._v("\n      "+n._s("asc"===n.vssue.query.sort?"↑":"↓")+"\n    ")]):n._e()]),n._v(" "),t("div",{staticClass:"vssue-pagination-page"},[t("span",{class:{"vssue-pagination-link":!0,disabled:1===n.page||n.disabled},attrs:{title:n.vssue.$t("prev")},domProps:{textContent:n._s("<")},on:{click:function(e){n.page-=1}}}),n._v(" "),t("label",[t("span",[n._v("\n        "+n._s(n.vssue.$t("page"))+"\n      ")]),n._v(" "),t("select",{directives:[{name:"show",rawName:"v-show",value:n.pageCount>1,expression:"pageCount > 1"},{name:"model",rawName:"v-model",value:n.page,expression:"page"}],staticClass:"vssue-pagination-select",attrs:{disabled:n.disabled},on:{change:function(e){var t=Array.prototype.filter.call(e.target.options,(function(n){return n.selected})).map((function(n){return"_value"in n?n._value:n.value}));n.page=e.target.multiple?t:t[0]}}},n._l(n.pageCount,(function(e){return t("option",{key:e,domProps:{value:e}},[n._v("\n          "+n._s(e)+"\n        ")])})),0),n._v(" "),t("span",{directives:[{name:"show",rawName:"v-show",value:n.pageCount<2,expression:"pageCount < 2"}],domProps:{textContent:n._s(n.page)}}),n._v(" "),t("span",{domProps:{textContent:n._s(" / "+n.pageCount+" ")}})]),n._v(" "),t("span",{class:{"vssue-pagination-link":!0,disabled:n.page===n.pageCount||n.disabled},attrs:{title:n.vssue.$t("next")},domProps:{textContent:n._s(">")},on:{click:function(e){n.page+=1}}})])])},staticRenderFns:[]},void 0,Wa,void 0,!1,void 0,!1,void 0,void 0,void 0);let Qa=class extends a.b{};Fa([Ct()],Qa.prototype,"vssue",void 0),Qa=Fa([Object(Tt.b)({components:{TransitionFade:Ba,VssueComment:Va,VssuePagination:Ha}})],Qa);const Ga=qa({render:function(){var n=this.$createElement,e=this._self._c||n;return e("div",{staticClass:"vssue-comments"},[e("VssuePagination"),this._v(" "),e("TransitionFade",{attrs:{group:""}},this._l(this.vssue.comments.data,(function(n){return e("VssueComment",{key:n.id,attrs:{comment:n}})})),1),this._v(" "),e("VssuePagination",{directives:[{name:"show",rawName:"v-show",value:this.vssue.comments.data.length>5,expression:"vssue.comments.data.length > 5"}]})],1)},staticRenderFns:[]},void 0,Qa,void 0,!1,void 0,!1,void 0,void 0,void 0);const Ka=qa({},void 0,a.b.extend({name:"VssueIcon",functional:!0,props:{type:{type:String,required:!1,default:"default"}},render:(n,{props:e,data:t,children:a})=>n("button",Object.assign(Object.assign({},t),{class:["vssue-button","vssue-button-"+e.type]}),a)}),void 0,void 0,void 0,!1,void 0,void 0,void 0);let Ya=class extends a.b{constructor(){super(...arguments),this.content=""}get user(){return this.vssue.user}get platform(){return this.vssue.API&&this.vssue.API.platform.name}get isInputDisabled(){return this.loading||null===this.user||null===this.vssue.issue}get isSubmitDisabled(){return""===this.content||this.vssue.isPending||null===this.vssue.issue}get loading(){return this.vssue.isCreatingComment}get contentRows(){return this.content.split("\n").length-1}get inputRows(){return this.contentRows<3?5:this.contentRows+2}created(){this.vssue.$on("reply-comment",n=>{const e=n.contentRaw.replace(/\n/g,"\n> "),t=`@${n.author.username}\n\n> ${e}\n\n`;this.content=this.content.concat(t),this.focus()})}beforeDestroy(){this.vssue.$off("reply-comment")}focus(){this.$refs.input.focus()}async submit(){this.isSubmitDisabled||(await this.vssue.postComment({content:this.content}),this.content="",await this.vssue.getComments())}};Fa([Ct()],Ya.prototype,"vssue",void 0),Ya=Fa([Object(Tt.b)({components:{VssueButton:Ka,VssueIcon:Ua}})],Ya);const Xa=qa({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"vssue-new-comment"},[t("div",{staticClass:"vssue-comment-avatar"},[n.user?t("a",{attrs:{href:n.user.homepage,title:n.user.username,target:"_blank",rel:"noopener noreferrer"}},[t("img",{attrs:{src:n.user.avatar,alt:n.user.username}})]):t("VssueIcon",{attrs:{name:n.platform.toLowerCase(),title:n.vssue.$t("loginToComment",{platform:n.platform})},on:{click:function(e){return n.vssue.login()}}})],1),n._v(" "),t("div",{staticClass:"vssue-new-comment-body"},[t("textarea",{directives:[{name:"model",rawName:"v-model",value:n.content,expression:"content"}],ref:"input",staticClass:"vssue-new-comment-input",attrs:{rows:n.inputRows,disabled:n.isInputDisabled,placeholder:n.vssue.$t(n.user?"placeholder":"noLoginPlaceHolder"),spellcheck:!1,"aria-label":"leave a comment"},domProps:{value:n.content},on:{keyup:function(e){return!e.type.indexOf("key")&&n._k(e.keyCode,"enter",13,e.key,"Enter")?null:e.ctrlKey?n.submit():null},input:function(e){e.target.composing||(n.content=e.target.value)}}})]),n._v(" "),t("div",{staticClass:"vssue-new-comment-footer"},[n.user?t("span",{staticClass:"vssue-current-user"},[t("span",[n._v(n._s(n.vssue.$t("currentUser"))+" - "+n._s(n.user.username)+" - ")]),n._v(" "),t("a",{staticClass:"vssue-logout",on:{click:function(e){return n.vssue.logout()}}},[n._v("\n        "+n._s(n.vssue.$t("logout"))+"\n      ")])]):t("span",{staticClass:"vssue-current-user"},[n._v("\n      "+n._s(n.vssue.$t("loginToComment",{platform:n.platform}))+"\n    ")]),n._v(" "),t("div",{staticClass:"vssue-new-comment-operations"},[n.user?t("VssueButton",{staticClass:"vssue-button-submit-comment",attrs:{type:"primary",disabled:n.isSubmitDisabled},on:{click:function(e){return n.submit()}}},[t("VssueIcon",{directives:[{name:"show",rawName:"v-show",value:n.loading,expression:"loading"}],attrs:{name:"loading"}}),n._v("\n\n        "+n._s(n.vssue.$t(n.loading?"submitting":"submitComment"))+"\n      ")],1):t("VssueButton",{staticClass:"vssue-button-login",attrs:{type:"primary",title:n.vssue.$t("loginToComment",{platform:n.platform})},on:{click:function(e){return n.vssue.login()}}},[n._v("\n        "+n._s(n.vssue.$t("login",{platform:n.platform}))+"\n      ")])],1)])])},staticRenderFns:[]},void 0,Ya,void 0,!1,void 0,!1,void 0,void 0,void 0);let Za=class extends a.b{constructor(){super(...arguments),this.progress={show:!1,percent:0,timer:null,speed:200},this.alert={show:!1,message:null,timer:null}}onLoadingCommentsChange(n){this.vssue.comments&&(n?this.progressStart():this.progressDone())}created(){this.vssue.$on("error",n=>this.alertShow(n.message))}beforeDestroy(){this.vssue.$off("error"),null!==this.progress.timer&&window.clearTimeout(this.progress.timer),null!==this.alert.timer&&window.clearTimeout(this.alert.timer)}progressStart(){this.progress.show=!0,this.progress.percent=0,this.progress.timer=window.setInterval(()=>{this.progress.percent+=5,this.progress.percent>94&&null!==this.progress.timer&&window.clearInterval(this.progress.timer)},this.progress.speed)}progressDone(){this.progress.percent=100,null!==this.progress.timer&&window.clearTimeout(this.progress.timer),this.progress.timer=null,window.setTimeout(()=>{this.progress.show=!1},this.progress.speed)}alertShow(n){this.alert.show=!0,this.alert.message=n,null!==this.alert.timer&&window.clearTimeout(this.alert.timer),this.alert.timer=window.setTimeout(()=>{this.alertHide()},3e3)}alertHide(){this.alert.show=!1,null!==this.alert.timer&&window.clearTimeout(this.alert.timer),this.alert.timer=null}};Fa([Ct()],Za.prototype,"vssue",void 0),Fa([$t("vssue.isLoadingComments")],Za.prototype,"onLoadingCommentsChange",null),Za=Fa([Object(Tt.b)({components:{TransitionFade:Ba}})],Za);const nr=qa({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"vssue-notice"},[t("div",{directives:[{name:"show",rawName:"v-show",value:n.progress.show,expression:"progress.show"}],staticClass:"vssue-progress",style:{width:n.progress.percent+"%",transition:"all "+n.progress.speed+"ms linear"}}),n._v(" "),t("TransitionFade",[t("div",{directives:[{name:"show",rawName:"v-show",value:n.alert.show,expression:"alert.show"}],staticClass:"vssue-alert",domProps:{textContent:n._s(n.alert.message)},on:{click:function(e){return n.alertHide()}}})])],1)},staticRenderFns:[]},void 0,Za,void 0,!1,void 0,!1,void 0,void 0,void 0);let er=class extends a.b{get status(){return this.vssue.isFailed?"failed":this.vssue.isInitializing?"initializing":this.vssue.isIssueNotCreated&&!this.vssue.isCreatingIssue?this.vssue.isAdmin||!this.vssue.isLogined?"issueNotCreated":"failed":this.vssue.isLoginRequired?"loginRequired":!this.vssue.comments||this.vssue.isCreatingIssue?"loadingComments":0===this.vssue.comments.data.length?"noComments":null}handleClick(){"issueNotCreated"===this.status?this.vssue.postIssue():"loginRequired"===this.status&&this.vssue.login()}};Fa([Ct()],er.prototype,"vssue",void 0),er=Fa([Object(Tt.b)({components:{TransitionFade:Ba,VssueIcon:Ua}})],er);const tr=qa({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("TransitionFade",[n.status?t("div",{key:n.status,staticClass:"vssue-status"},[["failed","loadingComments","initializing"].includes(n.status)?t("VssueIcon",{attrs:{name:"failed"===n.status?"error":"loading"}}):n._e(),n._v(" "),t("p",{staticClass:"vssue-status-info"},[t(["issueNotCreated","loginRequired"].includes(n.status)?"a":"span",{tag:"Component",on:{click:n.handleClick}},[n._v("\n        "+n._s(n.vssue.$t(n.status))+"\n      ")])],1)],1):n._e()])},staticRenderFns:[]},void 0,er,void 0,!1,void 0,!1,void 0,void 0,void 0);let ar=class extends a.b{};Fa([Ct()],ar.prototype,"vssue",void 0),ar=Fa([Object(Tt.b)({components:{TransitionFade:Ba,VssueIcon:Ua,VssueComments:Ga,VssueNewComment:Xa,VssueNotice:nr,VssueStatus:tr}})],ar);const rr=qa({render:function(){var n=this.$createElement,e=this._self._c||n;return e("TransitionFade",[this.vssue.isInitializing?e("VssueStatus"):e("div",{staticClass:"vssue-body"},[this.vssue.API?e("VssueNewComment"):this._e(),this._v(" "),e("VssueNotice"),this._v(" "),e("TransitionFade",[this.vssue.comments&&this.vssue.comments.data.length>0?e("VssueComments"):e("VssueStatus")],1)],1)],1)},staticRenderFns:[]},void 0,ar,void 0,!1,void 0,!1,void 0,void 0,void 0);let ir=class extends a.b{};Fa([Ct()],ir.prototype,"vssue",void 0),ir=Fa([Tt.b],ir);const or=qa({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"vssue-header"},[t("a",{staticClass:"vssue-header-comments-count",attrs:{href:n.vssue.issue?n.vssue.issue.link:null,target:"_blank",rel:"noopener noreferrer"}},[t("span",[n._v("\n      "+n._s(n.vssue.comments?n.vssue.$tc("comments",n.vssue.comments.count,{count:n.vssue.comments.count}):n.vssue.$tc("comments",0))+"\n    ")])]),n._v(" "),t("span",{staticClass:"vssue-header-powered-by"},[t("span",[n._v("Powered by")]),n._v(" "),n.vssue.API?t("span",[t("a",{attrs:{href:n.vssue.API.platform.link,title:n.vssue.API.platform.name+" API "+n.vssue.API.platform.version,target:"_blank",rel:"noopener noreferrer"}},[n._v("\n        "+n._s(n.vssue.API.platform.name)+"\n      ")]),n._v(" "),t("span",[n._v("&")])]):n._e(),n._v(" "),t("a",{attrs:{href:"https://github.com/meteorlxy/vssue",title:"Vssue v"+n.vssue.version,target:"_blank",rel:"noopener noreferrer"}},[n._v("\n      Vssue\n    ")])])])},staticRenderFns:[]},void 0,ir,void 0,!1,void 0,!1,void 0,void 0,void 0),sr={login:"Login with {platform}",logout:"Logout",currentUser:"Current User",loading:"Loading",submit:"Submit",submitting:"Submitting",submitComment:"Submit Comment",cancel:"Cancel",edit:"Edit",editMode:"Edit Mode",delete:"Delete",reply:"Reply",heart:"Heart",like:"Like",unlike:"Unlike",perPage:"Comments per page",sort:"Click to change the sort direction",page:"Page",prev:"Previous Page",next:"Next Page",comments:"Comments | {count} Comment | {count} Comments",loginToComment:"Login with {platform} account to leave a comment",placeholder:"Leave a comment. Styling with Markdown is supported. Ctrl + Enter to submit.",noLoginPlaceHolder:"Login to leave a comment. Styling with Markdown is supported. ",failed:"Failed to load comments",initializing:"Initializing...",issueNotCreated:"Click to create issue",loadingComments:"Loading comments...",loginRequired:"Login to view comments",noComments:"No comments yet. Leave the first comment !",reactionGiven:"Already given '{reaction}' reaction",deleteConfirm:"Confirm to delete this comment ?",deleteFailed:"Failed to delete comment"},lr={login:"使用 {platform} 登录",logout:"退出登录",currentUser:"当前用户",loading:"加载中",submit:"提交",submitting:"发表中",submitComment:"发表评论",cancel:"取消",edit:"编辑",editMode:"编辑模式",delete:"删除",reply:"回复",heart:"喜欢",like:"赞",unlike:"踩",perPage:"每页评论数",sort:"点击改变排序方式",page:"页数",prev:"上一页",next:"下一页",comments:"评论 | {count} 条评论 | {count} 条评论",loginToComment:"使用 {platform} 帐号登录后发表评论",placeholder:"留下你的评论丨支持 Markdown 语法丨Ctrl + Enter 发表评论",noLoginPlaceHolder:"登录后才能发表评论丨支持 Markdown 语法",failed:"评论加载失败",initializing:"正在初始化...",issueNotCreated:"点击创建 Issue",loadingComments:"正在加载评论...",loginRequired:"登录后查看评论",noComments:"还没有评论，来发表第一条评论吧！",reactionGiven:"已经添加过 '{reaction}' 了",deleteConfirm:"确认要删除该评论吗？",deleteFailed:"评论删除失败"},cr={login:"Entrar com {platform}",logout:"Sair",currentUser:"Usuário Atual",loading:"Carregando",submit:"Enviar",submitting:"Enviando",submitComment:"Enviar Comentário",cancel:"Cancelar",edit:"Editar",editMode:"Modo de Edição",delete:"Apagar",reply:"Responder",heart:"Heart",like:"Like",unlike:"Unlike",perPage:"Comentários por página",sort:"Clique para alterar a ordenação",page:"Página",prev:"Página Anterior",next:"Próxima Página",comments:"Comentários | {count} Comentário | {count} Comentários",loginToComment:"Entre com uma conta {platform} para deixar um comentário",placeholder:"Deixe um comentário. Estilos com Markdown suportados. Ctrl + Enter para enviar.",noLoginPlaceHolder:"Entre para deixar um comentário. Estilos com Markdown suportados. ",failed:"Falha ao carregar comentários",initializing:"Inicializando...",issueNotCreated:"Click to create issue",loadingComments:"Carregando comentários...",loginRequired:"Entrar para visualizar comentários",noComments:"Nenhum comentário. Deixe o primeiro comentário!",reactionGiven:"Já reagiu com '{reaction}'",deleteConfirm:"Apagar este comentário?",deleteFailed:"Falha ao apagar comentário"},ur={login:"{platform} でログイン",logout:"ログアウト",currentUser:"現在のユーザー",loading:"読み込み中",submit:"送信",submitting:"送信中",submitComment:"コメントを送信",cancel:"キャンセル",edit:"編集",editMode:"編集モード",delete:"削除",reply:"返信",heart:"ハート",like:"高評価",unlike:"低評価",perPage:"コメント/ページ",sort:"並び順を変更するにはクリックしてください",page:"ページ",prev:"前のページ",next:"次のページ",comments:"コメント | {count} コメント | {count} コメント",loginToComment:"コメントを残すには {platform} アカウントでログインしてください。",placeholder:"コメントを残してください。Markdown 記法をサポートしています。 Ctrl + Enter で送信できます。",noLoginPlaceHolder:"コメントを残すにはログインしてください。マークダウン記法をサポートしています。",failed:"コメントの読み込みに失敗しました",initializing:"初期化中...",issueNotCreated:"Click to create issue",loadingComments:"コメントの読み込み中...",loginRequired:"コメントを見るにはログインしてください",noComments:"まだコメントがありません。最初のコメントを残しましょう！",reactionGiven:"既に '{reaction}' のリアクションをしています",deleteConfirm:"本当にコメントを削除してもいいですか？",deleteFailed:"コメントの削除に失敗しました"},dr={login:"התחברו עם {platform}",logout:"התנתקו",currentUser:"משתמש/ת נוכחי/ת",loading:"טוען",submit:"שליחה",submitting:"שולח",submitComment:"שליחת תגובה",cancel:"ביטל",edit:"עריכה",editMode:"מצב עריכה",delete:"מחיקה",reply:"תשובה",heart:"לב",like:"לייק",unlike:"אנלייק",perPage:"תגובות לדף",sort:"לחצו כדי לשנות את כיוון המיון",page:"דף",prev:"הדף הקודם",next:"הדף הבא",comments:"תגובות | {count} תגובה | {count} תגובות",loginToComment:"התחברו עם חשבון {platform} כדי להשאיר תגובה",placeholder:"השאירו תגובה. יש תמיכה בעיצוב בעזרת Markdown. Ctrl + Enter כדי לשלוח.",noLoginPlaceHolder:"התחברו כדי להשאיר תגובה. יש תמיכה בעיצוב בעזרת Markdown. ",failed:"כשלון בטעינת התגובות",initializing:"מאתחל...",issueNotCreated:"לחצו ליצירת issue",loadingComments:"טוען תגובות...",loginRequired:"התחברו כדי לצפות בתגובות",noComments:"עדיין אין תגובות. השאירו תגובה ראשונה !",reactionGiven:"כבר ניתן חיווי '{reaction}'",deleteConfirm:"בטוחים במחיקת התגובה ?",deleteFailed:"כשלון במחיקת התגובה"};Object.prototype.hasOwnProperty.call(a.b,"$i18n")||a.b.use(Ma);const pr=new Ma({locale:"en",fallbackLocale:"en",messages:{en:sr,"en-US":sr,zh:lr,"zh-CN":lr,pt:cr,"pt-BR":cr,ja:ur,"ja-JP":ur,he:dr,"he-IL":dr}});let hr=class extends a.b{constructor(){super(...arguments),this.title=n=>`${n.prefix}${document.title}`,this.issueId=null,this.options=null,this.API=null,this.accessToken=null,this.user=null,this.issue=null,this.comments=null,this.query={page:1,perPage:10,sort:"desc"},this.isInitializing=!0,this.isIssueNotCreated=!1,this.isLoginRequired=!1,this.isFailed=!1,this.isCreatingIssue=!1,this.isLoadingComments=!1,this.isCreatingComment=!1,this.isUpdatingComment=!1}get version(){return"1.4.8"}get issueTitle(){return null===this.options?"":"function"==typeof this.title?this.title(this.options):`${this.options.prefix}${this.title}`}get isPending(){return this.isLoadingComments||this.isCreatingComment||this.isUpdatingComment}get isLogined(){return null!==this.accessToken&&null!==this.user}get isAdmin(){return null!==this.options&&null!==this.accessToken&&null!==this.user&&(this.user.username===this.options.owner||this.options.admins.includes(this.user.username))}get accessTokenKey(){return this.API?`Vssue.${this.API.platform.name.toLowerCase()}.access_token`:""}onQueryPerPageChange(){this.query.page=1,this.getComments()}onQueryChange(){this.getComments()}setOptions(n){this.options=Object.assign({labels:["Vssue"],state:"Vssue",prefix:"[Vssue]",admins:[],perPage:10,proxy:n=>"https://cors-anywhere.azm.workers.dev/"+n,issueContent:({url:n})=>n,autoCreateIssue:!1},n);const e=["api","owner","repo","clientId"];for(const n of e)this.options[n]||console.warn(`[Vssue] the option '${n}' is required`);if(this.options.locale)this.$i18n.locale=this.options.locale;else{const n=Object.keys(this.$i18n.messages),e=window.navigator.languages;this.$i18n.locale=e.filter(e=>n.includes(e)).shift()||"en"}}async init(){try{await this.initStore(),await this.initComments()}catch(n){n.response&&[401,403].includes(n.response.status)?this.isLoginRequired=!0:this.isFailed=!0,console.error(n)}}async initStore(){try{if(!this.options)throw new Error("Options are required to initialize Vssue");this.API=null,this.accessToken=null,this.user=null,this.issue=null,this.comments=null,this.query={page:1,perPage:this.options.perPage,sort:"desc"},this.isInitializing=!0,this.isIssueNotCreated=!1,this.isLoginRequired=!1,this.isFailed=!1,this.isCreatingIssue=!1,this.isLoadingComments=!1,this.isCreatingComment=!1,this.isUpdatingComment=!1;const n=this.options.api;this.API=new n({baseURL:this.options.baseURL,labels:this.options.labels,state:this.options.state,owner:this.options.owner,repo:this.options.repo,clientId:this.options.clientId,clientSecret:this.options.clientSecret,proxy:this.options.proxy}),await this.handleAuth()}finally{this.isInitializing=!1}}async initComments(){if(this.API&&this.options)if(this.issueId){const[n,e]=await Promise.all([this.API.getIssue({accessToken:this.accessToken,issueId:this.issueId}),this.API.getComments({accessToken:this.accessToken,issueId:this.issueId,query:this.query})]);this.issue=n,this.comments=e}else this.issue=await this.API.getIssue({accessToken:this.accessToken,issueTitle:this.issueTitle}),null===this.issue?(this.isIssueNotCreated=!0,this.options.autoCreateIssue&&await this.postIssue()):await this.getComments()}async postIssue(){if(this.API&&this.options&&!this.issue&&!this.issueId&&(this.isLogined||this.login(),this.isAdmin))try{this.isCreatingIssue=!0;const n=await this.API.postIssue({title:this.issueTitle,content:await this.options.issueContent({options:this.options,url:Nt(window.location.href)}),accessToken:this.accessToken});this.issue=n,this.isIssueNotCreated=!1,await this.getComments()}catch(n){this.isFailed=!0}finally{this.isCreatingIssue=!1}}async getComments(){try{if(!this.API||!this.issue||this.isLoadingComments)return;this.isLoadingComments=!0;const n=await this.API.getComments({accessToken:this.accessToken,issueId:this.issue.id,query:this.query});return this.comments=n,this.query.page!==n.page&&(this.query.page=n.page),this.query.perPage!==n.perPage&&(this.query.perPage=n.perPage),n}catch(n){if(!n.response||![401,403].includes(n.response.status)||this.isLogined)throw this.$emit("error",n),n;this.isLoginRequired=!0}finally{this.isLoadingComments=!1}}async postComment({content:n}){try{if(!this.API||!this.issue||this.isCreatingComment)return;this.isCreatingComment=!0;return await this.API.postComment({accessToken:this.accessToken,content:n,issueId:this.issue.id})}catch(n){throw this.$emit("error",n),n}finally{this.isCreatingComment=!1}}async putComment({commentId:n,content:e}){try{if(!this.API||!this.issue)return;return await this.API.putComment({accessToken:this.accessToken,issueId:this.issue.id,commentId:n,content:e})}catch(n){throw this.$emit("error",n),n}}async deleteComment({commentId:n}){try{if(!this.API||!this.issue)return;return await this.API.deleteComment({accessToken:this.accessToken,issueId:this.issue.id,commentId:n})}catch(n){throw this.$emit("error",n),n}}async getCommentReactions({commentId:n}){try{if(!this.API||!this.issue)return;return await this.API.getCommentReactions({accessToken:this.accessToken,issueId:this.issue.id,commentId:n})}catch(n){throw this.$emit("error",n),n}}async postCommentReaction({commentId:n,reaction:e}){try{if(!this.API||!this.issue)return!1;return await this.API.postCommentReaction({accessToken:this.accessToken,issueId:this.issue.id,commentId:n,reaction:e})}catch(n){throw this.$emit("error",n),n}}login(){this.API&&this.API.redirectAuth()}logout(){this.setAccessToken(null),this.user=null}async handleAuth(){if(!this.API)return;const n=await this.API.handleAuth();n?(this.setAccessToken(n),this.user=await this.API.getUser({accessToken:n})):this.getAccessToken()?this.user=await this.API.getUser({accessToken:this.accessToken}):(this.setAccessToken(null),this.user=null)}getAccessToken(){return this.accessToken=window.localStorage.getItem(this.accessTokenKey),this.accessToken}setAccessToken(n){null===n?window.localStorage.removeItem(this.accessTokenKey):window.localStorage.setItem(this.accessTokenKey,n),this.accessToken=n}};Fa([$t("query.perPage")],hr.prototype,"onQueryPerPageChange",null),Fa([$t("query.page"),$t("query.sort")],hr.prototype,"onQueryChange",null),hr=Fa([Object(Tt.b)({i18n:pr})],hr);var fr=hr;let mr=class extends a.b{constructor(){super(...arguments),this.vssue=new fr}onOptionsChange(n){this.vssue.setOptions(n)}mounted(){null!==this.title&&(this.vssue.title=this.title),null!==this.issueId&&(this.vssue.issueId=this.issueId),this.vssue.setOptions(this.options),this.vssue.init()}};var gr;Fa([Lt({type:[String,Function],required:!1,default:null})],mr.prototype,"title",void 0),Fa([Lt({type:[String,Number],required:!1,default:null})],mr.prototype,"issueId",void 0),Fa([Lt({type:Object,required:!1,default:()=>({})})],mr.prototype,"options",void 0),Fa([(gr="vssue",Object(Tt.a)((function(n,e){var t=n.provide;It(t)&&(t=n.provide=At(t)),t.managed[e]=gr||e})))],mr.prototype,"vssue",void 0),Fa([$t("options",{deep:!0})],mr.prototype,"onOptionsChange",null),mr=Fa([Object(Tt.b)({components:{Iconfont:Na,VssueBody:rr,VssueHeader:or}})],mr);const vr=qa({render:function(){var n=this.$createElement,e=this._self._c||n;return e("div",{staticClass:"vssue"},[e("Iconfont"),this._v(" "),e("VssueHeader"),this._v(" "),e("VssueBody")],1)},staticRenderFns:[]},void 0,mr,void 0,!1,void 0,!1,void 0,void 0,void 0);var yr=t(9),br=t.n(yr);function kr(n){return{username:n.login,avatar:n.avatar_url,homepage:n.html_url}}function wr(n){return{id:n.number,title:n.title,content:n.body,link:n.html_url}}function xr(n){return{like:n["+1"],unlike:n[-1],heart:n.heart}}function Sr(n){return{id:n.id,content:n.body_html,contentRaw:n.body,author:kr(n.user),createdAt:n.created_at,updatedAt:n.updated_at,reactions:xr(n.reactions)}}function _r(n){return"like"===n?"+1":"unlike"===n?"-1":n}class jr{constructor({baseURL:n="https://github.com",owner:e,repo:t,labels:a,clientId:r,clientSecret:i,state:o,proxy:s}){if(void 0===i||void 0===s)throw new Error("clientSecret and proxy is required for GitHub V3");this.baseURL=n,this.owner=e,this.repo=t,this.labels=a,this.clientId=r,this.clientSecret=i,this.state=o,this.proxy=s,this.$http=br.a.create({baseURL:"https://github.com"===n?"https://api.github.com":Mt(n,"api/v3"),headers:{Accept:"application/vnd.github.v3+json"}}),this.$http.interceptors.response.use(n=>n.data&&n.data.error?Promise.reject(new Error(n.data.error_description)):n,n=>(void 0===n.response&&"Network Error"===n.message&&(n.response={status:403}),Promise.reject(n)))}get platform(){return{name:"GitHub",link:this.baseURL,version:"v3",meta:{reactable:!0,sortable:!1}}}redirectAuth(){window.location.href=Dt(Mt(this.baseURL,"login/oauth/authorize"),{client_id:this.clientId,redirect_uri:window.location.href,scope:"public_repo",state:this.state})}async handleAuth(){const n=Bt(window.location.search);if(n.code){if(n.state!==this.state)return null;const e=n.code;delete n.code,delete n.state;const t=Dt(Nt(window.location.href),n)+window.location.hash;window.history.replaceState(null,"",t);return await this.getAccessToken({code:e})}return null}async getAccessToken({code:n}){const e=Mt(this.baseURL,"login/oauth/access_token"),t="function"==typeof this.proxy?this.proxy(e):this.proxy,{data:a}=await this.$http.post(t,{client_id:this.clientId,client_secret:this.clientSecret,code:n},{headers:{Accept:"application/json"}});return a.access_token}async getUser({accessToken:n}){const{data:e}=await this.$http.get("user",{headers:{Authorization:"token "+n}});return kr(e)}async getIssue({accessToken:n,issueId:e,issueTitle:t}){const a={};if(n&&(a.headers={Authorization:"token "+n}),!e){a.params={q:[`"${t}"`,"is:issue","in:title",`repo:${this.owner}/${this.repo}`,"is:public",...this.labels.map(n=>"label:"+n)].join(" "),timestamp:Date.now()};const{data:n}=await this.$http.get("search/issues",a);return n.items.map(wr).find(n=>n.title===t)||null}try{a.params={timestamp:Date.now()};const{data:n}=await this.$http.get(`repos/${this.owner}/${this.repo}/issues/${e}`,a);return wr(n)}catch(n){if(n.response&&404===n.response.status)return null;throw n}}async postIssue({accessToken:n,title:e,content:t}){const{data:a}=await this.$http.post(`repos/${this.owner}/${this.repo}/issues`,{title:e,body:t,labels:this.labels},{headers:{Authorization:"token "+n}});return wr(a)}async getComments({accessToken:n,issueId:e,query:{page:t=1,perPage:a=10}={}}){const r={params:{timestamp:Date.now()}},i={params:{page:t,per_page:a,timestamp:Date.now()},headers:{Accept:["application/vnd.github.v3.raw+json","application/vnd.github.v3.html+json","application/vnd.github.squirrel-girl-preview"]}};n&&(r.headers={Authorization:"token "+n},i.headers.Authorization="token "+n);const[o,s]=await Promise.all([this.$http.get(`repos/${this.owner}/${this.repo}/issues/${e}`,r),this.$http.get(`repos/${this.owner}/${this.repo}/issues/${e}/comments`,i)]),l=s.headers.link||null,c=/rel="next"/.test(l)?Number(l.replace(/^.*[^_]page=(\d*).*rel="next".*$/,"$1"))-1:/rel="prev"/.test(l)?Number(l.replace(/^.*[^_]page=(\d*).*rel="prev".*$/,"$1"))+1:1,u=l?Number(l.replace(/^.*per_page=(\d*).*$/,"$1")):a;return{count:Number(o.data.comments),page:c,perPage:u,data:s.data.map(Sr)}}async postComment({accessToken:n,issueId:e,content:t}){const{data:a}=await this.$http.post(`repos/${this.owner}/${this.repo}/issues/${e}/comments`,{body:t},{headers:{Authorization:"token "+n,Accept:["application/vnd.github.v3.raw+json","application/vnd.github.v3.html+json","application/vnd.github.squirrel-girl-preview"]}});return Sr(a)}async putComment({accessToken:n,commentId:e,content:t}){const{data:a}=await this.$http.patch(`repos/${this.owner}/${this.repo}/issues/comments/${e}`,{body:t},{headers:{Authorization:"token "+n,Accept:["application/vnd.github.v3.raw+json","application/vnd.github.v3.html+json","application/vnd.github.squirrel-girl-preview"]}});return Sr(a)}async deleteComment({accessToken:n,commentId:e}){const{status:t}=await this.$http.delete(`repos/${this.owner}/${this.repo}/issues/comments/${e}`,{headers:{Authorization:"token "+n}});return 204===t}async getCommentReactions({accessToken:n,commentId:e}){const{data:t}=await this.$http.get(`repos/${this.owner}/${this.repo}/issues/comments/${e}`,{params:{timestamp:Date.now()},headers:{Authorization:"token "+n,Accept:"application/vnd.github.squirrel-girl-preview"}});return xr(t.reactions)}async postCommentReaction({accessToken:n,commentId:e,reaction:t}){const a=await this.$http.post(`repos/${this.owner}/${this.repo}/issues/comments/${e}/reactions`,{content:_r(t)},{headers:{Authorization:"token "+n,Accept:"application/vnd.github.squirrel-girl-preview"}});return 200===a.status?this.deleteCommentReaction({accessToken:n,commentId:e,reactionId:a.data.id}):201===a.status}async deleteCommentReaction({accessToken:n,commentId:e,reactionId:t}){return 204===(await this.$http.delete(`repos/${this.owner}/${this.repo}/issues/comments/${e}/reactions/${t}`,{headers:{Authorization:"token "+n,Accept:"application/vnd.github.squirrel-girl-preview"}})).status}}function Tr(n){return null===n?{username:"ghost",avatar:"https://avatars3.githubusercontent.com/u/10137?v=4",homepage:"https://github.com/ghost"}:{username:n.login,avatar:n.avatarUrl,homepage:n.url}}function Cr(n){return{id:n.number,title:n.title,content:n.body,link:n.url}}function Ar(n){return{like:n.find(n=>"THUMBS_UP"===n.content).users.totalCount,unlike:n.find(n=>"THUMBS_DOWN"===n.content).users.totalCount,heart:n.find(n=>"HEART"===n.content).users.totalCount}}function Ir(n){return{id:n.id,content:n.bodyHTML,contentRaw:n.body,author:Tr(n.author),createdAt:n.createdAt,updatedAt:n.updatedAt,reactions:Ar(n.reactionGroups)}}function Er(n){return"like"===n?"THUMBS_UP":"unlike"===n?"THUMBS_DOWN":"heart"===n?"HEART":n}class Or{constructor({baseURL:n="https://github.com",owner:e,repo:t,labels:a,clientId:r,clientSecret:i,state:o,proxy:s}){if(void 0===i||void 0===s)throw new Error("clientSecret and proxy is required for GitHub V4");this.baseURL=n,this.owner=e,this.repo=t,this.labels=a,this.clientId=r,this.clientSecret=i,this.state=o,this.proxy=s,this._pageInfo={page:1,startCursor:null,endCursor:null,sort:null,perPage:null},this._issueNodeId=null,this.$http=br.a.create({baseURL:"https://github.com"===n?"https://api.github.com":Mt(n,"api"),headers:{Accept:"application/vnd.github.v3+json"}}),this.$http.interceptors.response.use(n=>n.data.error?Promise.reject(n.data.error_description):n.data.errors?Promise.reject(n.data.errors[0].message):n)}get platform(){return{name:"GitHub",link:this.baseURL,version:"v4",meta:{reactable:!0,sortable:!0}}}redirectAuth(){window.location.href=Dt(Mt(this.baseURL,"login/oauth/authorize"),{client_id:this.clientId,redirect_uri:window.location.href,scope:"public_repo",state:this.state})}async handleAuth(){const n=Bt(window.location.search);if(n.code){if(n.state!==this.state)return null;const e=n.code;delete n.code,delete n.state;const t=Dt(Nt(window.location.href),n)+window.location.hash;window.history.replaceState(null,"",t);return await this.getAccessToken({code:e})}return null}async getAccessToken({code:n}){const e=Mt(this.baseURL,"login/oauth/access_token"),t="function"==typeof this.proxy?this.proxy(e):this.proxy,{data:a}=await this.$http.post(t,{client_id:this.clientId,client_secret:this.clientSecret,code:n},{headers:{Accept:"application/json"}});return a.access_token}async getUser({accessToken:n}){const{data:e}=await this.$http.post("graphql",{query:"query getUser {\n  viewer {\n    login\n    avatarUrl\n    url\n  }\n}"},{headers:{Authorization:"token "+n}});return Tr(e.data.viewer)}async getIssue({accessToken:n,issueId:e,issueTitle:t}){const a={};if(n&&(a.headers={Authorization:"token "+n}),!e){const n=[`"${t}"`,"in:title",`repo:${this.owner}/${this.repo}`,"is:public",...this.labels.map(n=>"label:"+n)].join(" "),{data:e}=await this.$http.post("graphql",{variables:{query:n},query:"query getIssueByTitle(\n  $query: String!\n) {\n  search(\n    query: $query\n    type: ISSUE\n    first: 20\n    ) {\n      nodes {\n      ... on Issue {\n        id\n        number\n        title\n        body\n        url\n      }\n    }\n  }\n}"},a),r=e.data.search.nodes.find(n=>n.title===t);return r?(this._issueNodeId=r.id,Cr(r)):null}try{const{data:n}=await this.$http.post("graphql",{query:`query getIssueById {\n  repository(owner: "${this.owner}", name: "${this.repo}") {\n    issue (number: ${e}) {\n      id\n      number\n      title\n      body\n      url\n    }\n  }\n}`},a);return this._issueNodeId=n.data.repository.issue.id,Cr(n.data.repository.issue)}catch(n){if(n.response&&404===n.response.status)return null;throw n}}async postIssue({accessToken:n,title:e,content:t}){const{data:a}=await this.$http.post(`repos/${this.owner}/${this.repo}/issues`,{title:e,body:t,labels:this.labels},{headers:{Authorization:"token "+n}});return a.url=a.html_url,this._issueNodeId=a.node_id,Cr(a)}async getComments({accessToken:n,issueId:e,query:{page:t=1,perPage:a=10,sort:r="desc"}={}}){const i={};n&&(i.headers={Authorization:"token "+n}),null!==this._pageInfo.sort&&r!==this._pageInfo.sort&&(t=1);const{firstOrLast:o,afterOrBefore:s,cursor:l}=this._getQueryParams({page:t,sort:r}),{data:c}=await this.$http.post("graphql",{variables:{owner:this.owner,repo:this.repo,issueId:e,perPage:a},query:`query getComments(\n  $owner: String!\n  $repo: String!\n  $issueId: Int!\n  $perPage: Int!\n) {\n  repository(owner: $owner, name: $repo) {\n    issue(number: $issueId) {\n      comments(\n        ${o}: $perPage\n        ${null===s?"":`${s}: "${l}"`}\n      ) {\n        totalCount\n        pageInfo {\n          endCursor\n          startCursor\n        }\n        nodes {\n          id\n          body\n          bodyHTML\n          createdAt\n          updatedAt\n          author {\n            avatarUrl\n            login\n            url\n          }\n          reactionGroups {\n            users (first: 0) {\n              totalCount\n            }\n            content\n          }\n        }\n      }\n    }\n  }\n}`},i),u=c.data.repository.issue.comments;return"desc"===r&&u.nodes.reverse(),this._pageInfo={page:t,startCursor:u.pageInfo.startCursor,endCursor:u.pageInfo.endCursor,sort:r,perPage:a},{count:u.totalCount,page:t,perPage:a,data:u.nodes.map(Ir)}}async postComment({accessToken:n,content:e}){const{data:t}=await this.$http.post("graphql",{variables:{issueNodeId:this._issueNodeId,content:e},query:"mutation postComment(\n  $issueNodeId: ID!\n  $content: String!\n) {\n  addComment(\n    input: {\n      subjectId: $issueNodeId\n      body: $content\n    }\n  ) {\n    commentEdge {\n      node {\n        id\n        body\n        bodyHTML\n        createdAt\n        updatedAt\n        author {\n          avatarUrl\n          login\n          url\n        }\n        reactionGroups {\n          users (first: 0) {\n            totalCount\n          }\n          content\n        }\n      }\n    }\n  }\n}"},{headers:{Authorization:"token "+n}});return Ir(t.data.addComment.commentEdge.node)}async putComment({accessToken:n,commentId:e,content:t}){const{data:a}=await this.$http.post("graphql",{variables:{commentId:e,content:t},query:"mutation putComment(\n  $commentId: ID!,\n  $content: String!,\n) {\n  updateIssueComment(input: {\n    id: $commentId\n    body: $content\n  }) {\n    issueComment {\n      id\n      body\n      bodyHTML\n      createdAt\n      updatedAt\n      author {\n        avatarUrl\n        login\n        url\n      }\n      reactionGroups {\n        users (first: 0) {\n          totalCount\n        }\n        content\n      }\n    }\n  }\n}"},{headers:{Authorization:"token "+n}});return Ir(a.data.updateIssueComment.issueComment)}async deleteComment({accessToken:n,commentId:e}){return await this.$http.post("graphql",{variables:{commentId:e},query:"mutation deleteComment(\n  $commentId: ID!,\n) {\n  deleteIssueComment(input: {\n    id: $commentId\n  }) {\n    clientMutationId\n  }\n}"},{headers:{Authorization:"token "+n}}),!0}async getCommentReactions({accessToken:n,issueId:e,commentId:t}){const{firstOrLast:a,afterOrBefore:r,cursor:i}=this._getQueryParams(),{data:o}=await this.$http.post("graphql",{variables:{owner:this.owner,repo:this.repo,issueId:e,perPage:this._pageInfo.perPage},query:`query getComments(\n  $owner: String!\n  $repo: String!\n  $issueId: Int!\n  $perPage: Int!\n) {\n  repository(owner: $owner, name: $repo) {\n    issue(number: $issueId) {\n      comments(\n        ${a}: $perPage\n        ${null===r?"":`${r}: "${i}"`}\n      ) {\n        nodes {\n          id\n          reactionGroups {\n            users (first: 0) {\n              totalCount\n            }\n            content\n          }\n        }\n      }\n    }\n  }\n}`},{headers:{Authorization:"token "+n}});return Ar(o.data.repository.issue.comments.nodes.find(n=>n.id===t).reactionGroups)}async postCommentReaction({accessToken:n,commentId:e,reaction:t}){return await this.$http.post("graphql",{variables:{commentId:e,content:Er(t)},query:"mutation postCommentReaction(\n  $commentId: ID!,\n  $content: ReactionContent!,\n) {\n  addReaction(input: {\n    subjectId: $commentId\n    content: $content\n  }) {\n    reaction {\n      databaseId\n    }\n  }\n}"},{headers:{Authorization:"token "+n}}),!0}_getQueryParams({page:n=this._pageInfo.page,sort:e=this._pageInfo.sort}={}){let t,a,r;return 1===n?(t="asc"===e?"first":"last",a=null,r=null):"asc"===e?n>this._pageInfo.page?(t="first",a="after",r=this._pageInfo.endCursor):(t="last",a="before",r=this._pageInfo.startCursor):n>this._pageInfo.page?(t="last",a="before",r=this._pageInfo.startCursor):(t="first",a="after",r=this._pageInfo.endCursor),{firstOrLast:t,afterOrBefore:a,cursor:r}}}function Lr(n){return{username:n.username,avatar:n.avatar_url,homepage:n.web_url}}function $r(n){return{id:n.iid,title:n.title,content:n.description,link:n.web_url}}function Pr(n){return{id:n.id,content:n.body_html||"",contentRaw:n.body,author:Lr(n.author),createdAt:n.created_at,updatedAt:n.updated_at,reactions:n.reactions}}function zr(n){return{like:n.filter(n=>"thumbsup"===n.name).length,unlike:n.filter(n=>"thumbsdown"===n.name).length,heart:n.filter(n=>"heart"===n.name).length}}function Dr(n){return"like"===n?"thumbsup":"unlike"===n?"thumbsdown":n}class Mr{constructor({baseURL:n="https://gitlab.com",owner:e,repo:t,labels:a,clientId:r,state:i}){this.baseURL=n,this.owner=e,this.repo=t,this.labels=a,this.clientId=r,this.state=i,this._encodedRepo=encodeURIComponent(`${this.owner}/${this.repo}`),this.$http=br.a.create({baseURL:Mt(n,"api/v4"),headers:{Accept:"application/json"}})}get platform(){return{name:"GitLab",link:this.baseURL,version:"v4",meta:{reactable:!0,sortable:!0}}}redirectAuth(){window.location.href=Dt(Mt(this.baseURL,"oauth/authorize"),{client_id:this.clientId,redirect_uri:window.location.href,response_type:"token",state:this.state})}async handleAuth(){const n=Bt(window.location.hash.slice(1));if(!n.access_token||n.state!==this.state)return null;const e=n.access_token;delete n.access_token,delete n.token_type,delete n.expires_in,delete n.state;const t=zt(n),a=t?"#"+t:"",r=`${Nt(window.location.href)}${window.location.search}${a}`;return window.history.replaceState(null,"",r),e}async getUser({accessToken:n}){const{data:e}=await this.$http.get("user",{headers:{Authorization:"Bearer "+n}});return Lr(e)}async getIssue({accessToken:n,issueId:e,issueTitle:t}){const a={};if(n&&(a.headers={Authorization:"Bearer "+n}),!e){a.params={labels:this.labels.join(","),order_by:"created_at",sort:"asc",search:t};const{data:n}=await this.$http.get(`projects/${this._encodedRepo}/issues`,a);return n.map($r).find(n=>n.title===t)||null}try{const{data:n}=await this.$http.get(`projects/${this._encodedRepo}/issues/${e}`,a);return $r(n)}catch(n){if(n.response&&404===n.response.status)return null;throw n}}async postIssue({accessToken:n,title:e,content:t}){const{data:a}=await this.$http.post(`projects/${this._encodedRepo}/issues`,{title:e,description:t,labels:this.labels.join(",")},{headers:{Authorization:"Bearer "+n}});return $r(a)}async getComments({accessToken:n,issueId:e,query:{page:t=1,perPage:a=10,sort:r="desc"}={}}){const i={params:{page:t,per_page:a,order_by:"created_at",sort:r}};n&&(i.headers={Authorization:"Bearer "+n});const o=await this.$http.get(`projects/${this._encodedRepo}/issues/${e}/notes`,i),s=o.data,l=[];for(const t of s)l.push((async()=>{t.body_html=await this.getMarkdownContent({accessToken:n,contentRaw:t.body})})()),l.push((async()=>{t.reactions=await this.getCommentReactions({accessToken:n,issueId:e,commentId:t.id})})());return await Promise.all(l),{count:Number(o.headers["x-total"]),page:Number(o.headers["x-page"]),perPage:Number(o.headers["x-per-page"]),data:s.map(Pr)}}async postComment({accessToken:n,issueId:e,content:t}){const{data:a}=await this.$http.post(`projects/${this._encodedRepo}/issues/${e}/notes`,{body:t},{headers:{Authorization:"Bearer "+n}});return Pr(a)}async putComment({accessToken:n,issueId:e,commentId:t,content:a}){const{data:r}=await this.$http.put(`projects/${this._encodedRepo}/issues/${e}/notes/${t}`,{body:a},{headers:{Authorization:"Bearer "+n}}),[i,o]=await Promise.all([this.getMarkdownContent({accessToken:n,contentRaw:r.body}),this.getCommentReactions({accessToken:n,issueId:e,commentId:r.id})]);return r.body_html=i,r.reactions=o,Pr(r)}async deleteComment({accessToken:n,issueId:e,commentId:t}){const{status:a}=await this.$http.delete(`projects/${this._encodedRepo}/issues/${e}/notes/${t}`,{headers:{Authorization:"Bearer "+n}});return 204===a}async getCommentReactions({accessToken:n,issueId:e,commentId:t}){const{data:a}=await this.$http.get(`projects/${this._encodedRepo}/issues/${e}/notes/${t}/award_emoji`,{headers:{Authorization:"Bearer "+n}});return zr(a)}async postCommentReaction({issueId:n,commentId:e,reaction:t,accessToken:a}){try{return 201===(await this.$http.post(`projects/${this._encodedRepo}/issues/${n}/notes/${e}/award_emoji`,{name:Dr(t)},{headers:{Authorization:"Bearer "+a}})).status}catch(n){if(n.response&&404===n.response.status)return!1;throw n}}async getMarkdownContent({accessToken:n,contentRaw:e}){const t={};n&&(t.headers={Authorization:"Bearer "+n});const{data:a}=await this.$http.post("markdown",{text:e,gfm:!0},t);return a.html}}function Fr(n){return{username:n.nickname,avatar:n.links.avatar.href,homepage:n.links.html.href}}function Rr(n){return{id:n.id,title:n.title,content:n.content.raw,link:n.links.html.href}}function qr(n){return{id:n.id,content:n.content.html,contentRaw:n.content.raw,author:Fr(n.user),createdAt:n.created_on,updatedAt:n.updated_on,reactions:null}}class Nr{constructor({baseURL:n="https://bitbucket.org",owner:e,repo:t,clientId:a,state:r}){this.baseURL=n,this.owner=e,this.repo=t,this.clientId=a,this.state=r,this.$http=br.a.create({baseURL:"https://api.bitbucket.org/2.0",headers:{Accept:"application/json"}})}get platform(){return{name:"Bitbucket",link:this.baseURL,version:"v2",meta:{reactable:!1,sortable:!0}}}redirectAuth(){window.location.href=Dt(Mt(this.baseURL,"site/oauth2/authorize"),{client_id:this.clientId,redirect_uri:window.location.href,response_type:"token",state:this.state})}async handleAuth(){const n=Bt(window.location.hash.slice(1));if(!n.access_token||n.state!==this.state)return null;const e=n.access_token;delete n.access_token,delete n.token_type,delete n.expires_in,delete n.state,delete n.scopes;const t=zt(n),a=t?"#"+t:"",r=`${Nt(window.location.href)}${window.location.search}${a}`;return window.history.replaceState(null,"",r),e}async getUser({accessToken:n}){const{data:e}=await this.$http.get("user",{headers:{Authorization:"Bearer "+n}});return Fr(e)}async getIssue({accessToken:n,issueId:e,issueTitle:t}){const a={};if(n&&(a.headers={Authorization:"Bearer "+n}),!e){a.params={sort:"created_on",q:`title="${t}"`,timestamp:Date.now()};const{data:n}=await this.$http.get(`repositories/${this.owner}/${this.repo}/issues`,a);return n.size>0?Rr(n.values[0]):null}try{a.params={timestamp:Date.now()};const{data:n}=await this.$http.get(`repositories/${this.owner}/${this.repo}/issues/${e}`,a);return Rr(n)}catch(n){if(n.response&&404===n.response.status)return null;throw n}}async postIssue({accessToken:n,title:e,content:t}){const{data:a}=await this.$http.post(`repositories/${this.owner}/${this.repo}/issues`,{title:e,content:{raw:t},priority:"trivial",kind:"task"},{headers:{Authorization:"Bearer "+n}});return a.links.html={href:Mt(this.baseURL,`${this.owner}/${this.repo}/issues/${a.id}`)},Rr(a)}async getComments({accessToken:n,issueId:e,query:{page:t=1,perPage:a=10,sort:r="desc"}={}}){const i={params:{page:t,pagelen:a,sort:"desc"===r?"-created_on":"created_on",timestamp:Date.now()}};n&&(i.headers={Authorization:"Bearer "+n});const{data:o}=await this.$http.get(`repositories/${this.owner}/${this.repo}/issues/${e}/comments`,i);return{count:o.size,page:o.page,perPage:o.pagelen,data:o.values.filter(n=>null!==n.content.raw).map(qr)}}async postComment({accessToken:n,issueId:e,content:t}){const{data:a}=await this.$http.post(`repositories/${this.owner}/${this.repo}/issues/${e}/comments`,{content:{raw:t}},{headers:{Authorization:"Bearer "+n}});return qr(a)}async putComment({accessToken:n,issueId:e,commentId:t,content:a}){const{data:r}=await this.$http.put(`repositories/${this.owner}/${this.repo}/issues/${e}/comments/${t}`,{content:{raw:a}},{headers:{Authorization:"Bearer "+n}});return qr(r)}async deleteComment({accessToken:n,issueId:e,commentId:t}){const{status:a}=await this.$http.delete(`repositories/${this.owner}/${this.repo}/issues/${e}/comments/${t}`,{headers:{Authorization:"Bearer "+n}});return 204===a}async getCommentReactions(n){throw new Error("501 Not Implemented")}async postCommentReaction(n){throw new Error("501 Not Implemented")}}function Br(n){return{username:n.login,avatar:n.avatar_url,homepage:n.html_url}}function Ur(n){return{id:n.number,title:n.title,content:n.body,link:n.html_url}}function Jr(n){return{id:n.id,content:n.body_html||"",contentRaw:n.body,author:Br(n.user),createdAt:n.created_at,updatedAt:n.updated_at||"",reactions:null}}class Vr{constructor({baseURL:n="https://gitee.com",owner:e,repo:t,labels:a,clientId:r,clientSecret:i,state:o,proxy:s}){if(void 0===i||void 0===s)throw new Error("clientSecret and proxy is required for Gitee V5");this.baseURL=n,this.owner=e,this.repo=t,this.labels=a,this.clientId=r,this.clientSecret=i,this.state=o,this.proxy=s,this.$http=br.a.create({baseURL:Mt(n,"api/v5")}),this.$http.interceptors.response.use(n=>n,n=>(n.response.data&&n.response.data.message&&(n.message=n.response.data.message),Promise.reject(n)))}get platform(){return{name:"Gitee",link:this.baseURL,version:"v5",meta:{reactable:!1,sortable:!1}}}redirectAuth(){window.location.href=Dt(Mt(this.baseURL,"oauth/authorize"),{client_id:this.clientId,redirect_uri:window.location.href,scope:"user_info issues notes",response_type:"code",state:this.state})}async handleAuth(){const n=Bt(window.location.search);if(n.code){if(n.state!==this.state)return null;const e=n.code;delete n.code,delete n.state;const t=Dt(Nt(window.location.href),n)+window.location.hash;window.history.replaceState(null,"",t);return await this.getAccessToken({code:e})}return null}async getAccessToken({code:n}){const e=Mt(this.baseURL,"oauth/token"),t="function"==typeof this.proxy?this.proxy(e):this.proxy,{data:a}=await this.$http.post(t,{client_id:this.clientId,client_secret:this.clientSecret,code:n,grant_type:"authorization_code",redirect_uri:window.location.href});return a.access_token}async getUser({accessToken:n}){const{data:e}=await this.$http.get("user",{params:{access_token:n}});return Br(e)}async getIssue({accessToken:n,issueId:e,issueTitle:t}){const a={params:{timestamp:Date.now()}};if(n&&(a.params.access_token=n),!e){Object.assign(a.params,{q:t,repo:`${this.owner}/${this.repo}`,per_page:1});const{data:n}=await this.$http.get("search/issues",a);return n.map(Ur).find(n=>n.title===t)||null}try{const{data:n}=await this.$http.get(`repos/${this.owner}/${this.repo}/issues/${e}`,a);return Ur(n)}catch(n){if(n.response&&404===n.response.status)return null;throw n}}async postIssue({accessToken:n,title:e,content:t}){const{data:a}=await this.$http.post(`repos/${this.owner}/issues`,{access_token:n,repo:this.repo,title:e,body:t,labels:this.labels.join(",")});return Ur(a)}async getComments({accessToken:n,issueId:e,query:{page:t=1,perPage:a=10}={}}){const r={params:{page:t,per_page:a,timestamp:Date.now()},headers:{Accept:["application/vnd.gitee.html+json"]}};n&&(r.params.access_token=n);const i=await this.$http.get(`repos/${this.owner}/${this.repo}/issues/${e}/comments`,r);return{count:Number(i.headers.total_count),page:t,perPage:a,data:i.data.map(Jr)}}async postComment({accessToken:n,issueId:e,content:t}){const{data:a}=await this.$http.post(`repos/${this.owner}/${this.repo}/issues/${e}/comments`,{body:t,access_token:n},{headers:{Accept:["application/vnd.gitee.html+json"]}});return Jr(a)}async putComment({accessToken:n,commentId:e,content:t}){const{data:a}=await this.$http.patch(`repos/${this.owner}/${this.repo}/issues/comments/${e}`,{body:t,access_token:n},{headers:{Accept:["application/vnd.gitee.html+json"]}});return Jr(a)}async deleteComment({accessToken:n,commentId:e}){const{status:t}=await this.$http.delete(`repos/${this.owner}/${this.repo}/issues/comments/${e}`,{params:{access_token:n}});return 204===t}async getCommentReactions(n){throw new Error("501 Not Implemented")}async postCommentReaction(n){throw new Error("501 Not Implemented")}}t(328);var Wr={name:"Vssue",components:{VssueComponent:vr},props:{options:{type:Object,default:()=>({})}},data:()=>({key:"key",platformOptions:{github:jr,"github-v4":Or,gitlab:Mr,bitbucket:Nr,gitee:Vr}}),computed:{vssueOptions(){const{platformOptions:n,options:e}=this,t=n[e.platform];return{...e,api:t}}},watch:{$route(n,e){n.path!==e.path&&setTimeout(()=>{this.key="reco-"+(new Date).getTime()},300)}}},Hr=(t(329),{components:{Valine:jt,Vssue:Object(Ue.a)(Wr,(function(){return(0,this._self._c)("VssueComponent",{key:this.key,staticClass:"vssue-wrapper",attrs:{options:this.vssueOptions}})}),[],!1,null,null,null).exports},props:{isShowComments:{type:Boolean,default:!0}},data:()=>({commentsOptions:{solution:"vssue",options:{title:"vblog",platform:"github",owner:"lowskylee",repo:"vblog",clientId:"37da52dd478c000f6e16",clientSecret:"44055d7a85a0964de4a16cbdd133a81144b74c4d"}}}),computed:{solution(){const{commentsOptions:{solution:n},$themeConfig:{valineConfig:e,vssueConfig:t},$themeLocaleConfig:{valineConfig:a,vssueConfig:r}}=this;let i="";return void 0!==n?i=n:void 0!==a||void 0!==e?i="valine":void 0===r&&void 0===t||(i="vssue"),i},options(){const{commentsOptions:{options:n},$themeConfig:{valineConfig:e,vssueConfig:t},$themeLocaleConfig:{valineConfig:a,vssueConfig:r}}=this;return void 0!==n?n:void 0!==a||void 0!==e?a||e:void 0!==r||void 0!==t?r||t:null},componentName(){const n=this.solution;return"valine"===n?"Valine":"vssue"===n?"Vssue":""}},mounted(){this.$themeConfig.commentsSolution=this.solution}}),Qr=Object(Ue.a)(Hr,(function(){var n=this._self._c;return n("div",{directives:[{name:"show",rawName:"v-show",value:this.isShowComments,expression:"isShowComments"}],staticClass:"comments-wrapper"},[n("ClientOnly",[n(this.componentName,{tag:"component",attrs:{options:this.options}})],1)],1)}),[],!1,null,null,null).exports,Gr={props:{idVal:String,numStyle:Object,flagTitle:{type:String,default:"Your Article Title"}},methods:{getIdVal(n){const e=this.$site.base;return e.slice(0,e.length-1)+n}}},Kr=Object(Ue.a)(Gr,(function(){var n=this._self._c;return n("span",{staticClass:"leancloud-visitors",attrs:{id:this.getIdVal(this.idVal),"data-flag-title":this.flagTitle}},[n("a",{staticClass:"leancloud-visitors-count",style:this.numStyle})])}),[],!1,null,null,null).exports,Yr=(t(330),Object(Ue.a)({},(function(){var n=this,e=n._self._c;return e("div",{attrs:{id:"loader-wrapper"}},[e("div",{staticClass:"loader-main"},n._l(4,(function(n){return e("div",{key:"out"+n})})),0),n._v(" "),n.$frontmatter.home?e("h3",{staticClass:"title"},[n._v(n._s(n.$site.title||n.$localeConfig.title))]):n._e(),n._v(" "),n.$frontmatter.home?e("p",{staticClass:"description"},[n._v(n._s(n.$site.description||n.$localeConfig.description))]):n._e()])}),[],!1,null,"d48f4d20",null).exports),Xr=[({Vue:n,siteData:e,isServer:t,router:a})=>{n.mixin(Qe),n.mixin(tt),Object(at.c)(a),Object(at.a)(a)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},({Vue:n})=>{n.component("BackToTop",it)},({Vue:n})=>{n.component("Pagation",pt)},({Vue:n})=>{n.mixin({computed:{$perPage:()=>10}})},{},({Vue:n})=>{const e=Object.keys(ht).map(n=>{const e=ht[n],t="$"+n;return{[t](){const{pages:n}=this.$site;return new ft(e,n)},["$current"+(n.charAt(0).toUpperCase()+n.slice(1))](){const n=this.$route.meta.id;return this[t].getItemByName(n)}}}).reduce((n,e)=>(Object.assign(n,e),n),{});e.$frontmatterKey=function(){const n=this["$"+this.$route.meta.id];return n||null},n.mixin({computed:e})},({Vue:n})=>{n.mixin({computed:{$pagination(){return this.$route.meta.pid&&this.$route.meta.id?this.$getPagination(this.$route.meta.pid,this.$route.meta.id):null}},methods:{$getPagination(n,e){return e=e||n,yt.getPagination(n,e,this.$route)}}})},({Vue:n})=>{const e={$service:()=>bt};n.mixin({computed:e})},wt,({Vue:n})=>{n.component("KanBanNiang",St)},({Vue:n})=>{n.component("Comments",Qr),n.component("AccessNumber",Kr)},({Vue:n})=>{n.component("LoadingPage",Yr)}],Zr=["BackToTop","KanBanNiang"];class ni extends class{constructor(){this.store=new a.b({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){a.b.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(ni.prototype,{getPageAsyncComponent:ce,getLayoutAsyncComponent:ue,getAsyncComponent:de,getVueComponent:pe});var ei={install(n){const e=new ni;n.$vuepress=e,n.prototype.$vuepress=e}};function ti(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var ai={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return fe("pageKey",e),a.b.component(e)||a.b.component(e,ce(e)),a.b.component(e)?n(e):n("")}},ri={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},ii={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},oi=(t(331),t(332),Object(Ue.a)(ii,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),si={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};a.b.config.productionTip=!1,a.b.use(Hn),a.b.use(ei),a.b.mixin(function(n,e,t=a.b){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const r=new(n(t.$vuepress.$get("siteData"))),i=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r)),o={};return Object.keys(i).reduce((n,e)=>(e.startsWith("$")&&(n[e]=i[e].get),n),o),{computed:o}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const a in n)"/"===a?t=n[a]:0===this.$page.path.indexOf(a)&&(e=n[a]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,a=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?a?a+" | "+t:t:a||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const a=n[t];if(a.path.toLowerCase()===e.toLowerCase())return a}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},We)),a.b.component("Content",ai),a.b.component("ContentSlotsDistributor",ri),a.b.component("OutboundLink",oi),a.b.component("ClientOnly",si),a.b.component("Layout",ue("Layout")),a.b.component("NotFound",ue("NotFound")),a.b.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.9",hash:"9d3c126"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:We.routerBase||We.base,t=new Hn({base:e,mode:"history",fallback:!1,routes:Ve,scrollBehavior:(n,e,t)=>t||(n.hash?!a.b.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,a)=>{if(ti(n,e.path))a();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";ti(n,t)?a(t):a()}else a();else{const t=e.path+"/",r=e.path+".html";ti(n,r)?a(r):ti(n,t)?a(t):a()}})}(t);const r={};try{await Promise.all(Xr.filter(n=>"function"==typeof n).map(e=>e({Vue:a.b,options:r,router:t,siteData:We,isServer:n})))}catch(n){console.error(n)}return{app:new a.b(Object.assign(r,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Zr.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);